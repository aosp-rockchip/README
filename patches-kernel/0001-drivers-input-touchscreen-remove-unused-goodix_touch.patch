From 1f70ad388c8926e04bf3c54f2eaf45caec2a639a Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Sat, 3 Nov 2018 16:39:32 +0800
Subject: [PATCH] drivers/input/touchscreen: remove unused goodix_touch driver

Change-Id: I55d557be33d87baec3625e1c1a609162d1861d66
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/input/touchscreen/goodix_touch.c      | 903 ------------------
 drivers/input/touchscreen/goodix_touch_82x.c  | 883 -----------------
 .../input/touchscreen/goodix_touch_82x_760.c  | 883 -----------------
 include/linux/goodix_queue.h                  | 121 ---
 include/linux/goodix_touch.h                  |  78 --
 include/linux/goodix_touch_82x.h              | 164 ----
 6 files changed, 3032 deletions(-)
 delete mode 100644 drivers/input/touchscreen/goodix_touch.c
 delete mode 100644 drivers/input/touchscreen/goodix_touch_82x.c
 delete mode 100644 drivers/input/touchscreen/goodix_touch_82x_760.c
 delete mode 100644 include/linux/goodix_queue.h
 delete mode 100644 include/linux/goodix_touch.h
 delete mode 100644 include/linux/goodix_touch_82x.h

diff --git a/drivers/input/touchscreen/goodix_touch.c b/drivers/input/touchscreen/goodix_touch.c
deleted file mode 100644
index a4213c8c992c..000000000000
--- a/drivers/input/touchscreen/goodix_touch.c
+++ /dev/null
@@ -1,903 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*---------------------------------------------------------------------------------------------------------
- * driver/input/touchscreen/goodix_touch.c
- *
- * Copyright(c) 2010 Goodix Technology Corp. All rights reserved.      
- * Author: Eltonny
- * Date: 2010.11.11                                    
- *                                                                                                         
- *---------------------------------------------------------------------------------------------------------*/
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/time.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/earlysuspend.h>
-#include <linux/hrtimer.h>
-#include <linux/i2c.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-//#include <mach/gpio.h>
-//#include <plat/gpio-cfg.h>
-//#include <plat/gpio-bank-l.h>
-//#include <plat/gpio-bank-f.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <mach/iomux.h>
-#include <linux/goodix_touch.h>
-#include <linux/goodix_queue.h>
-
-#ifndef GUITAR_GT80X
-#error The code does not match the hardware version.
-#endif
-
-static struct workqueue_struct *goodix_wq;
-
-/********************************************
-*	管理当前手指状态的伪队列，对当前手指根据时间顺序排序
-*	适用于Guitar小屏		*/
-static struct point_queue  finger_list;	//record the fingers list 
-/*************************************************/
-
-const char *rk29_ts_name = "Goodix TouchScreen of GT80X";
-/*used by guitar_update module */
-struct i2c_client * i2c_connect_client = NULL;
-EXPORT_SYMBOL(i2c_connect_client);
-	
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void goodix_ts_early_suspend(struct early_suspend *h);
-static void goodix_ts_late_resume(struct early_suspend *h);
-#endif
-
-/*read the gt80x register ,used i2c bus*/
-static int gt80x_read_regs(struct i2c_client *client, u8 reg, u8 buf[], unsigned len)
-{
-	int ret;
-	ret =i2c_master_reg8_recv(client, reg, buf, len, 200*1000);
-	if(ret < 0)
-		dev_err(&client->dev,"i2c_read fail =%d\n",ret);
-	return ret;
-}
-/* set the gt80x registe,used i2c bus*/
-static int gt80x_write_regs(struct i2c_client *client, u8 reg, u8 const buf[], unsigned short len)
-{
-	int ret;
-	ret = i2c_master_reg8_send(client,reg, buf, len, 200*1000);
- 	if (ret < 0) {
-		dev_err(&client->dev,"i2c_write fail =%d\n",ret);
-    }
-	return ret;
-}
-#if 0
-/*******************************************************	
-功能：	
-	读取从机数据
-	每个读操作用两条i2c_msg组成，第1条消息用于发送从机地址，
-	第2条用于发送读取地址和取回数据；每条消息前发送起始信号
-参数：
-	client:	i2c设备，包含设备地址
-	buf[0]：	首字节为读取地址
-	buf[1]~buf[len]：数据缓冲区
-	len：	读取数据长度
-return：
-	执行消息数
-*********************************************************/
-/*Function as i2c_master_send */
-static int i2c_read_bytes(struct i2c_client *client, uint8_t *buf, int len)
-{
-	struct i2c_msg msgs[2];
-	int ret=-1;
-	//发送写地址
-	msgs[0].flags=!I2C_M_RD;//写消息
-	msgs[0].addr=client->addr;
-	msgs[0].len=1;
-	msgs[0].buf=&buf[0];
-	//接收数据
-	msgs[1].flags=I2C_M_RD;//读消息
-	msgs[1].addr=client->addr;
-	msgs[1].len=len-1;
-	msgs[1].buf=&buf[1];
-	
-	ret=i2c_transfer(client->adapter,msgs,2);
-	return ret;
-}
-
-/*******************************************************	
-功能：
-	向从机写数据
-参数：
-	client:	i2c设备，包含设备地址
-	buf[0]：	首字节为写地址
-	buf[1]~buf[len]：数据缓冲区
-	len：	数据长度	
-return：
-	执行消息数
-*******************************************************/
-/*Function as i2c_master_send */
-static int i2c_write_bytes(struct i2c_client *client,uint8_t *data,int len)
-{
-	struct i2c_msg msg;
-	int ret=-1;
-	//发送设备地址
-	msg.flags=!I2C_M_RD;//写消息
-	msg.addr=client->addr;
-	msg.len=len;
-	msg.buf=data;		
-	
-	ret=i2c_transfer(client->adapter,&msg,1);
-	return ret;
-}
-#endif
-/*******************************************************
-功能：
-	Guitar初始化函数，用于发送配置信息，获取版本信息
-参数：
-	ts:	client私有数据结构体
-return：
-	执行结果码，0表示正常执行
-*******************************************************/
-static int goodix_init_panel(struct goodix_ts_data *ts)
-{
-	int i, ret = -1;
-	u8 start_reg = 0x30;
-	u8 buf[53];
-	uint8_t config_info[53] = {
-		0x13,0x05,0x04,0x28,0x02,0x14,0x14,0x10,0x50,0xBA,
-		0x14,0x00,0x1E,0x00,0x01,0x23,0x45,0x67,0x89,0xAB,
-		0xCD,0xE1,0x00,0x00,0x00,0x00,0x4D,0xC1,0x20,0x01,
-		0x01,0x83,0x50,0x3C,0x1E,0xB4,0x00,0x33,0x2C,0x01,
-		0xEC,0x3C,0x64,0x32,0x71,0x00,0x00,0x00,0x00,0x00,
-		0x00,0x00,0x01
-	};
-
-	ret = gt80x_write_regs(ts->client, start_reg, config_info, 53);
-	if (ret < 0) {
-		printk("download gt80x firmware err %d\n", ret);
-		goto error_i2c_transfer;
-	}
-	msleep(10);
-#if 0
-	ret = gt80x_read_regs(ts->client, start_reg, buf, 53);
-	if (ret < 0)
-	{
-		printk("\n--%s--Read Register values error !!!\n",__FUNCTION__);
-	}
-		
-	for (i = 0; i < 53; i++)
-	{
-		if (buf[i] != config_info[i])
-		{
-			dev_err(&ts->client->dev,"may be i2c errorat reg_add[%d] = %#x current value = %#x expect value = %#x\n",
-					 i, 0x30 + i, buf[i], config_info[i]);
-			break;
-		}
-	}
-#endif
-	return 0;
-
-error_i2c_transfer:
-	return ret;
-}
-/*读取GT80X的版本号并打印*/
-static int  goodix_read_version(struct goodix_ts_data *ts)
-{
-	int ret;
-	uint8_t reg1 = 0x69;
-	uint8_t reg2 = 0x6a;
-	//uint8_t version[2]={0x69,0xff};	//command of reading Guitar's version 
-	uint8_t version[1]={0xff};	//command of reading Guitar's version 
-	//uint8_t version_data[41];		//store touchscreen version infomation
-	uint8_t version_data[40];		//store touchscreen version infomation
-	memset(version_data, 0 , sizeof(version_data));
-	//version_data[0]=0x6A;
-	//ret=i2c_write_bytes(ts->client,version,2);
-	ret = gt80x_write_regs(ts->client, reg1, version, 1);
-	if (ret < 0) 
-		goto error_i2c_version;
-	msleep(16);
-
-	//ret=i2c_read_bytes(ts->client,version_data, 40);
-	ret = gt80x_read_regs(ts->client, reg2, version_data, 40);
-	if (ret < 0) 
-		goto error_i2c_version;
-	//dev_info(&ts->client->dev," Guitar Version: %s\n", &version_data[1]);
-	printk("%s: Guitar Version: %s\n", __func__, version_data);
-
-	version[0] = 0x00;				//cancel the command
-	//i2c_write_bytes(ts->client, version, 2);
-	ret = gt80x_write_regs(ts->client, reg1, version, 1);
-	return 0;
-	
-error_i2c_version:
-	return ret;
-}
-
-/*******************************************************	
-功能：
-	触摸屏工作函数
-	由中断触发，接受1组坐标数据，校验后再分析输出
-参数：
-	ts:	client私有数据结构体
-return：
-	执行结果码，0表示正常执行
-********************************************************/
-static void goodix_ts_work_func(struct work_struct *work)
-{	
-	static uint8_t finger_bit = 0;	//last time fingers' state
-	uint8_t read_position = 0;
-	uint8_t point_data[35] = {0};
-	uint8_t finger = 0;				//record which finger is changed
-	int ret = -1; 
-	int count = 0;
-	int check_sum = 0;
-	//unsigned char start_reg = 0x00;
-	struct goodix_ts_data *ts = container_of(work, struct goodix_ts_data, work);
-	struct goodix_i2c_rmi_platform_data *pdata = ts->client->dev.platform_data;
-
-//#ifdef SHUTDOWN_PORT
-	if (pdata && pdata->shutdown_pin) {	
-		//if (gpio_get_value(SHUTDOWN_PORT))
-		if (gpio_get_value(pdata->shutdown_pin))
-		{
-			//printk(KERN_ALERT  "Guitar stop working.The data is invalid. \n");
-			goto NO_ACTION;
-		}
-	}
-//#endif
-
-	//if i2c transfer is failed, let it restart less than 10 times
-	if (ts->retry > 9) {
-		if(!ts->use_irq && (ts->timer.state != HRTIMER_STATE_INACTIVE))		
-			hrtimer_cancel(&ts->timer);
-		dev_info(&(ts->client->dev), "Because of transfer error, %s stop working.\n",rk29_ts_name);
-		return ;
-	}
-	if(ts->bad_data) 
-		msleep(16);
-
-	ret = gt80x_read_regs(ts->client, point_data[0], &point_data[1], 34);
-	if(ret <= 0)	
-	{
-		//dev_err(&(ts->client->dev),"I2C transfer error. Number:%d\n ", ret);
-		ts->bad_data = 1;
-		ts->retry++;
-		if(ts->power)
-		{
-			ts->power(ts, 0);
-			ts->power(ts, 1);
-		}
-		else
-		{
-			goodix_init_panel(ts);
-			msleep(500);
-		}
-		goto XFER_ERROR;
-	}	
-	ts->bad_data = 0; 
-	
-	//The bit indicate which fingers pressed down
-	switch (point_data[1] & 0x1f)
-	{
-		case 0:
-		case 1:
-			for (count = 1; count < 8; count++)
-				check_sum += (int)point_data[count];
-			if ((check_sum % 256) != point_data[8])
-				goto XFER_ERROR;
-			break;
-		case 2:
-		case 3:
-			for ( count = 1; count < 13; count++)
-				check_sum += (int)point_data[count];
-			if ((check_sum % 256) != point_data[13])
-				goto XFER_ERROR;
-			break;	
-		default:		//(point_data[1]& 0x1f) > 3
-			for (count = 1; count < 34; count++)
-				check_sum += (int)point_data[count];
-			if ((check_sum % 256) != point_data[34])
-				goto XFER_ERROR;
-	}
-	
-	point_data[1] &= 0x1f;
-	finger = finger_bit ^ point_data[1];
-	if (finger == 0 && point_data[1] == 0)			
-		goto NO_ACTION;						//no fingers and no action
-	else if(finger == 0)							//the same as last time
-		goto BIT_NO_CHANGE;					
-	//check which point(s) DOWN or UP
-	for (count = 0; (finger != 0) && (count < MAX_FINGER_NUM);  count++)
-	{
-		if ((finger & 0x01) == 1)		//current bit is 1, so NO.postion finger is change
-		{							
-			if (((finger_bit >> count) & 0x01) ==1 )	//NO.postion finger is UP
-				set_up_point(&finger_list, count);
-			else 
-				add_point(&finger_list, count);
-		}
-		finger >>= 1;
-	}
-
-BIT_NO_CHANGE:
-	for(count = 0; count < finger_list.length; count++)
-	{	
-		if(finger_list.pointer[count].state == FLAG_UP)
-		{
-			finger_list.pointer[count].x = finger_list.pointer[count].y = 0;
-			finger_list.pointer[count].pressure = 0;
-			continue;
-		}
-		
-		if(finger_list.pointer[count].num < 3)
-			read_position = finger_list.pointer[count].num*5 + 3;
-		else if (finger_list.pointer[count].num == 4)
-			read_position = 29;
-
-		if(finger_list.pointer[count].num != 3)
-		{
-			finger_list.pointer[count].x = (unsigned int) (point_data[read_position]<<8) + (unsigned int)( point_data[read_position+1]);
-			finger_list.pointer[count].y = (unsigned int)(point_data[read_position+2]<<8) + (unsigned int) (point_data[read_position+3]);
-			finger_list.pointer[count].pressure = (unsigned int) (point_data[read_position+4]);
-		}
-		else 
-		{
-			finger_list.pointer[count].x = (unsigned int) (point_data[18]<<8) + (unsigned int)( point_data[25]);
-			finger_list.pointer[count].y = (unsigned int)(point_data[26]<<8) + (unsigned int) (point_data[27]);
-			finger_list.pointer[count].pressure = (unsigned int) (point_data[28]);
-		}
-
-		// 将触摸屏的坐标映射到LCD坐标上. 触摸屏短边为X轴，LCD坐标一般长边为X轴，可能需要调整原点位置
-		finger_list.pointer[count].x = (TOUCH_MAX_WIDTH - finger_list.pointer[count].x)*SCREEN_MAX_WIDTH/TOUCH_MAX_WIDTH;//y
-		finger_list.pointer[count].y =  finger_list.pointer[count].y*SCREEN_MAX_HEIGHT/TOUCH_MAX_HEIGHT ;				//x
-		gt80xy_swap(finger_list.pointer[count].x, finger_list.pointer[count].y); 
-
-		//printk("%s: dx = %d dy = %d\n", __func__,
-		//	   finger_list.pointer[count].x, finger_list.pointer[count].y);
-
-	}
-
-#ifndef GOODIX_MULTI_TOUCH	
-		if(finger_list.pointer[0].state == FLAG_DOWN)
-		{
-			input_report_abs(ts->input_dev, ABS_X, finger_list.pointer[0].x);
-			input_report_abs(ts->input_dev, ABS_Y, finger_list.pointer[0].y);	
-		} 
-		input_report_abs(ts->input_dev, ABS_PRESSURE, pressure[0]);
-		input_report_key(ts->input_dev, BTN_TOUCH, finger_list.pointer[0].state);   
-#else
-
-	/* ABS_MT_TOUCH_MAJOR is used as ABS_MT_PRESSURE in android. */
-	for(count = 0; count < (finger_list.length); count++)
-	{
-		if(finger_list.pointer[count].state == FLAG_DOWN)
-		{
-			input_report_abs(ts->input_dev, ABS_MT_POSITION_X, finger_list.pointer[count].x);
-			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, finger_list.pointer[count].y);
-		} 
-		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, finger_list.pointer[count].pressure);
-		input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, finger_list.pointer[count].pressure);
-		input_mt_sync(ts->input_dev);	
-	}
-	#if 0
-	read_position = finger_list.length-1;
-	if(finger_list.length > 0 && finger_list.pointer[read_position].state == FLAG_DOWN)
-	{
-		input_report_abs(ts->input_dev, ABS_MT_POSITION_X, finger_list.pointer[read_position].x);
-		input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, finger_list.pointer[read_position].y);
-	}	
-	input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, finger_list.pointer[read_position].pressure);
-	input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, finger_list.pointer[read_position].pressure);
-	input_mt_sync(ts->input_dev);
-	#endif	
-#endif
-	input_sync(ts->input_dev);
-
-	del_point(&finger_list);
-	finger_bit=point_data[1];
-	
-XFER_ERROR:	
-NO_ACTION:
-	if(ts->use_irq)
-		enable_irq(ts->client->irq);
-
-}
-
-/*******************************************************	
-功能：
-	计时器响应函数
-	由计时器触发，调度触摸屏工作函数运行；之后重新计时
-参数：
-	timer：函数关联的计时器	
-return：
-	计时器工作模式，HRTIMER_NORESTART表示不需要自动重启
-********************************************************/
-static enum hrtimer_restart goodix_ts_timer_func(struct hrtimer *timer)
-{
-	struct goodix_ts_data *ts = container_of(timer, struct goodix_ts_data, timer);
-	queue_work(goodix_wq, &ts->work);
-	if(ts->timer.state != HRTIMER_STATE_INACTIVE)
-		hrtimer_start(&ts->timer, ktime_set(0, 16000000), HRTIMER_MODE_REL);
-	return HRTIMER_NORESTART;
-}
-
-/*******************************************************	
-功能：
-	中断响应函数
-	由中断触发，调度触摸屏处理函数运行
-参数：
-	timer：函数关联的计时器	
-return：
-	计时器工作模式，HRTIMER_NORESTART表示不需要自动重启
-********************************************************/
-//#if defined(INT_PORT)
-static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
-{
-	struct goodix_ts_data *ts = dev_id;
-	
-	disable_irq_nosync(ts->client->irq);
-	queue_work(goodix_wq, &ts->work);
-	
-	return IRQ_HANDLED;
-}
-//#endif
-
-/*******************************************************	
-功能：
-	GT80X的电源管理
-参数：
-	on:设置GT80X运行模式，0为进入Sleep模式
-return：
-	是否设置成功，小于0表示设置失败
-********************************************************/
-//#if defined(SHUTDOWN_PORT)
-static int goodix_ts_power(struct goodix_ts_data * ts, int on)
-{
-	int ret = -1;
-	struct goodix_i2c_rmi_platform_data *pdata = NULL;
-
-	if(ts == NULL || (ts && !ts->use_shutdown))
-		return -1;
-
-	pdata = ts->client->dev.platform_data;
-
-	switch(on) 
-	{
-		case 0:
-			gpio_set_value(pdata->shutdown_pin, 1);
-			msleep(5);
-			if(gpio_get_value(pdata->shutdown_pin))	//has been suspend
-				ret = 0;
-			break;
-		case 1:
-			gpio_set_value(pdata->shutdown_pin, 0);
-			msleep(5);
-			if(gpio_get_value(pdata->shutdown_pin))	//has been suspend
-				ret = -1;
-			else 
-			{
-				ret = goodix_init_panel(ts);
-                if(!ret)
-					msleep(500);
-			}
-			break;	
-		//default:printk("Command ERROR.\n");
-	}
-	printk(on?"Set Guitar's Shutdown LOW\n":"Set Guitar's Shutdown HIGH\n");
-	return 0;
-}
-//#endif
-
-/*******************************************************	
-功能：
-	触摸屏探测函数
-	在注册驱动时调用（要求存在对应的client）；
-	用于IO,中断等资源申请；设备注册；触摸屏初始化等工作
-参数：
-	client：待驱动的设备结构体
-	id：设备ID
-return：
-	执行结果码，0表示正常执行
-********************************************************/
-static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct goodix_ts_data *ts;
-	int ret = 0;
-	int retry=0;
-	int count=0;
-	u8 test_reg = 0x30;
-	u8 test_buf[] = {0x01};
-
-	struct goodix_i2c_rmi_platform_data *pdata;
-	pdata = client->dev.platform_data;
-
-	dev_dbg(&client->dev,"Install touchscreen driver for guitar.\n");
-
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
-	{
-		dev_err(&client->dev, "System need I2C function.\n");
-		ret = -ENODEV;
-		goto err_check_functionality_failed;
-	}
-	
-	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
-	if (ts == NULL) {
-		ret = -ENOMEM;
-		goto err_alloc_data_failed;
-	}
-	//Check I2C function
-//#ifdef SHUTDOWN_PORT	
-	if (pdata && pdata->shutdown_pin) {
-		//ret = gpio_request(SHUTDOWN_PORT, "TS_SHUTDOWN");	//Request IO
-		ret = gpio_request(pdata->shutdown_pin, "TS_SHUTDOWN");	//Request IO
-		if (ret < 0) 
-		{
-			//printk(KERN_ALERT "Failed to request GPIO:%d, ERRNO:%d\n",(int)SHUTDOWN_PORT,ret);
-			printk(KERN_ALERT "Failed to request GPIO:%d, ERRNO:%d\n",(int)pdata->shutdown_pin,ret);
-			goto err_gpio_request;
-		}	
-		//gpio_direction_output(SHUTDOWN_PORT, 0);	//Touchscreen is waiting to wakeup
-		//ret = gpio_get_value(SHUTDOWN_PORT);
-		gpio_direction_output(pdata->shutdown_pin, 0);	//Touchscreen is waiting to wakeup
-		ret = gpio_get_value(pdata->shutdown_pin);
-		if (ret)
-		{
-			printk(KERN_ALERT  "Cannot set touchscreen to work.\n");
-			goto err_i2c_failed;
-		}
-	}
-//#endif		
-	
-	i2c_connect_client = client;				//used by Guitar Updating.
-	msleep(16);
-
-	for (retry = 0; retry < 5; retry++)
-	{
-		ret = gt80x_write_regs(client, test_reg, test_buf, 1);	//Test i2c.
-		if (ret > 0)
-			break;
-	}
-	if (ret < 0)
-	{
-		dev_err(&client->dev, "Warnning: I2C connection might be something wrong!\n");
-		goto err_i2c_failed;
-	}
-
-//#ifdef SHUTDOWN_PORT	
-	if (pdata && pdata->shutdown_pin) {
-		ts->use_shutdown = 1;
-		//gpio_set_value(SHUTDOWN_PORT, 1);
-		gpio_set_value(pdata->shutdown_pin, 1);
-	}//suspend
-//#endif	
-	
-	INIT_WORK(&ts->work, goodix_ts_work_func);
-	ts->client = client;
-	i2c_set_clientdata(client, ts);
-	//pdata = client->dev.platform_data;
-	
-	ts->input_dev = input_allocate_device();
-	if (ts->input_dev == NULL) {
-		ret = -ENOMEM;
-		dev_dbg(&client->dev,"Failed to allocate input device\n");
-		goto err_input_dev_alloc_failed;
-	}
-
-	ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
-#ifndef GOODIX_MULTI_TOUCH	
-	ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-	ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
-	//	| BIT_MASK(ABS_MT_TOUCH_MAJOR)| BIT_MASK(ABS_MT_WIDTH_MAJOR)
-  	//	BIT_MASK(ABS_MT_POSITION_X) |
-  	//	BIT_MASK(ABS_MT_POSITION_Y); 	// for android
-
-	input_set_abs_params(ts->input_dev, ABS_X, 0, SCREEN_MAX_HEIGHT, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_Y, 0, SCREEN_MAX_WIDTH, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);	
-#else
-	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, SCREEN_MAX_HEIGHT, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, SCREEN_MAX_WIDTH, 0, 0);	
-#endif	
-
-	sprintf(ts->phys, "input/ts)");
-	ts->input_dev->name = rk29_ts_name;
-	ts->input_dev->phys = ts->phys;
-	ts->input_dev->id.bustype = BUS_I2C;
-	ts->input_dev->id.vendor = 0xDEAD;
-	ts->input_dev->id.product = 0xBEEF;
-	ts->input_dev->id.version = 10427;	
-
-	finger_list.length = 0;
-	ret = input_register_device(ts->input_dev);
-	if (ret) {
-		dev_err(&client->dev,"Probe: Unable to register %s input device\n", ts->input_dev->name);
-		goto err_input_register_device_failed;
-	}
-
-	ts->use_irq = 0;
-	ts->retry = 0;
-	ts->bad_data = 0;
-//#if defined(INT_PORT)	
-	//client->irq=TS_INT;
-	//gpio_set_value(TS_INT, 0);		
-	
-	if (pdata && pdata->irq_pin) {
-		client->irq = gpio_to_irq(client->irq);
-		if (client->irq)
-		{
-			//ret = gpio_request(INT_PORT, "TS_INT");	//Request IO
-			ret = gpio_request(pdata->irq_pin, "TS_INT");	//Request IO
-			if (ret < 0) 
-			{
-				//dev_err(&client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(int)INT_PORT,ret);
-				dev_err(&client->dev, "Failed to request GPIO:%d, ERRNO:%d\n", (int)pdata->irq_pin, ret);
-				goto err_int_request_failed;
-			}
-			//ret = s3c_gpio_cfgpin(INT_PORT, INT_CFG);	//Set IO port function
-			ret  = request_irq(client->irq, goodix_ts_irq_handler ,  IRQ_TYPE_EDGE_RISING,
-				client->name, ts);
-			if (ret != 0) {
-				dev_err(&client->dev,"Can't allocate touchscreen's interrupt!ERRNO:%d\n", ret);
-				//gpio_direction_input(INT_PORT);
-				//gpio_free(INT_PORT);
-				gpio_direction_input(pdata->irq_pin);
-				gpio_free(pdata->irq_pin);
-				goto err_int_request_failed;
-			}
-			else 
-			{	
-				//disable_irq(TS_INT);
-				disable_irq(client->irq);
-				ts->use_irq = 1;
-				dev_dbg(&client->dev,"Reques EIRQ %d succesd on GPIO:%d\n",client->irq, pdata->irq_pin);
-			}
-		}
-	}
-//#endif
-
-err_int_request_failed:	
-	if (!ts->use_irq) 
-	{
-		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-		ts->timer.function = goodix_ts_timer_func;
-		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-	}
-
-//#ifdef SHUTDOWN_PORT		
-	if (pdata && pdata->shutdown_pin) {
-		//gpio_set_value(SHUTDOWN_PORT, 0);
-		gpio_set_value(pdata->shutdown_pin, 0);
-		msleep(10);
-		ts->power = goodix_ts_power;
-	}
-//#endif	
-	for(count = 0; count < 3; count++)
-	{
-		ret = goodix_init_panel(ts);	
-		if(ret != 0)		//Initiall failed
-			continue;
-		else
-		{
-			if(ts->use_irq)
-				enable_irq(client->irq);
-				//enable_irq(TS_INT);
-			break;
-		}
-	}
-	if(ret != 0) {
-		ts->bad_data = 1;
-		goto err_init_godix_ts;
-	}
-	goodix_read_version(ts);
-	msleep(500);
-	
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
-	ts->early_suspend.suspend = goodix_ts_early_suspend;
-	ts->early_suspend.resume = goodix_ts_late_resume;
-	register_early_suspend(&ts->early_suspend);
-#endif
-	dev_info(&client->dev,"Start  %s in %s mode\n", 
-		ts->input_dev->name, ts->use_irq ? "Interrupt" : "Polling");
-	return 0;
-
-err_init_godix_ts:
-	if(ts->use_irq)
-	{
-		//free_irq(TS_INT,ts);
-		free_irq(client->irq,ts);
-//#if defined(INT_PORT)		
-		if (pdata && pdata->irq_pin)
-			gpio_free(pdata->irq_pin);
-//#endif
-	}
-
-err_input_register_device_failed:
-	input_free_device(ts->input_dev);
-
-err_input_dev_alloc_failed:
-	i2c_set_clientdata(client, NULL);
-err_i2c_failed:
-//#ifdef SHUTDOWN_PORT	
-	if (pdata && pdata->shutdown_pin) {
-		//gpio_direction_input(SHUTDOWN_PORT);
-		//gpio_free(SHUTDOWN_PORT);
-		gpio_direction_input(pdata->shutdown_pin);
-		gpio_free(pdata->shutdown_pin);
-	}
-//#endif
-err_gpio_request:
-	kfree(ts);
-err_alloc_data_failed:
-err_check_functionality_failed:
-	return ret;
-}
-
-
-/*******************************************************	
-功能：
-	驱动资源释放
-参数：
-	client：设备结构体
-return：
-	执行结果码，0表示正常执行
-********************************************************/
-static int goodix_ts_remove(struct i2c_client *client)
-{
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-	struct goodix_i2c_rmi_platform_data *pdata;
-	pdata = client->dev.platform_data;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	unregister_early_suspend(&ts->early_suspend);
-#endif
-	if (ts->use_irq)
-	{
-		free_irq(client->irq, ts);
-//#if defined(INT_PORT)		
-		if (pdata && pdata->irq_pin)
-			gpio_free(pdata->irq_pin);
-			//gpio_free(INT_PORT);
-//#endif
-	}	
-	else
-		hrtimer_cancel(&ts->timer);
-
-//#ifdef SHUTDOWN_PORT		
-	if (pdata && pdata->shutdown_pin) {
-		if(ts->use_shutdown)
-		{
-			//gpio_direction_input(SHUTDOWN_PORT);
-			//gpio_free(SHUTDOWN_PORT);
-			gpio_direction_input(pdata->shutdown_pin);
-			gpio_free(pdata->shutdown_pin);
-		}
-	}
-//#endif
-	dev_notice(&client->dev,"The driver is removing...\n");
-	i2c_set_clientdata(client, NULL);
-	input_unregister_device(ts->input_dev);
-	if(ts->input_dev)
-		kfree(ts->input_dev);
-	kfree(ts);
-	return 0;
-}
-
-//停用设备
-static int goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-	int ret;
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-	if (ts->use_irq)
-		disable_irq(client->irq);
-	else if(ts->timer.state)
-		hrtimer_cancel(&ts->timer);
-	ret = cancel_work_sync(&ts->work);	
-	if(ret && ts->use_irq)
-		enable_irq(client->irq);
-	if (ts->power) {
-		ret = ts->power(ts,0);
-		if (ret < 0)
-			printk(KERN_ERR "%s power off failed\n", rk29_ts_name);
-	}
-	return 0;
-}
-//重新唤醒
-static int goodix_ts_resume(struct i2c_client *client)
-{
-	int ret;
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-	if (ts->power) {
-		ret = ts->power(ts, 1);
-		if (ret < 0)
-			printk(KERN_ERR "%s power on failed\n", rk29_ts_name);
-	}
-
-	if (ts->use_irq)
-		enable_irq(client->irq);
-	else
-		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-	return 0;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void goodix_ts_early_suspend(struct early_suspend *h)
-{
-	struct goodix_ts_data *ts;
-	ts = container_of(h, struct goodix_ts_data, early_suspend);
-	goodix_ts_suspend(ts->client, PMSG_SUSPEND);
-}
-
-static void goodix_ts_late_resume(struct early_suspend *h)
-{
-	struct goodix_ts_data *ts;
-	ts = container_of(h, struct goodix_ts_data, early_suspend);
-	goodix_ts_resume(ts->client);
-}
-#endif
-
-//可用于该驱动的 设备名—设备ID 列表
-//only one client
-static const struct i2c_device_id goodix_ts_id[] = {
-	{ GOODIX_I2C_NAME, 0 },
-	{ }
-};
-
-//设备驱动结构体
-static struct i2c_driver goodix_ts_driver = {
-	.probe		= goodix_ts_probe,
-	.remove		= goodix_ts_remove,
-#ifndef CONFIG_HAS_EARLYSUSPEND
-	.suspend	= goodix_ts_suspend,
-	.resume		= goodix_ts_resume,
-#endif
-	.id_table	= goodix_ts_id,
-	.driver = {
-		.name	= GOODIX_I2C_NAME,
-		.owner = THIS_MODULE,
-	},
-};
-
-/*******************************************************	
-功能：
-	驱动加载函数
-return：
-	执行结果码，0表示正常执行
-********************************************************/
-static int __devinit goodix_ts_init(void)
-{
-	int ret;
-	//printk(KERN_DEBUG "%s is installing...\n", rk29_ts_name);
-	goodix_wq = create_workqueue("goodix_wq");
-	if (!goodix_wq) {
-		printk(KERN_ALERT "Creat workqueue faiked\n");
-		return -ENOMEM;
-		
-	}
-	ret=i2c_add_driver(&goodix_ts_driver);
-	return ret; 
-}
-
-/*******************************************************	
-功能：
-	驱动卸载函数
-参数：
-	client：设备结构体
-********************************************************/
-static void __exit goodix_ts_exit(void)
-{
-	printk(KERN_DEBUG "%s is exiting...\n", rk29_ts_name);
-	i2c_del_driver(&goodix_ts_driver);
-	if (goodix_wq)
-		destroy_workqueue(goodix_wq);
-}
-
-late_initcall(goodix_ts_init);
-module_exit(goodix_ts_exit);
-
-MODULE_DESCRIPTION("Goodix Touchscreen Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/goodix_touch_82x.c b/drivers/input/touchscreen/goodix_touch_82x.c
deleted file mode 100644
index 459e273a3c89..000000000000
--- a/drivers/input/touchscreen/goodix_touch_82x.c
+++ /dev/null
@@ -1,883 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * 
- * Copyright (C) 2011 Goodix, Inc.
- * 
- * Author: Scott
- * Date: 2012.01.05
- */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <mach/gpio.h>
-//#include <plat/gpio-cfg.h>
-#include <linux/irq.h>
-#include <linux/err.h>
-#include<linux/workqueue.h>
-#include<linux/slab.h>
-#include <linux/goodix_touch_82x.h>    //w++
-
-#include <linux/input/mt.h>
-
-#define READ_TOUCH_ADDR_H   0x0F
-#define READ_TOUCH_ADDR_L   0x40
-#define READ_KEY_ADDR_H     0x0F
-#define READ_KEY_ADDR_L     0x41
-#define READ_COOR_ADDR_H    0x0F
-#define READ_COOR_ADDR_L    0x42
-#define RESOLUTION_LOC      71
-#define TRIGGER_LOC         66
-//#typedef s32 int    //w++
-
-struct goodix_ts_data {
-	uint16_t addr;
-	struct i2c_client *client;
-	struct input_dev *input_dev;
-	bool use_irq;
-	bool use_reset;
-	bool init_finished;
-	struct hrtimer timer;
-	struct work_struct  work;
-	char phys[32];
-	int bad_data;
-	int retry;
-	s32 (*power)(struct goodix_ts_data * ts, s32 on);
-	struct early_suspend early_suspend;
-	int xmax;
-	int ymax;
-	bool swap_xy;
-	bool xpol;
-	bool ypol;
-	int irq_is_disable;
-	int interrupt_port;
-	int reset_port;
-};
-struct goodix_ts_data *ts82x_temp;		//w++
-
-static struct workqueue_struct *goodix_wq;
-static const char *goodix_ts_name ="Goodix TouchScreen of Guitar ";//"Goodix Capacitive TouchScreen";
-
-static s32 goodix_ts_remove(struct i2c_client *);
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void goodix_ts_early_suspend(struct early_suspend *h);
-static void goodix_ts_late_resume(struct early_suspend *h);
-#endif
-
-#ifdef CREATE_WR_NODE
-extern s32 init_wr_node(struct i2c_client*);
-extern void uninit_wr_node(void);
-#endif
-
-#ifdef AUTO_UPDATE_GUITAR
-extern s32 init_update_proc(struct goodix_ts_data *);
-#else
-static void guitar_reset( struct goodix_ts_data *ts,u8 ms);
-#endif
-
-static int err_gt82x = 0;   //w++记载有没有此设备的检测
-//#define LONGPRESS_LOCK_SPECKEY
-#ifdef LONGPRESS_LOCK_SPECKEY
-#define KEY_LOCK KEY_F13
-#define LOCK_LONG_PRESS_CNT 20
-static int Origin2LockPressCnt = 0;
-static int lockflag =0;
-//static int touch_key_hold_press = 0;
-
-ssize_t glock_status_show_gt82x(struct device *dev, char *buf)
-{
-	return sprintf(buf, "%d", lockflag);
-}
-struct timer_list longkey_timer_82x;
-#endif
-#ifdef LONGPRESS_LOCK_SPECKEY
-static DRIVER_ATTR(get_lock_status, 0777, glock_status_show_gt82x, NULL);
-#endif
-
-#if 0
-#define TOUCH_MAX_HEIGHT   1024   //w++2
-#define TOUCH_MAX_WIDTH     768
-#else
-#define AUTO_SET
-u16 TOUCH_MAX_HEIGHT;
-u16 TOUCH_MAX_WIDTH;
-#endif
-
-#define GT828_I2C_RATE 200000
-
-/*Function as i2c_master_send */
-static s32 i2c_read_bytes(struct i2c_client *client, u8 *buf, s32 len)
-{
-    struct i2c_msg msgs[2];
-    s32 ret=-1;
-
-    msgs[0].flags=!I2C_M_RD;
-    msgs[0].addr=client->addr;
-    msgs[0].len=2;
-    msgs[0].buf=&buf[0];
-    msgs[0].scl_rate=100000;
-    msgs[0].udelay=2000;
-
-    msgs[1].flags=I2C_M_RD;
-    msgs[1].addr=client->addr;
-    msgs[1].len=len - ADDR_LENGTH;
-    msgs[1].buf=&buf[2];
-    msgs[1].scl_rate=100000;
-    msgs[1].udelay=2000;	
-
-    ret=i2c_transfer(client->adapter,msgs, 2);
-
-    return ret;
-}
-
-/*Function as i2c_master_send */
-static s32 i2c_write_bytes(struct i2c_client *client,u8 *data,s32 len)
-{
-    struct i2c_msg msg;
-    s32 ret=-1;
-    
-    msg.flags=!I2C_M_RD;
-    msg.addr=client->addr;
-    msg.len=len;
-    msg.buf=data;        
-    msg.scl_rate=100000;
-    msg.udelay=2000;
-    ret=i2c_transfer(client->adapter,&msg, 1);
-
-    return ret;
-}
-
-static s32 i2c_pre_cmd(struct goodix_ts_data *ts)
-{
-    s32 ret;
-    u8 pre_cmd_data[2]={0x0f, 0xff};
-
-    ret=i2c_write_bytes(ts->client,pre_cmd_data,2);
-    return ret;//*/
-}
-
-static s32 i2c_end_cmd(struct goodix_ts_data *ts)
-{
-    s32 ret;
-    u8 end_cmd_data[2]={0x80, 0x00};    
-
-    ret=i2c_write_bytes(ts->client,end_cmd_data,2);
-    return ret;//*/
-}
-
-
-s32 goodix_init_panel(struct goodix_ts_data *ts, u8 send)
-{
-    s32 ret = -1;
-    u8 config_info[]=
-    {
-    0x0F,0x80,/*config address*/
-#if 1	
-// 300-N3216E-A00
-/*
-	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
-	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
-	0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,
-	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x21,0x00,0x00,0x09,0x00,
-	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x25,0x29,
-	0x27,0x2B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x13,0x01,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x01
-*/
-//300-N3788E-A00-V1.0             1024*768
-/*
-	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
-	0x18,0x0A,0x19,0xFF,0x13,0xFF,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,
-	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0x00,0xFF,
-	0x0E,0x0F,0x10,0x11,0x12,0x09,0x03,0x88,0x88,0x88,0x25,0x00,0x00,0x08,0x00,
-	0x00,0x02,0x3C,0x28,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x33,0x38,
-	0x30,0x35,0x25,0x00,0x25,0x19,0x05,0x14,0x10,0x02,0x30,0x01,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x01
-*/
-	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
-	0x18,0x0A,0x19,0x0B,0x1A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
-	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,
-	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x19,0x00,0x00,0x08,0x00,
-	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x2D,0x38,
-	0x2F,0x3B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x01,0x01,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x01
-#else
-	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
-	0x18,0x0A,0x19,0x0B,0x1A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
-	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,
-	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x19,0x00,0x00,0x08,0x00,
-	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x2D,0x38,
-	0x2F,0x3B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x01,0x01,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x01
-#endif
-    };
-
-#ifdef AUTO_SET
-	TOUCH_MAX_WIDTH  = ((config_info[RESOLUTION_LOC] << 8)|config_info[RESOLUTION_LOC + 1]);
-	TOUCH_MAX_HEIGHT = ((config_info[RESOLUTION_LOC + 2] << 8)|config_info[RESOLUTION_LOC + 3]);
-	
-	GTDEBUG_MSG("TOUCH_MAX_WIDTH  : 0x%d\n", (s32)TOUCH_MAX_WIDTH);
-	GTDEBUG_MSG("TOUCH_MAX_HEIGHT : 0x%d\n", (s32)TOUCH_MAX_HEIGHT);
-#else
-/*
-	config_info[RESOLUTION_LOC]     = TOUCH_MAX_WIDTH >> 8;
-	config_info[RESOLUTION_LOC + 1] = TOUCH_MAX_WIDTH & 0xff;
-	config_info[RESOLUTION_LOC + 2] = TOUCH_MAX_HEIGHT >> 8;
-	config_info[RESOLUTION_LOC + 3] = TOUCH_MAX_HEIGHT & 0xff;
-*/
-#endif
-
-    if (INT_TRIGGER == GT_IRQ_FALLING) {
-        config_info[TRIGGER_LOC] &= 0xf7; 
-    } else if (INT_TRIGGER == GT_IRQ_RISING) {
-        config_info[TRIGGER_LOC] |= 0x08;
-    }
-
-    if (send) {
-        ret=i2c_write_bytes(ts->client,config_info, (sizeof(config_info)/sizeof(config_info[0])));
-        if (ret <= 0) {
-            return fail;
-        }
-        i2c_end_cmd(ts);
-        msleep(10);
-    }
-    return success;
-}
-
-static s32 touch_num(u8 value, s32 max)
-{
-    s32 tmp = 0;
-
-    while((tmp < max) && value) {
-        if ((value & 0x01) == 1) {
-            tmp++;
-        }
-        value = value >> 1;
-    }
-
-    return tmp;
-}
-
-#ifdef LONGPRESS_LOCK_SPECKEY   //w++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-static void open_longkey_timer_82x(unsigned long data)
-{
-	if((++Origin2LockPressCnt>LOCK_LONG_PRESS_CNT)&&(Origin2LockPressCnt<LOCK_LONG_PRESS_CNT+2)) {  //w++超过一个时间,发长按消息
-		Origin2LockPressCnt = LOCK_LONG_PRESS_CNT + 3;
-		//if(lockflag ==0) {
-			input_report_key(ts82x_temp->input_dev, KEY_LOCK, 1);
-			lockflag = (lockflag)? 0 : 1;
-			input_sync(ts82x_temp->input_dev);
-		//}
-	}
-	longkey_timer_82x.expires=jiffies+msecs_to_jiffies(100);
-	add_timer(&longkey_timer_82x);
-	printk("w++++++++   Origin2LockPressCnt = %d\n",Origin2LockPressCnt); 
-	printk("lockflag = %d\n",lockflag);
-}
-#endif
-
-static void goodix_ts_work_func(struct work_struct *work)
-{
-    u8 finger = 0;
-    u8 chk_sum = 0;
-    u8 key = 0;
-    static u8 last_key = 0;
-    u16 X_value;
-    u16 Y_value;
-	u16 value_tmp;
-    u32 count = 0;
-    u32 position = 0;
-    s32 ret = -1;
-    s32 tmp = 0;
-    s32 i;
-    u8 *coor_point;
-    u8 touch_data[2 + 2 + 5*MAX_FINGER_NUM + 1] = {READ_TOUCH_ADDR_H,READ_TOUCH_ADDR_L,0, 0};
-    static u8 finger_last[MAX_FINGER_NUM]={0};
-    u8 finger_current[MAX_FINGER_NUM] = {0};
-
-    struct goodix_ts_data *ts = container_of(work, struct goodix_ts_data, work);
-    struct i2c_client *client = ts->client;
-	struct goodix_i2c_rmi_platform_data *pdata = client->dev.platform_data;
-	
-#ifndef INT_PORT
-COORDINATE_POLL:
-#endif
-    if( tmp > 9) {
-        dev_info(&(ts->client->dev), "Because of transfer error,touchscreen stop working.\n");
-        goto XFER_ERROR ;
-    }
-
-    ret=i2c_read_bytes(ts->client, touch_data,sizeof(touch_data)/sizeof(touch_data[0])); 
-    i2c_end_cmd(ts);
-    if(ret <= 0) {
-        dev_err(&(ts->client->dev),"I2C transfer error. Number:%d\n ", ret);
-        ts->bad_data = 1;
-        tmp ++;
-#ifndef INT_PORT
-        goto COORDINATE_POLL;
-#else
-        goto XFER_ERROR;
-#endif
-    }
-
-    if(ts->bad_data) {
-        //TODO:Is sending config once again (to reset the chip) useful?    
-        ts->bad_data = 0;
-        msleep(20);
-    }
-
-    if((touch_data[2]&0xC0)!=0x80) {
-        goto DATA_NO_READY;        
-    }
-
-
-    key = touch_data[3]&0x0f; // 1, 2, 4, 8
-    if (key == 0x0f) {
-        if (fail == goodix_init_panel(ts, 1)) {
-			GTDEBUG_COOR("Reload config failed!\n");
-        } else {   
-			GTDEBUG_COOR("Reload config successfully!\n");
-        }
-        goto XFER_ERROR;
-    }
-
-    finger = (u8)touch_num(touch_data[2]&0x1f, MAX_FINGER_NUM);
-
-	GTDEBUG_COOR("touch num:%x\n", finger);
-
-    for (i = 0;i < MAX_FINGER_NUM; i++) {
-        finger_current[i] = !!(touch_data[2] & (0x01<<(i)));
-    }
-
-    coor_point = &touch_data[4];
-    chk_sum = 0;
-    for ( i = 0; i < 5*finger; i++) {
-        chk_sum += coor_point[i];
-		//GTDEBUG_COOR("%5x", coor_point[i]);
-    }
-	//GTDEBUG_COOR("\ncheck sum:%x\n", chk_sum);
-	//GTDEBUG_COOR("check sum byte:%x\n", coor_point[5*finger]);
-    if (chk_sum != coor_point[5*finger]) {
-        goto XFER_ERROR;
-    }
-
-    if (finger) {
-        for(i = 0, position=0;position < MAX_FINGER_NUM; position++) {  
-            if(finger_current[position]) {     
-				X_value = (coor_point[i] << 8) | coor_point[i + 1];
-				Y_value = (coor_point[i + 2] << 8) | coor_point[i + 3];
-				
-				input_mt_slot(ts->input_dev, position);
-				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
-				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, FLAG_DOWN);
-				
-				//input_report_key(ts->input_dev, BTN_TOUCH, 1);
-				//input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, position - 1);
-				if(pdata->swap_xy) {
-					value_tmp = X_value;
-					X_value = Y_value;
-					Y_value = value_tmp;
-				}
-				//printk("goodix_touch_82x X_value=%d,Y_value=%d\n",X_value,Y_value);
-				if(pdata->xpol)
-					X_value = pdata->xmax - X_value;
-				if(pdata->ypol)
-					Y_value = pdata->ymax - Y_value;
-				
-				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, X_value);  //can change x-y!!!
-				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, 600-Y_value);
-				//input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,15);
-				//input_mt_sync(ts->input_dev);
-				i += 5;
-
-				//GTDEBUG_COOR("FI:%x X:%04d Y:%04d\n",position, (s32)Y_value,(s32)X_value);
-				//printk("-----------touch_num:%d;--------FI:%x----------- X:%04d ----------Y:%04d\n",finger,position, (s32)X_value,(s32)Y_value);
-				//GTDEBUG_COOR("Y:%d\n", (s32)Y_value);
-			} else if(finger_last[position]) {
-				input_mt_slot(ts->input_dev, position);
-				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
-				GTDEBUG_COOR(" Finger  %d  release!!\n",position);
-			}
-		}
-	} else {
-		for(position=0;position < MAX_FINGER_NUM; position++) {
-			if( finger_last[position]) {
-				input_mt_slot(ts->input_dev, position);
-				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
-				GTDEBUG_COOR(" Finger  %d  release!!\n",position);
-			}
-		}
-	}
-
-    input_sync(ts->input_dev);
-    
-    for(position=0;position<MAX_FINGER_NUM; position++) {
-        finger_last[position] = finger_current[position];
-    }
-
-DATA_NO_READY:
-XFER_ERROR:
-	if(ts->use_irq && ts->irq_is_disable == 1) {
-		ts->irq_is_disable = 0;
-		enable_irq(ts->client->irq);
-	}
-}
-
-static enum hrtimer_restart goodix_ts_timer_func(struct hrtimer *timer)
-{
-    struct goodix_ts_data *ts = container_of(timer, struct goodix_ts_data, timer);
-
-    queue_work(goodix_wq, &ts->work);
-    hrtimer_start(&ts->timer, ktime_set(0, (POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
-
-    return HRTIMER_NORESTART;
-}
-
-static irqreturn_t goodix_ts_irq_handler(s32 irq, void *dev_id)
-{
-	struct goodix_ts_data *ts = (struct goodix_ts_data*)dev_id;
-	
-	if (ts->use_irq && (!ts->irq_is_disable)) {
-		disable_irq_nosync(ts->client->irq);
-		ts->irq_is_disable = 1;
-	}
-	
-	queue_work(goodix_wq, &ts->work);
-	
-	return IRQ_HANDLED;
-}
-
-//#if defined(INT_PORT)    // 0 : sleep  1 wake up
-static s32 goodix_ts_power(struct goodix_ts_data * ts, s32 on)
-{
-    s32 ret = -1;
-    u8 i2c_control_buf[3] = {0x0f,0xf2,0xc0};        //suspend cmd
-
-    if(ts == NULL || !ts->use_irq)
-        return -2;
-
-    switch(on)
-    {
-    case 0:
-        ret = i2c_write_bytes(ts->client, i2c_control_buf, 3);
-        return ret;
-
-    case 1:
-        GPIO_DIRECTION_OUTPUT(ts->interrupt_port, 0);
-        mdelay(10);
-        GPIO_SET_VALUE(ts->interrupt_port, 1);
-        GPIO_DIRECTION_INPUT(ts->interrupt_port);
-        GPIO_PULL_UPDOWN(ts->interrupt_port, 0);
-        return success;
-
-    default:
-        GTDEBUG_MSG(KERN_DEBUG "%s: Cant't support this command.", goodix_ts_name);
-        return -EINVAL;
-    }
-
-}
-
-static s32 init_input_dev(struct goodix_ts_data *ts)
-{
-    s32 i;
-    s32 ret = 0;
-
-    ts->input_dev = input_allocate_device();
-    if (ts->input_dev == NULL)
-    {
-        dev_dbg(&ts->client->dev,"goodix_ts_probe: Failed to allocate input device\n");
-        return fail;
-    }
- 
-	//ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-	//ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-	//ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);// absolute coor (x,y)
-	
-    goodix_init_panel(ts, 0);
- 
-#ifdef GOODIX_MULTI_TOUCH
-
-	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
-	__set_bit(EV_ABS, ts->input_dev->evbit);
-	input_mt_init_slots(ts->input_dev, MAX_FINGER_NUM);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
-
-	/* 
-	input_mt_init_slots(ts->input_dev, MAX_FINGER_NUM);
-	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
-	*/
-#else
-    input_set_abs_params(ts->input_dev, ABS_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
-    input_set_abs_params(ts->input_dev, ABS_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
-    input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
-#endif    
-
-    memcpy(ts->phys, "input/ts", 8);
-    ts->input_dev->name = goodix_ts_name;
-    ts->input_dev->phys = ts->phys;
-    ts->input_dev->id.bustype = BUS_I2C;
-    ts->input_dev->id.vendor = 0xDEAD;
-    ts->input_dev->id.product = 0xBEEF;
-    ts->input_dev->id.version = 10427;    //screen firmware version
-
-#ifdef LONGPRESS_LOCK_SPECKEY    //w++
-    set_bit(KEY_LOCK, ts->input_dev->keybit);
-#endif
-    ret = input_register_device(ts->input_dev);
-    if (ret) {
-        dev_err(&ts->client->dev,"Probe: Unable to register %s input device\n", ts->input_dev->name);
-        input_free_device(ts->input_dev);
-        return fail;
-    }
-    GTDEBUG_MSG("Register input device successfully!\n");
-
-    return success;
-}
-
-static s32 set_pins(struct goodix_ts_data *ts)
-{
-    s32 ret = -1;
-    
-	//ts->client->irq=TS_INT;        //If not defined in client
-	if (ts->client->irq) {
-		ret = GPIO_REQUEST(ts->interrupt_port, "TS_INT");    //Request IO
-		if (ret < 0) {
-		    dev_err(&ts->client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(s32)ts->interrupt_port,ret);
-		    goto err_gpio_request_failed;
-		}
-		GTDEBUG_MSG("Request int port successfully!\n");
-		
-		GPIO_DIRECTION_INPUT(ts->interrupt_port);
-		GPIO_PULL_UPDOWN(ts->interrupt_port, 0);
-		//GPIO_CFG_PIN(INT_PORT, INT_CFG);        //Set IO port function    
-		
-		ret = request_irq(gpio_to_irq(ts->interrupt_port), goodix_ts_irq_handler,
-				IRQF_TRIGGER_FALLING, ts->client->name, ts);
-
-		if (ret != 0) {
-			dev_err(&ts->client->dev,"Cannot allocate ts INT!ERRNO:%d\n", ret);
-			GPIO_DIRECTION_INPUT(ts->interrupt_port);
-			GPIO_FREE(ts->interrupt_port);
-			goto err_gpio_request_failed;
-		} else {
-		    disable_irq(ts->client->irq);
-		    ts->use_irq = 1;
-		    ts->irq_is_disable = 1;
-		    dev_dbg(&ts->client->dev, "Reques EIRQ %d successed on GPIO:%d\n", gpio_to_irq(ts->interrupt_port), ts->interrupt_port);
-		}
-	}
-
-err_gpio_request_failed:
-    if (!ts->use_irq) {
-        hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-        ts->timer.function = goodix_ts_timer_func;
-        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-        GTDEBUG_MSG("Use timer!\n");
-    }
-
-    ret = GPIO_REQUEST(ts->reset_port, "TS_RESET");    //Request IO
-    if (ret < 0) {
-        dev_err(&ts->client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(s32)ts->reset_port,ret);
-    } else {
-        ts->use_reset = 1;
-        GPIO_DIRECTION_OUTPUT(ts->reset_port,1);
-        GPIO_PULL_UPDOWN(ts->reset_port, 0);
-		GTDEBUG_MSG("Request reset port successfully!\n");	
-    }
-
-    dev_info(&ts->client->dev,"Start %s in %s mode\n", 
-              ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
-
-    return ts->use_irq;
-}
-
-static s32 goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-    s32 ret = 0;
-    s32 retry=0;
-    struct goodix_ts_data *ts = NULL;
-    struct goodix_i2c_rmi_platform_data *pdata = client->dev.platform_data;
-	//struct ft5406_platform_data *pdata = pdata = client->dev.platform_data;
-    printk("w++++++goodix_ts_probe gt28x ");
-
-	if (pdata->init_platform_hw) {
-		pdata->init_platform_hw();
-	}
-
-	//printk("gt82x---0000000000000000\n");
-    //Check I2C function
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-        dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
-        return -ENODEV;
-    }
-
-    ts = kzalloc(sizeof(*ts), GFP_KERNEL);
-    if (ts == NULL) {
-        return -ENOMEM;
-    }
-	pdata = client->dev.platform_data;
-
-    INIT_WORK(&ts->work, goodix_ts_work_func);        //init work_struct
-    ts->client = client;
-    ts->power = goodix_ts_power;
-    ts->bad_data = 0;
-    ts->use_irq = 1;
-    ts->use_reset =1;
-    ts->irq_is_disable = 0;
-    ts->interrupt_port=pdata->gpio_irq;
-    ts->reset_port=pdata->gpio_reset;
-    i2c_set_clientdata(client, ts);
- 
-    if (fail == init_input_dev(ts)) {
-    	kfree(ts);
-        return -1;
-    }
-    set_pins(ts);
-#ifdef CONFIG_HAS_EARLYSUSPEND
-    ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
-    ts->early_suspend.suspend = goodix_ts_early_suspend;
-    ts->early_suspend.resume = goodix_ts_late_resume;
-    register_early_suspend(&ts->early_suspend);
-#endif
-#ifdef CREATE_WR_NODE
-    init_wr_node(client);
-#endif
-#ifdef AUTO_UPDATE_GUITAR
-    if (0xff == init_update_proc(ts)) {
-        GTDEBUG_MSG("Need update!\n");
-        return 0;
-    }
-#else
-    msleep(5);
-    guitar_reset(ts,10);
-#endif
-
-    //Test I2C connection. 
-	//GTDEBUG_MSG("GT82X++++++   Testing I2C connection...\n");
-    for(retry = 0;retry < 3; retry++) {
-		ret = i2c_pre_cmd(ts);
-		if (ret > 0)
-		    break;
-		msleep(20);
-    }
-    if(ret <= 0) {
-		dev_err(&client->dev, "Warnning: I2C communication might be ERROR!\n");
-		GTDEBUG_MSG("I2C test failed. I2C addr:%x\n", client->addr);
-		goodix_ts_remove(ts->client); 
-		return -1;
-    }
-	//printk("gt82x---777777777777777\n");
-	//Send config
-	for (retry = 0; retry < 3; retry++) {
-	    if (success == goodix_init_panel(ts, 1)) {
-	        GTDEBUG_MSG("Initialize successfully!\n");
-	        break;
-	    }
-	}
-    if (retry >= 3) {
-        ts->bad_data=1;
-        GTDEBUG_MSG("Initialize failed!\n");
-        goodix_ts_remove(ts->client);
-        return -1;
-    }
-    //Enable interrupt
-    if(ts->use_irq && ts->irq_is_disable == 1) {
-        ts->irq_is_disable = 0;
-        enable_irq(client->irq);
-    }
-
-    return 0;
-}
-
-static s32 goodix_ts_remove(struct i2c_client *client)
-{
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-    dev_notice(&client->dev,"The driver is removing...\n");
-    
-#ifdef CONFIG_HAS_EARLYSUSPEND
-    unregister_early_suspend(&ts->early_suspend);
-#endif
-
-#ifdef CREATE_WR_NODE
-    uninit_wr_node();
-#endif
-
-    if (ts && ts->use_irq) {
-        free_irq(client->irq, ts);
-        GPIO_DIRECTION_INPUT(ts->interrupt_port);
-        GPIO_FREE(ts->interrupt_port);
-    } else if(ts) {
-        hrtimer_cancel(&ts->timer);
-	}
-
-    if (ts && ts->use_reset) {
-        GPIO_DIRECTION_INPUT(ts->reset_port);
-        GPIO_FREE(ts->interrupt_port);
-    }
-    
-    i2c_set_clientdata(client, NULL);
-    input_unregister_device(ts->input_dev);
-    input_free_device(ts->input_dev);
-    kfree(ts);
-    return success;
-}
-
-static s32 goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-    s32 ret;
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-    if (ts->irq_is_disable == 2) {
-        return 0;
-    }
-
-    if (ts->use_irq) {
-        if (!ts->irq_is_disable) {
-            disable_irq(client->irq);
-            ts->irq_is_disable = 1;
-        }
-    } else {
-        hrtimer_cancel(&ts->timer);
-    }
-    
-    if (ts->power) {
-        ret = ts->power(ts, 0);
-        if (ret <= 0)
-            GTDEBUG_MSG(KERN_ERR "goodix_ts_resume power off failed\n");
-	}
-	printk("-----gt813------suspend.\n");
-    return 0;
-}
-
-static s32 goodix_ts_resume(struct i2c_client *client)
-{
-    s32 ret;
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-    if (ts->irq_is_disable == 2) {
-        return 0;
-    }
-
-    if (ts->power) {
-        ret = ts->power(ts, 1);
-        if (ret <= 0)
-            GTDEBUG_MSG(KERN_ERR "goodix_ts_resume power on failed\n");
-    }
-
-    if (ts->use_irq) {
-        ts->irq_is_disable = 0;
-        enable_irq(client->irq);
-    } else {
-        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-    }
-	printk("-----gt813------goodix_ts_resume.\n");
-
-    return success;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void goodix_ts_early_suspend(struct early_suspend *h)
-{
-    struct goodix_ts_data *ts;
-    ts = container_of(h, struct goodix_ts_data, early_suspend);
-    goodix_ts_suspend(ts->client, PMSG_SUSPEND);
-}
-
-static void goodix_ts_late_resume(struct early_suspend *h)
-{
-    struct goodix_ts_data *ts;
-    ts = container_of(h, struct goodix_ts_data, early_suspend);
-    goodix_ts_resume(ts->client);
-}
-#endif
-
-//******************************Begin of firmware update surpport*******************************
-#ifndef AUTO_UPDATE_GUITAR
-static void guitar_reset( struct goodix_ts_data *ts,u8 ms)
-{
-    GPIO_DIRECTION_OUTPUT(ts->reset_port, 0);
-    GPIO_SET_VALUE(ts->reset_port, 0);
-    msleep(ms);
-
-	//GPIO_DIRECTION_OUTPUT(ts->reset_port);
-    GPIO_SET_VALUE(ts->reset_port, 1);
-    GPIO_PULL_UPDOWN(ts->reset_port, 0);
-
-    msleep(20);
-err_gpio_request_failed:	
-    return;
-}
-#endif
-
-//only one client
-static const struct i2c_device_id goodix_ts_id[] = {
-    {"Goodix-TS-82X", 0 },
-    { }
-};
-
-static struct i2c_driver goodix_ts_driver = {
-    .probe      = goodix_ts_probe,
-    .remove     = goodix_ts_remove,
-#ifndef CONFIG_HAS_EARLYSUSPEND
-    .suspend    = goodix_ts_suspend,
-    .resume     = goodix_ts_resume,
-#endif
-    .id_table   = goodix_ts_id,
-    .driver     = {
-        .name   =  "Goodix-TS-82X",
-        .owner  = THIS_MODULE,
-    },
-};
-
-static s32 __devinit goodix_ts_init(void)
-{
-	int ret; 
-	
-	printk("+++++++++++++++++++++++++++++liqing.\n");
-    goodix_wq = create_workqueue("goodix_wq");        //create a work queue and worker thread
-    if (!goodix_wq) {
-		GTDEBUG_MSG(KERN_ALERT "creat workqueue faiked\n");
-		return -ENOMEM;
-    }
-    ret = i2c_add_driver(&goodix_ts_driver);
-	if (ret) {
-		printk("Register raydium_ts driver failed gt82x.\n");
-		return ret;   //w++
-	}
-#ifdef LONGPRESS_LOCK_SPECKEY
-	if(err_gt82x>=0)   //w++
-
-	ret =driver_create_file(&goodix_ts_driver.driver, &driver_attr_get_lock_status);
-#endif
-    return ret;
-}
-
-static void __exit goodix_ts_exit(void)
-{
-	GTDEBUG_MSG(KERN_ALERT "Touchscreen driver of guitar exited.\n");
-	i2c_del_driver(&goodix_ts_driver);
-	if (goodix_wq)
-		destroy_workqueue(goodix_wq);        //release our work queue
-#ifdef LONGPRESS_LOCK_SPECKEY   //w++
-	driver_remove_file(&goodix_ts_driver.driver, &driver_attr_get_lock_status);
-#endif
-}
-
-module_init(goodix_ts_init);               
-module_exit(goodix_ts_exit);
-
-MODULE_DESCRIPTION("Goodix Touchscreen Driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/input/touchscreen/goodix_touch_82x_760.c b/drivers/input/touchscreen/goodix_touch_82x_760.c
deleted file mode 100644
index 958653dffb1e..000000000000
--- a/drivers/input/touchscreen/goodix_touch_82x_760.c
+++ /dev/null
@@ -1,883 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * 
- * Copyright (C) 2011 Goodix, Inc.
- * 
- * Author: Scott
- * Date: 2012.01.05
- */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <mach/gpio.h>
-//#include <plat/gpio-cfg.h>
-#include <linux/irq.h>
-#include <linux/err.h>
-#include<linux/workqueue.h>
-#include<linux/slab.h>
-#include <linux/goodix_touch_82x.h>    //w++
-
-#include <linux/input/mt.h>
-
-#define READ_TOUCH_ADDR_H   0x0F
-#define READ_TOUCH_ADDR_L   0x40
-#define READ_KEY_ADDR_H     0x0F
-#define READ_KEY_ADDR_L     0x41
-#define READ_COOR_ADDR_H    0x0F
-#define READ_COOR_ADDR_L    0x42
-#define RESOLUTION_LOC      71
-#define TRIGGER_LOC         66
-//#typedef s32 int    //w++
-
-struct goodix_ts_data {
-	uint16_t addr;
-	struct i2c_client *client;
-	struct input_dev *input_dev;
-	bool use_irq;
-	bool use_reset;
-	bool init_finished;
-	struct hrtimer timer;
-	struct work_struct  work;
-	char phys[32];
-	int bad_data;
-	int retry;
-	s32 (*power)(struct goodix_ts_data * ts, s32 on);
-	struct early_suspend early_suspend;
-	int xmax;
-	int ymax;
-	bool swap_xy;
-	bool xpol;
-	bool ypol;
-	int irq_is_disable;
-	int interrupt_port;
-	int reset_port;
-};
-struct goodix_ts_data *ts82x_temp;		//w++
-
-static struct workqueue_struct *goodix_wq;
-static const char *goodix_ts_name ="Goodix TouchScreen of Guitar ";//"Goodix Capacitive TouchScreen";
-
-static s32 goodix_ts_remove(struct i2c_client *);
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void goodix_ts_early_suspend(struct early_suspend *h);
-static void goodix_ts_late_resume(struct early_suspend *h);
-#endif
-
-#ifdef CREATE_WR_NODE
-extern s32 init_wr_node(struct i2c_client*);
-extern void uninit_wr_node(void);
-#endif
-
-#ifdef AUTO_UPDATE_GUITAR
-extern s32 init_update_proc(struct goodix_ts_data *);
-#else
-static void guitar_reset( struct goodix_ts_data *ts,u8 ms);
-#endif
-
-static int err_gt82x = 0;   //w++记载有没有此设备的检测
-//#define LONGPRESS_LOCK_SPECKEY
-#ifdef LONGPRESS_LOCK_SPECKEY
-#define KEY_LOCK KEY_F13
-#define LOCK_LONG_PRESS_CNT 20
-static int Origin2LockPressCnt = 0;
-static int lockflag =0;
-//static int touch_key_hold_press = 0;
-
-ssize_t glock_status_show_gt82x(struct device *dev, char *buf)
-{
-	return sprintf(buf, "%d", lockflag);
-}
-struct timer_list longkey_timer_82x;
-#endif
-#ifdef LONGPRESS_LOCK_SPECKEY
-static DRIVER_ATTR(get_lock_status, 0777, glock_status_show_gt82x, NULL);
-#endif
-
-#if 1
-#define TOUCH_MAX_HEIGHT   1024   //w++2
-#define TOUCH_MAX_WIDTH     600
-#else
-#define AUTO_SET
-u16 TOUCH_MAX_HEIGHT;
-u16 TOUCH_MAX_WIDTH;
-#endif
-
-#define GT828_I2C_RATE 200000
-
-/*Function as i2c_master_send */
-static s32 i2c_read_bytes(struct i2c_client *client, u8 *buf, s32 len)
-{
-    struct i2c_msg msgs[2];
-    s32 ret=-1;
-
-    msgs[0].flags=!I2C_M_RD;
-    msgs[0].addr=client->addr;
-    msgs[0].len=2;
-    msgs[0].buf=&buf[0];
-    msgs[0].scl_rate=100000;
-    msgs[0].udelay=2000;
-
-    msgs[1].flags=I2C_M_RD;
-    msgs[1].addr=client->addr;
-    msgs[1].len=len - ADDR_LENGTH;
-    msgs[1].buf=&buf[2];
-    msgs[1].scl_rate=100000;
-    msgs[1].udelay=2000;	
-
-    ret=i2c_transfer(client->adapter,msgs, 2);
-
-    return ret;
-}
-
-/*Function as i2c_master_send */
-static s32 i2c_write_bytes(struct i2c_client *client,u8 *data,s32 len)
-{
-    struct i2c_msg msg;
-    s32 ret=-1;
-    
-    msg.flags=!I2C_M_RD;
-    msg.addr=client->addr;
-    msg.len=len;
-    msg.buf=data;        
-    msg.scl_rate=100000;
-    msg.udelay=2000;
-    ret=i2c_transfer(client->adapter,&msg, 1);
-
-    return ret;
-}
-
-static s32 i2c_pre_cmd(struct goodix_ts_data *ts)
-{
-    s32 ret;
-    u8 pre_cmd_data[2]={0x0f, 0xff};
-
-    ret=i2c_write_bytes(ts->client,pre_cmd_data,2);
-    return ret;//*/
-}
-
-static s32 i2c_end_cmd(struct goodix_ts_data *ts)
-{
-    s32 ret;
-    u8 end_cmd_data[2]={0x80, 0x00};    
-
-    ret=i2c_write_bytes(ts->client,end_cmd_data,2);
-    return ret;//*/
-}
-
-
-s32 goodix_init_panel(struct goodix_ts_data *ts, u8 send)
-{
-    s32 ret = -1;
-    u8 config_info[]=
-    {
-    0x0F,0x80,/*config address*/
-#if 1	
-// 300-N3216E-A00
-/*
-	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
-	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
-	0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,
-	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x21,0x00,0x00,0x09,0x00,
-	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x25,0x29,
-	0x27,0x2B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x13,0x01,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x01
-*/
-//300-N3788E-A00-V1.0             1024*768
-/*
-	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
-	0x18,0x0A,0x19,0xFF,0x13,0xFF,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,
-	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0x00,0xFF,
-	0x0E,0x0F,0x10,0x11,0x12,0x09,0x03,0x88,0x88,0x88,0x25,0x00,0x00,0x08,0x00,
-	0x00,0x02,0x3C,0x28,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x33,0x38,
-	0x30,0x35,0x25,0x00,0x25,0x19,0x05,0x14,0x10,0x02,0x30,0x01,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x01
-*/
-	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
-	0x18,0x0A,0x19,0x0B,0x1A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
-	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,
-	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x19,0x00,0x00,0x08,0x00,
-	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x2D,0x38,
-	0x2F,0x3B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x01,0x01,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x01
-#else
-	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
-	0x18,0x0A,0x19,0x0B,0x1A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
-	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,
-	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x19,0x00,0x00,0x08,0x00,
-	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x2D,0x38,
-	0x2F,0x3B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x01,0x01,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x01
-#endif
-    };
-
-#ifdef AUTO_SET
-	TOUCH_MAX_WIDTH  = ((config_info[RESOLUTION_LOC] << 8)|config_info[RESOLUTION_LOC + 1]);
-	TOUCH_MAX_HEIGHT = ((config_info[RESOLUTION_LOC + 2] << 8)|config_info[RESOLUTION_LOC + 3]);
-	
-	GTDEBUG_MSG("TOUCH_MAX_WIDTH  : 0x%d\n", (s32)TOUCH_MAX_WIDTH);
-	GTDEBUG_MSG("TOUCH_MAX_HEIGHT : 0x%d\n", (s32)TOUCH_MAX_HEIGHT);
-#else
-
-	config_info[RESOLUTION_LOC]     = TOUCH_MAX_WIDTH >> 8;
-	config_info[RESOLUTION_LOC + 1] = TOUCH_MAX_WIDTH & 0xff;
-	config_info[RESOLUTION_LOC + 2] = TOUCH_MAX_HEIGHT >> 8;
-	config_info[RESOLUTION_LOC + 3] = TOUCH_MAX_HEIGHT & 0xff;
-
-#endif
-
-    if (INT_TRIGGER == GT_IRQ_FALLING) {
-        config_info[TRIGGER_LOC] &= 0xf7; 
-    } else if (INT_TRIGGER == GT_IRQ_RISING) {
-        config_info[TRIGGER_LOC] |= 0x08;
-    }
-
-    if (send) {
-        ret=i2c_write_bytes(ts->client,config_info, (sizeof(config_info)/sizeof(config_info[0])));
-        if (ret <= 0) {
-            return fail;
-        }
-        i2c_end_cmd(ts);
-        msleep(10);
-    }
-    return success;
-}
-
-static s32 touch_num(u8 value, s32 max)
-{
-    s32 tmp = 0;
-
-    while((tmp < max) && value) {
-        if ((value & 0x01) == 1) {
-            tmp++;
-        }
-        value = value >> 1;
-    }
-
-    return tmp;
-}
-
-#ifdef LONGPRESS_LOCK_SPECKEY   //w++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-static void open_longkey_timer_82x(unsigned long data)
-{
-	if((++Origin2LockPressCnt>LOCK_LONG_PRESS_CNT)&&(Origin2LockPressCnt<LOCK_LONG_PRESS_CNT+2)) {  //w++超过一个时间,发长按消息
-		Origin2LockPressCnt = LOCK_LONG_PRESS_CNT + 3;
-		//if(lockflag ==0) {
-			input_report_key(ts82x_temp->input_dev, KEY_LOCK, 1);
-			lockflag = (lockflag)? 0 : 1;
-			input_sync(ts82x_temp->input_dev);
-		//}
-	}
-	longkey_timer_82x.expires=jiffies+msecs_to_jiffies(100);
-	add_timer(&longkey_timer_82x);
-	printk("w++++++++   Origin2LockPressCnt = %d\n",Origin2LockPressCnt); 
-	printk("lockflag = %d\n",lockflag);
-}
-#endif
-
-static void goodix_ts_work_func(struct work_struct *work)
-{
-    u8 finger = 0;
-    u8 chk_sum = 0;
-    u8 key = 0;
-    static u8 last_key = 0;
-    u16 X_value;
-    u16 Y_value;
-	u16 value_tmp;
-    u32 count = 0;
-    u32 position = 0;
-    s32 ret = -1;
-    s32 tmp = 0;
-    s32 i;
-    u8 *coor_point;
-    u8 touch_data[2 + 2 + 5*MAX_FINGER_NUM + 1] = {READ_TOUCH_ADDR_H,READ_TOUCH_ADDR_L,0, 0};
-    static u8 finger_last[MAX_FINGER_NUM]={0};
-    u8 finger_current[MAX_FINGER_NUM] = {0};
-
-    struct goodix_ts_data *ts = container_of(work, struct goodix_ts_data, work);
-    struct i2c_client *client = ts->client;
-	struct goodix_i2c_rmi_platform_data *pdata = client->dev.platform_data;
-	
-#ifndef INT_PORT
-COORDINATE_POLL:
-#endif
-    if( tmp > 9) {
-        dev_info(&(ts->client->dev), "Because of transfer error,touchscreen stop working.\n");
-        goto XFER_ERROR ;
-    }
-
-    ret=i2c_read_bytes(ts->client, touch_data,sizeof(touch_data)/sizeof(touch_data[0])); 
-    i2c_end_cmd(ts);
-    if(ret <= 0) {
-        dev_err(&(ts->client->dev),"I2C transfer error. Number:%d\n ", ret);
-        ts->bad_data = 1;
-        tmp ++;
-#ifndef INT_PORT
-        goto COORDINATE_POLL;
-#else
-        goto XFER_ERROR;
-#endif
-    }
-
-    if(ts->bad_data) {
-        //TODO:Is sending config once again (to reset the chip) useful?    
-        ts->bad_data = 0;
-        msleep(20);
-    }
-
-    if((touch_data[2]&0xC0)!=0x80) {
-        goto DATA_NO_READY;        
-    }
-
-
-    key = touch_data[3]&0x0f; // 1, 2, 4, 8
-    if (key == 0x0f) {
-        if (fail == goodix_init_panel(ts, 1)) {
-			GTDEBUG_COOR("Reload config failed!\n");
-        } else {   
-			GTDEBUG_COOR("Reload config successfully!\n");
-        }
-        goto XFER_ERROR;
-    }
-
-    finger = (u8)touch_num(touch_data[2]&0x1f, MAX_FINGER_NUM);
-
-	GTDEBUG_COOR("touch num:%x\n", finger);
-
-    for (i = 0;i < MAX_FINGER_NUM; i++) {
-        finger_current[i] = !!(touch_data[2] & (0x01<<(i)));
-    }
-
-    coor_point = &touch_data[4];
-    chk_sum = 0;
-    for ( i = 0; i < 5*finger; i++) {
-        chk_sum += coor_point[i];
-		//GTDEBUG_COOR("%5x", coor_point[i]);
-    }
-	//GTDEBUG_COOR("\ncheck sum:%x\n", chk_sum);
-	//GTDEBUG_COOR("check sum byte:%x\n", coor_point[5*finger]);
-    if (chk_sum != coor_point[5*finger]) {
-        goto XFER_ERROR;
-    }
-
-    if (finger) {
-        for(i = 0, position=0;position < MAX_FINGER_NUM; position++) {  
-            if(finger_current[position]) {     
-				X_value = (coor_point[i] << 8) | coor_point[i + 1];
-				Y_value = (coor_point[i + 2] << 8) | coor_point[i + 3];
-				
-				input_mt_slot(ts->input_dev, position);
-				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
-				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, FLAG_DOWN);
-				
-				//input_report_key(ts->input_dev, BTN_TOUCH, 1);
-				//input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, position - 1);
-				if(pdata->swap_xy) {
-					value_tmp = X_value;
-					X_value = Y_value;
-					Y_value = value_tmp;
-				}
-				//printk("goodix_touch_82x X_value=%d,Y_value=%d\n",X_value,Y_value);
-				//if(pdata->xpol)
-					X_value = 1024 - X_value;
-			//	if(pdata->ypol)
-			//		Y_value = 600 - Y_value;
-			//				
-				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, X_value);  //can change x-y!!!
-				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, Y_value);
-				//input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,15);
-				//input_mt_sync(ts->input_dev);
-				i += 5;
-
-				//GTDEBUG_COOR("FI:%x X:%04d Y:%04d\n",position, (s32)Y_value,(s32)X_value);
-				//printk("-----------touch_num:%d;--------FI:%x----------- X:%04d ----------Y:%04d\n",finger,position, (s32)X_value,(s32)Y_value);
-				//GTDEBUG_COOR("Y:%d\n", (s32)Y_value);
-			} else if(finger_last[position]) {
-				input_mt_slot(ts->input_dev, position);
-				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
-				GTDEBUG_COOR(" Finger  %d  release!!\n",position);
-			}
-		}
-	} else {
-		for(position=0;position < MAX_FINGER_NUM; position++) {
-			if( finger_last[position]) {
-				input_mt_slot(ts->input_dev, position);
-				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
-				GTDEBUG_COOR(" Finger  %d  release!!\n",position);
-			}
-		}
-	}
-
-    input_sync(ts->input_dev);
-    
-    for(position=0;position<MAX_FINGER_NUM; position++) {
-        finger_last[position] = finger_current[position];
-    }
-
-DATA_NO_READY:
-XFER_ERROR:
-	if(ts->use_irq && ts->irq_is_disable == 1) {
-		ts->irq_is_disable = 0;
-		enable_irq(ts->client->irq);
-	}
-}
-
-static enum hrtimer_restart goodix_ts_timer_func(struct hrtimer *timer)
-{
-    struct goodix_ts_data *ts = container_of(timer, struct goodix_ts_data, timer);
-
-    queue_work(goodix_wq, &ts->work);
-    hrtimer_start(&ts->timer, ktime_set(0, (POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
-
-    return HRTIMER_NORESTART;
-}
-
-static irqreturn_t goodix_ts_irq_handler(s32 irq, void *dev_id)
-{
-	struct goodix_ts_data *ts = (struct goodix_ts_data*)dev_id;
-	
-	if (ts->use_irq && (!ts->irq_is_disable)) {
-		disable_irq_nosync(ts->client->irq);
-		ts->irq_is_disable = 1;
-	}
-	
-	queue_work(goodix_wq, &ts->work);
-	
-	return IRQ_HANDLED;
-}
-
-//#if defined(INT_PORT)    // 0 : sleep  1 wake up
-static s32 goodix_ts_power(struct goodix_ts_data * ts, s32 on)
-{
-    s32 ret = -1;
-    u8 i2c_control_buf[3] = {0x0f,0xf2,0xc0};        //suspend cmd
-
-    if(ts == NULL || !ts->use_irq)
-        return -2;
-
-    switch(on)
-    {
-    case 0:
-        ret = i2c_write_bytes(ts->client, i2c_control_buf, 3);
-        return ret;
-
-    case 1:
-        GPIO_DIRECTION_OUTPUT(ts->interrupt_port, 0);
-        mdelay(10);
-        GPIO_SET_VALUE(ts->interrupt_port, 1);
-        GPIO_DIRECTION_INPUT(ts->interrupt_port);
-        GPIO_PULL_UPDOWN(ts->interrupt_port, 0);
-        return success;
-
-    default:
-        GTDEBUG_MSG(KERN_DEBUG "%s: Cant't support this command.", goodix_ts_name);
-        return -EINVAL;
-    }
-
-}
-
-static s32 init_input_dev(struct goodix_ts_data *ts)
-{
-    s32 i;
-    s32 ret = 0;
-
-    ts->input_dev = input_allocate_device();
-    if (ts->input_dev == NULL)
-    {
-        dev_dbg(&ts->client->dev,"goodix_ts_probe: Failed to allocate input device\n");
-        return fail;
-    }
- 
-	//ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-	//ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-	//ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);// absolute coor (x,y)
-	
-    goodix_init_panel(ts, 0);
- 
-#ifdef GOODIX_MULTI_TOUCH
-
-	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
-	__set_bit(EV_ABS, ts->input_dev->evbit);
-	input_mt_init_slots(ts->input_dev, MAX_FINGER_NUM);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
-
-	/* 
-	input_mt_init_slots(ts->input_dev, MAX_FINGER_NUM);
-	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
-	*/
-#else
-    input_set_abs_params(ts->input_dev, ABS_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
-    input_set_abs_params(ts->input_dev, ABS_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
-    input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
-#endif    
-
-    memcpy(ts->phys, "input/ts", 8);
-    ts->input_dev->name = goodix_ts_name;
-    ts->input_dev->phys = ts->phys;
-    ts->input_dev->id.bustype = BUS_I2C;
-    ts->input_dev->id.vendor = 0xDEAD;
-    ts->input_dev->id.product = 0xBEEF;
-    ts->input_dev->id.version = 10427;    //screen firmware version
-
-#ifdef LONGPRESS_LOCK_SPECKEY    //w++
-    set_bit(KEY_LOCK, ts->input_dev->keybit);
-#endif
-    ret = input_register_device(ts->input_dev);
-    if (ret) {
-        dev_err(&ts->client->dev,"Probe: Unable to register %s input device\n", ts->input_dev->name);
-        input_free_device(ts->input_dev);
-        return fail;
-    }
-    GTDEBUG_MSG("Register input device successfully!\n");
-
-    return success;
-}
-
-static s32 set_pins(struct goodix_ts_data *ts)
-{
-    s32 ret = -1;
-    
-	//ts->client->irq=TS_INT;        //If not defined in client
-	if (ts->client->irq) {
-		ret = GPIO_REQUEST(ts->interrupt_port, "TS_INT");    //Request IO
-		if (ret < 0) {
-		    dev_err(&ts->client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(s32)ts->interrupt_port,ret);
-		    goto err_gpio_request_failed;
-		}
-		GTDEBUG_MSG("Request int port successfully!\n");
-		
-		GPIO_DIRECTION_INPUT(ts->interrupt_port);
-		GPIO_PULL_UPDOWN(ts->interrupt_port, 0);
-		//GPIO_CFG_PIN(INT_PORT, INT_CFG);        //Set IO port function    
-		
-		ret = request_irq(gpio_to_irq(ts->interrupt_port), goodix_ts_irq_handler,
-				IRQF_TRIGGER_FALLING, ts->client->name, ts);
-
-		if (ret != 0) {
-			dev_err(&ts->client->dev,"Cannot allocate ts INT!ERRNO:%d\n", ret);
-			GPIO_DIRECTION_INPUT(ts->interrupt_port);
-			GPIO_FREE(ts->interrupt_port);
-			goto err_gpio_request_failed;
-		} else {
-		    disable_irq(ts->client->irq);
-		    ts->use_irq = 1;
-		    ts->irq_is_disable = 1;
-		    dev_dbg(&ts->client->dev, "Reques EIRQ %d successed on GPIO:%d\n", gpio_to_irq(ts->interrupt_port), ts->interrupt_port);
-		}
-	}
-
-err_gpio_request_failed:
-    if (!ts->use_irq) {
-        hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-        ts->timer.function = goodix_ts_timer_func;
-        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-        GTDEBUG_MSG("Use timer!\n");
-    }
-
-    ret = GPIO_REQUEST(ts->reset_port, "TS_RESET");    //Request IO
-    if (ret < 0) {
-        dev_err(&ts->client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(s32)ts->reset_port,ret);
-    } else {
-        ts->use_reset = 1;
-        GPIO_DIRECTION_OUTPUT(ts->reset_port,1);
-        GPIO_PULL_UPDOWN(ts->reset_port, 0);
-		GTDEBUG_MSG("Request reset port successfully!\n");	
-    }
-
-    dev_info(&ts->client->dev,"Start %s in %s mode\n", 
-              ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
-
-    return ts->use_irq;
-}
-
-static s32 goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-    s32 ret = 0;
-    s32 retry=0;
-    struct goodix_ts_data *ts = NULL;
-    struct goodix_i2c_rmi_platform_data *pdata = client->dev.platform_data;
-	//struct ft5406_platform_data *pdata = pdata = client->dev.platform_data;
-    printk("w++++++goodix_ts_probe gt28x ");
-
-	if (pdata->init_platform_hw) {
-		pdata->init_platform_hw();
-	}
-
-	//printk("gt82x---0000000000000000\n");
-    //Check I2C function
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-        dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
-        return -ENODEV;
-    }
-
-    ts = kzalloc(sizeof(*ts), GFP_KERNEL);
-    if (ts == NULL) {
-        return -ENOMEM;
-    }
-	pdata = client->dev.platform_data;
-
-    INIT_WORK(&ts->work, goodix_ts_work_func);        //init work_struct
-    ts->client = client;
-    ts->power = goodix_ts_power;
-    ts->bad_data = 0;
-    ts->use_irq = 1;
-    ts->use_reset =1;
-    ts->irq_is_disable = 0;
-    ts->interrupt_port=pdata->gpio_irq;
-    ts->reset_port=pdata->gpio_reset;
-    i2c_set_clientdata(client, ts);
- 
-    if (fail == init_input_dev(ts)) {
-    	kfree(ts);
-        return -1;
-    }
-    set_pins(ts);
-#ifdef CONFIG_HAS_EARLYSUSPEND
-    ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
-    ts->early_suspend.suspend = goodix_ts_early_suspend;
-    ts->early_suspend.resume = goodix_ts_late_resume;
-    register_early_suspend(&ts->early_suspend);
-#endif
-#ifdef CREATE_WR_NODE
-    init_wr_node(client);
-#endif
-#ifdef AUTO_UPDATE_GUITAR
-    if (0xff == init_update_proc(ts)) {
-        GTDEBUG_MSG("Need update!\n");
-        return 0;
-    }
-#else
-    msleep(5);
-    guitar_reset(ts,10);
-#endif
-
-    //Test I2C connection. 
-	//GTDEBUG_MSG("GT82X++++++   Testing I2C connection...\n");
-    for(retry = 0;retry < 3; retry++) {
-		ret = i2c_pre_cmd(ts);
-		if (ret > 0)
-		    break;
-		msleep(20);
-    }
-    if(ret <= 0) {
-		dev_err(&client->dev, "Warnning: I2C communication might be ERROR!\n");
-		GTDEBUG_MSG("I2C test failed. I2C addr:%x\n", client->addr);
-		goodix_ts_remove(ts->client); 
-		return -1;
-    }
-	//printk("gt82x---777777777777777\n");
-	//Send config
-	for (retry = 0; retry < 3; retry++) {
-	    if (success == goodix_init_panel(ts, 1)) {
-	        GTDEBUG_MSG("Initialize successfully!\n");
-	        break;
-	    }
-	}
-    if (retry >= 3) {
-        ts->bad_data=1;
-        GTDEBUG_MSG("Initialize failed!\n");
-        goodix_ts_remove(ts->client);
-        return -1;
-    }
-    //Enable interrupt
-    if(ts->use_irq && ts->irq_is_disable == 1) {
-        ts->irq_is_disable = 0;
-        enable_irq(client->irq);
-    }
-
-    return 0;
-}
-
-static s32 goodix_ts_remove(struct i2c_client *client)
-{
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-    dev_notice(&client->dev,"The driver is removing...\n");
-    
-#ifdef CONFIG_HAS_EARLYSUSPEND
-    unregister_early_suspend(&ts->early_suspend);
-#endif
-
-#ifdef CREATE_WR_NODE
-    uninit_wr_node();
-#endif
-
-    if (ts && ts->use_irq) {
-        free_irq(client->irq, ts);
-        GPIO_DIRECTION_INPUT(ts->interrupt_port);
-        GPIO_FREE(ts->interrupt_port);
-    } else if(ts) {
-        hrtimer_cancel(&ts->timer);
-	}
-
-    if (ts && ts->use_reset) {
-        GPIO_DIRECTION_INPUT(ts->reset_port);
-        GPIO_FREE(ts->interrupt_port);
-    }
-    
-    i2c_set_clientdata(client, NULL);
-    input_unregister_device(ts->input_dev);
-    input_free_device(ts->input_dev);
-    kfree(ts);
-    return success;
-}
-
-static s32 goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-    s32 ret;
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-    if (ts->irq_is_disable == 2) {
-        return 0;
-    }
-
-    if (ts->use_irq) {
-        if (!ts->irq_is_disable) {
-            disable_irq(client->irq);
-            ts->irq_is_disable = 1;
-        }
-    } else {
-        hrtimer_cancel(&ts->timer);
-    }
-    
-    if (ts->power) {
-        ret = ts->power(ts, 0);
-        if (ret <= 0)
-            GTDEBUG_MSG(KERN_ERR "goodix_ts_resume power off failed\n");
-	}
-	printk("-----gt813------suspend.\n");
-    return 0;
-}
-
-static s32 goodix_ts_resume(struct i2c_client *client)
-{
-    s32 ret;
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-    if (ts->irq_is_disable == 2) {
-        return 0;
-    }
-
-    if (ts->power) {
-        ret = ts->power(ts, 1);
-        if (ret <= 0)
-            GTDEBUG_MSG(KERN_ERR "goodix_ts_resume power on failed\n");
-    }
-
-    if (ts->use_irq) {
-        ts->irq_is_disable = 0;
-        enable_irq(client->irq);
-    } else {
-        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-    }
-	printk("-----gt813------goodix_ts_resume.\n");
-
-    return success;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void goodix_ts_early_suspend(struct early_suspend *h)
-{
-    struct goodix_ts_data *ts;
-    ts = container_of(h, struct goodix_ts_data, early_suspend);
-    goodix_ts_suspend(ts->client, PMSG_SUSPEND);
-}
-
-static void goodix_ts_late_resume(struct early_suspend *h)
-{
-    struct goodix_ts_data *ts;
-    ts = container_of(h, struct goodix_ts_data, early_suspend);
-    goodix_ts_resume(ts->client);
-}
-#endif
-
-//******************************Begin of firmware update surpport*******************************
-#ifndef AUTO_UPDATE_GUITAR
-static void guitar_reset( struct goodix_ts_data *ts,u8 ms)
-{
-    GPIO_DIRECTION_OUTPUT(ts->reset_port, 0);
-    GPIO_SET_VALUE(ts->reset_port, 0);
-    msleep(ms);
-
-	//GPIO_DIRECTION_OUTPUT(ts->reset_port);
-    GPIO_SET_VALUE(ts->reset_port, 1);
-    GPIO_PULL_UPDOWN(ts->reset_port, 0);
-
-    msleep(20);
-err_gpio_request_failed:	
-    return;
-}
-#endif
-
-//only one client
-static const struct i2c_device_id goodix_ts_id[] = {
-    {"Goodix-TS-82X", 0 },
-    { }
-};
-
-static struct i2c_driver goodix_ts_driver = {
-    .probe      = goodix_ts_probe,
-    .remove     = goodix_ts_remove,
-#ifndef CONFIG_HAS_EARLYSUSPEND
-    .suspend    = goodix_ts_suspend,
-    .resume     = goodix_ts_resume,
-#endif
-    .id_table   = goodix_ts_id,
-    .driver     = {
-        .name   =  "Goodix-TS-82X",
-        .owner  = THIS_MODULE,
-    },
-};
-
-static s32 __devinit goodix_ts_init(void)
-{
-	int ret; 
-	
-	printk("+++++++++++++++++++++++++++++liqing.\n");
-    goodix_wq = create_workqueue("goodix_wq");        //create a work queue and worker thread
-    if (!goodix_wq) {
-		GTDEBUG_MSG(KERN_ALERT "creat workqueue faiked\n");
-		return -ENOMEM;
-    }
-    ret = i2c_add_driver(&goodix_ts_driver);
-	if (ret) {
-		printk("Register raydium_ts driver failed gt82x.\n");
-		return ret;   //w++
-	}
-#ifdef LONGPRESS_LOCK_SPECKEY
-	if(err_gt82x>=0)   //w++
-
-	ret =driver_create_file(&goodix_ts_driver.driver, &driver_attr_get_lock_status);
-#endif
-    return ret;
-}
-
-static void __exit goodix_ts_exit(void)
-{
-	GTDEBUG_MSG(KERN_ALERT "Touchscreen driver of guitar exited.\n");
-	i2c_del_driver(&goodix_ts_driver);
-	if (goodix_wq)
-		destroy_workqueue(goodix_wq);        //release our work queue
-#ifdef LONGPRESS_LOCK_SPECKEY   //w++
-	driver_remove_file(&goodix_ts_driver.driver, &driver_attr_get_lock_status);
-#endif
-}
-
-module_init(goodix_ts_init);               
-module_exit(goodix_ts_exit);
-
-MODULE_DESCRIPTION("Goodix Touchscreen Driver");
-MODULE_LICENSE("GPL");
-
diff --git a/include/linux/goodix_queue.h b/include/linux/goodix_queue.h
deleted file mode 100644
index a298cd4cda9f..000000000000
--- a/include/linux/goodix_queue.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*---------------------------------------------------------------------------------------------------------
- * kernel/include/linux/goodix_queue.h
- *
- * Copyright(c) 2010 Goodix Technology Corp. All rights reserved.      
- * Author: Eltonny
- * Date: 2010.11.11                                    
- *                                                                                                         
- *---------------------------------------------------------------------------------------------------------*/
- 
-/* 用于管理手指序列的伪队列操作函数，
- * 适用于Goodix的Guitar小屏驱动
- * 调整手指上报顺序以避免出现手指ID交换现象
- * 在大屏驱动中，该功能将被调整
- */ 
-#ifndef _LINUX_GOODIX_QUEUE_H
-#define	_LINUX_GOODIX_QUEUE_H
-#include <linux/goodix_touch.h>
-
-struct point_node
-{
-	uint8_t num;
-	uint8_t state;
-	uint8_t pressure;
-	unsigned int x;
-	unsigned int y;
-};
-
-struct point_queue
-{
-	int length;
-	struct point_node pointer[MAX_FINGER_NUM];
-};
-
-
-/*******************************************************	
-功能：
-	删除手指队列中松键的手指
-参数：
-	point_list
-********************************************************/
-static void del_point(struct point_queue *point_list)
-{
-	int count = point_list->length-1;
-	int position;
-	for(; count >= 0; count--)		//note: must search from tail to head
-    	if(point_list->pointer[count].state == FLAG_UP)
-        {             	
-			if(point_list->length == 0 )
-				return ;
-			position = count;
-			for(; position < MAX_FINGER_NUM -1; position++)
-				point_list->pointer[position] = point_list->pointer[position+1];
-			point_list->length--;
-        }
-}
-
-/*******************************************************	
-功能：
-	在队列尾中加入新增的手指
-参数：
-	point_list
-	num：手指标号
-return：
-	是否成功增加手指
-********************************************************/
-static int add_point(struct point_queue *point_list, int num)
-{
-	if(point_list->length >= MAX_FINGER_NUM || num < 0 )
-		return -1;
-	point_list->pointer[point_list->length].num = num;
-	point_list->pointer[point_list->length].state = FLAG_DOWN;
-	point_list->length++;
-	return 0;
-}
-
-/*******************************************************	
-功能：
-	查找指定标号的手指位置
-参数：
-	point_list
-	num：手指标号
-return：
-	返回找到的手指在队列中的位置
-********************************************************/
-static int search_point(struct point_queue *point_list, int num)
-{
-	int count = 0;
-	if(point_list->length <= 0 || num < 0 || num > MAX_FINGER_NUM)
-		return -1;	//no data
-	for(; count < point_list->length; count++)
-		if(point_list->pointer[count].num == num)
-			return count;
-		else continue;
-	return -1;
-}
-
-/*******************************************************	
-功能：
-	查找松键的手指并设置标志位为FLAG_UP
-参数：
-	point_list
-	num：手指标号
-return：
-	是否成功设置手指标志位
-********************************************************/
-static int set_up_point(struct point_queue *point_list, int num)
-{
-	int number = 0;
-	if(point_list->length <= 0 || num < 0 || num > MAX_FINGER_NUM)
-		return -1;	//no data
-	number = search_point(point_list, num);
-	if(num >= 0)
-	{
-		point_list->pointer[number].state = FLAG_UP;
-		return 0;
-	}
-	return -1;
-}
-
-#endif /* _LINUX_GOODIX_QUEUE_H */
diff --git a/include/linux/goodix_touch.h b/include/linux/goodix_touch.h
deleted file mode 100644
index b51ad5282769..000000000000
--- a/include/linux/goodix_touch.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*---------------------------------------------------------------------------------------------------------
- * kernel/include/linux/goodix_touch.h
- *
- * Copyright(c) 2010 Goodix Technology Corp. All rights reserved.      
- * Author: Eltonny
- * Date: 2010.11.11                                    
- *                                                                                                         
- *---------------------------------------------------------------------------------------------------------*/
-
-#ifndef 	_LINUX_GOODIX_TOUCH_H
-#define		_LINUX_GOODIX_TOUCH_H
-
-#include <linux/earlysuspend.h>
-#include <linux/hrtimer.h>
-#include <linux/i2c.h>
-#include <linux/input.h>
-
-#define GOODIX_I2C_NAME "goodix-ts"
-#define GUITAR_GT80X
-//触摸屏的分辨率
-#define TOUCH_MAX_HEIGHT 	7680	
-#define TOUCH_MAX_WIDTH	 	5120
-//显示屏的分辨率，根据具体平台更改，与触摸屏映射坐标相关
-#define SCREEN_MAX_HEIGHT	1024				
-#define SCREEN_MAX_WIDTH	600
-
-//#define SHUTDOWN_PORT 	RK29_PIN4_PD5			//SHUTDOWN管脚号
-//#define INT_PORT  		RK29_PIN0_PA2			//Int IO port
-
-#if 0
-#ifdef INT_PORT
-	#define TS_INT 		gpio_to_irq(INT_PORT)	//Interrupt Number,EINT18 as 119
-	//#define  INT_CFG    	S3C_GPIO_SFN(3)			//IO configer,EINT type
-#else
-	#define TS_INT 	0
-#endif
-#endif
-
-#define FLAG_UP 	0
-#define FLAG_DOWN 	1
-
-#define GOODIX_MULTI_TOUCH
-#ifndef GOODIX_MULTI_TOUCH
-	#define MAX_FINGER_NUM 1
-#else
-	#define MAX_FINGER_NUM 2					//最大支持手指数(<=5)
-#endif
-#undef GOODIX_TS_DEBUG
-
-#define gt80xy_swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
-
-struct goodix_ts_data {
-	uint16_t addr;
-	struct i2c_client *client;
-	struct input_dev *input_dev;
-	uint8_t use_irq;
-	uint8_t use_shutdown;
-	struct hrtimer timer;
-	struct work_struct  work;
-	char phys[32];
-	int bad_data;
-	int retry;
-
-	struct early_suspend early_suspend;
-	int (*power)(struct goodix_ts_data * ts, int on);
-};
-
-struct goodix_i2c_rmi_platform_data {
-	uint32_t version;	/* Use this entry for panels with */
-	//该结构体用于管理设备平台资源
-	//预留，用于之后的功能扩展
-
-	unsigned shutdown_pin;
-	unsigned irq_pin;
-};
-
-#endif /* _LINUX_GOODIX_TOUCH_H */
diff --git a/include/linux/goodix_touch_82x.h b/include/linux/goodix_touch_82x.h
deleted file mode 100644
index 0b8f92fb04f6..000000000000
--- a/include/linux/goodix_touch_82x.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * 
- * Copyright (C) 2011 Goodix, Inc.
- * 
- * Author: Scott
- * Date: 2012.01.05
- */
-
-#ifndef _LINUX_GOODIX_TOUCH_H
-#define _LINUX_GOODIX_TOUCH_H
-
-#include <linux/earlysuspend.h>
-#include <linux/hrtimer.h>
-#include <linux/i2c.h>
-#include <linux/input.h>
-
-#define fail    0
-#define success 1
-
-#define false   0
-#define true    1
-
-#define FLAG_UP 		0
-#define FLAG_DOWN 	1
-
-#define RELEASE_DATE "2012-02-07"
-
-#define GOODIX_I2C_NAME	 "Goodix-TS-82X"
-#define GOODIX_I2C_ADDR     0X5D
-
-#if 1
-#define GTDEBUG(fmt, arg...) printk("<--GT-DEBUG-->"fmt, ##arg)
-#else
-#define DEBUG(fmt, arg...)
-#endif
-
-#if 1
-#define GTNOTICE(fmt, arg...) printk("<--GT-NOTICE-->"fmt, ##arg)
-#else
-#define NOTICE(fmt, arg...)
-#endif
-
-#if 1
-#define GTWARNING(fmt, arg...) printk("<--GT-WARNING-->"fmt, ##arg)
-#else
-#define WARNING(fmt, arg...)
-#endif
-
-#if 1
-#define GTDEBUG_MSG(fmt, arg...) printk("<--GT msg-->"fmt, ##arg)
-#else
-#define DEBUG_MSG(fmt, arg...)
-#endif
-
-#if 1
-#define GTDEBUG_UPDATE(fmt, arg...) printk("<--GT update-->"fmt, ##arg)
-#else
-#define DEBUG_UPDATE(fmt, arg...)
-#endif 
-
-#if 0   //w++
-#define GTDEBUG_COOR(fmt, arg...) printk(fmt, ##arg)
-#define GTDEBUG_COORD
-#else
-#define GTDEBUG_COOR(fmt, arg...)
-#define DEBUG_COOR(fmt, arg...)
-#endif
-
-#if 1
-#define GTDEBUG_ARRAY(array, num)   do{\
-                                   int i;\
-                                   u8* a = array;\
-                                   for (i = 0; i < (num); i++)\
-                                   {\
-                                       printk("%02x   ", (a)[i]);\
-                                       if ((i + 1 ) %10 == 0)\
-                                       {\
-                                           printk("\n");\
-                                       }\
-                                   }\
-                                   printk("\n");\
-                                  }while(0)
-#else
-#define DEBUG_ARRAY(array, num) 
-#endif 
-
-#define ADDR_MAX_LENGTH     2
-#define ADDR_LENGTH         ADDR_MAX_LENGTH
-
-//#define CREATE_WR_NODE
-//#define AUTO_UPDATE_GUITAR             //ϵԶжǷҪ
-
-//--------------------------For user redefine-----------------------------//
-//-------------------------GPIO REDEFINE START----------------------------//
-#define GPIO_DIRECTION_INPUT(port)          gpio_direction_input(port)
-#define GPIO_DIRECTION_OUTPUT(port, val)    gpio_direction_output(port, val)
-#define GPIO_SET_VALUE(port, val)           gpio_set_value(port, val)
-#define GPIO_FREE(port)                     gpio_free(port)
-#define GPIO_REQUEST(port, name)            gpio_request(port, name)
-#define GPIO_PULL_UPDOWN(port, val)      gpio_pull_updown(port,val)  // s3c_gpio_setpull(port, val)
-#define GPIO_CFG_PIN(port, cfg)                 //s3c_gpio_cfgpin(port, cfg)
-//-------------------------GPIO REDEFINE END------------------------------//
-
-
-//*************************TouchScreen Work Part Start**************************
-
-#define RESET_PORT          S3C64XX_GPF(3)          //RESETܽź
-#define INT_PORT            S3C64XX_GPL(10)         //Int IO port
-#ifdef INT_PORT
-    #define TS_INT          gpio_to_irq(INT_PORT)      //Interrupt Number,EINT18(119)
-    #define INT_CFG         S3C_GPIO_SFN(3)            //IO configer as EINT
-#else
-    #define TS_INT          0
-#endif
-
-
-#define GT_IRQ_RISING       IRQ_TYPE_EDGE_RISING
-#define GT_IRQ_FALLING      IRQ_TYPE_EDGE_FALLING
-#define INT_TRIGGER         GT_IRQ_FALLING
-#define POLL_TIME           10        //actual query spacing interval:POLL_TIME+6
-
-#define GOODIX_MULTI_TOUCH
-#ifdef GOODIX_MULTI_TOUCH
-    #define MAX_FINGER_NUM    5
-#else
-    #define MAX_FINGER_NUM    1
-#endif
-
-#define gtswap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
-
-struct goodix_i2c_rmi_platform_data {
- /*   u8 bad_data;	
-    u8 irq_is_disable;
-    u16 addr;
-    s32 use_reset;        //use RESET flag
-    s32 use_irq;          //use EINT flag
-    u32 version;
-    s32 (*power)(struct goodix_ts_data * ts, s32 on);
-    struct i2c_client *client;
-    struct input_dev *input_dev;
-    struct hrtimer timer;
-    struct work_struct work;
-    struct early_suspend early_suspend;
-    s8 phys[32];
-*/	
-    uint32_t version;	/* Use this entry for panels with */
-    unsigned gpio_shutdown;
-    unsigned gpio_irq;
-    unsigned gpio_reset;
-    bool irq_edge; /* 0:rising edge, 1:falling edge */
-    bool swap_xy;
-    bool xpol;
-    bool ypol;
-    int xmax;
-    int ymax;
-    int config_info_len;
-    u8 *config_info;
-    int (*init_platform_hw)(void);
-
-};
-//*************************TouchScreen Work Part End****************************
-
-#endif /* _LINUX_GOODIX_TOUCH_H */
-- 
2.35.3

