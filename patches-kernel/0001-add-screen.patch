From b6da7672a0111bdb4177ddb8b0454bde0dfc67ff Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E9=92=9F=E5=8B=87=E6=B1=AA?= <zyw@rock-chips.com>
Date: Fri, 14 May 2010 12:57:10 +0000
Subject: [PATCH] add screen

---
 drivers/video/display/screen/Kconfig          |  38 ++
 drivers/video/display/screen/Makefile         |  28 ++
 drivers/video/display/screen/hdmi_anx7150.c   | 130 +++++
 drivers/video/display/screen/hdmi_null.c      |  14 +
 drivers/video/display/screen/lanmow7_lcd048.c | 193 ++++++++
 drivers/video/display/screen/lcd_a060se02.c   | 162 ++++++
 drivers/video/display/screen/lcd_hl070vm4.c   | 189 +++++++
 drivers/video/display/screen/lcd_hsd800x480.c | 226 +++++++++
 drivers/video/display/screen/lcd_nt35580.c    | 461 ++++++++++++++++++
 drivers/video/display/screen/lcd_nt35582.c    | 429 ++++++++++++++++
 drivers/video/display/screen/lcd_null.c       |  16 +
 drivers/video/display/screen/lcd_s1d13521.c   | 323 ++++++++++++
 drivers/video/display/screen/lcd_td043mgea1.c | 259 ++++++++++
 .../video/display/screen/lcd_tj048nc01ca.c    | 193 ++++++++
 drivers/video/display/screen/s1d13521.h       |  95 ++++
 drivers/video/display/screen/s1d13521ioctl.h  | 134 +++++
 drivers/video/display/screen/screen.h         |  86 ++++
 drivers/video/display/screen/tv_null.c        |  15 +
 18 files changed, 2991 insertions(+)
 create mode 100755 drivers/video/display/screen/Kconfig
 create mode 100755 drivers/video/display/screen/Makefile
 create mode 100755 drivers/video/display/screen/hdmi_anx7150.c
 create mode 100755 drivers/video/display/screen/hdmi_null.c
 create mode 100755 drivers/video/display/screen/lanmow7_lcd048.c
 create mode 100755 drivers/video/display/screen/lcd_a060se02.c
 create mode 100755 drivers/video/display/screen/lcd_hl070vm4.c
 create mode 100755 drivers/video/display/screen/lcd_hsd800x480.c
 create mode 100755 drivers/video/display/screen/lcd_nt35580.c
 create mode 100755 drivers/video/display/screen/lcd_nt35582.c
 create mode 100755 drivers/video/display/screen/lcd_null.c
 create mode 100755 drivers/video/display/screen/lcd_s1d13521.c
 create mode 100755 drivers/video/display/screen/lcd_td043mgea1.c
 create mode 100755 drivers/video/display/screen/lcd_tj048nc01ca.c
 create mode 100755 drivers/video/display/screen/s1d13521.h
 create mode 100755 drivers/video/display/screen/s1d13521ioctl.h
 create mode 100755 drivers/video/display/screen/screen.h
 create mode 100755 drivers/video/display/screen/tv_null.c

diff --git a/drivers/video/display/screen/Kconfig b/drivers/video/display/screen/Kconfig
new file mode 100755
index 000000000000..53eb5911607e
--- /dev/null
+++ b/drivers/video/display/screen/Kconfig
@@ -0,0 +1,38 @@
+choice
+    depends on DISPLAY_SUPPORT
+	prompt  "LCD Panel Select"
+config LCD_NULL
+	bool "NULL"
+config LCD_TD043MGEA1
+	bool "RGB TD043MGEA1"
+config LCD_TJ048NC01CA
+    bool "RGB TJ048NC01CA"
+config LCD_HL070VM4AU
+    bool "RGB_HL070VM4AU"
+config LCD_HSD070IDW1
+    bool "RGB Hannstar800x480"
+config LCD_A060SE02
+    bool "MCU A060SE02"
+config LCD_S1D13521
+    bool "MCU S1D13521"
+config LCD_NT35582
+	bool "MCU NT35582"
+config LCD_NT35580
+	bool "MCU NT35580"
+endchoice
+
+choice
+    depends on DISPLAY_SUPPORT
+	prompt  "TVOUT Chip Select"
+config TV_NULL
+	bool "NULL"
+endchoice
+
+choice
+    depends on DISPLAY_SUPPORT
+	prompt  "HDMI Chip Select"
+config HDMI_NULL
+	bool "NULL"
+config HDMI_ANX7150
+	bool "HDMI ANX7150"
+endchoice
diff --git a/drivers/video/display/screen/Makefile b/drivers/video/display/screen/Makefile
new file mode 100755
index 000000000000..6cad992cf25b
--- /dev/null
+++ b/drivers/video/display/screen/Makefile
@@ -0,0 +1,28 @@
+obj-$(CONFIG_LCD_NULL) += lcd_null.o
+obj-$(CONFIG_TV_NULL) += tv_null.o
+obj-$(CONFIG_HDMI_NULL) += hdmi_null.o
+
+
+obj-$(CONFIG_LCD_TD043MGEA1) += lcd_td043mgea1.o
+obj-$(CONFIG_LCD_HSD070IDW1) += lcd_hsd800x480.o
+obj-$(CONFIG_LCD_HL070VM4AU) += lcd_hl070vm4.o
+ifeq ($(CONFIG_MACH_RK2808SDK),y)
+obj-$(CONFIG_LCD_TJ048NC01CA) 		+= lcd_tj048nc01ca.o
+endif
+ifeq ($(CONFIG_MACH_PWS700AA),y)
+obj-$(CONFIG_LCD_TJ048NC01CA) 		+= lcd_tj048nc01ca.o
+endif
+ifeq ($(CONFIG_MACH_LANMO_W7),y)
+obj-$(CONFIG_LCD_TJ048NC01CA) 		+= lanmow7_lcd048.o
+endif
+
+obj-$(CONFIG_LCD_A060SE02) += lcd_a060se02.o
+obj-$(CONFIG_LCD_S1D13521) += lcd_s1d13521.o
+obj-$(CONFIG_LCD_NT35582) += lcd_nt35582.o
+obj-$(CONFIG_LCD_NT35580) += lcd_nt35580.o
+
+obj-$(CONFIG_HDMI_ANX7150) += hdmi_anx7150.o
+
+
+
+
diff --git a/drivers/video/display/screen/hdmi_anx7150.c b/drivers/video/display/screen/hdmi_anx7150.c
new file mode 100755
index 000000000000..24da4a6cbc8c
--- /dev/null
+++ b/drivers/video/display/screen/hdmi_anx7150.c
@@ -0,0 +1,130 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define DCLK_POL		0
+#define SWAP_RB			1
+
+/* 576p Timing */
+#define OUT_CLK			27
+#define H_PW			64
+#define H_BP			132
+#define H_VD			720
+#define H_FP			12
+#define V_PW			5
+#define V_BP			44
+#define V_VD			576
+#define V_FP			5
+
+/* 720p Timing */
+#define OUT_CLK2	    74
+#define H_PW2			40
+#define H_BP2			260
+#define H_VD2			1280
+#define H_FP2			440
+#define V_PW2			5
+#define V_BP2			25
+#define V_VD2			720
+#define V_FP2			5
+
+
+int anx7150_init(void);
+int anx7150_standby(u8 enable);
+
+
+void set_hdmi_info(struct rk28fb_screen *screen)
+{
+    struct rk28fb_screen *screen2 = screen + 1;
+
+    /* ****************** 576p ******************* */
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = anx7150_init;
+    screen->standby = anx7150_standby;
+
+
+    /* ****************** 720p ******************* */
+    /* screen type & face */
+    screen2->type = OUT_TYPE;
+    screen2->face = OUT_FACE;
+
+    /* Screen size */
+    screen2->x_res = H_VD2;
+    screen2->y_res = V_VD2;
+
+    /* Timing */
+    screen2->pixclock = OUT_CLK2;
+	screen2->left_margin = H_BP2;
+	screen2->right_margin = H_FP2;
+	screen2->hsync_len = H_PW2;
+	screen2->upper_margin = V_BP2;
+	screen2->lower_margin = V_FP2;
+	screen2->vsync_len = V_PW2;
+
+	/* Pin polarity */
+	screen2->pin_hsync = 0;
+	screen2->pin_vsync = 0;
+	screen2->pin_den = 0;
+	screen2->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen2->swap_rb = SWAP_RB;
+    screen2->swap_rg = 0;
+    screen2->swap_gb = 0;
+    screen2->swap_delta = 0;
+    screen2->swap_dumy = 0;
+
+    /* Operation function*/
+    screen2->init = anx7150_init;
+    screen2->standby = anx7150_standby;
+}
+
+
+int anx7150_init(void)
+{
+    return 0;
+}
+
+int anx7150_standby(u8 enable)
+{
+    return 0;
+}
+
diff --git a/drivers/video/display/screen/hdmi_null.c b/drivers/video/display/screen/hdmi_null.c
new file mode 100755
index 000000000000..c39836d4e44e
--- /dev/null
+++ b/drivers/video/display/screen/hdmi_null.c
@@ -0,0 +1,14 @@
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk2818_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include "screen.h"
+
+
+void set_hdmi_info(struct rk28fb_screen *screen)
+{
+    memset(screen, 0, sizeof(struct rk28fb_screen));
+    screen->face = OUT_P666;
+}
diff --git a/drivers/video/display/screen/lanmow7_lcd048.c b/drivers/video/display/screen/lanmow7_lcd048.c
new file mode 100755
index 000000000000..4e4fee9c100f
--- /dev/null
+++ b/drivers/video/display/screen/lanmow7_lcd048.c
@@ -0,0 +1,193 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			23
+
+/* Timing */
+#define H_PW			1
+#define H_BP			120
+#define H_VD			800
+#define H_FP			20
+
+#define V_PW			1
+#define V_BP			20
+#define V_VD			480
+#define V_FP			4
+
+/* Other */
+#define DCLK_POL		1
+#define SWAP_RB			1
+
+int lcd_init(void);
+int lcd_standby(u8 enable);
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    //screen->init = lcd_init;
+    screen->standby = lcd_standby;
+
+}
+
+void spi_screenreg_set(uint32 Addr, uint32 Data)
+{
+#define CS_OUT()        GPIOSetPinDirection(GPIOPortB_Pin3, GPIO_OUT)
+#define CS_SET()        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_HIGH)
+#define CS_CLR()        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_LOW)
+#define CLK_OUT()       GPIOSetPinDirection(GPIOPortE_Pin5, GPIO_OUT)  //I2C0_SCL
+#define CLK_SET()       GPIOSetPinLevel(GPIOPortE_Pin5, GPIO_HIGH)
+#define CLK_CLR()       GPIOSetPinLevel(GPIOPortE_Pin5, GPIO_LOW)
+#define TXD_OUT()       GPIOSetPinDirection(GPIOPortE_Pin4, GPIO_OUT)  //I2C0_SDA
+#define TXD_SET()       GPIOSetPinLevel(GPIOPortE_Pin4, GPIO_HIGH)
+#define TXD_CLR()       GPIOSetPinLevel(GPIOPortE_Pin4, GPIO_LOW)
+
+#define DRVDelayUs(i)   udelay(i*2)
+
+    uint32 i;
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    DRVDelayUs(2);
+    DRVDelayUs(2);
+
+    CS_SET();
+    TXD_CLR();
+    CLK_CLR();
+    DRVDelayUs(2);
+
+	CS_CLR();
+	for(i = 0; i < 7; i++)  //reg
+	{
+		if(Addr &(1<<(6-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+		CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	TXD_CLR();  //write
+
+	// \u6a21\u62dfCLK
+    CLK_CLR();
+    DRVDelayUs(2);
+    CLK_SET();
+    DRVDelayUs(2);
+
+	for(i = 0; i < 8; i++)  //data
+	{
+		if(Data &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+        CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	CS_SET();
+	CLK_CLR();
+	TXD_CLR();
+	DRVDelayUs(2);
+
+}
+
+
+int lcd_init(void)
+{
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_GPIO1_A45);
+	
+	//R(0xess (A5~A0) Data(D7~D0)
+#if 0
+    spi_screenreg_set(0x03, 0x86);
+    spi_screenreg_set(0x05, 0x33);
+    spi_screenreg_set(0x09, 0xFF);
+    spi_screenreg_set(0x3A, 0x95);
+    spi_screenreg_set(0x3C, 0xE0);
+    spi_screenreg_set(0x3D, 0xF4);
+    spi_screenreg_set(0x3E, 0x21);
+    spi_screenreg_set(0x3F, 0x87);
+    spi_screenreg_set(0x15, 0x55);
+    spi_screenreg_set(0x16, 0xAF);
+    spi_screenreg_set(0x17, 0xFC);
+    spi_screenreg_set(0x18, 0x00);
+    spi_screenreg_set(0x19, 0x4B);
+    spi_screenreg_set(0x1A, 0x80);
+    spi_screenreg_set(0x1B, 0xFF);
+    spi_screenreg_set(0x1C, 0x39);
+    spi_screenreg_set(0x1D, 0x69);
+    spi_screenreg_set(0x1E, 0x9F);
+    spi_screenreg_set(0x1F, 0x09);
+    spi_screenreg_set(0x20, 0x8F);
+    spi_screenreg_set(0x21, 0xF0);
+    spi_screenreg_set(0x22, 0x2B);
+    spi_screenreg_set(0x23, 0x58);
+    spi_screenreg_set(0x24, 0x7C);
+    spi_screenreg_set(0x25, 0xA5);
+    spi_screenreg_set(0x26, 0xFF);
+#endif
+
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_I2C0);
+    return 0;
+}
+
+int lcd_standby(u8 enable)
+{
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_GPIO1_A45);
+	if(enable) {
+		spi_screenreg_set(0x43, 0x20);
+	} else {
+		spi_screenreg_set(0x43, 0xE0);
+	}
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_I2C0);
+    return 0;
+}
+
+
diff --git a/drivers/video/display/screen/lcd_a060se02.c b/drivers/video/display/screen/lcd_a060se02.c
new file mode 100755
index 000000000000..f67ff453bcc6
--- /dev/null
+++ b/drivers/video/display/screen/lcd_a060se02.c
@@ -0,0 +1,162 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_MCU
+#define OUT_FACE		OUT_P16BPP4
+
+/* Timing */
+#define H_PW			1
+#define H_BP			1
+#define H_VD			600
+#define H_FP			5
+
+#define V_PW			1
+#define V_BP			1
+#define V_VD			800
+#define V_FP			1
+
+#define P_WR            200
+
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			1
+
+
+
+int lcd_init(void)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    // init set
+    mcu_ioctl(MCU_WRCMD, 0x0000);
+    mcu_ioctl(MCU_WRDATA, 0x0001);
+
+    // start display
+    mcu_ioctl(MCU_WRCMD, 0x1001);
+    mcu_ioctl(MCU_WRDATA, 0x0001);
+    mcu_ioctl(MCU_WRDATA, 0x0001);
+    mcu_ioctl(MCU_WRDATA, 0x0320);
+    mcu_ioctl(MCU_WRDATA, 0x0258);
+
+    // 初始化图象
+    int i=0, j=0;
+    while(0)
+    {
+        mcu_ioctl(MCU_WRCMD, 0x1001);
+        mcu_ioctl(MCU_WRDATA, 0x0001);
+        mcu_ioctl(MCU_WRDATA, 0x0001);
+        mcu_ioctl(MCU_WRDATA, 0x0320);
+        mcu_ioctl(MCU_WRDATA, 0x0258);
+
+        for(i=0; i<800*100; i++)
+            mcu_ioctl(MCU_WRDATA, j%2 ? 0xffff : 0x0000);
+        for(i=0; i<800*100; i++)
+            mcu_ioctl(MCU_WRDATA, j%2 ? 0x0000 : 0xffff);
+        j++;
+
+        mcu_ioctl(MCU_WRCMD, 0x1002);
+        msleep(2000);
+        printk(">>>>>> lcd_init : send test image! \n");
+    }
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return 0;
+}
+
+int lcd_standby(u8 enable)
+{
+    return 0;
+}
+
+int lcd_refresh(u8 arg)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    switch(arg)
+    {
+    case REFRESH_PRE:   //DMA传送前准备
+    #if 0
+        mcu_ioctl(MCU_WRCMD, 0x1001);
+        mcu_ioctl(MCU_WRDATA, 0x0001);
+        mcu_ioctl(MCU_WRDATA, 0x0001);
+        mcu_ioctl(MCU_WRDATA, 0x0320);
+        mcu_ioctl(MCU_WRDATA, 0x0258);
+        printk(">>>>>> lcd_refresh : REFRESH_PRE! \n");
+    #else
+        // init set
+        mcu_ioctl(MCU_WRCMD, 0x0000);
+        mcu_ioctl(MCU_WRDATA, 0x0001);
+        // start display
+        mcu_ioctl(MCU_WRCMD, 0x1001);
+        mcu_ioctl(MCU_WRDATA, 0x0001);
+        mcu_ioctl(MCU_WRDATA, 0x0001);
+        mcu_ioctl(MCU_WRDATA, 0x0320);
+        mcu_ioctl(MCU_WRDATA, 0x0258);
+        printk(">>>>>> lcd_refresh : REFRESH_PRE!!! \n");
+    #endif
+        break;
+
+    case REFRESH_END:   //DMA传送结束后
+        mcu_ioctl(MCU_WRCMD, 0x1002);
+        printk(">>>>>> lcd_refresh : REFRESH_END! \n");
+        break;
+
+    default:
+        break;
+    }
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+
+    return 0;
+}
+
+
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+	screen->mcu_wrperiod = P_WR;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = lcd_init;
+    screen->standby = lcd_standby;
+    screen->refresh = lcd_refresh;
+}
+
+
+
+
diff --git a/drivers/video/display/screen/lcd_hl070vm4.c b/drivers/video/display/screen/lcd_hl070vm4.c
new file mode 100755
index 000000000000..8d5b43b242d3
--- /dev/null
+++ b/drivers/video/display/screen/lcd_hl070vm4.c
@@ -0,0 +1,189 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			27
+
+/* Timing */
+#define H_PW			10
+#define H_BP			206  
+#define H_VD			800
+#define H_FP			40
+
+#define V_PW			10
+#define V_BP			25
+#define V_VD			480
+#define V_FP			10
+
+/* Other */
+#define DCLK_POL		1 ///0
+#define SWAP_RB			1
+
+int init(void);
+int standby(u8 enable);
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = init;
+    screen->standby = standby;
+}
+
+
+//void spi_screenreg_set(uint32 Addr, uint32 Data)
+void spi_screenreg_set(uint32 Data)
+{
+//#define CS_OUT()        GPIOSetPinDirection(GPIOPortB_Pin3, GPIO_OUT)	//CS
+#define CS_OUT()		GPIOSetPinDirection(GPIOPortB_Pin2, GPIO_OUT)
+#define CS_SET()        GPIOSetPinLevel(GPIOPortB_Pin2, GPIO_HIGH)
+#define CS_CLR()        GPIOSetPinLevel(GPIOPortB_Pin2, GPIO_LOW)
+//#define CLK_OUT()       GPIOSetPinDirection(GPIOPortE_Pin7, GPIO_OUT)  //I2C0_SCL
+#define CLK_OUT()		GPIOSetPinDirection(GPIOPortE_Pin5, GPIO_OUT)
+#define CLK_SET()       GPIOSetPinLevel(GPIOPortE_Pin5, GPIO_HIGH)
+#define CLK_CLR()       GPIOSetPinLevel(GPIOPortE_Pin5, GPIO_LOW)
+//#define TXD_OUT()       GPIOSetPinDirection(GPIOPortE_Pin6, GPIO_OUT)  //I2C0_SDA
+#define TXD_OUT()		GPIOSetPinDirection(GPIOPortE_Pin4, GPIO_OUT)
+#define TXD_SET()       GPIOSetPinLevel(GPIOPortE_Pin4, GPIO_HIGH)
+#define TXD_CLR()       GPIOSetPinLevel(GPIOPortE_Pin4, GPIO_LOW)
+
+#define DRVDelayUs(i)   udelay(i*2)
+    uint32 i;
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    DRVDelayUs(2);
+    DRVDelayUs(2);
+
+    CS_SET();
+    TXD_SET();
+    CLK_SET();
+    DRVDelayUs(2);
+
+	CS_CLR();
+	for(i = 0; i < 16; i++)  //reg
+	{
+		if(Data &(1<<(15-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+		CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+/*
+	TXD_CLR();  //write
+
+	// \u6a21\u62dfCLK
+    CLK_CLR();
+    DRVDelayUs(2);
+    CLK_SET();
+    DRVDelayUs(2);
+
+	TXD_SET();  //highz
+
+	// \u6a21\u62dfCLK
+    CLK_CLR();
+    DRVDelayUs(2);
+    CLK_SET();
+    DRVDelayUs(2);
+
+
+	//for(i = 0; i < 8; i++)  //data
+	for(i = 0; i < 16; i++)
+	{
+		if(Data &(1<<(15-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+        CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+*/
+	CS_SET();
+	CLK_CLR();
+	TXD_CLR();
+	DRVDelayUs(2); 
+
+}
+
+
+int init(void)
+{
+    rockchip_mux_api_set(GPIOB2_U0CTSN_SEL_NAME, IOMUXB_GPIO0_B2);    
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_GPIO1_A45);    
+/*
+r0 00000010 11011011
+r1 00010001 01101111
+r2 00100000 10000000
+r3 00110000 00001000
+r4 01000001 10010000-->>01000001 10011111
+r5 01100001 11001110
+*/
+	spi_screenreg_set(0x02db);
+	spi_screenreg_set(0x116f);
+	spi_screenreg_set(0x2080);
+	spi_screenreg_set(0x3008);
+	spi_screenreg_set(0x419f);
+	spi_screenreg_set(0x61ce);
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_I2C0);
+    return 0;
+}
+
+int standby(u8 enable)
+{
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_GPIO1_A45);
+	if(!enable) {
+		init();
+	} //else {
+//		spi_screenreg_set(0x03, 0x5f);
+//	}
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_I2C0);
+    return 0;
+}
+
diff --git a/drivers/video/display/screen/lcd_hsd800x480.c b/drivers/video/display/screen/lcd_hsd800x480.c
new file mode 100755
index 000000000000..5fd7fa771560
--- /dev/null
+++ b/drivers/video/display/screen/lcd_hsd800x480.c
@@ -0,0 +1,226 @@
+/* This Lcd Driver is HSD070IDW1 write by cst 2009.10.27 */
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			28
+
+/* Timing */
+#define H_PW			1
+#define H_BP			88
+#define H_VD			800
+#define H_FP			40
+
+#define V_PW			3
+#define V_BP			29
+#define V_VD			480
+#define V_FP			13
+
+/* Other */
+#define DCLK_POL		1
+#define SWAP_RB			1
+
+int init(void);
+int standby(u8 enable);
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    /*screen->init = init;*/
+    screen->init = NULL; 
+    screen->standby = standby;
+}
+//cannot need init,so set screen->init = null at rk28_fb.c file 
+
+void spi_screenreg_set(uint32 Addr, uint32 Data)
+{
+#define CS_OUT()        GPIOSetPinDirection(GPIOPortB_Pin3, GPIO_OUT)
+#define CS_SET()        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_HIGH)
+#define CS_CLR()        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_LOW)
+#define CLK_OUT()       GPIOSetPinDirection(GPIOPortE_Pin7, GPIO_OUT)  //I2C0_SCL
+#define CLK_SET()       GPIOSetPinLevel(GPIOPortE_Pin7, GPIO_HIGH)
+#define CLK_CLR()       GPIOSetPinLevel(GPIOPortE_Pin7, GPIO_LOW)
+#define TXD_OUT()       GPIOSetPinDirection(GPIOPortE_Pin6, GPIO_OUT)  //I2C0_SDA
+#define TXD_SET()       GPIOSetPinLevel(GPIOPortE_Pin6, GPIO_HIGH)
+#define TXD_CLR()       GPIOSetPinLevel(GPIOPortE_Pin6, GPIO_LOW)
+
+#define DRVDelayUs(i)   udelay(i*2)
+
+    uint32 i;
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    DRVDelayUs(2);
+    DRVDelayUs(2);
+
+    CS_SET();
+    TXD_SET();
+    CLK_SET();
+    DRVDelayUs(2);
+
+	CS_CLR();
+	for(i = 0; i < 6; i++)  //reg
+	{
+		if(Addr &(1<<(5-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+		CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	TXD_CLR();  //write
+
+	// \u6a21\u62dfCLK
+    CLK_CLR();
+    DRVDelayUs(2);
+    CLK_SET();
+    DRVDelayUs(2);
+
+	TXD_SET();  //highz
+
+	// \u6a21\u62dfCLK
+    CLK_CLR();
+    DRVDelayUs(2);
+    CLK_SET();
+    DRVDelayUs(2);
+
+
+	for(i = 0; i < 8; i++)  //data
+	{
+		if(Data &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+        CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	CS_SET();
+	CLK_CLR();
+	TXD_CLR();
+	DRVDelayUs(2);
+
+}
+
+
+int init(void)
+{
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_GPIO1_A45);
+
+    spi_screenreg_set(0x02, 0x07);
+    spi_screenreg_set(0x03, 0x5f);
+    spi_screenreg_set(0x04, 0x17);
+    spi_screenreg_set(0x05, 0x20);
+    spi_screenreg_set(0x06, 0x08);
+    spi_screenreg_set(0x07, 0x20);
+    spi_screenreg_set(0x08, 0x20);
+    spi_screenreg_set(0x09, 0x20);
+    spi_screenreg_set(0x0a, 0x20);
+    spi_screenreg_set(0x0b, 0x22);
+    spi_screenreg_set(0x0c, 0x22);
+    spi_screenreg_set(0x0d, 0x22);
+    spi_screenreg_set(0x0e, 0x10);
+    spi_screenreg_set(0x0f, 0x10);
+    spi_screenreg_set(0x10, 0x10);
+
+    spi_screenreg_set(0x11, 0x15);
+    spi_screenreg_set(0x12, 0xAA);
+    spi_screenreg_set(0x13, 0xFF);
+    spi_screenreg_set(0x14, 0xb0);
+    spi_screenreg_set(0x15, 0x8e);
+    spi_screenreg_set(0x16, 0xd6);
+    spi_screenreg_set(0x17, 0xfe);
+    spi_screenreg_set(0x18, 0x28);
+    spi_screenreg_set(0x19, 0x52);
+    spi_screenreg_set(0x1A, 0x7c);
+
+    spi_screenreg_set(0x1B, 0xe9);
+    spi_screenreg_set(0x1C, 0x42);
+    spi_screenreg_set(0x1D, 0x88);
+    spi_screenreg_set(0x1E, 0xb8);
+    spi_screenreg_set(0x1F, 0xFF);
+    spi_screenreg_set(0x20, 0xF0);
+    spi_screenreg_set(0x21, 0xF0);
+    spi_screenreg_set(0x22, 0x09);
+
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_I2C0);
+    return 0;
+}
+
+int standby(u8 enable)
+{
+#if 0
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_GPIO1_A45);
+	if(enable) {
+		spi_screenreg_set(0x03, 0xde);
+	} else {
+		spi_screenreg_set(0x03, 0x5f);
+	}
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_I2C0);
+#else
+    
+    GPIOSetPinDirection(GPIOPortB_Pin3, GPIO_OUT);
+    GPIOSetPinDirection(GPIOPortB_Pin2, GPIO_OUT);
+
+    if(enable)
+       {
+        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_LOW);          
+        GPIOSetPinLevel(GPIOPortB_Pin2, GPIO_HIGH);          
+       }
+    else
+       {
+        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_HIGH);          
+        GPIOSetPinLevel(GPIOPortB_Pin2, GPIO_LOW);          
+        }
+#endif
+    return 0;
+}
+
diff --git a/drivers/video/display/screen/lcd_nt35580.c b/drivers/video/display/screen/lcd_nt35580.c
new file mode 100755
index 000000000000..ef2d2d1bc349
--- /dev/null
+++ b/drivers/video/display/screen/lcd_nt35580.c
@@ -0,0 +1,461 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			24
+
+/* Timing */
+#define H_PW			1
+#define H_BP			1
+#define H_VD			480
+#define H_FP			2
+
+#define V_PW			1
+#define V_BP			4
+#define V_VD			800
+#define V_FP			2
+
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			1
+
+
+#define CS_OUT()        GPIOSetPinDirection(GPIOPortB_Pin3, GPIO_OUT)
+#define CS_SET()        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_HIGH)
+#define CS_CLR()        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_LOW)
+#define CLK_OUT()       GPIOSetPinDirection(GPIOPortE_Pin7, GPIO_OUT)  //I2C0_SCL
+#define CLK_SET()       GPIOSetPinLevel(GPIOPortE_Pin7, GPIO_HIGH)
+#define CLK_CLR()       GPIOSetPinLevel(GPIOPortE_Pin7, GPIO_LOW)
+
+#define TXD_OUT()       GPIOSetPinDirection(GPIOPortE_Pin6, GPIO_OUT)  //I2C0_SDA
+#define TXD_SET()       GPIOSetPinLevel(GPIOPortE_Pin6, GPIO_HIGH)
+#define TXD_CLR()       GPIOSetPinLevel(GPIOPortE_Pin6, GPIO_LOW)
+#define TXD_IN()        GPIOSetPinDirection(GPIOPortE_Pin6, GPIO_IN)
+#define TXD_GET()       GPIOGetPinLevel(GPIOPortE_Pin6)
+
+
+#define delay_us(i)      udelay(i)
+
+
+uint32 spi_screenreg_get(uint32 Addr)
+{
+    uint32 i;
+	u8 addr_h = (Addr>>8) & 0x000000ff;
+	u8 addr_l = Addr & 0x000000ff;
+	u8 cmd1 = 0x20;   //0010 0000
+	u8 cmd2 = 0x00;   //0000 0000
+	u8 cmd3 = 0x00;   //0000 0000
+
+    u8 data_l = 0;
+    u8 tmp;
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    delay_us(8);
+
+    CS_SET();
+    CLK_CLR();
+    TXD_CLR();
+    delay_us(4);
+
+	// first transmit
+	CS_CLR();
+	delay_us(4);
+	for(i = 0; i < 8; i++)
+	{
+		if(cmd1 &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	for(i = 0; i < 8; i++)
+	{
+		if(addr_h &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	CLK_CLR();
+	TXD_CLR();
+	delay_us(4);
+	CS_SET();
+	delay_us(8);
+
+	// second transmit
+	CS_CLR();
+	delay_us(4);
+	for(i = 0; i < 8; i++)
+	{
+		if(cmd2 &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	for(i = 0; i < 8; i++)
+	{
+		if(addr_l &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	CLK_CLR();
+	TXD_CLR();
+	delay_us(4);
+	CS_SET();
+	delay_us(8);
+
+	// third transmit
+	CS_CLR();
+	delay_us(4);
+	for(i = 0; i < 8; i++)
+	{
+		if(cmd3 &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	TXD_CLR();
+	TXD_IN();
+	for(i = 0; i < 8; i++)
+	{
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+
+        tmp = TXD_GET();
+        data_l += (tmp<<(7-i));
+
+		delay_us(4);
+	}
+	CLK_CLR();
+	TXD_CLR();
+	delay_us(4);
+	CS_SET();
+	delay_us(8);
+
+	return data_l;
+}
+
+
+void spi_screenreg_set(uint32 Addr, uint32 Data)
+{
+    uint32 i;
+	u8 addr_h = (Addr>>8) & 0x000000ff;
+	u8 addr_l = Addr & 0x000000ff;
+	u8 data_l = Data & 0x000000ff;
+	u8 cmd1 = 0x20;   //0010 0000
+	u8 cmd2 = 0x00;   //0000 0000
+	u8 cmd3 = 0x40;   //0100 0000
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    delay_us(8);
+
+    CS_SET();
+    CLK_CLR();
+    TXD_CLR();
+    delay_us(4);
+
+	// first transmit
+	CS_CLR();
+	delay_us(4);
+	for(i = 0; i < 8; i++)
+	{
+		if(cmd1 &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	for(i = 0; i < 8; i++)
+	{
+		if(addr_h &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	CLK_CLR();
+	TXD_CLR();
+	delay_us(4);
+	CS_SET();
+	delay_us(8);
+
+	// second transmit
+	CS_CLR();
+	delay_us(4);
+	for(i = 0; i < 8; i++)
+	{
+		if(cmd2 &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	for(i = 0; i < 8; i++)
+	{
+		if(addr_l &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	CLK_CLR();
+	TXD_CLR();
+	delay_us(4);
+	CS_SET();
+	delay_us(8);
+
+	// third transmit
+	CS_CLR();
+	delay_us(4);
+	for(i = 0; i < 8; i++)
+	{
+		if(cmd3 &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	for(i = 0; i < 8; i++)
+	{
+		if(data_l &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		CLK_CLR();
+		delay_us(4);
+		CLK_SET();
+		delay_us(4);
+	}
+	CLK_CLR();
+	TXD_CLR();
+	delay_us(4);
+	CS_SET();
+	delay_us(8);
+
+    //printk("Addr=0x%04x, WData=0x%02x, RData=0x%02x \n", Addr, Data, spi_screenreg_get(Addr));
+
+}
+
+
+
+
+
+int lcd_init(void)
+{
+
+#if 0
+    GPIO_SetPinDirection(reset_pin, GPIO_OUT);
+    GPIO_SetPinLevel(reset_pin,GPIO_HIGH);
+    DelayMs_nops(100);
+    GPIO_SetPinLevel(reset_pin,GPIO_LOW);
+    DelayMs_nops(100);
+    GPIO_SetPinLevel(reset_pin,GPIO_HIGH);
+#endif
+
+    rockchip_mux_api_set(GPIOE_U1IR_I2C1_NAME, IOMUXA_GPIO1_A67);
+
+    spi_screenreg_set(0x2E80, 0x0001);
+    spi_screenreg_set(0x0680, 0x002D);
+    spi_screenreg_set(0xD380, 0x0004);
+    spi_screenreg_set(0xD480, 0x0060);
+    spi_screenreg_set(0xD580, 0x0007);
+    spi_screenreg_set(0xD680, 0x005A);
+    spi_screenreg_set(0xD080, 0x000F);
+    spi_screenreg_set(0xD180, 0x0016);
+    spi_screenreg_set(0xD280, 0x0004);
+    spi_screenreg_set(0xDC80, 0x0004);
+    spi_screenreg_set(0xD780, 0x0001);
+
+    spi_screenreg_set(0x2280, 0x000F);
+    spi_screenreg_set(0x2480, 0x0068);
+    spi_screenreg_set(0x2580, 0x0000);
+    spi_screenreg_set(0x2780, 0x00AF);
+
+    spi_screenreg_set(0x3A00, 0x0060);
+    spi_screenreg_set(0x3B00, 0x0003);
+    spi_screenreg_set(0x3B02, 0x0005);
+    spi_screenreg_set(0x3B03, 0x0002);
+    spi_screenreg_set(0x3B04, 0x0002);
+    spi_screenreg_set(0x3B05, 0x0002);
+
+    spi_screenreg_set(0x0180, 0x0000);
+    spi_screenreg_set(0x4080, 0x0051);
+    spi_screenreg_set(0x4180, 0x0055);
+    spi_screenreg_set(0x4280, 0x0058);
+    spi_screenreg_set(0x4380, 0x0064);
+    spi_screenreg_set(0x4480, 0x001A);
+    spi_screenreg_set(0x4580, 0x002E);
+    spi_screenreg_set(0x4680, 0x005F);
+    spi_screenreg_set(0x4780, 0x0021);
+    spi_screenreg_set(0x4880, 0x001C);
+    spi_screenreg_set(0x4980, 0x0022);
+    spi_screenreg_set(0x4A80, 0x005D);
+    spi_screenreg_set(0x4B80, 0x0019);
+    spi_screenreg_set(0x4C80, 0x0046);
+    spi_screenreg_set(0x4D80, 0x0062);
+    spi_screenreg_set(0x4E80, 0x0048);
+    spi_screenreg_set(0x4F80, 0x005B);
+
+    spi_screenreg_set(0x5080, 0x002F);
+    spi_screenreg_set(0x5180, 0x005E);
+    spi_screenreg_set(0x5880, 0x002E);
+    spi_screenreg_set(0x5980, 0x003B);
+    spi_screenreg_set(0x5A80, 0x008D);
+    spi_screenreg_set(0x5B80, 0x00A7);
+    spi_screenreg_set(0x5C80, 0x0027);
+    spi_screenreg_set(0x5D80, 0x0039);
+    spi_screenreg_set(0x5E80, 0x0065);
+    spi_screenreg_set(0x5F80, 0x0055);
+
+    spi_screenreg_set(0x6080, 0x001A);
+    spi_screenreg_set(0x6180, 0x0021);
+    spi_screenreg_set(0x6280, 0x008F);
+    spi_screenreg_set(0x6380, 0x0022);
+    spi_screenreg_set(0x6480, 0x0053);
+    spi_screenreg_set(0x6580, 0x0066);
+    spi_screenreg_set(0x6680, 0x008A);
+    spi_screenreg_set(0x6780, 0x0097);
+    spi_screenreg_set(0x6880, 0x001F);
+    spi_screenreg_set(0x6980, 0x0026);
+
+    spi_screenreg_set(0x1100, 0x0000);
+    msleep(150);
+    spi_screenreg_set(0x2900, 0x0000);
+
+#if 0
+    printk("spi_screenreg_set(0x5555, 0x0055)... \n");
+    while(1) {
+       spi_screenreg_set(0x5555, 0x0055);
+       msleep(1);
+    }
+#endif
+
+#if 0
+    while(1) {
+        int i = 0;
+        for(i=0; i<400*480; i++)
+            mcu_ioctl(MCU_WRDATA, 0xffffffff);
+        for(i=0; i<400*480; i++)
+            mcu_ioctl(MCU_WRDATA, 0x00000000);
+        msleep(1000);
+        printk(">>>>> MCU_WRDATA ...\n");
+
+        for(i=0; i<400*480; i++)
+            mcu_ioctl(MCU_WRDATA, 0x00000000);
+        for(i=0; i<400*480; i++)
+            mcu_ioctl(MCU_WRDATA, 0xffffffff);
+        msleep(1000);
+        printk(">>>>> MCU_WRDATA ...\n");
+    }
+#endif
+
+    rockchip_mux_api_set(GPIOE_U1IR_I2C1_NAME, IOMUXA_I2C1);
+    return 0;
+}
+
+
+int lcd_standby(u8 enable)
+{
+    return 0;
+}
+
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = lcd_init;
+    screen->standby = lcd_standby;
+}
+
+
+
+
+
diff --git a/drivers/video/display/screen/lcd_nt35582.c b/drivers/video/display/screen/lcd_nt35582.c
new file mode 100755
index 000000000000..ad02e73c9725
--- /dev/null
+++ b/drivers/video/display/screen/lcd_nt35582.c
@@ -0,0 +1,429 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_MCU
+#define OUT_FACE		OUT_P888
+
+/* Timing */
+#define H_PW			1
+#define H_BP		    1
+#define H_VD			480
+#define H_FP			5
+
+#define V_PW			1
+#define V_BP			1
+#define V_VD			800
+#define V_FP			1
+
+#define P_WR            27
+#define USE_FMARK       0 //2               //是否使用FMK (0:不支持 1:横屏支持 2:横竖屏都支持)
+#define FRMRATE         60              //MCU屏的刷新率 (FMK有效时用)
+
+
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			1
+
+void Set_LCD_8B_REG(unsigned char regh,unsigned char regl, uint32 data)
+{
+    uint32 cmd;
+	cmd = (regh<<8) + regl;
+	if(-1==data) {
+	    mcu_ioctl(MCU_WRCMD,cmd);
+	} else {
+	    mcu_ioctl(MCU_WRCMD,cmd);
+	    mcu_ioctl(MCU_WRDATA,data);
+    }
+}
+
+int lcd_init(void)
+{
+    int i = 0;
+
+#if 0
+    GPIO_SetPinDirection(reset_pin, GPIO_OUT);
+    GPIO_SetPinLevel(reset_pin,GPIO_HIGH);
+    DelayMs_nops(100);
+    GPIO_SetPinLevel(reset_pin,GPIO_LOW);
+    DelayMs_nops(100);
+    GPIO_SetPinLevel(reset_pin,GPIO_HIGH);
+#endif
+
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+
+
+    Set_LCD_8B_REG(0xC0,0X00,0x86);
+
+    Set_LCD_8B_REG(0xC0,0X01,0x00);
+    Set_LCD_8B_REG(0xC0,0X02,0x86);
+    Set_LCD_8B_REG(0xC0,0X03,0x00);
+
+    Set_LCD_8B_REG(0xC1,0X00,0x60); //0x004f
+    Set_LCD_8B_REG(0xC2,0X00,0x21);
+    Set_LCD_8B_REG(0xC2,0X02,0x70); //0x0202
+
+    Set_LCD_8B_REG(0xB6,0x00,0x10); //0x0030
+    Set_LCD_8B_REG(0xB6,0x02,0x30);
+
+    Set_LCD_8B_REG(0xC7,0X00,0x6F);
+
+    Set_LCD_8B_REG(0xE0,0X00,0X0E);
+    Set_LCD_8B_REG(0xE0,0X01,0X14);
+    Set_LCD_8B_REG(0xE0,0X02,0X29);
+    Set_LCD_8B_REG(0xE0,0X03,0X3A);
+    Set_LCD_8B_REG(0xE0,0X04,0X1D);
+    Set_LCD_8B_REG(0xE0,0X05,0X30);
+    Set_LCD_8B_REG(0xE0,0X06,0X61);
+    Set_LCD_8B_REG(0xE0,0X07,0X3D);
+    Set_LCD_8B_REG(0xE0,0X08,0X22);
+    Set_LCD_8B_REG(0xE0,0X09,0X2A);
+    Set_LCD_8B_REG(0xE0,0X0A,0X87);
+    Set_LCD_8B_REG(0xE0,0X0B,0X16);
+    Set_LCD_8B_REG(0xE0,0X0C,0X3B);
+    Set_LCD_8B_REG(0xE0,0X0D,0X4C);
+    Set_LCD_8B_REG(0xE0,0X0E,0X78);
+    Set_LCD_8B_REG(0xE0,0X0F,0X96);
+    Set_LCD_8B_REG(0xE0,0X10,0X4A);
+    Set_LCD_8B_REG(0xE0,0X11,0X4D);
+
+    Set_LCD_8B_REG(0xE1,0X00,0X0E);
+    Set_LCD_8B_REG(0xE1,0X01,0X14);
+    Set_LCD_8B_REG(0xE1,0X02,0X29);
+    Set_LCD_8B_REG(0xE1,0X03,0X3A);
+    Set_LCD_8B_REG(0xE1,0X04,0X1D);
+    Set_LCD_8B_REG(0xE1,0X05,0X30);
+    Set_LCD_8B_REG(0xE1,0X06,0X61);
+    Set_LCD_8B_REG(0xE1,0X07,0X3F);
+    Set_LCD_8B_REG(0xE1,0X08,0X20);
+    Set_LCD_8B_REG(0xE1,0X09,0X26);
+    Set_LCD_8B_REG(0xE1,0X0A,0X83);
+    Set_LCD_8B_REG(0xE1,0X0B,0X16);
+    Set_LCD_8B_REG(0xE1,0X0C,0X3B);
+    Set_LCD_8B_REG(0xE1,0X0D,0X4C);
+    Set_LCD_8B_REG(0xE1,0X0E,0X78);
+    Set_LCD_8B_REG(0xE1,0X0F,0X96);
+    Set_LCD_8B_REG(0xE1,0X10,0X4A);
+    Set_LCD_8B_REG(0xE1,0X11,0X4D);
+
+    Set_LCD_8B_REG(0xE2,0X00,0X0E);
+    Set_LCD_8B_REG(0xE2,0X01,0X14);
+    Set_LCD_8B_REG(0xE2,0X02,0X29);
+    Set_LCD_8B_REG(0xE2,0X03,0X3A);
+    Set_LCD_8B_REG(0xE2,0X04,0X1D);
+    Set_LCD_8B_REG(0xE2,0X05,0X30);
+    Set_LCD_8B_REG(0xE2,0X06,0X61);
+    Set_LCD_8B_REG(0xE2,0X07,0X3D);
+    Set_LCD_8B_REG(0xE2,0X08,0X22);
+    Set_LCD_8B_REG(0xE2,0X09,0X2A);
+    Set_LCD_8B_REG(0xE2,0X0A,0X87);
+    Set_LCD_8B_REG(0xE2,0X0B,0X16);
+    Set_LCD_8B_REG(0xE2,0X0C,0X3B);
+    Set_LCD_8B_REG(0xE2,0X0D,0X4C);
+    Set_LCD_8B_REG(0xE2,0X0E,0X78);
+    Set_LCD_8B_REG(0xE2,0X0F,0X96);
+    Set_LCD_8B_REG(0xE2,0X10,0X4A);
+    Set_LCD_8B_REG(0xE2,0X11,0X4D);
+
+    Set_LCD_8B_REG(0xE3,0X00,0X0E);
+    Set_LCD_8B_REG(0xE3,0X01,0X14);
+    Set_LCD_8B_REG(0xE3,0X02,0X29);
+    Set_LCD_8B_REG(0xE3,0X03,0X3A);
+    Set_LCD_8B_REG(0xE3,0X04,0X1D);
+    Set_LCD_8B_REG(0xE3,0X05,0X30);
+    Set_LCD_8B_REG(0xE3,0X06,0X61);
+    Set_LCD_8B_REG(0xE3,0X07,0X3F);
+    Set_LCD_8B_REG(0xE3,0X08,0X20);
+    Set_LCD_8B_REG(0xE3,0X09,0X26);
+    Set_LCD_8B_REG(0xE3,0X0A,0X83);
+    Set_LCD_8B_REG(0xE3,0X0B,0X16);
+    Set_LCD_8B_REG(0xE3,0X0C,0X3B);
+    Set_LCD_8B_REG(0xE3,0X0D,0X4C);
+    Set_LCD_8B_REG(0xE3,0X0E,0X78);
+    Set_LCD_8B_REG(0xE3,0X0F,0X96);
+    Set_LCD_8B_REG(0xE3,0X10,0X4A);
+    Set_LCD_8B_REG(0xE3,0X11,0X4D);
+
+    Set_LCD_8B_REG(0xE4,0X00,0X0E);
+    Set_LCD_8B_REG(0xE4,0X01,0X14);
+    Set_LCD_8B_REG(0xE4,0X02,0X29);
+    Set_LCD_8B_REG(0xE4,0X03,0X3A);
+    Set_LCD_8B_REG(0xE4,0X04,0X1D);
+    Set_LCD_8B_REG(0xE4,0X05,0X30);
+    Set_LCD_8B_REG(0xE4,0X06,0X61);
+    Set_LCD_8B_REG(0xE4,0X07,0X3D);
+    Set_LCD_8B_REG(0xE4,0X08,0X22);
+    Set_LCD_8B_REG(0xE4,0X09,0X2A);
+    Set_LCD_8B_REG(0xE4,0X0A,0X87);
+    Set_LCD_8B_REG(0xE4,0X0B,0X16);
+    Set_LCD_8B_REG(0xE4,0X0C,0X3B);
+    Set_LCD_8B_REG(0xE4,0X0D,0X4C);
+    Set_LCD_8B_REG(0xE4,0X0E,0X78);
+    Set_LCD_8B_REG(0xE4,0X0F,0X96);
+    Set_LCD_8B_REG(0xE4,0X10,0X4A);
+    Set_LCD_8B_REG(0xE4,0X11,0X4D);
+
+    Set_LCD_8B_REG(0xE5,0X00,0X0E);
+    Set_LCD_8B_REG(0xE5,0X01,0X14);
+    Set_LCD_8B_REG(0xE5,0X02,0X29);
+    Set_LCD_8B_REG(0xE5,0X03,0X3A);
+    Set_LCD_8B_REG(0xE5,0X04,0X1D);
+    Set_LCD_8B_REG(0xE5,0X05,0X30);
+    Set_LCD_8B_REG(0xE5,0X06,0X61);
+    Set_LCD_8B_REG(0xE5,0X07,0X3F);
+    Set_LCD_8B_REG(0xE5,0X08,0X20);
+    Set_LCD_8B_REG(0xE5,0X09,0X26);
+    Set_LCD_8B_REG(0xE5,0X0A,0X83);
+    Set_LCD_8B_REG(0xE5,0X0B,0X16);
+    Set_LCD_8B_REG(0xE5,0X0C,0X3B);
+    Set_LCD_8B_REG(0xE5,0X0D,0X4C);
+    Set_LCD_8B_REG(0xE5,0X0E,0X78);
+    Set_LCD_8B_REG(0xE5,0X0F,0X96);
+    Set_LCD_8B_REG(0xE5,0X10,0X4A);
+    Set_LCD_8B_REG(0xE5,0X11,0X4D);
+
+    Set_LCD_8B_REG(0x36,0X01,0X01);
+
+    Set_LCD_8B_REG(0x11,0X00,0X00);
+    msleep(100);
+    Set_LCD_8B_REG(0x29,0X00,0X00);
+    msleep(100);
+
+
+    Set_LCD_8B_REG(0x2a,0X00,0X00);
+    Set_LCD_8B_REG(0x2a,0X01,0X00);
+    Set_LCD_8B_REG(0x2a,0X02,0X01);
+    Set_LCD_8B_REG(0x2a,0X03,0Xdf);
+    msleep(100);
+    Set_LCD_8B_REG(0x2b,0X00,0X00);
+    Set_LCD_8B_REG(0x2b,0X01,0X00);
+    Set_LCD_8B_REG(0x2b,0X02,0X03);
+    Set_LCD_8B_REG(0x2b,0X03,0X1f);
+    msleep(100);
+    {
+        uint32 fte = 0;
+        Set_LCD_8B_REG(0x44,0x00,(fte>>8)&0xff);
+        Set_LCD_8B_REG(0x44,0x01,(fte)&0xff);
+    }
+    Set_LCD_8B_REG(0x0E,0X00,0X80);
+    Set_LCD_8B_REG(0x35,0X00,0X80);
+
+#if (480==H_VD)
+    Set_LCD_8B_REG(0x36,0X00,0x00);
+#else
+    Set_LCD_8B_REG(0x36,0X00,0x22);
+#endif
+    Set_LCD_8B_REG(0x2c,0X00,-1);
+
+    for(i=0; i<480*800; i++) {
+        mcu_ioctl(MCU_WRDATA, 0x00000000);
+    }
+
+#if 0
+    // for test
+    while(1) {
+        int i = 0;
+        for(i=0; i<400*480; i++)
+            mcu_ioctl(MCU_WRDATA, 0xffffffff);
+        for(i=0; i<400*480; i++)
+            mcu_ioctl(MCU_WRDATA, 0x00000000);
+        msleep(1000);
+        printk(">>>>> MCU_WRDATA ...\n");
+
+        for(i=0; i<400*480; i++)
+            mcu_ioctl(MCU_WRDATA, 0x00000000);
+        for(i=0; i<400*480; i++)
+            mcu_ioctl(MCU_WRDATA, 0xffffffff);
+        msleep(1000);
+        printk(">>>>> MCU_WRDATA ...\n");
+    }
+#endif
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return 0;
+}
+
+
+int lcd_standby(u8 enable)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+    if(enable) {
+        Set_LCD_8B_REG(0x10,0X00,-1);
+    } else {
+        Set_LCD_8B_REG(0x11,0X00,-1);
+    }
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return 0;
+}
+
+
+int lcd_refresh(u8 arg)
+{
+    switch(arg)
+    {
+    case REFRESH_PRE:   //DMA传送前准备
+        mcu_ioctl(MCU_SETBYPASS, 1);
+        Set_LCD_8B_REG(0x2c,0X00,-1);
+        mcu_ioctl(MCU_SETBYPASS, 0);
+        break;
+
+    case REFRESH_END:   //DMA传送结束后
+        mcu_ioctl(MCU_SETBYPASS, 1);
+        Set_LCD_8B_REG(0x29,0X00,-1);
+        mcu_ioctl(MCU_SETBYPASS, 0);
+        break;
+
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+
+int lcd_scandir(u16 dir)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    // 暂时关闭MCU显示,在lcd_refresh的case REFRESH_END再打开
+    // 否则画面会异常
+    Set_LCD_8B_REG(0x28,0X00,-1);
+
+    Set_LCD_8B_REG(0x2a,0X00,0X00);
+    Set_LCD_8B_REG(0x2a,0X01,0X00);
+    Set_LCD_8B_REG(0x2a,0X02,0X01);
+    Set_LCD_8B_REG(0x2a,0X03,0Xdf);
+    Set_LCD_8B_REG(0x2b,0X00,0X00);
+    Set_LCD_8B_REG(0x2b,0X01,0X00);
+    Set_LCD_8B_REG(0x2b,0X02,0X03);
+    Set_LCD_8B_REG(0x2b,0X03,0X1f);
+
+    switch(dir)
+    {
+    case 0:
+        Set_LCD_8B_REG(0x36,0X00,0x00);
+        break;
+    case 90:
+        Set_LCD_8B_REG(0x36,0X00,0x22);
+        break;
+    case 180:
+        Set_LCD_8B_REG(0x36,0X00,0x03);
+        break;
+    case 270:
+        Set_LCD_8B_REG(0x36,0X00,0x21);
+        break;
+    default:
+        break;
+    }
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return 0;
+}
+
+
+int lcd_disparea(u8 area)
+{
+    uint32 x0, y0, x1, y1, fte;
+
+	mcu_ioctl(MCU_SETBYPASS, 1);
+
+    switch(area)
+    {
+    case 0:
+        fte = 0;
+        x0 = 0;
+        y0 = 0;
+        x1 = 399;
+        y1 = 479;
+        break;
+
+    case 2:
+        x0 = 0;
+        y0 = 0;
+        x1 = 799;
+        y1 = 479;
+        break;
+
+    case 1:
+    default:
+        fte = 400;
+        x0 = 400;
+        y0 = 0;
+        x1 = 799;
+        y1 = 479;
+        break;
+    }
+
+    //Set_LCD_8B_REG(0x44,0x00,(fte>>8)&0xff);
+    //Set_LCD_8B_REG(0x44,0x01,(fte)&0xff);
+    Set_LCD_8B_REG(0x2a,0X00,(y0>>8)&0xff);
+	Set_LCD_8B_REG(0x2a,0X01,y0&0xff);
+	Set_LCD_8B_REG(0x2a,0X02,(y1>>8)&0xff);
+	Set_LCD_8B_REG(0x2a,0X03,y1&0xff);
+
+	Set_LCD_8B_REG(0x2b,0X00,(x0>>8)&0xff);
+	Set_LCD_8B_REG(0x2b,0X01,x0&0xff);
+	Set_LCD_8B_REG(0x2b,0X02,(x1>>8)&0xff);
+	Set_LCD_8B_REG(0x2b,0X03,x1&0xff);
+    Set_LCD_8B_REG(0x2c,0X00,-1);
+
+	mcu_ioctl(MCU_SETBYPASS, 0);
+
+    return (0);
+
+}
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	screen->mcu_wrperiod = P_WR;
+	screen->mcu_usefmk = USE_FMARK;
+    screen->mcu_frmrate = FRMRATE;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = lcd_init;
+    screen->standby = lcd_standby;
+    screen->scandir = lcd_scandir;
+    screen->refresh = lcd_refresh;
+    screen->disparea = lcd_disparea;
+}
+
+
+
+
+
diff --git a/drivers/video/display/screen/lcd_null.c b/drivers/video/display/screen/lcd_null.c
new file mode 100755
index 000000000000..14870c5edb0f
--- /dev/null
+++ b/drivers/video/display/screen/lcd_null.c
@@ -0,0 +1,16 @@
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    memset(screen, 0, sizeof(struct rk28fb_screen));
+    screen->face = OUT_P666;
+}
diff --git a/drivers/video/display/screen/lcd_s1d13521.c b/drivers/video/display/screen/lcd_s1d13521.c
new file mode 100755
index 000000000000..37c45f098758
--- /dev/null
+++ b/drivers/video/display/screen/lcd_s1d13521.c
@@ -0,0 +1,323 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+#include "s1d13521.h"
+#include "s1d13521ioctl.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_MCU
+#define OUT_FACE		OUT_P16BPP4
+
+/* Timing */
+#define H_PW			1
+#define H_BP			1
+#define H_VD			600
+#define H_FP			5
+
+#define V_PW			1
+#define V_BP			1
+#define V_VD			800
+#define V_FP			1
+
+#define P_WR            200
+
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			1
+
+
+
+int s1d13521if_refresh(u8 arg);
+
+#define GPIO_RESET_L	GPIOPortC_Pin0	//reset pin
+#define GPIO_HIRQ		GPIOPortC_Pin1	//IRQ
+#define GPIO_HDC		GPIOPortC_Pin2	//Data(HIHG) or Command(LOW)
+#define GPIO_HCS_L		GPIOPortC_Pin3	//Chip select
+#define GPIO_HRD_L		GPIOPortC_Pin4	//Read mode, low active
+#define GPIO_HWE_L		GPIOPortC_Pin5	//Write mode, low active
+#define GPIO_HRDY		GPIOPortC_Pin6	//Bus ready
+#define GPIO_RMODE		GPIOPortC_Pin7	//rmode ->CNF1
+
+
+//----------------------------------------------------------------------------
+// PRIVATE FUNCTION:
+// Set registers to initial values
+//----------------------------------------------------------------------------
+
+int s1d13521if_wait_for_ready(void)
+{
+    int cnt = 1000;
+    int d = GPIOGetPinLevel(GPIO_HRDY);
+
+    while (d == 0)
+    {
+        mdelay(1);
+
+        if (--cnt <= 0)         // Avoid endless loop
+        {
+            printk(">>>>>> wait_for_ready -- timeout! \n");
+            return -1;
+        }
+
+        d = GPIOGetPinLevel(GPIO_HRDY);
+    }
+
+    return 0;
+}
+
+
+int s1d13521if_cmd(unsigned ioctlcmd,s1d13521_ioctl_cmd_params *params, int numparams)
+{
+    int i;
+    s1d13521if_wait_for_ready();
+
+    mcu_ioctl(MCU_WRCMD, ioctlcmd);
+    for (i = 0; i < numparams; i++) {
+        mcu_ioctl(MCU_WRDATA, params->param[i]);
+    }
+
+    return 0;
+}
+
+void s1d13521if_WriteReg16(u16 Index, u16 Value)
+{
+    s1d13521if_wait_for_ready();
+    mcu_ioctl(MCU_WRCMD, WR_REG);
+    mcu_ioctl(MCU_WRDATA, Index);
+    mcu_ioctl(MCU_WRDATA, Value);
+}
+
+
+void s1d13521fb_InitRegisters(void)
+{
+    unsigned i, cmd,j,numparams;
+    s1d13521_ioctl_cmd_params cmd_params;
+    S1D_INSTANTIATE_REGISTERS(static,InitCmdArray);
+
+    i = 0;
+
+    while (i < sizeof(InitCmdArray)/sizeof(InitCmdArray[0]))
+    {
+        cmd = InitCmdArray[i++];
+        numparams = InitCmdArray[i++];
+
+        for (j = 0; j < numparams; j++)
+                cmd_params.param[j] = InitCmdArray[i++];
+
+        s1d13521if_cmd(cmd,&cmd_params,numparams);
+    }
+}
+
+void s1d13521if_init_gpio(void)
+{
+    int i;
+	rockchip_mux_api_set(GPIOC_LCDC18BIT_SEL_NAME, IOMUXB_GPIO0_C01);
+	rockchip_mux_api_set(GPIOC_LCDC24BIT_SEL_NAME, IOMUXB_GPIO0_C2_7);
+	for(i = 0; i < 8; i++){
+		if(i == 1 || i == 6){//HIRQ, HRDY
+			GPIOSetPinDirection(GPIOPortC_Pin0+i, GPIO_IN);
+		} else {//RESET_L, HD/C, HCS_L, HRD_L, HWE_L, RMODE
+			GPIOSetPinDirection(GPIOPortC_Pin0+i, GPIO_OUT);
+			GPIOPullUpDown(GPIOPortC_Pin0+i, GPIOPullUp);
+			GPIOSetPinLevel(GPIOPortC_Pin0+i, GPIO_HIGH);
+		}
+	}
+}
+
+void s1d13521if_set_reset(void)
+{
+	GPIOSetPinLevel(GPIO_RMODE, GPIO_HIGH);
+
+    // reset pulse
+    mdelay(10);
+	GPIOSetPinLevel(GPIO_RESET_L, GPIO_LOW);
+	mdelay(10);
+	GPIOSetPinLevel(GPIO_RESET_L, GPIO_HIGH);
+	mdelay(10);
+
+	//s1d13521if_WaitForHRDY();
+}
+
+
+
+int s1d13521if_init(void)
+{
+    int i=0;
+    s1d13521_ioctl_cmd_params cmd_params;
+
+    s1d13521if_init_gpio();
+    s1d13521if_set_reset();
+
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    s1d13521fb_InitRegisters();
+
+#if 1
+    s1d13521if_WriteReg16(0x330,0x84);              // LUT AutoSelect+P4N
+    s1d13521if_cmd(WAIT_DSPE_TRG,&cmd_params,0);
+    cmd_params.param[0] = (0x2 << 4);
+    s1d13521if_cmd(LD_IMG,&cmd_params,1);
+    cmd_params.param[0] = 0x154;
+    s1d13521if_cmd(WR_REG,&cmd_params,1);
+
+    for(i=0; i<600*200; i++) {
+        mcu_ioctl(MCU_WRDATA, 0xffff);
+    }
+
+    s1d13521if_cmd(LD_IMG_END,&cmd_params,0);
+    cmd_params.param[0] = ((WF_MODE_INIT<<8) |0x4000);
+    s1d13521if_cmd(UPD_FULL,&cmd_params,1);         // update all pixels
+    s1d13521if_cmd(WAIT_DSPE_TRG,&cmd_params,0);
+    s1d13521if_cmd(WAIT_DSPE_FREND,&cmd_params,0);
+#endif
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+
+
+#if 0
+    // 初始化图象
+    mcu_ioctl(MCU_SETBYPASS, 1);
+    while(1)
+    {
+        int i=0, j=0;
+        // Copy virtual framebuffer to display framebuffer.
+
+        unsigned mode = WF_MODE_GC;
+        unsigned cmd = UPD_FULL;
+
+//        unsigned reg330 = s1d13521if_ReadReg16(0x330);
+        s1d13521if_WriteReg16(0x330,0x84);              // LUT AutoSelect + P4N
+        // Copy virtual framebuffer to hardware via indirect interface burst mode write
+        s1d13521if_cmd(WAIT_DSPE_TRG,&cmd_params,0);
+        cmd_params.param[0] = (0x2<<4);
+        s1d13521if_cmd(LD_IMG,&cmd_params,1);
+        cmd_params.param[0] = 0x154;
+        s1d13521if_cmd(WR_REG,&cmd_params,1);
+
+        for(i=0; i<600*100; i++) {
+            mcu_ioctl(MCU_WRDATA, 0xffff);
+        }
+        for(i=0; i<600*100; i++) {
+            mcu_ioctl(MCU_WRDATA, 0x0000);
+        }
+
+        s1d13521if_cmd(LD_IMG_END,&cmd_params,0);
+        cmd_params.param[0] = (mode<<8);
+        s1d13521if_cmd(cmd,&cmd_params,1);              // update all pixels
+        s1d13521if_cmd(WAIT_DSPE_TRG,&cmd_params,0);
+        s1d13521if_cmd(WAIT_DSPE_FREND,&cmd_params,0);
+
+        msleep(2000);
+        printk(">>>>>> lcd_init : send test image! \n");
+    }
+    mcu_ioctl(MCU_SETBYPASS, 0);
+#endif
+
+
+    return 0;
+}
+
+int s1d13521if_standby(u8 enable)
+{
+    return 0;
+}
+
+int s1d13521if_refresh(u8 arg)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    switch(arg)
+    {
+    case REFRESH_PRE:   //DMA传送前准备
+        {
+            // Copy virtual framebuffer to display framebuffer.
+            s1d13521_ioctl_cmd_params cmd_params;
+
+    //        unsigned reg330 = s1d13521if_ReadReg16(0x330);
+            s1d13521if_WriteReg16(0x330,0x84);              // LUT AutoSelect + P4N
+
+            // Copy virtual framebuffer to hardware via indirect interface burst mode write
+            s1d13521if_cmd(WAIT_DSPE_TRG,&cmd_params,0);
+            cmd_params.param[0] = (0x2<<4);
+            s1d13521if_cmd(LD_IMG,&cmd_params,1);
+            cmd_params.param[0] = 0x154;
+            s1d13521if_cmd(WR_REG,&cmd_params,1);
+        }
+        printk(">>>>>> lcd_refresh : REFRESH_PRE! \n");
+        break;
+
+    case REFRESH_END:   //DMA传送结束后
+        {
+            s1d13521_ioctl_cmd_params cmd_params;
+            unsigned mode = WF_MODE_GC;
+            unsigned cmd = UPD_FULL;
+
+            s1d13521if_cmd(LD_IMG_END,&cmd_params,0);
+
+            cmd_params.param[0] = (mode<<8);
+            s1d13521if_cmd(cmd,&cmd_params,1);              // update all pixels
+
+            s1d13521if_cmd(WAIT_DSPE_TRG,&cmd_params,0);
+            s1d13521if_cmd(WAIT_DSPE_FREND,&cmd_params,0);
+        }
+        printk(">>>>>> lcd_refresh : REFRESH_END! \n");
+        break;
+
+    default:
+        break;
+    }
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+
+    return 0;
+}
+
+
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+	screen->mcu_wrperiod = P_WR;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = s1d13521if_init;
+    screen->standby = s1d13521if_standby;
+    screen->refresh = s1d13521if_refresh;
+}
+
+
+
+
diff --git a/drivers/video/display/screen/lcd_td043mgea1.c b/drivers/video/display/screen/lcd_td043mgea1.c
new file mode 100755
index 000000000000..efe2dd14ede8
--- /dev/null
+++ b/drivers/video/display/screen/lcd_td043mgea1.c
@@ -0,0 +1,259 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk2818_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			27
+
+/* Timing */
+#define H_PW			10
+#define H_BP			206
+#define H_VD			800
+#define H_FP			40
+
+#define V_PW			10
+#define V_BP			25
+#define V_VD			480
+#define V_FP			10
+
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			0
+
+
+#define CS_OUT()        gpio_direction_output(RK2818_PIN_PA4, 0)
+#define CS_SET()        gpio_set_value(RK2818_PIN_PA4, GPIO_HIGH)
+#define CS_CLR()        gpio_set_value(RK2818_PIN_PA4, GPIO_LOW)
+#define CLK_OUT()       gpio_direction_output(RK2818_PIN_PE7, 0)  //I2C0_SCL
+#define CLK_SET()       gpio_set_value(RK2818_PIN_PE7, GPIO_HIGH)
+#define CLK_CLR()       gpio_set_value(RK2818_PIN_PE7, GPIO_LOW)
+#define TXD_OUT()       gpio_direction_output(RK2818_PIN_PE6, 0)  //I2C0_SDA
+#define TXD_SET()       gpio_set_value(RK2818_PIN_PE6, GPIO_HIGH)
+#define TXD_CLR()       gpio_set_value(RK2818_PIN_PE6, GPIO_LOW)
+
+
+int init(void);
+int standby(u8 enable);
+
+void screen_set_iomux(u8 enable)
+{
+    int ret=-1;
+    if(enable)
+    {
+        rk2818_mux_api_set(CXGPIO_HSADC_SEL_NAME, 0);
+        ret = gpio_request(RK2818_PIN_PA4, NULL); 
+        if(0)//(ret != 0)
+        {
+            gpio_free(RK2818_PIN_PA4);
+            printk(">>>>>> lcd cs gpio_request err \n ");           
+            goto pin_err;
+        }  
+        
+        rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 0);                   
+
+        ret = gpio_request(RK2818_PIN_PE7, NULL); 
+        if(0)//(ret != 0)
+        {
+            gpio_free(RK2818_PIN_PE7);
+            printk(">>>>>> lcd clk gpio_request err \n "); 
+            goto pin_err;
+        }  
+        
+        ret = gpio_request(RK2818_PIN_PE6, NULL); 
+        if(0)//(ret != 0)
+        {
+            gpio_free(RK2818_PIN_PE6);
+            printk(">>>>>> lcd txd gpio_request err \n "); 
+            goto pin_err;
+        }        
+    }
+    else
+    {
+         gpio_free(RK2818_PIN_PA4); 
+         rk2818_mux_api_set(CXGPIO_HSADC_SEL_NAME, 1);
+
+         gpio_free(RK2818_PIN_PE7);   
+         gpio_free(RK2818_PIN_PE6); 
+         rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 1);
+   }
+    return ;
+pin_err:
+    return ;
+
+}
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = init;
+    screen->standby = standby;
+}
+
+
+void spi_screenreg_set(u32 Addr, u32 Data)
+{
+
+#define DRVDelayUs(i)   udelay(i*2)
+
+    u32 i;
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    DRVDelayUs(2);
+    DRVDelayUs(2);
+
+    CS_SET();
+    TXD_SET();
+    CLK_SET();
+    DRVDelayUs(2);
+
+	CS_CLR();
+	for(i = 0; i < 6; i++)  //reg
+	{
+		if(Addr &(1<<(5-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+		CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	TXD_CLR();  //write
+
+	// \u6a21\u62dfCLK
+    CLK_CLR();
+    DRVDelayUs(2);
+    CLK_SET();
+    DRVDelayUs(2);
+
+	TXD_SET();  //highz
+
+	// \u6a21\u62dfCLK
+    CLK_CLR();
+    DRVDelayUs(2);
+    CLK_SET();
+    DRVDelayUs(2);
+
+
+	for(i = 0; i < 8; i++)  //data
+	{
+		if(Data &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+        CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	CS_SET();
+	CLK_CLR();
+	TXD_CLR();
+	DRVDelayUs(2);
+
+}
+
+
+int init(void)
+{    
+	printk(">>>>>> %s : %s \n", __FILE__, __FUNCTION__);
+
+    screen_set_iomux(1);
+
+    spi_screenreg_set(0x02, 0x07);
+    spi_screenreg_set(0x03, 0x5f);
+    spi_screenreg_set(0x04, 0x17);
+    spi_screenreg_set(0x05, 0x20);
+    spi_screenreg_set(0x06, 0x08);
+    spi_screenreg_set(0x07, 0x20);
+    spi_screenreg_set(0x08, 0x20);
+    spi_screenreg_set(0x09, 0x20);
+    spi_screenreg_set(0x0a, 0x20);
+    spi_screenreg_set(0x0b, 0x22);
+    spi_screenreg_set(0x0c, 0x22);
+    spi_screenreg_set(0x0d, 0x22);
+    spi_screenreg_set(0x0e, 0x10);
+    spi_screenreg_set(0x0f, 0x10);
+    spi_screenreg_set(0x10, 0x10);
+
+    spi_screenreg_set(0x11, 0x15);
+    spi_screenreg_set(0x12, 0xAA);
+    spi_screenreg_set(0x13, 0xFF);
+    spi_screenreg_set(0x14, 0xb0);
+    spi_screenreg_set(0x15, 0x8e);
+    spi_screenreg_set(0x16, 0xd6);
+    spi_screenreg_set(0x17, 0xfe);
+    spi_screenreg_set(0x18, 0x28);
+    spi_screenreg_set(0x19, 0x52);
+    spi_screenreg_set(0x1A, 0x7c);
+
+    spi_screenreg_set(0x1B, 0xe9);
+    spi_screenreg_set(0x1C, 0x42);
+    spi_screenreg_set(0x1D, 0x88);
+    spi_screenreg_set(0x1E, 0xb8);
+    spi_screenreg_set(0x1F, 0xFF);
+    spi_screenreg_set(0x20, 0xF0);
+    spi_screenreg_set(0x21, 0xF0);
+    spi_screenreg_set(0x22, 0x09);
+
+    screen_set_iomux(0);
+    return 0;
+}
+
+int standby(u8 enable)
+{   
+	printk(">>>>>> %s : %s \n", __FILE__, __FUNCTION__);
+    
+    screen_set_iomux(1);
+	if(enable) {
+		spi_screenreg_set(0x03, 0xde);
+	} else {
+		spi_screenreg_set(0x03, 0x5f);
+	}
+    screen_set_iomux(0);
+    return 0;
+}
+
diff --git a/drivers/video/display/screen/lcd_tj048nc01ca.c b/drivers/video/display/screen/lcd_tj048nc01ca.c
new file mode 100755
index 000000000000..4e4fee9c100f
--- /dev/null
+++ b/drivers/video/display/screen/lcd_tj048nc01ca.c
@@ -0,0 +1,193 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/lcdcon.h>
+#include <asm/arch/rk28_i2c.h>
+#include <asm/arch/rk28_fb.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			23
+
+/* Timing */
+#define H_PW			1
+#define H_BP			120
+#define H_VD			800
+#define H_FP			20
+
+#define V_PW			1
+#define V_BP			20
+#define V_VD			480
+#define V_FP			4
+
+/* Other */
+#define DCLK_POL		1
+#define SWAP_RB			1
+
+int lcd_init(void);
+int lcd_standby(u8 enable);
+
+void set_lcd_info(struct rk28fb_screen *screen)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    /* Timing */
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    //screen->init = lcd_init;
+    screen->standby = lcd_standby;
+
+}
+
+void spi_screenreg_set(uint32 Addr, uint32 Data)
+{
+#define CS_OUT()        GPIOSetPinDirection(GPIOPortB_Pin3, GPIO_OUT)
+#define CS_SET()        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_HIGH)
+#define CS_CLR()        GPIOSetPinLevel(GPIOPortB_Pin3, GPIO_LOW)
+#define CLK_OUT()       GPIOSetPinDirection(GPIOPortE_Pin5, GPIO_OUT)  //I2C0_SCL
+#define CLK_SET()       GPIOSetPinLevel(GPIOPortE_Pin5, GPIO_HIGH)
+#define CLK_CLR()       GPIOSetPinLevel(GPIOPortE_Pin5, GPIO_LOW)
+#define TXD_OUT()       GPIOSetPinDirection(GPIOPortE_Pin4, GPIO_OUT)  //I2C0_SDA
+#define TXD_SET()       GPIOSetPinLevel(GPIOPortE_Pin4, GPIO_HIGH)
+#define TXD_CLR()       GPIOSetPinLevel(GPIOPortE_Pin4, GPIO_LOW)
+
+#define DRVDelayUs(i)   udelay(i*2)
+
+    uint32 i;
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    DRVDelayUs(2);
+    DRVDelayUs(2);
+
+    CS_SET();
+    TXD_CLR();
+    CLK_CLR();
+    DRVDelayUs(2);
+
+	CS_CLR();
+	for(i = 0; i < 7; i++)  //reg
+	{
+		if(Addr &(1<<(6-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+		CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	TXD_CLR();  //write
+
+	// \u6a21\u62dfCLK
+    CLK_CLR();
+    DRVDelayUs(2);
+    CLK_SET();
+    DRVDelayUs(2);
+
+	for(i = 0; i < 8; i++)  //data
+	{
+		if(Data &(1<<(7-i)))
+			TXD_SET();
+		else
+			TXD_CLR();
+
+		// \u6a21\u62dfCLK
+        CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	CS_SET();
+	CLK_CLR();
+	TXD_CLR();
+	DRVDelayUs(2);
+
+}
+
+
+int lcd_init(void)
+{
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_GPIO1_A45);
+	
+	//R(0xess (A5~A0) Data(D7~D0)
+#if 0
+    spi_screenreg_set(0x03, 0x86);
+    spi_screenreg_set(0x05, 0x33);
+    spi_screenreg_set(0x09, 0xFF);
+    spi_screenreg_set(0x3A, 0x95);
+    spi_screenreg_set(0x3C, 0xE0);
+    spi_screenreg_set(0x3D, 0xF4);
+    spi_screenreg_set(0x3E, 0x21);
+    spi_screenreg_set(0x3F, 0x87);
+    spi_screenreg_set(0x15, 0x55);
+    spi_screenreg_set(0x16, 0xAF);
+    spi_screenreg_set(0x17, 0xFC);
+    spi_screenreg_set(0x18, 0x00);
+    spi_screenreg_set(0x19, 0x4B);
+    spi_screenreg_set(0x1A, 0x80);
+    spi_screenreg_set(0x1B, 0xFF);
+    spi_screenreg_set(0x1C, 0x39);
+    spi_screenreg_set(0x1D, 0x69);
+    spi_screenreg_set(0x1E, 0x9F);
+    spi_screenreg_set(0x1F, 0x09);
+    spi_screenreg_set(0x20, 0x8F);
+    spi_screenreg_set(0x21, 0xF0);
+    spi_screenreg_set(0x22, 0x2B);
+    spi_screenreg_set(0x23, 0x58);
+    spi_screenreg_set(0x24, 0x7C);
+    spi_screenreg_set(0x25, 0xA5);
+    spi_screenreg_set(0x26, 0xFF);
+#endif
+
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_I2C0);
+    return 0;
+}
+
+int lcd_standby(u8 enable)
+{
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_GPIO1_A45);
+	if(enable) {
+		spi_screenreg_set(0x43, 0x20);
+	} else {
+		spi_screenreg_set(0x43, 0xE0);
+	}
+    rockchip_mux_api_set(GPIOE_I2C0_SEL_NAME, IOMUXA_I2C0);
+    return 0;
+}
+
+
diff --git a/drivers/video/display/screen/s1d13521.h b/drivers/video/display/screen/s1d13521.h
new file mode 100755
index 000000000000..edaf6292aac0
--- /dev/null
+++ b/drivers/video/display/screen/s1d13521.h
@@ -0,0 +1,95 @@
+/*===============================================================================
+**  Generic Header information generated by 13521CFG.EXE (Build 4)
+**  (C)SEIKO EPSON CORPORATION 2002-2007. All rights reserved.
+**
+**  DISPLAYS      WxH         FREQ    SUBTYPE
+**  ------------- ----------- ------- -------------------------------------------
+** *LCD1=Parallel 800x600     NA      EPD Panel
+**
+**  DIMENSIONS  WxHxBPP @ STRIDE       START   SADDR     ADDITIONAL
+**  ----------- ---------------------- ------- --------- -----------------------
+** *Main        800x600x4 @ 800        NA      000EA600h LUTAuto=on
+**
+**  CLOCKS        FREQ        SOURCE
+**  ------------- ----------- ---------------------------------------------------
+**  INCLK         132.000 MHz PLL
+**  SYSCLK         66.000 MHz PLL/2
+**  PCLK           26.400 MHz PLL/5
+**  SPICLK         13.200 MHz SYSCLK/5
+**  I2CCLK          4.125 MHz PLL/16
+**  SDRAMCLK      132.000 MHz PLL
+**  SDRAMREFCLK    63.954 KHz CLKI/516
+**
+**  This file defines the configuration environment and registers,
+**  which can be used by any software, such as display drivers.
+**
+**  Note: If you transfer this file to any non-PC system, use ASCII
+**  mode (not BINARY) to maintain system-specific line terminators.
+**===============================================================================*/
+
+#define S1D_13521
+
+#define S1D_DISPLAY_WIDTH               600
+#define S1D_DISPLAY_HEIGHT              800
+
+#define S1D_DISPLAY_BPP                 8
+
+//#define S1D_DISPLAY_SCANLINE_BYTES      600
+#define S1D_DISPLAY_FRAME_RATE          0
+#define S1D_DISPLAY_PCLK                26400000L
+#define S1D_PHYSICAL_REG_ADDR           0x00000000L
+#define S1D_PHYSICAL_REG_SIZE           90L
+#define S1D_PHYSICAL_VMEM_REQUIRED      640000L
+#define S1D_PALETTE_SIZE                256
+#define S1D_POWER_DELAY_OFF             0
+#define S1D_POWER_DELAY_ON              0
+#define S1D_HWBLT
+#define S1D_SWBLT
+
+
+#define BS60_INIT_HSIZE         800
+#define BS60_INIT_VSIZE         600
+
+#define BS60_INIT_FSLEN         4
+#define BS60_INIT_FBLEN         4
+#define BS60_INIT_FELEN         10
+#define BS60_INIT_LSLEN         10
+#define BS60_INIT_LBLEN         4
+#define BS60_INIT_LELEN         100
+#define BS60_INIT_PIXCLKDIV     6
+#define BS60_INIT_SDRV_CFG      (100 | (1<< 8) | (1<<9))
+#define BS60_INIT_GDRV_CFG      0x2
+#define BS60_INIT_LUTIDXFMT     (4 | (1<<7))
+#define BS60_INIT_ROTMODE       3    // rotation mode = 180 degrees
+
+#define WF_MODE_INIT            0
+#define WF_MODE_MU              1
+#define WF_MODE_GU              2
+#define WF_MODE_GC              3
+#define WF_MODE_PU              4
+
+typedef unsigned short S1D_INDEX;
+typedef unsigned short S1D_VALUE;
+
+#define S1D_INSTANTIATE_REGISTERS(scope_prefix,variable_name)  \
+  scope_prefix S1D_VALUE variable_name[] =  \
+        { \
+        INIT_SYS_RUN,   0,                                                      \
+        INIT_DSPE_CFG,  5,      BS60_INIT_HSIZE,                                \
+                                BS60_INIT_VSIZE,                                \
+                                BS60_INIT_SDRV_CFG,                             \
+                                BS60_INIT_GDRV_CFG,                             \
+                                BS60_INIT_LUTIDXFMT,                            \
+        INIT_DSPE_TMG,  5,      BS60_INIT_FSLEN,                                \
+                                (BS60_INIT_FELEN<<8)|BS60_INIT_FBLEN,           \
+                                BS60_INIT_LSLEN,                                \
+                                (BS60_INIT_LELEN<<8)|BS60_INIT_LBLEN,           \
+                                BS60_INIT_PIXCLKDIV,                            \
+        RD_WFM_INFO,    2,      0x0886, 0,                                      \
+        UPD_GDRV_CLR,   0,                                                      \
+        WAIT_DSPE_TRG,  0,                                                      \
+        INIT_ROTMODE,   1,      (BS60_INIT_ROTMODE << 8)                        \
+        }
+
+
+
diff --git a/drivers/video/display/screen/s1d13521ioctl.h b/drivers/video/display/screen/s1d13521ioctl.h
new file mode 100755
index 000000000000..3170b90d807e
--- /dev/null
+++ b/drivers/video/display/screen/s1d13521ioctl.h
@@ -0,0 +1,134 @@
+//-----------------------------------------------------------------------------
+//      
+// linux/drivers/video/epson/s1d1352ioctl.h -- IOCTL definitions for Epson
+// S1D13521 controller frame buffer driver.
+// 
+// Copyright(c) Seiko Epson Corporation 2009.
+// All rights reserved.
+//
+// This file is subject to the terms and conditions of the GNU General Public
+// License. See the file COPYING in the main directory of this archive for
+// more details.
+//
+//---------------------------------------------------------------------------- 
+
+/* ioctls
+    0x45 is 'E'                                                          */
+
+struct s1d13521_ioctl_hwc
+{
+        unsigned addr;
+        unsigned value;
+        void* buffer;
+};
+
+#define S1D13521_REGREAD                0x4540
+#define S1D13521_REGWRITE               0x4541
+#define S1D13521_MEMBURSTREAD           0x4546
+#define S1D13521_MEMBURSTWRITE          0x4547
+#define S1D13521_VBUF_REFRESH           0x4548
+
+// System commands
+#define INIT_CMD_SET                    0x00
+#define INIT_PLL_STANDBY                0x01
+#define RUN_SYS                         0x02
+#define STBY                            0x04
+#define SLP                             0x05
+#define INIT_SYS_RUN                    0x06
+#define INIT_SYS_STBY                   0x07
+#define INIT_SDRAM                      0x08
+#define INIT_DSPE_CFG                   0x09
+#define INIT_DSPE_TMG                   0x0A
+#define INIT_ROTMODE                    0x0B
+
+// Register and memory access commands
+#define RD_REG                          0x10
+#define WR_REG                          0x11
+#define RD_SFM                          0x12
+#define WR_SFM                          0x13
+#define END_SFM                         0x14
+
+// Burst access commands
+#define BST_RD_SDR                      0x1C
+#define BST_WR_SDR                      0x1D
+#define BST_END_SDR                     0x1E
+
+// Image loading commands
+#define LD_IMG                          0x20
+#define LD_IMG_AREA                     0x22
+#define LD_IMG_END                      0x23
+#define LD_IMG_WAIT                     0x24
+#define LD_IMG_SETADR                   0x25
+#define LD_IMG_DSPEADR                  0x26
+
+// Polling commands
+#define WAIT_DSPE_TRG                   0x28
+#define WAIT_DSPE_FREND                 0x29
+#define WAIT_DSPE_LUTFREE               0x2A
+#define WAIT_DSPE_MLUTFREE              0x2B
+
+// Waveform update commands
+#define RD_WFM_INFO                     0x30
+#define UPD_INIT                        0x32
+#define UPD_FULL                        0x33
+#define UPD_FULL_AREA                   0x34
+#define UPD_PART                        0x35
+#define UPD_PART_AREA                   0x36
+#define UPD_GDRV_CLR                    0x37
+#define UPD_SET_IMGADR                  0x38
+
+#pragma pack(1)
+
+typedef struct
+{
+        u16 param[5];
+}s1d13521_ioctl_cmd_params;
+
+#pragma pack()
+
+#define S1D13521_INIT_CMD_SET           (0x4500 | INIT_CMD_SET)
+#define S1D13521_INIT_PLL_STANDBY       (0x4500 | INIT_PLL_STANDBY)
+#define S1D13521_RUN_SYS                (0x4500 | RUN_SYS)
+#define S1D13521_STBY                   (0x4500 | STBY)
+#define S1D13521_SLP                    (0x4500 | SLP)
+#define S1D13521_INIT_SYS_RUN           (0x4500 | INIT_SYS_RUN)
+#define S1D13521_INIT_SYS_STBY          (0x4500 | INIT_SYS_STBY)
+#define S1D13521_INIT_SDRAM             (0x4500 | INIT_SDRAM)
+#define S1D13521_INIT_DSPE_CFG          (0x4500 | INIT_DSPE_CFG)
+#define S1D13521_INIT_DSPE_TMG          (0x4500 | INIT_DSPE_TMG)
+#define S1D13521_INIT_ROTMODE           (0x4500 | INIT_ROTMODE)
+#define S1D13521_RD_REG                 (0x4500 | RD_REG)
+#define S1D13521_WR_REG                 (0x4500 | WR_REG)
+#define S1D13521_RD_SFM                 (0x4500 | RD_SFM)
+#define S1D13521_WR_SFM                 (0x4500 | WR_SFM)
+#define S1D13521_END_SFM                (0x4500 | END_SFM)
+
+// Burst access commands
+#define S1D13521_BST_RD_SDR             (0x4500 | BST_RD_SDR)
+#define S1D13521_BST_WR_SDR             (0x4500 | BST_WR_SDR)
+#define S1D13521_BST_END_SDR            (0x4500 | BST_END_SDR)
+
+// Image loading IOCTL commands
+#define S1D13521_LD_IMG                 (0x4500 | LD_IMG)
+#define S1D13521_LD_IMG_AREA            (0x4500 | LD_IMG_AREA)
+#define S1D13521_LD_IMG_END             (0x4500 | LD_IMG_END)
+#define S1D13521_LD_IMG_WAIT            (0x4500 | LD_IMG_WAIT)
+#define S1D13521_LD_IMG_SETADR          (0x4500 | LD_IMG_SETADR)
+#define S1D13521_LD_IMG_DSPEADR         (0x4500 | LD_IMG_DSPEADR)
+
+// Polling commands
+#define S1D13521_WAIT_DSPE_TRG          (0x4500 | WAIT_DSPE_TRG)
+#define S1D13521_WAIT_DSPE_FREND        (0x4500 | WAIT_DSPE_FREND)
+#define S1D13521_WAIT_DSPE_LUTFREE      (0x4500 | WAIT_DSPE_LUTFREE)
+#define S1D13521_WAIT_DSPE_MLUTFREE     (0x4500 | WAIT_DSPE_MLUTFREE)
+
+// Waveform update IOCTL commands
+#define S1D13521_RD_WFM_INFO            (0x4500 | RD_WFM_INFO)
+#define S1D13521_UPD_INIT               (0x4500 | UPD_INIT)
+#define S1D13521_UPD_FULL               (0x4500 | UPD_FULL)
+#define S1D13521_UPD_FULL_AREA          (0x4500 | UPD_FULL_AREA)
+#define S1D13521_UPD_PART               (0x4500 | UPD_PART)
+#define S1D13521_UPD_PART_AREA          (0x4500 | UPD_PART_AREA)
+#define S1D13521_UPD_GDRV_CLR           (0x4500 | UPD_GDRV_CLR)
+#define S1D13521_UPD_SET_IMGADR         (0x4500 | UPD_SET_IMGADR)
+
diff --git a/drivers/video/display/screen/screen.h b/drivers/video/display/screen/screen.h
new file mode 100755
index 000000000000..5b051facc9a5
--- /dev/null
+++ b/drivers/video/display/screen/screen.h
@@ -0,0 +1,86 @@
+typedef enum _SCREEN_TYPE {
+    SCREEN_NULL = 0,
+    SCREEN_RGB,
+	SCREEN_MCU,
+    SCREEN_TVOUT,
+    SCREEN_HDMI,
+} SCREEN_TYPE;
+
+typedef enum _REFRESH_STAGE {
+    REFRESH_PRE = 0,
+    REFRESH_END,
+
+} REFRESH_STAGE;
+
+
+typedef enum _MCU_IOCTL {
+    MCU_WRCMD = 0,
+    MCU_WRDATA,
+    MCU_SETBYPASS,
+
+} MCU_IOCTL;
+
+
+typedef enum _MCU_STATUS {
+    MS_IDLE = 0,
+    MS_MCU,
+    MS_EBOOK,
+    MS_EWAITSTART,
+    MS_EWAITEND,
+    MS_EEND,
+
+} MCU_STATUS;
+
+
+/* Sceen description */
+struct rk28fb_screen {
+    /* screen type & out face */
+    u16 type;
+    u16 face;
+
+	/* Screen size */
+	u16 x_res;
+	u16 y_res;
+
+    /* Timing */
+	u16 pixclock;
+	u16 left_margin;
+	u16 right_margin;
+	u16 hsync_len;
+	u16 upper_margin;
+	u16 lower_margin;
+	u16 vsync_len;
+
+    /* mcu need */
+	u8 mcu_wrperiod;
+    u8 mcu_usefmk;
+    u8 mcu_frmrate;
+
+	/* Pin polarity */
+	u8 pin_hsync;
+	u8 pin_vsync;
+	u8 pin_den;
+	u8 pin_dclk;
+	u8 pin_dispon;
+
+	/* Swap rule */
+    u8 swap_rb;
+    u8 swap_rg;
+    u8 swap_gb;
+    u8 swap_delta;
+    u8 swap_dumy;
+
+    /* Operation function*/
+    int (*init)(void);
+    int (*standby)(u8 enable);
+    int (*refresh)(u8 arg);
+    int (*scandir)(u16 dir);
+    int (*disparea)(u8 area);
+
+};
+
+extern void set_lcd_info(struct rk28fb_screen *screen);
+extern void set_tv_info(struct rk28fb_screen *screen);
+extern void set_hdmi_info(struct rk28fb_screen *screen);
+
+
diff --git a/drivers/video/display/screen/tv_null.c b/drivers/video/display/screen/tv_null.c
new file mode 100755
index 000000000000..80064b19e2c0
--- /dev/null
+++ b/drivers/video/display/screen/tv_null.c
@@ -0,0 +1,15 @@
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk2818_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include "screen.h"
+
+
+
+void set_tv_info(struct rk28fb_screen *screen)
+{
+    memset(screen, 0, sizeof(struct rk28fb_screen));
+    screen->face = OUT_P666;
+}
-- 
2.35.3

