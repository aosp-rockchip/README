From b92010b3de31fd30e9dfcbfda81313c46ce567e8 Mon Sep 17 00:00:00 2001
From: zyc <zyc@rock-chips.com>
Date: Mon, 3 Nov 2014 17:42:04 +0800
Subject: [PATCH] rk312x camera : oneframe v0.1.9,pingpong v0.1.9

---
 arch/arm/boot/dts/rk3126-cif-sensor.dtsi      |   14 +-
 arch/arm/mach-rockchip/rk_camera.c            |   11 +-
 arch/arm/mach-rockchip/rk_camera.h            |  381 +--
 .../arm/mach-rockchip/rk_camera_sensor_info.h |   16 -
 drivers/media/video/Kconfig                   |    4 +
 drivers/media/video/Makefile                  |   18 +
 drivers/media/video/generic_sensor.h          |    8 +
 drivers/media/video/rk30_camera_oneframe.c    |   54 +-
 drivers/media/video/rk30_camera_pingpong.c    | 2971 +++++++----------
 9 files changed, 1365 insertions(+), 2112 deletions(-)

diff --git a/arch/arm/boot/dts/rk3126-cif-sensor.dtsi b/arch/arm/boot/dts/rk3126-cif-sensor.dtsi
index 63857b6936c3..49651152be36 100755
--- a/arch/arm/boot/dts/rk3126-cif-sensor.dtsi
+++ b/arch/arm/boot/dts/rk3126-cif-sensor.dtsi
@@ -48,7 +48,7 @@
 		};
 
 		
-		 gc0309{
+		 gc0329{
 			is_front = <0>;
 			//rockchip,power = <&gpio2 GPIO_B2 GPIO_ACTIVE_HIGH>;
 			//rockchip,power_pmu_name1 = "rk818_ldo4";
@@ -58,14 +58,16 @@
 			rockchip,powerdown = <&gpio3 GPIO_B3 GPIO_ACTIVE_HIGH>;
 			//rockchip,powerdown_pmu = "";
 			//rockchip,powerdown_pmu_voltage = <3000000>;
-			pwdn_active = <gc0309_PWRDN_ACTIVE>;
+			pwdn_active = <gc0329_PWRDN_ACTIVE>;
 			pwr_active = <PWR_ACTIVE_HIGH>;
 			mir = <0>;
-			flash_attach = <0>;
-			resolution = <gc0309_FULL_RESOLUTION>;
-			powerup_sequence = <gc0309_PWRSEQ>;
+			flash_attach = <1>;
+			//rockchip,flash = <>;
+			flash_active = <1>;
+			resolution = <gc0329_FULL_RESOLUTION>;
+			powerup_sequence = <gc0329_PWRSEQ>;
 			orientation = <0>;		
-			i2c_add = <gc0309_I2C_ADDR>;
+			i2c_add = <gc0329_I2C_ADDR>;
 			i2c_rata = <100000>;
 			i2c_chl = <1>;
 			cif_chl = <0>;
diff --git a/arch/arm/mach-rockchip/rk_camera.c b/arch/arm/mach-rockchip/rk_camera.c
index 3407b1cea6c9..0eed737a5682 100644
--- a/arch/arm/mach-rockchip/rk_camera.c
+++ b/arch/arm/mach-rockchip/rk_camera.c
@@ -163,7 +163,7 @@ static int	rk_dts_sensor_probe(struct platform_device *pdev)
 		u32	powerdown = INVALID_GPIO,power = INVALID_GPIO,reset = INVALID_GPIO;
 		u32 af = INVALID_GPIO,flash = INVALID_GPIO;
 
-		int pwr_active = 0, rst_active = 0, pwdn_active = 0;
+		int pwr_active = 0, rst_active = 0, pwdn_active = 0,flash_active = 0;
 		int orientation = 0;
 		struct rkcamera_platform_data *new_camera; 
 		
@@ -231,6 +231,9 @@ static int	rk_dts_sensor_probe(struct platform_device *pdev)
 		}
 		if (of_property_read_u32(cp, "rockchip,flash", &flash)) {
 				dprintk("%s:Get %s rockchip,flash failed!\n",__func__, cp->name);				
+		}		
+		if (of_property_read_u32(cp, "flash_active", &flash_active)) {
+				dprintk("%s:Get %s flash_active failed!\n",__func__, cp->name);				
 		}
 		if (of_property_read_u32(cp, "i2c_add", &i2c_add)) {
 			printk("%s:Get %s rockchip,i2c_add failed!\n",__func__, cp->name);				
@@ -261,7 +264,10 @@ static int	rk_dts_sensor_probe(struct platform_device *pdev)
 		new_camera->io.gpio_power = power;
 		new_camera->io.gpio_af = af;
 		new_camera->io.gpio_flash = flash;
-		new_camera->io.gpio_flag = ((pwr_active&0x01)<<RK29_CAM_POWERACTIVE_BITPOS)|((rst_active&0x01)<<RK29_CAM_RESETACTIVE_BITPOS)|((pwdn_active&0x01)<<RK29_CAM_POWERDNACTIVE_BITPOS);
+		new_camera->io.gpio_flag = ((pwr_active&0x01)<<RK29_CAM_POWERACTIVE_BITPOS)
+									|((rst_active&0x01)<<RK29_CAM_RESETACTIVE_BITPOS)
+									|((pwdn_active&0x01)<<RK29_CAM_POWERDNACTIVE_BITPOS)
+									|((flash_active&0x01)<<RK29_CAM_FLASHACTIVE_BITPOS);
 		new_camera->orientation = orientation;
 		new_camera->resolution = resolution;
 		new_camera->mirror = mir;
@@ -524,7 +530,6 @@ static int sensor_flash_default_cb (struct rk29camera_gpio_res *res, int on)
 
 	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
 
-
     if (camera_flash != INVALID_GPIO) {
 		if (camera_io_init & RK29_CAM_FLASHACTIVE_MASK) {
             switch (on)
diff --git a/arch/arm/mach-rockchip/rk_camera.h b/arch/arm/mach-rockchip/rk_camera.h
index 75037d75d242..02db4b0aef43 100644
--- a/arch/arm/mach-rockchip/rk_camera.h
+++ b/arch/arm/mach-rockchip/rk_camera.h
@@ -26,6 +26,7 @@
 #include <media/soc_camera.h>
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
+#include "rk_camera_sensor_info.h"
 
 #define RK29_CAM_PLATFORM_DEV_ID 33
 #define RK_CAM_PLATFORM_DEV_ID_0 RK29_CAM_PLATFORM_DEV_ID
@@ -44,8 +45,6 @@
 #define RK29_CAM_FLASHACTIVE_BITPOS	0x03
 #define RK29_CAM_AFACTIVE_BITPOS	0x04
 
-#define RK_CAM_NUM 0 //YZM
-#define RK29_CAM_SUPPORT_NUMS  RK_CAM_NUM
 #define RK_CAM_SUPPORT_RESOLUTION 0x800000
 
 #define _CONS(a,b) a##b
@@ -60,381 +59,9 @@
 
  
 /*---------------- Camera Sensor Must Define Macro Begin  ------------------------*/
-
-#define RK29_CAM_SENSOR_OV7675 ov7675
-#define RK29_CAM_SENSOR_OV9650 ov9650
-#define RK29_CAM_SENSOR_OV2640 ov2640
-#define RK29_CAM_SENSOR_OV2655 ov2655
-#define RK29_CAM_SENSOR_OV2659 ov2659
-
-#define RK29_CAM_SENSOR_OV2660 ov2660 /*yzm*/
-
-#define RK29_CAM_SENSOR_OV7690 ov7690
-#define RK29_CAM_SENSOR_OV3640 ov3640
-#define RK29_CAM_SENSOR_OV3660 ov3660
-#define RK29_CAM_SENSOR_OV5640 ov5640
-#define RK29_CAM_SENSOR_OV5642 ov5642
-#define RK29_CAM_SENSOR_S5K6AA s5k6aa
-#define RK29_CAM_SENSOR_MT9D112 mt9d112
-#define RK29_CAM_SENSOR_MT9D113 mt9d113
-#define RK29_CAM_SENSOR_MT9P111 mt9p111
-#define RK29_CAM_SENSOR_MT9T111 mt9t111
-#define RK29_CAM_SENSOR_GT2005  gt2005
-#define RK29_CAM_SENSOR_GC0307  gc0307
-#define RK29_CAM_SENSOR_GC0308  gc0308
-#define RK29_CAM_SENSOR_GC0309  gc0309
-#define RK29_CAM_SENSOR_GC2015  gc2015
-#define RK29_CAM_SENSOR_GC0328  gc0328
-#define RK29_CAM_SENSOR_GC0329  gc0329
-#define RK29_CAM_SENSOR_GC2035	gc2035
-#define RK29_CAM_SENSOR_SIV120B  siv120b
-#define RK29_CAM_SENSOR_SIV121D  siv121d
-#define RK29_CAM_SENSOR_SID130B  sid130B
-#define RK29_CAM_SENSOR_HI253  hi253
-#define RK29_CAM_SENSOR_HI704  hi704
-#define RK29_CAM_SENSOR_NT99250 nt99250
-#define RK29_CAM_SENSOR_SP0718  sp0718
-#define RK29_CAM_SENSOR_SP0838  sp0838
-#define RK29_CAM_SENSOR_SP2518  sp2518
-#define RK29_CAM_SENSOR_S5K5CA  s5k5ca
-#define RK29_CAM_ISP_MTK9335	mtk9335isp
-#define RK29_CAM_SENSOR_HM2057  hm2057
-#define RK29_CAM_SENSOR_HM5065  hm5065
-#define RK29_CAM_SENSOR_NT99160 nt99160  //oyyf@rock-chips.com 
-#define RK29_CAM_SENSOR_NT99240 nt99240  //oyyf@rock-chips.com 
-#define RK29_CAM_SENSOR_NT99252 nt99252  //oyyf@rock-chips.com 
-#define RK29_CAM_SENSOR_NT99340 nt99340  //oyyf@rock-chips.com 
-#define RK29_CAM_ISP_ICATCH7002_MI1040  icatchmi1040   
-#define RK29_CAM_ISP_ICATCH7002_OV5693  icatchov5693
-#define RK29_CAM_ISP_ICATCH7002_OV8825  icatchov8825   //zyt
-#define RK29_CAM_ISP_ICATCH7002_OV2720  icatchov2720   //zyt
-
-#define RK29_CAM_SENSOR_NAME_OV7675 "ov7675"
-#define RK29_CAM_SENSOR_NAME_OV9650 "ov9650"
-#define RK29_CAM_SENSOR_NAME_OV2640 "ov2640"
-#define RK29_CAM_SENSOR_NAME_OV2655 "ov2655"
-#define RK29_CAM_SENSOR_NAME_OV2659 "ov2659"
-
-#define RK29_CAM_SENSOR_NAME_OV2660 "ov2660"  /*yzm*/
-
-
-#define RK29_CAM_SENSOR_NAME_OV7690 "ov7690"
-#define RK29_CAM_SENSOR_NAME_OV3640 "ov3640"
-#define RK29_CAM_SENSOR_NAME_OV3660 "ov3660"
-#define RK29_CAM_SENSOR_NAME_OV5640 "ov5640"
-#define RK29_CAM_SENSOR_NAME_OV5642 "ov5642"
-#define RK29_CAM_SENSOR_NAME_S5K6AA "s5k6aa"
-#define RK29_CAM_SENSOR_NAME_MT9D112 "mt9d112"
-#define RK29_CAM_SENSOR_NAME_MT9D113 "mt9d113"
-#define RK29_CAM_SENSOR_NAME_MT9P111 "mt9p111"
-#define RK29_CAM_SENSOR_NAME_MT9T111 "mt9t111"
-#define RK29_CAM_SENSOR_NAME_GT2005  "gt2005"
-#define RK29_CAM_SENSOR_NAME_GC0307  "gc0307"
-#define RK29_CAM_SENSOR_NAME_GC0308  "gc0308"
-#define RK29_CAM_SENSOR_NAME_GC0309  "gc0309"
-#define RK29_CAM_SENSOR_NAME_GC2015  "gc2015"
-#define RK29_CAM_SENSOR_NAME_GC0328  "gc0328"
-#define RK29_CAM_SENSOR_NAME_GC2035  "gc2035"
-#define RK29_CAM_SENSOR_NAME_GC0329  "gc0329"
-#define RK29_CAM_SENSOR_NAME_SIV120B "siv120b"
-#define RK29_CAM_SENSOR_NAME_SIV121D "siv121d"
-#define RK29_CAM_SENSOR_NAME_SID130B "sid130B"
-#define RK29_CAM_SENSOR_NAME_HI253  "hi253"
-#define RK29_CAM_SENSOR_NAME_HI704  "hi704"
-#define RK29_CAM_SENSOR_NAME_NT99250 "nt99250"
-#define RK29_CAM_SENSOR_NAME_SP0718  "sp0718"
-#define RK29_CAM_SENSOR_NAME_SP0838  "sp0838"
-#define RK29_CAM_SENSOR_NAME_SP2518  "sp2518"
-#define RK29_CAM_SENSOR_NAME_S5K5CA  "s5k5ca"
-#define RK29_CAM_ISP_NAME_MTK9335ISP "mtk9335isp"
-#define RK29_CAM_SENSOR_NAME_HM2057  "hm2057"
-#define RK29_CAM_SENSOR_NAME_HM5065  "hm5065"
-#define RK29_CAM_ISP_NAME_ICATCH7002_MI1040 "icatchmi1040"
-#define RK29_CAM_ISP_NAME_ICATCH7002_OV5693 "icatchov5693"
-#define RK29_CAM_ISP_NAME_ICATCH7002_OV8825 "icatchov8825" //zyt
-#define RK29_CAM_ISP_NAME_ICATCH7002_OV2720 "icatchov2720" //zyt
-
-//Sensor full resolution define
-#define ov7675_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define ov9650_FULL_RESOLUTION     0x130000           // 1.3 megapixel   
-#define ov2640_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define ov2655_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define ov2659_FULL_RESOLUTION     0x200000           // 2 megapixel
-
-#define ov2660_FULL_RESOLUTION     0x200000           // 2 megapixel
-
-#define ov7690_FULL_RESOLUTION     0x300000           // 2 megapixel
-#define ov3640_FULL_RESOLUTION     0x300000           // 3 megapixel
-#define ov3660_FULL_RESOLUTION     0x300000           // 3 megapixel
-#define ov5640_FULL_RESOLUTION     0x500000           // 5 megapixel
-#if defined(CONFIG_SOC_CAMERA_OV5642_INTERPOLATION_8M)
-	#define ov5642_FULL_RESOLUTION     0x800000            // 8 megapixel
-#else	
-    #define ov5642_FULL_RESOLUTION     0x500000           // 5 megapixel
-#endif
-#define s5k6aa_FULL_RESOLUTION     0x130000           // 1.3 megapixel
-#define mt9d112_FULL_RESOLUTION    0x200000           // 2 megapixel
-#define mt9d113_FULL_RESOLUTION    0x200000           // 2 megapixel
-#define mt9t111_FULL_RESOLUTION    0x300000           // 3 megapixel
-#define mt9p111_FULL_RESOLUTION    0x500000           // 5 megapixel
-#define gt2005_FULL_RESOLUTION     0x200000           // 2 megapixel
-#if defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_5M)
-	#define gc0308_FULL_RESOLUTION     0x500000            // 5 megapixel
-#elif defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_3M)
-	#define gc0308_FULL_RESOLUTION     0x300000            // 3 megapixel
-#elif defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_2M)
-	#define gc0308_FULL_RESOLUTION     0x200000            // 2 megapixel
-#else
-	#define gc0308_FULL_RESOLUTION     0x30000            // 0.3 megapixel#endif
-#endif
-#define gc0328_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define gc0307_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define gc0309_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define gc2015_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define siv120b_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define siv121d_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define sid130B_FULL_RESOLUTION     0x200000           // 2 megapixel    
-
-#if defined(CONFIG_SOC_CAMERA_HI253_INTERPOLATION_5M) 
-	#define hi253_FULL_RESOLUTION       0x500000			// 5 megapixel
-#elif defined(CONFIG_SOC_CAMERA_HI253_INTERPOLATION_3M)
-	#define hi253_FULL_RESOLUTION       0x300000           // 3 megapixel
-#else
-	#define hi253_FULL_RESOLUTION       0x200000           // 2 megapixel
-#endif
-
-#define hi704_FULL_RESOLUTION       0x30000            // 0.3 megapixel
-#define nt99250_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define sp0718_FULL_RESOLUTION      0x30000            // 0.3 megapixel
-#define sp0838_FULL_RESOLUTION      0x30000            // 0.3 megapixel
-#define sp2518_FULL_RESOLUTION      0x200000            // 2 megapixel
-#define gc0329_FULL_RESOLUTION      0x30000            // 0.3 megapixel
-#define s5k5ca_FULL_RESOLUTION      0x300000            // 3 megapixel
-#define mtk9335isp_FULL_RESOLUTION  0x500000   		//5 megapixel
-#define gc2035_FULL_RESOLUTION      0x200000            // 2 megapixel
-#define hm2057_FULL_RESOLUTION      0x200000            // 2 megapixel
-#define hm5065_FULL_RESOLUTION      0x500000            // 5 megapixel
-#define nt99160_FULL_RESOLUTION     0x100000           // oyyf@rock-chips.com:  1 megapixel 1280*720    
-#define nt99240_FULL_RESOLUTION     0x200000           // oyyf@rock-chips.com:  2 megapixel 1600*1200
-#define nt99252_FULL_RESOLUTION     0x200000           // oyyf@rock-chips.com:  2 megapixel 1600*1200
-#define nt99340_FULL_RESOLUTION     0x300000           // oyyf@rock-chips.com:  3 megapixel 2048*1536
-#define icatchmi1040_FULL_RESOLUTION 0x200000
-#define icatchov5693_FULL_RESOLUTION 0x500000
-#define icatchov8825_FULL_RESOLUTION 0x800000					//zyt
-#define icatchov2720_FULL_RESOLUTION 0x210000                   //zyt
-#define end_FULL_RESOLUTION         0x00
-
-//Sensor i2c addr define
-#define ov7675_I2C_ADDR             0x78            
-#define ov9650_I2C_ADDR             0x60           
-#define ov2640_I2C_ADDR             0x60
-#define ov2655_I2C_ADDR             0x60
-#define ov2659_I2C_ADDR             0x60
-
-#define ov2660_I2C_ADDR             0x60   /*yzm*/
-
-#define ov7690_I2C_ADDR             0x42
-#define ov3640_I2C_ADDR             0x78
-#define ov3660_I2C_ADDR             0x78
-#define ov5640_I2C_ADDR             0x78
-#define ov5642_I2C_ADDR             0x78
-
-#define s5k6aa_I2C_ADDR             0x78           //0x5a
-#define s5k5ca_I2C_ADDR             0x78           //0x5a
-
-#define mt9d112_I2C_ADDR             0x78
-#define mt9d113_I2C_ADDR             0x78
-#define mt9t111_I2C_ADDR             0x78           // 0x7a 
-
-#define mt9p111_I2C_ADDR            0x78            //0x7a
-#define gt2005_I2C_ADDR             0x78           
-#define gc0307_I2C_ADDR             0x42
-#define gc0328_I2C_ADDR             0x42
-#define gc0308_I2C_ADDR             0x42
-#define gc0309_I2C_ADDR             0x42
-#define gc0329_I2C_ADDR             0x62           
-#define gc2015_I2C_ADDR             0x60
-#define gc2035_I2C_ADDR             0x78            
-
-#define siv120b_I2C_ADDR             INVALID_VALUE           
-#define siv121d_I2C_ADDR             INVALID_VALUE           
-#define sid130B_I2C_ADDR             0x37
-
-#define hi253_I2C_ADDR             0x40
-#define hi704_I2C_ADDR             0x60
-
-#define nt99160_I2C_ADDR             0x54
-#define nt99240_I2C_ADDR             0x6c
-#define nt99250_I2C_ADDR             0x6c
-#define nt99252_I2C_ADDR             0x6c
-#define nt99340_I2C_ADDR             0x76
-
-#define sp0718_I2C_ADDR             0x42
-#define sp0838_I2C_ADDR             INVALID_VALUE  
-#define sp0a19_I2C_ADDR             0x7a
-#define sp1628_I2C_ADDR             0x78
-#define sp2518_I2C_ADDR             0x60 
-#define mtk9335isp_I2C_ADDR         0x50 
-#define hm2057_I2C_ADDR             0x48
-#define hm5065_I2C_ADDR             0x3e
-#define icatchmi1040_I2C_ADDR		0x78
-#define icatchov5693_I2C_ADDR       0x78
-#define icatchov8825_I2C_ADDR       0x78  //zyt
-#define icatchov2720_I2C_ADDR       0x78  //zyt
-#define end_I2C_ADDR                INVALID_VALUE
-
-
-//Sensor power down active level define
-#define ov7675_PWRDN_ACTIVE             0x01            
-#define ov9650_PWRDN_ACTIVE             0x01           
-#define ov2640_PWRDN_ACTIVE             0x01
-#define ov2655_PWRDN_ACTIVE             0x01
-#define ov2659_PWRDN_ACTIVE             0x01
-
-#define ov2660_PWRDN_ACTIVE             0x01  /*yzm*/
-
-#define ov7690_PWRDN_ACTIVE             0x01
-#define ov3640_PWRDN_ACTIVE             0x01
-#define ov3660_PWRDN_ACTIVE             0x01
-#define ov5640_PWRDN_ACTIVE             0x01
-#define ov5642_PWRDN_ACTIVE             0x01
-
-#define s5k6aa_PWRDN_ACTIVE             0x00           
-#define s5k5ca_PWRDN_ACTIVE             0x00           
-
-#define mt9d112_PWRDN_ACTIVE             0x01
-#define mt9d113_PWRDN_ACTIVE             0x01
-#define mt9t111_PWRDN_ACTIVE             0x01  
-#define mt9p111_PWRDN_ACTIVE             0x01
-
-#define gt2005_PWRDN_ACTIVE             0x00           
-#define gc0307_PWRDN_ACTIVE             0x01
-#define gc0308_PWRDN_ACTIVE             0x01
-#define gc0328_PWRDN_ACTIVE             0x01
-#define gc0309_PWRDN_ACTIVE             0x01
-#define gc0329_PWRDN_ACTIVE             0x01           
-#define gc2015_PWRDN_ACTIVE             0x01
-#define gc2035_PWRDN_ACTIVE             0x01            
-
-#define siv120b_PWRDN_ACTIVE             INVALID_VALUE           
-#define siv121d_PWRDN_ACTIVE             INVALID_VALUE           
-#define sid130B_PWRDN_ACTIVE             0x37
-
-#define hi253_PWRDN_ACTIVE             0x01
-#define hi704_PWRDN_ACTIVE             0x01
-
-#define nt99160_PWRDN_ACTIVE             0x01
-#define nt99240_PWRDN_ACTIVE             0x01
-#define nt99250_PWRDN_ACTIVE             0x01
-#define nt99252_PWRDN_ACTIVE             0x01
-#define nt99340_PWRDN_ACTIVE             0x01
-
-#define sp0718_PWRDN_ACTIVE             0x01
-#define sp0838_PWRDN_ACTIVE             0x01  
-#define sp0a19_PWRDN_ACTIVE             0x01
-#define sp1628_PWRDN_ACTIVE             0x01
-#define sp2518_PWRDN_ACTIVE             0x01 
-#define hm2057_PWRDN_ACTIVE             0x01
-#define hm5065_PWRDN_ACTIVE             0x00
-#define mtk9335isp_PWRDN_ACTIVE         0x01 
-#define end_PWRDN_ACTIVE                INVALID_VALUE
-
-
-//Sensor power up sequence  define
-//type: bit0-bit4
-#define SENSOR_PWRSEQ_BEGIN         0x00
-#define SENSOR_PWRSEQ_AVDD          0x01
-#define SENSOR_PWRSEQ_DOVDD         0x02
-#define SENSOR_PWRSEQ_DVDD          0x03
-#define SENSOR_PWRSEQ_PWR           0x04
-#define SENSOR_PWRSEQ_HWRST         0x05
-#define SENSOR_PWRSEQ_PWRDN         0x06
-#define SENSOR_PWRSEQ_CLKIN         0x07
-#define SENSOR_PWRSEQ_END           0x0F
-
-#define SENSOR_PWRSEQ_SET(type,idx)    (type<<(idx*4))
-#define SENSOR_PWRSEQ_GET(seq,idx)     ((seq>>(idx*4))&0x0f)
-
-#define sensor_PWRSEQ_DEFAULT      (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,1)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWRDN,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,3))
-
-#define ov7675_PWRSEQ                   sensor_PWRSEQ_DEFAULT            
-#define ov9650_PWRSEQ                   sensor_PWRSEQ_DEFAULT  
-#define ov2640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov2655_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov2659_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define ov2660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define ov7690_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov3640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov3660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov5640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov5642_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define s5k6aa_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
-#define s5k5ca_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
-
-#define mt9d112_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define mt9d113_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define mt9t111_PWRSEQ                   sensor_PWRSEQ_DEFAULT 
-#define mt9p111_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define gt2005_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
-#define gc0307_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc0308_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc0328_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc0309_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc0329_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
-#define gc2015_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc2035_PWRSEQ                   sensor_PWRSEQ_DEFAULT            
-
-#define siv120b_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
-#define siv121d_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
-#define sid130B_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define hi253_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define hi704_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define nt99160_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define nt99240_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define nt99250_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define nt99252_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define nt99340_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define sp0718_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define sp0838_PWRSEQ                   sensor_PWRSEQ_DEFAULT  
-#define sp0a19_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define sp1628_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define sp2518_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define hm2057_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define hm5065_PWRSEQ                   (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,1)|\
-                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWRDN,0)|\
-                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,3))
-#define mtk9335isp_PWRSEQ               sensor_PWRSEQ_DEFAULT
-#define icatchov5693_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))
-                                    
-#define icatchov8825_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))     //zyt                                    
-                                    
-#define icatchov2720_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))     //zyt 
-
-#define icatchmi1040_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))
-
-#define end_PWRSEQ                      0xffffffff
-                                          
-
-
+/*
+ move to rk_camera_sensor_info.h   yzm                                    
+*/
 /*---------------- Camera Sensor Must Define Macro End  ------------------------*/
 
 
diff --git a/arch/arm/mach-rockchip/rk_camera_sensor_info.h b/arch/arm/mach-rockchip/rk_camera_sensor_info.h
index b37ffdb3e49a..7b5e380cd2d3 100644
--- a/arch/arm/mach-rockchip/rk_camera_sensor_info.h
+++ b/arch/arm/mach-rockchip/rk_camera_sensor_info.h
@@ -8,9 +8,6 @@
 #define RK29_CAM_SENSOR_OV2640 ov2640
 #define RK29_CAM_SENSOR_OV2655 ov2655
 #define RK29_CAM_SENSOR_OV2659 ov2659
-
-#define RK29_CAM_SENSOR_OV2660 ov2660 /*yzm*/
-
 #define RK29_CAM_SENSOR_OV7690 ov7690
 #define RK29_CAM_SENSOR_OV3640 ov3640
 #define RK29_CAM_SENSOR_OV3660 ov3660
@@ -56,10 +53,6 @@
 #define RK29_CAM_SENSOR_NAME_OV2640 "ov2640"
 #define RK29_CAM_SENSOR_NAME_OV2655 "ov2655"
 #define RK29_CAM_SENSOR_NAME_OV2659 "ov2659"
-
-#define RK29_CAM_SENSOR_NAME_OV2660 "ov2660"  /*yzm*/
-
-
 #define RK29_CAM_SENSOR_NAME_OV7690 "ov7690"
 #define RK29_CAM_SENSOR_NAME_OV3640 "ov3640"
 #define RK29_CAM_SENSOR_NAME_OV3660 "ov3660"
@@ -172,9 +165,6 @@
 #define ov2640_I2C_ADDR             0x60
 #define ov2655_I2C_ADDR             0x60
 #define ov2659_I2C_ADDR             0x60
-
-#define ov2660_I2C_ADDR             0x60   /*yzm*/
-
 #define ov7690_I2C_ADDR             0x42
 #define ov3640_I2C_ADDR             0x78
 #define ov3660_I2C_ADDR             0x78
@@ -235,9 +225,6 @@
 #define ov2640_PWRDN_ACTIVE             0x01
 #define ov2655_PWRDN_ACTIVE             0x01
 #define ov2659_PWRDN_ACTIVE             0x01
-
-#define ov2660_PWRDN_ACTIVE             0x01  /*yzm*/
-
 #define ov7690_PWRDN_ACTIVE             0x01
 #define ov3640_PWRDN_ACTIVE             0x01
 #define ov3660_PWRDN_ACTIVE             0x01
@@ -310,9 +297,6 @@
 #define ov2640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
 #define ov2655_PWRSEQ                   sensor_PWRSEQ_DEFAULT
 #define ov2659_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define ov2660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
 #define ov7690_PWRSEQ                   sensor_PWRSEQ_DEFAULT
 #define ov3640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
 #define ov3660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 4274f0b18ca4..6a92b1a916ed 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -16,4 +16,8 @@ menu "rockchip camera sensor interface driver"
 		depends on ROCKCHIP_CAMERA_SENSOR_INTERFACE
 		default y
 		
+	config RK30_CAMERA_PINGPONG
+		tristate "rk30_camera_pingpong"
+		depends on ROCKCHIP_CAMERA_SENSOR_INTERFACE
+		
 endmenu		
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 00df4b1e3e58..51299a5644be 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -1,3 +1,21 @@
+obj-$(CONFIG_RK30_CAMERA_PINGPONG) += rk30_camera_pingpong.o generic_sensor.o \
+gc0307.o \
+gc0308.o \
+gc0309.o \
+gc0328.o \
+gc0329.o \
+gc2015.o \
+gc2035.o \
+gt2005.o \
+hm2057.o \
+hm5065.o \
+mt9p111.o \
+nt99160_2way.o \
+nt99240_2way.o \
+ov2659.o \
+ov5640.o \
+sp0838.o \
+sp2518.o
 obj-$(CONFIG_RK30_CAMERA_ONEFRAME) += rk30_camera_oneframe.o generic_sensor.o \
 gc0307.o \
 gc0308.o \
diff --git a/drivers/media/video/generic_sensor.h b/drivers/media/video/generic_sensor.h
index 12024982cb8c..a6f26a9f47f2 100755
--- a/drivers/media/video/generic_sensor.h
+++ b/drivers/media/video/generic_sensor.h
@@ -517,6 +517,14 @@ static inline int sensor_v4l2ctrl_flash_cb(struct soc_camera_device *icd, struct
     //struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
     int value = ext_ctrl->value;
 
+	
+	if(value == 0xfefe5a5a){	
+		if ((ctrl_info->cur_value == 2) || (ctrl_info->cur_value == 1)) {
+			generic_sensor_ioctrl(icd, Sensor_Flash, Flash_On);					
+		}
+		
+		return 0;
+	}
     if ((value < ctrl_info->qctrl->minimum) || (value > ctrl_info->qctrl->maximum)) {
         printk(KERN_ERR "%s(%d): value(0x%x) isn't between in (0x%x,0x%x)\n",__FUNCTION__,__LINE__,value,
             ctrl_info->qctrl->minimum,ctrl_info->qctrl->maximum);
diff --git a/drivers/media/video/rk30_camera_oneframe.c b/drivers/media/video/rk30_camera_oneframe.c
index bb6ca97866f9..e1ffdc1a1bd0 100755
--- a/drivers/media/video/rk30_camera_oneframe.c
+++ b/drivers/media/video/rk30_camera_oneframe.c
@@ -193,11 +193,16 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 /*********yzm**********/
 
 static u32 CRU_PCLK_REG30;
+static u32 CRU_CLK_OUT;
+static u32 clk_cif_out_src_gate_en;
+static u32 CRU_CLKSEL29_CON;
+static u32 cif0_clk_sel;
 static u32 ENANABLE_INVERT_PCLK_CIF0;
 static u32 DISABLE_INVERT_PCLK_CIF0;
 static u32 ENANABLE_INVERT_PCLK_CIF1;
 static u32 DISABLE_INVERT_PCLK_CIF1;
-	
+static u32 CHIP_NAME;
+
 #define write_cru_reg(addr, val)            __raw_writel(val, addr+RK_CRU_VIRT)
 #define read_cru_reg(addr)                  __raw_readl(addr+RK_CRU_VIRT)
 #define mask_cru_reg(addr, msk, val)        write_cru_reg(addr,(val)|((~(msk))&read_cru_reg(addr)))
@@ -272,8 +277,13 @@ static u32 DISABLE_INVERT_PCLK_CIF1;
 		 1. Add  power and powerdown controled by PMU.
 *v0.1.8:
 		 1. Support front and rear camera support are the same.
+*v0.1.9:
+		 1. Support pingpong mode.
+		 2. Fix cif_clk_out cannot close which base on XIN24M and cannot turn to 0
+		 3. Move Camera Sensor Macro from rk_camera.h to rk_camera_sensor_info.h
+		 4. Support flash control when preview size == picture size
 */
-#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 1, 0x8)
+#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 1, 0x9)
 static int version = RK_CAM_VERSION_CODE;
 module_param(version, int, S_IRUGO);
 
@@ -491,6 +501,13 @@ static void rk_camera_diffchips(const char *rockchip_name)
 		DISABLE_INVERT_PCLK_CIF0  = ((0x1<<23)|(0x0<<7));
 		ENANABLE_INVERT_PCLK_CIF1 = ENANABLE_INVERT_PCLK_CIF0;
 		DISABLE_INVERT_PCLK_CIF1  = DISABLE_INVERT_PCLK_CIF0;
+
+		CRU_CLK_OUT = 0xdc;
+		clk_cif_out_src_gate_en = ((0x1<<23)|(0x1<<7));
+		CRU_CLKSEL29_CON = 0xb8;
+		cif0_clk_sel = ((0x1<<23)|(0x0<<7));
+
+		CHIP_NAME = 3126;
 	}
 }
 static inline void rk_cru_set_soft_reset(u32 idx, bool on , u32 RK_CRU_SOFTRST_CON)
@@ -562,7 +579,7 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 	int bytes_per_line_host;
 	fmt.packing = SOC_MBUS_PACKING_1_5X8;
 
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 
 
 		bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
@@ -1217,7 +1234,6 @@ static int rk_camera_mclk_ctrl(int cif_idx, int on, int clk_rate)
 {
     int err = 0,cif;    
     struct rk_cif_clk *clk;
-    struct clk *cif_clk_out_div;
 
 	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 
@@ -1247,31 +1263,19 @@ static int rk_camera_mclk_ctrl(int cif_idx, int on, int clk_rate)
         clk_set_rate(clk->cif_clk_out,clk_rate);
         clk->on = true;
     } else if (!on && clk->on) {
+		clk_set_rate(clk->cif_clk_out,36000000);/*yzm :just for close clk which base on XIN24M */
     	msleep(100);
         clk_disable_unprepare(clk->aclk_cif);
     	clk_disable_unprepare(clk->hclk_cif);
     	clk_disable_unprepare(clk->cif_clk_in);
+		if(CHIP_NAME == 3126){
+			write_cru_reg(CRU_CLKSEL29_CON, 0x007c0000);
+			write_cru_reg(CRU_CLK_OUT, 0x00800080);
+		}
     	clk_disable_unprepare(clk->cif_clk_out);
     	clk_disable_unprepare(clk->pd_cif);
-        clk->on = false;
-        if(cif){
-            cif_clk_out_div =  clk_get(NULL, "cif1_out_div");
-        }else{
-            cif_clk_out_div =  clk_get(NULL, "cif0_out_div");
-            if(IS_ERR_OR_NULL(cif_clk_out_div)) {
-                cif_clk_out_div =  clk_get(NULL, "cif_out_div");
-            }
-        }
-        
-        if(!IS_ERR_OR_NULL(cif_clk_out_div)) {   /* ddl@rock-chips.com: v0.3.0x13 */ 
-            err = clk_set_parent(clk->cif_clk_out, cif_clk_out_div);
-            clk_put(cif_clk_out_div);
-        } else {
-            err = -1;
-        }
-        
-        if(err)
-           RKCAMERA_TR("WARNING %s_%s_%d: camera sensor mclk maybe not close, please check!!!\n", __FILE__, __FUNCTION__, __LINE__); 
+		
+		clk->on = false;
     }
     //spin_unlock(&clk->lock);
 rk_camera_clk_ctrl_end:
@@ -1536,7 +1540,7 @@ static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
         }
     } else {
 		if(IS_CIF0()){
-			write_cru_reg(CRU_PCLK_REG30, (read_cru_reg(CRU_PCLK_REG30) & 0xFFFFEFF ) | DISABLE_INVERT_PCLK_CIF0);
+			write_cru_reg(CRU_PCLK_REG30, (read_cru_reg(CRU_PCLK_REG30) & 0xFFFFFF7F ) | DISABLE_INVERT_PCLK_CIF0);
         } else {
 			write_cru_reg(CRU_PCLK_REG30, (read_cru_reg(CRU_PCLK_REG30) & 0xFFFEFFF) | DISABLE_INVERT_PCLK_CIF1);
         }
@@ -2651,7 +2655,7 @@ static int rk_camera_s_stream(struct soc_camera_device *icd, int enable)
 		cif_ctrl_val |= ENABLE_CAPTURE;
         write_cif_reg(pcdev->base,CIF_CIF_CTRL, cif_ctrl_val);
         spin_unlock_irqrestore(&pcdev->lock,flags);
-        printk("%s:stream enable CIF_CIF_CTRL 0x%lx",__func__,read_cif_reg(pcdev->base,CIF_CIF_CTRL));
+        printk("%s:stream enable CIF_CIF_CTRL 0x%lx\n",__func__,read_cif_reg(pcdev->base,CIF_CIF_CTRL));
 		hrtimer_start(&(pcdev->fps_timer.timer),ktime_set(3, 0),HRTIMER_MODE_REL);
         pcdev->fps_timer.istarted = true;
 	} else {
diff --git a/drivers/media/video/rk30_camera_pingpong.c b/drivers/media/video/rk30_camera_pingpong.c
index d24a0b7b0fa7..5b8a39b01e86 100755
--- a/drivers/media/video/rk30_camera_pingpong.c
+++ b/drivers/media/video/rk30_camera_pingpong.c
@@ -1,15 +1,3 @@
-/*
- * V4L2 Driver for RK28 camera host
- *
- * Copyright (C) 2006, Sascha Hauer, Pengutronix
- * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-#if defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK30) ||defined(CONFIG_ARCH_RK3188)
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/io.h>
@@ -30,46 +18,58 @@
 #include <linux/mutex.h>
 #include <linux/videodev2.h>
 #include <linux/kthread.h>
-#include <mach/iomux.h>
+
 #include <media/v4l2-common.h>
 #include <media/v4l2-dev.h>
 #include <media/videobuf-dma-contig.h>
 #include <media/soc_camera.h>
 #include <media/soc_mediabus.h>
-#include <mach/io.h>
-#include <plat/ipp.h>
-#include <plat/vpu_service.h>
+#include <media/videobuf-core.h>
+#include <linux/rockchip/iomap.h>
+
 #include "../../video/rockchip/rga/rga.h"
-#if defined(CONFIG_ARCH_RK30)||defined(CONFIG_ARCH_RK3188)
-#include <mach/rk30_camera.h>
-#include <mach/cru.h>
-#include <mach/pmu.h>
-#endif
+#include "../../../arch/arm/mach-rockchip/rk30_camera.h"/*yzm*/
+#include <linux/rockchip/cru.h>
 
-#if defined(CONFIG_ARCH_RK2928)
+/*******yzm*********
+
+#include <plat/efuse.h>
+#if (defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026))
 #include <mach/rk2928_camera.h>
 #include <mach/cru.h>
 #include <mach/pmu.h>
 #define SOFT_RST_CIF1 (SOFT_RST_MAX+1)
 #endif
+*/
 #include <asm/cacheflush.h>
+
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/of_fdt.h>
+#include <media/soc_camera.h>
+#include <media/camsys_head.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+ 
 static int debug = 0;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
-#if defined(CONFIG_TRACE_LOG_PRINTK)
- #define RK30_CAM_DEBUG_TRACE(format, ...) printk(KERN_ERR"rk30_camera: " format, ## __VA_ARGS__)
-#else
- #define RK30_CAM_DEBUG_TRACE(format, ...)
-#endif
-#define RK30_CAM_LOG_TRACE(format, ...) printk(KERN_WARNING"rk30_camera: " format, ## __VA_ARGS__)
+#define CAMMODULE_NAME     "rk_cam_cif"   
+
+#define wprintk(level, fmt, arg...) do {			\
+	if (debug >= level) 					\
+	    printk(KERN_ERR "%s(%d): " fmt,CAMMODULE_NAME,__LINE__,## arg); } while (0)
 
 #define dprintk(level, fmt, arg...) do {			\
 	if (debug >= level) 					\
-	printk(KERN_WARNING"rk_camera: " fmt , ## arg); } while (0)
+	    printk(KERN_ERR"%s(%d): " fmt,CAMMODULE_NAME,__LINE__,## arg); } while (0)	    
+
+#define RKCAMERA_TR(format, ...)  printk(KERN_ERR "%s(%d):" format,CAMMODULE_NAME,__LINE__,## __VA_ARGS__)
+#define RKCAMERA_DG1(format, ...) wprintk(1, format, ## __VA_ARGS__)
+#define RKCAMERA_DG2(format, ...) dprintk(2, format, ## __VA_ARGS__)
+#define debug_printk(format, ...) dprintk(3, format, ## __VA_ARGS__)
 
-#define RKCAMERA_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
-#define RKCAMERA_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
-// CIF Reg Offset
+/* CIF Reg Offset*/
 #define  CIF_CIF_CTRL                       0x00
 #define  CIF_CIF_INTEN                      0x04
 #define  CIF_CIF_INTSTAT                    0x08
@@ -98,8 +98,8 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define	 CIF_CIF_LAST_LINE                  0x68
 #define	 CIF_CIF_LAST_PIX                   0x6c
 
-//The key register bit descrition
-// CIF_CTRL Reg , ignore SCM,WBC,ISP,
+/*The key register bit descrition*/
+/* CIF_CTRL Reg , ignore SCM,WBC,ISP,*/
 #define  DISABLE_CAPTURE              (0x00<<0)
 #define  ENABLE_CAPTURE               (0x01<<0)
 #define  MODE_ONEFRAME                (0x00<<1)
@@ -107,12 +107,12 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define  MODE_LINELOOP                (0x02<<1)
 #define  AXI_BURST_16                 (0x0F << 12)
 
-//CIF_CIF_INTEN
+/*CIF_CIF_INTEN*/
 #define  FRAME_END_EN			(0x01<<1)
 #define  BUS_ERR_EN				(0x01<<6)
 #define  SCL_ERR_EN				(0x01<<7)
 
-//CIF_CIF_FOR
+/*CIF_CIF_FOR*/
 #define  VSY_HIGH_ACTIVE                   (0x01<<0)
 #define  VSY_LOW_ACTIVE                    (0x00<<0)
 #define  HSY_LOW_ACTIVE 			       (0x01<<1)
@@ -145,7 +145,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define  UV_STORAGE_ORDER_UVUV             (0x00<<19)
 #define  UV_STORAGE_ORDER_VUVU             (0x01<<19)
 
-//CIF_CIF_SCL_CTRL
+/*CIF_CIF_SCL_CTRL*/
 #define ENABLE_SCL_DOWN                    (0x01<<0)		
 #define DISABLE_SCL_DOWN                   (0x00<<0)
 #define ENABLE_SCL_UP                      (0x01<<1)		
@@ -163,14 +163,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 
 #define MIN(x,y)   ((x<y) ? x: y)
 #define MAX(x,y)    ((x>y) ? x: y)
-#define RK_SENSOR_12MHZ      12*1000*1000 
 #define RK_SENSOR_24MHZ      24*1000*1000          /* MHz */
-#define RK_SENSOR_48MHZ      48*1000*1000
+#define RK_SENSOR_48MHZ      48
+
+#define __raw_readl(p)		  (*(unsigned long *)(p))
+#define __raw_writel(v,p)     (*(unsigned long *)(p) = (v))
 
 #define write_cif_reg(base,addr, val)  __raw_writel(val, addr+(base))
 #define read_cif_reg(base,addr) __raw_readl(addr+(base))
 #define mask_cif_reg(addr, msk, val)    write_cif_reg(addr, (val)|((~(msk))&read_cif_reg(addr)))
 
+/*
 #if defined(CONFIG_ARCH_RK30) || defined(CONFIG_ARCH_RK3188)
 //CRU,PIXCLOCK
 #define CRU_PCLK_REG30                     0xbc
@@ -185,11 +188,35 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define RQUEST_RST_CIF0                    (0x01 << 14)
 #define RQUEST_RST_CIF1                    (0x01 << 15)
 
-#define write_cru_reg(addr, val)  __raw_writel(val, addr+RK30_CRU_BASE)
-#define read_cru_reg(addr) __raw_readl(addr+RK30_CRU_BASE)
-#define mask_cru_reg(addr, msk, val)	write_cru_reg(addr,(val)|((~(msk))&read_cru_reg(addr)))
+#define write_cru_reg(addr, val)            __raw_writel(val, addr+RK30_CRU_BASE)
+#define read_cru_reg(addr)                  __raw_readl(addr+RK30_CRU_BASE)
+#define mask_cru_reg(addr, msk, val)        write_cru_reg(addr,(val)|((~(msk))&read_cru_reg(addr)))
+#endif
+*/
+/*********yzm**********/
+
+static u32 CRU_PCLK_REG30;
+static u32 CRU_CLK_OUT;
+static u32 CRU_CLKSEL29_CON;
+static u32 ENANABLE_INVERT_PCLK_CIF0;
+static u32 DISABLE_INVERT_PCLK_CIF0;
+static u32 ENANABLE_INVERT_PCLK_CIF1;
+static u32 DISABLE_INVERT_PCLK_CIF1;
+static u32 CHIP_NAME;
+	
+#define write_cru_reg(addr, val)            __raw_writel(val, addr+RK_CRU_VIRT)
+#define read_cru_reg(addr)                  __raw_readl(addr+RK_CRU_VIRT)
+#define mask_cru_reg(addr, msk, val)        write_cru_reg(addr,(val)|((~(msk))&read_cru_reg(addr)))
+/*********yzm*********end*/
+/*
+#if defined(CONFIG_ARCH_RK2928)
+#define write_cru_reg(addr, val)  
+#define read_cru_reg(addr)                 0 
+#define mask_cru_reg(addr, msk, val)	
 #endif
+*/
 
+/*
 #if defined(CONFIG_ARCH_RK3066B) || defined(CONFIG_ARCH_RK3188)
 //GRF_IO_CON3                        0x100
 #define CIF_DRIVER_STRENGTH_2MA            (0x00 << 12)
@@ -203,43 +230,24 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CIF_CLKOUT_AMP_1V8                 (0x01 << 10)
 #define CIF_CLKOUT_AMP_MASK                (0x01 << 26)
 
-#define write_grf_reg(addr, val)  __raw_writel(val, addr+RK30_GRF_BASE)
-#define read_grf_reg(addr) __raw_readl(addr+RK30_GRF_BASE)
-#define mask_grf_reg(addr, msk, val)	write_grf_reg(addr,(val)|((~(msk))&read_grf_reg(addr)))
+#define write_grf_reg(addr, val)           __raw_writel(val, addr+RK30_GRF_BASE)
+#define read_grf_reg(addr)                 __raw_readl(addr+RK30_GRF_BASE)
+#define mask_grf_reg(addr, msk, val)       write_grf_reg(addr,(val)|((~(msk))&read_grf_reg(addr)))
 #else
 #define write_grf_reg(addr, val)  
-#define read_grf_reg(addr)                0
+#define read_grf_reg(addr)                 0
 #define mask_grf_reg(addr, msk, val)	
 #endif
+*/
+#define CAM_WORKQUEUE_IS_EN()   (false)//(true)
+#define CAM_IPPWORK_IS_EN()     (false)/*((pcdev->zoominfo.a.c.width != pcdev->icd->user_width) || (pcdev->zoominfo.a.c.height != pcdev->icd->user_height))*/
 
-#if defined(CONFIG_ARCH_RK2928)
-#define write_cru_reg(addr, val)  
-#define read_cru_reg(addr)                 0 
-#define mask_cru_reg(addr, msk, val)	
-#endif
-
-
-//when work_with_ipp is not enabled,CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF is not defined.something wrong with it
-#ifdef CONFIG_VIDEO_RK29_WORK_IPP//CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF
-#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF
-#define CAM_WORKQUEUE_IS_EN()   ((pcdev->host_width != pcdev->icd->user_width) || (pcdev->host_height != pcdev->icd->user_height)\
-                                      || (pcdev->icd_cb.sensor_cb))
-#define CAM_IPPWORK_IS_EN()     ((pcdev->host_width != pcdev->icd->user_width) || (pcdev->host_height != pcdev->icd->user_height))                                  
-#else
-#define CAM_WORKQUEUE_IS_EN()  (true)
-#define CAM_IPPWORK_IS_EN()     ((pcdev->zoominfo.a.c.width != pcdev->icd->user_width) || (pcdev->zoominfo.a.c.height != pcdev->icd->user_height))
-#endif
-#else //CONFIG_VIDEO_RK29_WORK_IPP
-#define CAM_WORKQUEUE_IS_EN()    (false)
-#define CAM_IPPWORK_IS_EN()      (false) 
-#endif
-
-#define IS_CIF0()		(pcdev->hostid == RK_CAM_PLATFORM_DEV_ID_0)
+#define IS_CIF0()		(true)/*(pcdev->hostid == RK_CAM_PLATFORM_DEV_ID_0)*/
 #if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_IPP)
 #define CROP_ALIGN_BYTES (0x03)
 #define CIF_DO_CROP 0
 #elif (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_ARM)
-#define CROP_ALIGN_BYTES (0x03)
+#define CROP_ALIGN_BYTES (0x0f)
 #define CIF_DO_CROP 0
 #elif (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_RGA)
 #define CROP_ALIGN_BYTES (0x03)
@@ -248,87 +256,61 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CROP_ALIGN_BYTES (0x0F)
 #define CIF_DO_CROP 1
 #endif
-//Configure Macro
+
 /*
-*			 Driver Version Note
-*
-*v0.0.x : this driver is 2.6.32 kernel driver;
-*v0.1.x : this driver is 3.0.8 kernel driver;
-*
-*v0.x.1 : this driver first support rk2918;
-*v0.x.2 : fix this driver support v4l2 format is V4L2_PIX_FMT_NV12 and V4L2_PIX_FMT_NV16,is not V4L2_PIX_FMT_YUV420 
-*		  and V4L2_PIX_FMT_YUV422P;
-*v0.x.3 : this driver support VIDIOC_ENUM_FRAMEINTERVALS;
-*v0.x.4 : this driver support digital zoom;
-*v0.x.5 : this driver support test framerate and query framerate from board file configuration;
-*v0.x.6 : this driver improve test framerate method;
-*v0.x.7 : digital zoom use the ipp to do scale and crop , otherwise ipp just do the scale. Something wrong with digital zoom if
-          we do crop with cif and do scale with ipp , we will fix this  next version.
-*v0.x.8 : temp version,reinit capture list when setup video buf.
-*v0.x.9 : 1. add the case of IPP unsupportted ,just cropped by CIF(not do the scale) this version. 
-          2. flush workqueue when releas buffer
-*v0.x.a: 1. reset cif and wake up vb when cif have't receive data in a fixed time(now setted as 2 secs) so that app can
-             be quitted
-          2. when the flash is on ,flash off in a fixed time to prevent from flash light too hot.
-          3. when front and back camera are the same sensor,and one has the flash ,other is not,flash can't work corrrectly ,fix it
-          4. add  menu configs for convineuent to customize sensor series
-*v0.x.b:  specify the version is  NOT sure stable.
-*v0.x.c:  1. add cif reset when resolution changed to avoid of collecting data erro
-          2. irq process is splitted to two step.
-*v0.x.e: fix bugs of early suspend when display_pd is closed. 
-*v0.x.f: fix calculate ipp memory size is enough or not in try_fmt function; 
-*v0.x.11: fix struct rk_camera_work may be reentrant
-*v0.x.13: 1.add scale by arm,rga and pp.
-          2.CIF do the crop when digital zoom.
-		  3.fix bug in prob func:request mem twice. 
-		  4.video_vq may be null when reinit work,fix it
-		  5.arm scale algorithm has something wrong(may exceed the bound of width or height) ,fix it.
-*v0.x.15: 
-*         1. support rk3066b;
-*v0.4.15:
-*         1. cif work on pingping mode;
-*v0.x.17: 
-*         1. support 8Mega picture;
-*v0.x.19:
-*         1. invalidate the limit which scale is invalidat when scale ratio > 2;
-*v0.x.1b: 1. fix oops bug  when using arm to do scale_crop if preview buffer is not allocated correctly 
-          2. rk_camera_set_fmt will called twice, optimize the procedure. at the first time call ,just to do the sensor init.
-
-*v0.x.1c:
-*         1. fix query resolution error;
-*v0.x.1d: 
-*         1. add mv9335+ov5650 driver;
-*         2. fix 2928 digitzoom erro(arm crop scale) of selected zone;
-*v0.x.1f:
-*         1. support rk3188
-*v0.x.21:
-		  1. cif change mode to free run.support icatch 7002.
+*v0.1.0 : this driver is 3.10 kernel driver;
+		copy and updata from v0.3.0x19;
+		support rk312x;
+*v0.1.1:
+         1. spin lock in struct rk_cif_clk is not neccessary,and scheduled func clk_get called in this spin lock scope
+            cause warning, so remove this spin lock .
+*v0.1.2:
+		 1. rk3126 and rk3128 use different dts file.		 
+*v0.1.3:
+		 1. i2c 1 and wifi use the common io in rk3128,so just enable i2c1 in rk3126 dts file
+*v0.1.4:
+		 1. When cif was at work, the aclk is closed ,may cause bus abnormal ,so sleep 100ms before close aclk 
+*v0.1.5:	
+           1. Improve the code to support all configuration.reset,af,flash...
+*v0.1.6:
+		 1. Delete SOCAM_DATAWIDTH_8 in SENSOR_BUS_PARAM parameters,it conflict with V4L2_MBUS_PCLK_SAMPLE_FALLING.
+*v0.1.7:
+		 1. Add  power and powerdown controled by PMU.
+*v0.1.8:
+		 1. Support front and rear camera support are the same.
+*v0.1.9:
+		 1. Support pingpong mode.
+		 2. Fix cif_clk_out cannot close which base on XIN24M and cannot turn to 0.
+		 3. Move Camera Sensor Macro from rk_camera.h to rk_camera_sensor_info.h
 */
-#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 4, 0x21)
+#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 1, 0x9)
+static int version = RK_CAM_VERSION_CODE;
+module_param(version, int, S_IRUGO);
 
 /* limit to rk29 hardware capabilities */
-#define RK_CAM_BUS_PARAM   (SOCAM_MASTER |\
-                SOCAM_HSYNC_ACTIVE_HIGH |\
-                SOCAM_HSYNC_ACTIVE_LOW |\
-                SOCAM_VSYNC_ACTIVE_HIGH |\
-                SOCAM_VSYNC_ACTIVE_LOW |\
-                SOCAM_PCLK_SAMPLE_RISING |\
-                SOCAM_PCLK_SAMPLE_FALLING|\
-                SOCAM_DATA_ACTIVE_HIGH |\
-                SOCAM_DATA_ACTIVE_LOW|\
+#define RK_CAM_BUS_PARAM   (V4L2_MBUS_MASTER |\
+                V4L2_MBUS_HSYNC_ACTIVE_HIGH |\
+                V4L2_MBUS_HSYNC_ACTIVE_LOW |\
+                V4L2_MBUS_VSYNC_ACTIVE_HIGH |\
+                V4L2_MBUS_VSYNC_ACTIVE_LOW |\
+                V4L2_MBUS_PCLK_SAMPLE_RISING |\
+                V4L2_MBUS_PCLK_SAMPLE_FALLING|\
+                V4L2_MBUS_DATA_ACTIVE_HIGH |\
+                V4L2_MBUS_DATA_ACTIVE_LOW|\
                 SOCAM_DATAWIDTH_8|SOCAM_DATAWIDTH_10|\
                 SOCAM_MCLK_24MHZ |SOCAM_MCLK_48MHZ)
 
 #define RK_CAM_W_MIN        48
 #define RK_CAM_H_MIN        32
-#define RK_CAM_W_MAX        3856            /* ddl@rock-chips.com : 10M Pixel */
+#define RK_CAM_W_MAX        3856                /* ddl@rock-chips.com : 10M Pixel */
 #define RK_CAM_H_MAX        2764
-#define RK_CAM_FRAME_INVAL_INIT 0
-#define RK_CAM_FRAME_INVAL_DC 0          /* ddl@rock-chips.com :  */
-#define RK30_CAM_FRAME_MEASURE  5
+#define RK_CAM_FRAME_INVAL_INIT      0
+#define RK_CAM_FRAME_INVAL_DC        0          /* ddl@rock-chips.com :  */
+#define RK30_CAM_FRAME_MEASURE       5
+
+
 extern void videobuf_dma_contig_free(struct videobuf_queue *q, struct videobuf_buffer *buf);
 extern dma_addr_t videobuf_to_dma_contig(struct videobuf_buffer *buf);
-
 /* buffer for one video frame */
 struct rk_camera_buffer
 {
@@ -337,7 +319,6 @@ struct rk_camera_buffer
     enum v4l2_mbus_pixelcode	code;
     int			inwork;
 };
-
 enum rk_camera_reg_state
 {
 	Reg_Invalidate,
@@ -353,7 +334,7 @@ struct rk_camera_reg
 	unsigned int cifFmt;
     unsigned int cifVirWidth;
     unsigned int cifScale;
-//	unsigned int VipCrm;
+/*	unsigned int VipCrm;*/
 	enum rk_camera_reg_state Inval;
 };
 struct rk_camera_work
@@ -362,31 +343,26 @@ struct rk_camera_work
 	struct rk_camera_dev *pcdev;
 	struct work_struct work;
     struct list_head queue;
-    unsigned int index; 
-    unsigned int ts;
+    unsigned int index;    
 };
-
 struct rk_camera_frmivalenum
 {
     struct v4l2_frmivalenum fival;
     struct rk_camera_frmivalenum *nxt;
 };
-
 struct rk_camera_frmivalinfo
 {
     struct soc_camera_device *icd;
     struct rk_camera_frmivalenum *fival_list;
 };
-
 struct rk_camera_zoominfo
 {
     struct semaphore sem;
     struct v4l2_crop a;
     int vir_width;
-   int vir_height;
+    int vir_height;
     int zoom_rate;
 };
-
 #if CAMERA_VIDEOBUF_ARM_ACCESS
 struct rk29_camera_vbinfo
 {
@@ -395,37 +371,25 @@ struct rk29_camera_vbinfo
     unsigned int size;
 };
 #endif
-
 struct rk_camera_timer{
 	struct rk_camera_dev *pcdev;
 	struct hrtimer timer;
     bool istarted;
 };
-struct rk_cif_clk
+struct rk_cif_clk 
 {
-    //************must modify start************/
-    struct clk *pd_cif;
-    struct clk *aclk_cif;
+    /************must modify start************/
+	struct clk *pd_cif;
+	struct clk *aclk_cif;
     struct clk *hclk_cif;
     struct clk *cif_clk_in;
     struct clk *cif_clk_out;
-    //************must modify end************/
+	/************must modify end************/
 
-    spinlock_t lock;
+   // spinlock_t lock;
     bool on;
 };
-static struct rk_cif_clk  cif_clk[2];
-struct hdr_exposure
-{
-    unsigned int set_ts;
-    unsigned int get_ts;
-    unsigned int code;
-};
-struct rk_hdr_info_s
-{
-    bool en;
-    struct hdr_exposure frame[3];
-};
+
 struct rk_cif_crop
 {
     spinlock_t lock;
@@ -433,87 +397,84 @@ struct rk_cif_crop
     struct v4l2_rect bounds;
 };
 
-#define CONFIG_CIF_STOP_SYNC 1
+struct rk_cif_irqinfo
+{
+    unsigned int irq;
+    unsigned long cifirq_idx;
+    unsigned long cifirq_normal_idx;
+    unsigned long cifirq_abnormal_idx;
+
+    unsigned long dmairq_idx;
+    spinlock_t lock;
+};
 
 struct rk_camera_dev
 {
-	struct soc_camera_host	soc_host;
-	struct device		*dev;
-	/* RK2827x is only supposed to handle one camera on its Quick Capture
-	 * interface. If anyone ever builds hardware to enable more than
-	 * one camera, they will have to modify this driver too */
-	struct soc_camera_device *icd;
+    struct soc_camera_host	soc_host;    
+    struct device		*dev;
+    /* RK2827x is only supposed to handle one camera on its Quick Capture
+     * interface. If anyone ever builds hardware to enable more than
+     * one camera, they will have to modify this driver too */
+    struct soc_camera_device *icd;
+    void __iomem *base;
+    int frame_inval;           /* ddl@rock-chips.com : The first frames is invalidate  */
 
-	//************must modify start************/
-	struct clk *pd_cif;
-	struct clk *aclk_cif;
-    struct clk *hclk_cif;
-    struct clk *cif_clk_in;
-    struct clk *cif_clk_out;
-	//************must modify end************/
-	void __iomem *base;
-	int frame_inval;           /* ddl@rock-chips.com : The first frames is invalidate  */
-	unsigned int irq;
-	unsigned int fps;
+    unsigned int fps;
     unsigned int last_fps;
     unsigned long frame_interval;
-	unsigned int pixfmt;
-	//for ipp	
-	unsigned int vipmem_phybase;
+    unsigned int pixfmt;
+    /*for ipp	*/
+    unsigned int vipmem_phybase;
     void __iomem *vipmem_virbase;
-	unsigned int vipmem_size;
-	unsigned int vipmem_bsize;
+    unsigned int vipmem_size;
+    unsigned int vipmem_bsize;
 #if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vbinfo;
-#endif  
-	unsigned int vbinfo_count;
-
-	int host_width;
-	int host_height;
-	int host_left;  //sensor output size ?
-	int host_top;
-	int hostid;
+    unsigned int vbinfo_count;
+#endif    
+    int host_width;
+    int host_height;
+    int host_left;  /*sensor output size ?*/
+    int host_top;
+    int hostid;
     int icd_width;
     int icd_height;
+
     struct rk_cif_crop cropinfo;
+    struct rk_cif_irqinfo irqinfo;
 
-	struct rk29camera_platform_data *pdata;
-	struct resource		*res;
-	struct list_head	capture;
-	struct rk_camera_zoominfo zoominfo;
+    struct rk29camera_platform_data *pdata;
+    struct resource		*res;
+    struct list_head	capture;
+    struct rk_camera_zoominfo zoominfo;
 
-	spinlock_t		lock;
+    spinlock_t		lock;
 
 	struct videobuf_buffer	*active0;
 	struct videobuf_buffer	*active1;
-	struct rk_camera_reg reginfo_suspend;
-	struct workqueue_struct *camera_wq;
-	struct rk_camera_work *camera_work;
+	int active_buf;
+    struct rk_camera_reg reginfo_suspend;
+    struct workqueue_struct *camera_wq;
+    struct rk_camera_work *camera_work;
     struct list_head camera_work_queue;
     spinlock_t camera_work_lock;
-	unsigned int camera_work_count;
-	struct rk_camera_timer fps_timer;
-	struct rk_camera_work camera_reinit_work;
-	int icd_init;
-	rk29_camera_sensor_cb_s icd_cb;
-	struct rk_camera_frmivalinfo icd_frmival[2];
+    unsigned int camera_work_count;
+    struct rk_camera_timer fps_timer;
+    struct rk_camera_work camera_reinit_work;
+    int icd_init;
+    rk29_camera_sensor_cb_s icd_cb;
+    struct rk_camera_frmivalinfo icd_frmival[2];
     bool timer_get_fps;
     unsigned int reinit_times; 
     struct videobuf_queue *video_vq;
-    volatile bool stop_cif;
-#if CONFIG_CIF_STOP_SYNC
-	wait_queue_head_t cif_stop_done;
-	volatile  bool cif_stopped;
-#endif
+    atomic_t stop_cif;
     struct timeval first_tv;
-
-    struct rk_hdr_info_s  hdr_info;
-//	spinlock_t		irq_lock;
+    
+    int chip_id;
 };
 
 static const struct v4l2_queryctrl rk_camera_controls[] =
 {
-	#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
     {
         .id		= V4L2_CID_ZOOM_ABSOLUTE,
         .type		= V4L2_CTRL_TYPE_INTEGER,
@@ -522,29 +483,84 @@ static const struct v4l2_queryctrl rk_camera_controls[] =
         .maximum	= 300,
         .step		= 5,
         .default_value = 100,
-    },
-    #endif
-
-    {
-        .id		= V4L2_CID_HDR,
-        .type		= V4L2_CTRL_TYPE_BOOLEAN,
-        .name		= "HDR",
-        .minimum	= 0,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 0,
     }
-
-    
 };
 
+static struct rk_cif_clk  cif_clk[2];
+
 static DEFINE_MUTEX(camera_lock);
 static const char *rk_cam_driver_description = "RK_Camera";
 
 static int rk_camera_s_stream(struct soc_camera_device *icd, int enable);
 static void rk_camera_capture_process(struct work_struct *work);
 
-// #define OPTIMIZE_MEMORY_USE
+static void rk_camera_diffchips(const char *rockchip_name)
+{
+	if(strstr(rockchip_name,"3128")||strstr(rockchip_name,"3126"))
+	{	
+		CRU_PCLK_REG30 = 0xbc;
+		ENANABLE_INVERT_PCLK_CIF0 = ((0x1<<23)|(0x1<<7));
+		DISABLE_INVERT_PCLK_CIF0  = ((0x1<<23)|(0x0<<7));
+		ENANABLE_INVERT_PCLK_CIF1 = ENANABLE_INVERT_PCLK_CIF0;
+		DISABLE_INVERT_PCLK_CIF1  = DISABLE_INVERT_PCLK_CIF0;
+		
+		CRU_CLK_OUT = 0xdc;
+		CRU_CLKSEL29_CON = 0xb8;
+
+		CHIP_NAME = 3126;
+	}
+}
+static inline void rk_cru_set_soft_reset(u32 idx, bool on , u32 RK_CRU_SOFTRST_CON)
+{
+	void __iomem *reg = RK_CRU_VIRT + RK_CRU_SOFTRST_CON;
+	u32 val = on ? 0x10001U << 14 : 0x10000U << 14;
+	writel_relaxed(val, reg);
+	dsb();
+}
+
+static void rk_camera_cif_reset(struct rk_camera_dev *pcdev, int only_rst)
+{
+    int ctrl_reg,inten_reg,crop_reg,set_size_reg,for_reg,vir_line_width_reg,scl_reg,y_reg,uv_reg;
+	u32 RK_CRU_SOFTRST_CON = 0;
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	if(strstr(pcdev->pdata->rockchip_name,"3128")||strstr(pcdev->pdata->rockchip_name,"3126"))
+		RK_CRU_SOFTRST_CON = RK312X_CRU_SOFTRSTS_CON(6);
+	
+	if (only_rst == true) {
+        rk_cru_set_soft_reset(0, true ,RK_CRU_SOFTRST_CON);
+        udelay(5);
+        rk_cru_set_soft_reset(0, false ,RK_CRU_SOFTRST_CON);
+    } else {
+        ctrl_reg = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
+        if (ctrl_reg & ENABLE_CAPTURE) {
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, ctrl_reg&~ENABLE_CAPTURE);
+        }
+    	crop_reg = read_cif_reg(pcdev->base,CIF_CIF_CROP);
+    	set_size_reg = read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE);
+    	inten_reg = read_cif_reg(pcdev->base,CIF_CIF_INTEN);
+    	for_reg = read_cif_reg(pcdev->base,CIF_CIF_FOR);
+    	vir_line_width_reg = read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH);
+    	scl_reg = read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL);
+    	y_reg = read_cif_reg(pcdev->base, CIF_CIF_FRM0_ADDR_Y);
+    	uv_reg = read_cif_reg(pcdev->base, CIF_CIF_FRM0_ADDR_UV);
+    	
+    	rk_cru_set_soft_reset(0, true ,RK_CRU_SOFTRST_CON);
+    	udelay(5);
+    	rk_cru_set_soft_reset(0, false ,RK_CRU_SOFTRST_CON); 
+
+        write_cif_reg(pcdev->base,CIF_CIF_CTRL, ctrl_reg&~ENABLE_CAPTURE);
+	    write_cif_reg(pcdev->base,CIF_CIF_INTEN, inten_reg);
+	    write_cif_reg(pcdev->base,CIF_CIF_CROP, crop_reg);
+	    write_cif_reg(pcdev->base,CIF_CIF_SET_SIZE, set_size_reg);
+	    write_cif_reg(pcdev->base,CIF_CIF_FOR, for_reg);
+	    write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH,vir_line_width_reg);
+	    write_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL,scl_reg);
+	    write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y,y_reg);      /*ddl@rock-chips.com v0.3.0x13 */
+	    write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV,uv_reg);
+    }
+    return;
+}
+
 
 /*
  *  Videobuf operations
@@ -553,7 +569,7 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
                                unsigned int *size)
 {
     struct soc_camera_device *icd = vq->priv_data;
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
 	unsigned int i;
     struct rk_camera_work *wk;
@@ -563,6 +579,9 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 	int bytes_per_line_host;
 	fmt.packing = SOC_MBUS_PACKING_1_5X8;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 		bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
 						icd->current_fmt->host_fmt);
 	if(icd->current_fmt->host_fmt->fourcc ==  V4L2_PIX_FMT_RGB565)
@@ -573,6 +592,7 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 	else
 		bytes_per_line_host = soc_mbus_bytes_per_line(pcdev->host_width,
 					   icd->current_fmt->host_fmt);
+   /* dev_dbg(&icd->dev, "count=%d, size=%d\n", *count, *size);*/ /*yzm*/
 
 	if (bytes_per_line_host < 0)
 		return bytes_per_line_host;
@@ -582,17 +602,14 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 	pcdev->vipmem_bsize = PAGE_ALIGN(bytes_per_line_host * pcdev->host_height);
 
 	if (CAM_WORKQUEUE_IS_EN()) {
-        #ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF
-        if (CAM_IPPWORK_IS_EN()) 
-        #endif
-        {
+		
+        if (CAM_IPPWORK_IS_EN())  {
             BUG_ON(pcdev->vipmem_size<pcdev->vipmem_bsize);
-        #ifndef OPTIMIZE_MEMORY_USE
     		if (*count > pcdev->vipmem_size/pcdev->vipmem_bsize) {    /* Buffers must be limited, when this resolution is genered by IPP */
     			*count = pcdev->vipmem_size/pcdev->vipmem_bsize;
     		}
-		#endif
         }
+        
 		if ((pcdev->camera_work_count != *count) && pcdev->camera_work) {
 			kfree(pcdev->camera_work);
 			pcdev->camera_work = NULL;
@@ -602,7 +619,7 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 		if (pcdev->camera_work == NULL) {
 			pcdev->camera_work = wk = kzalloc(sizeof(struct rk_camera_work)*(*count), GFP_KERNEL);
 			if (pcdev->camera_work == NULL) {
-				RK30_CAM_DEBUG_TRACE("\n %s kmalloc fail\n", __FUNCTION__);
+				RKCAMERA_TR("kmalloc failed\n");
 				BUG();
 			}
             INIT_LIST_HEAD(&pcdev->camera_work_queue);
@@ -624,7 +641,7 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
         if (pcdev->vbinfo == NULL) {
             pcdev->vbinfo = kzalloc(sizeof(struct rk29_camera_vbinfo)*(*count), GFP_KERNEL);
             if (pcdev->vbinfo == NULL) {
-				RK30_CAM_DEBUG_TRACE("\n %s vbinfo kmalloc fail\n", __FUNCTION__);
+				RKCAMERA_TR("vbinfo kmalloc fail\n");
 				BUG();
 			}
             memset(pcdev->vbinfo,0,sizeof(struct rk29_camera_vbinfo)*(*count));
@@ -632,10 +649,8 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
         }
 #endif        
 	}
-	
-	pcdev->vbinfo_count = *count;
     pcdev->video_vq = vq;
-    RK30_CAM_DEBUG_TRACE("%s..%d.. videobuf size:%d, vipmem_buf size:%d, count:%d \n",__FUNCTION__,__LINE__, *size,pcdev->vipmem_size, *count);
+    RKCAMERA_DG1("videobuf size:%d, vipmem_buf size:%d, count:%d \n",*size,pcdev->vipmem_size, *count);
 
     return 0;
 }
@@ -643,7 +658,10 @@ static void rk_videobuf_free(struct videobuf_queue *vq, struct rk_camera_buffer
 {
     struct soc_camera_device *icd = vq->priv_data;
 
-    dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
+    dev_dbg(icd->control, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,/*yzm*/
             &buf->vb, buf->vb.baddr, buf->vb.bsize);
 
 	/* ddl@rock-chips.com: buf_release called soc_camera_streamoff and soc_camera_close*/
@@ -656,9 +674,9 @@ static void rk_videobuf_free(struct videobuf_queue *vq, struct rk_camera_buffer
 	 * This waits until this buffer is out of danger, i.e., until it is no
 	 * longer in STATE_QUEUED or STATE_ACTIVE
 	 */
-	//videobuf_waiton(vq, &buf->vb, 0, 0);
+	videobuf_waiton(vq, &buf->vb, 0, 0);
     videobuf_dma_contig_free(vq, &buf->vb);
-    dev_dbg(&icd->dev, "%s freed\n", __func__);
+    /*dev_dbg(&icd->dev, "%s freed\n", __func__);*/ /*yzm*/
     buf->vb.state = VIDEOBUF_NEEDS_INIT;
 	return;
 }
@@ -669,13 +687,16 @@ static int rk_videobuf_prepare(struct videobuf_queue *vq, struct videobuf_buffer
     int ret;
     int bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
 						icd->current_fmt->host_fmt);
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	
 	if ((bytes_per_line < 0) || (vb->boff == 0))
 		return -EINVAL;
 
     buf = container_of(vb, struct rk_camera_buffer, vb);
 
-    dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
-            vb, vb->baddr, vb->bsize);
+    /*dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,*/ /*yzm*/
+      /*      vb, vb->baddr, vb->bsize);*/ /*yzm*/
     
     /* Added list head initialization on alloc */
     WARN_ON(!list_empty(&vb->queue));    
@@ -683,9 +704,9 @@ static int rk_videobuf_prepare(struct videobuf_queue *vq, struct videobuf_buffer
     BUG_ON(NULL == icd->current_fmt);
 
     if (buf->code    != icd->current_fmt->code ||
-        vb->width   != icd->user_width ||
-        vb->height  != icd->user_height ||
-        vb->field   != field) {
+            vb->width   != icd->user_width ||
+            vb->height  != icd->user_height ||
+             vb->field   != field) {
         buf->code    = icd->current_fmt->code;
         vb->width   = icd->user_width;
         vb->height  = icd->user_height;
@@ -714,77 +735,46 @@ static int rk_videobuf_prepare(struct videobuf_queue *vq, struct videobuf_buffer
     return ret;
 }
 
-#if 0
-static void rk_camera_store_register(struct rk_camera_dev *pcdev)
-{
-#if defined(CONFIG_ARCH_RK3188)
-	pcdev->reginfo_suspend.cifCtrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
-	pcdev->reginfo_suspend.cifCrop = read_cif_reg(pcdev->base,CIF_CIF_CROP);
-	pcdev->reginfo_suspend.cifFs = read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE);
-	pcdev->reginfo_suspend.cifIntEn = read_cif_reg(pcdev->base,CIF_CIF_INTEN);
-	pcdev->reginfo_suspend.cifFmt= read_cif_reg(pcdev->base,CIF_CIF_FOR);
-	pcdev->reginfo_suspend.cifVirWidth = read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH);
-	pcdev->reginfo_suspend.cifScale= read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL);
-	
-	cru_set_soft_reset(SOFT_RST_CIF0, true);
-	udelay(3);
-	cru_set_soft_reset(SOFT_RST_CIF0, false);
-	
-#endif
-}
-static void rk_camera_restore_register(struct rk_camera_dev *pcdev)
-{
-#if defined(CONFIG_ARCH_RK3188)
-	write_cif_reg(pcdev->base,CIF_CIF_CTRL, pcdev->reginfo_suspend.cifCtrl&~ENABLE_CAPTURE);
-	write_cif_reg(pcdev->base,CIF_CIF_INTEN, pcdev->reginfo_suspend.cifIntEn);
-	write_cif_reg(pcdev->base,CIF_CIF_CROP, pcdev->reginfo_suspend.cifCrop);
-	write_cif_reg(pcdev->base,CIF_CIF_SET_SIZE, pcdev->reginfo_suspend.cifFs);
-	write_cif_reg(pcdev->base,CIF_CIF_FOR, pcdev->reginfo_suspend.cifFmt);
-	write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH,pcdev->reginfo_suspend.cifVirWidth);
-	write_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL, pcdev->reginfo_suspend.cifScale);
-#endif
-}
-#endif
-
 static inline void rk_videobuf_capture(struct videobuf_buffer *vb,struct rk_camera_dev *rk_pcdev, int fmt_ready)
 {
 	unsigned int y_addr,uv_addr;
 	struct rk_camera_dev *pcdev = rk_pcdev;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
     if (vb) {
-		if (CAM_WORKQUEUE_IS_EN()) {
-		    #ifdef OPTIMIZE_MEMORY_USE
-			y_addr = vb->boff;
-			uv_addr = y_addr + vb->width * vb->height;
-		    #else
+		if (CAM_WORKQUEUE_IS_EN() & CAM_IPPWORK_IS_EN()) {
 			y_addr = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
 			uv_addr = y_addr + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;
 			if (y_addr > (pcdev->vipmem_phybase + pcdev->vipmem_size - pcdev->vipmem_bsize)) {
-				RK30_CAM_DEBUG_TRACE("vipmem for IPP is overflow! %dx%d -> %dx%d vb_index:%d\n",pcdev->host_width,pcdev->host_height,
+				RKCAMERA_TR("vipmem for IPP is overflow! %dx%d -> %dx%d vb_index:%d\n",pcdev->host_width,pcdev->host_height,
 					          pcdev->icd->user_width,pcdev->icd->user_height, vb->i);
 				BUG();
 			}
-			#endif
 		} else {
 			y_addr = vb->boff;
 			uv_addr = y_addr + vb->width * vb->height;
 		}
-        
-		switch(fmt_ready)
-		{
-			case 0:
-				write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y, y_addr);
-        		write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV, uv_addr);
-				break;
-			case 1:
-				write_cif_reg(pcdev->base,CIF_CIF_FRM1_ADDR_Y, y_addr);
-        		write_cif_reg(pcdev->base,CIF_CIF_FRM1_ADDR_UV, uv_addr);
-				break;
-			default:
-				RK30_CAM_DEBUG_TRACE("%s(%d): fmt_ready(%d) is wrong!\n", __FUNCTION__, __LINE__,fmt_ready);
-				break;
-		}
-      
+#if defined(CONFIG_ARCH_RK3188)
+		rk_camera_cif_reset(pcdev,false);
+#endif
+
+	switch(fmt_ready)
+	{
+		case 0:
+			write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y, y_addr);
+			write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV, uv_addr);
+			break;
+		case 1:
+			write_cif_reg(pcdev->base,CIF_CIF_FRM1_ADDR_Y, y_addr);
+			write_cif_reg(pcdev->base,CIF_CIF_FRM1_ADDR_UV, uv_addr);
+			break;
+		default:
+			printk("%s(%d): fmt_ready(%d) is wrong!\n", __FUNCTION__, __LINE__,fmt_ready);
+			break;
+	}
+
     }
 }
 /* Locking: Caller holds q->irqlock */
@@ -792,15 +782,14 @@ static void rk_videobuf_queue(struct videobuf_queue *vq,
                                 struct videobuf_buffer *vb)
 {
     struct soc_camera_device *icd = vq->priv_data;
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
 #if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info;
 #endif
 
-    dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
-            vb, vb->baddr, vb->bsize);
-   // spin_lock_irqsave(&pcdev->irq_lock, flags);
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 
     vb->state = VIDEOBUF_QUEUED;
 	if (list_empty(&pcdev->capture)) {
@@ -831,56 +820,40 @@ static void rk_videobuf_queue(struct videobuf_queue *vq,
                 vb_info->size = vb->bsize;
                 vb_info->phy_addr = vb->boff;
             } else {
-                RK30_CAM_DEBUG_TRACE("%s..%d:ioremap videobuf %d failed\n",__FUNCTION__,__LINE__, vb->i);
+                RKCAMERA_TR("ioremap videobuf %d failed\n",vb->i);
             }
         }
     }
-#endif
-    if((((read_cif_reg(pcdev->base,CIF_CIF_CTRL)) & ENABLE_CAPTURE) == 0)){
-        if (!pcdev->active0) {
-            pcdev->active0 = vb;
-            rk_videobuf_capture(vb,pcdev,0);
-    		list_del_init(&(vb->queue));
-        } else if (!pcdev->active1) {
-            pcdev->active1 = vb;
-            rk_videobuf_capture(vb,pcdev,1);
-    		list_del_init(&(vb->queue));
-        }
-    }
-	//spin_unlock_irqrestore(&pcdev->irq_lock, flags);
-}
-static int rk_pixfmt2ippfmt(unsigned int pixfmt, int *ippfmt)
-{
-	switch (pixfmt)
-	{
-		case V4L2_PIX_FMT_NV16:
-		case V4L2_PIX_FMT_NV61:
-		{
-			*ippfmt = IPP_Y_CBCR_H2V1;
-			break;
-		}
-		case V4L2_PIX_FMT_NV12:
-		case V4L2_PIX_FMT_NV21:
-		{
-			*ippfmt = IPP_Y_CBCR_H2V2;
-			break;
-		}
-		default:
-			goto rk_pixfmt2ippfmt_err;
-	}
+#endif    
 
-	return 0;
-rk_pixfmt2ippfmt_err:
-	return -1;
+	if (!pcdev->active0) {
+		pcdev->active0 = vb;
+		rk_videobuf_capture(vb,pcdev,0);		
+        /*if (atomic_read(&pcdev->stop_cif) == false) {           //ddl@rock-chips.com v0.3.0x13
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL) | ENABLE_CAPTURE));
+        }  */     
+		list_del_init(&(vb->queue));
+	} else if (!pcdev->active1) {
+		pcdev->active1 = vb;
+		rk_videobuf_capture(vb,pcdev,1);
+        /*if (atomic_read(&pcdev->stop_cif) == false) {           //ddl@rock-chips.com v0.3.0x13
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL) | ENABLE_CAPTURE));
+        } */		
+		list_del_init(&(vb->queue));
+	}
+	
 }
 
-#if 0
+#if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_RGA)
 static int rk_pixfmt2rgafmt(unsigned int pixfmt, int *ippfmt)
 {
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
 	switch (pixfmt)
 	{
 		case V4L2_PIX_FMT_YUV420:
-		case V4L2_PIX_FMT_UYVY: // yuv 422, but sensor has defined this format(in fact ,should be defined yuv 420), treat this as yuv 420.
+		case V4L2_PIX_FMT_UYVY: /* yuv 422, but sensor has defined this format(in fact ,should be defined yuv 420), treat this as yuv 420.*/
 		case V4L2_PIX_FMT_YUYV: 
 			{
 				*ippfmt = RK_FORMAT_YCbCr_420_SP;
@@ -912,7 +885,6 @@ static int rk_pixfmt2rgafmt(unsigned int pixfmt, int *ippfmt)
 	return -1;
 }
 #endif
-
 #if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_PP)
 static int rk_camera_scale_crop_pp(struct work_struct *work){
 	struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);
@@ -922,33 +894,8 @@ static int rk_camera_scale_crop_pp(struct work_struct *work){
 	unsigned long int flags;
 	int scale_times,w,h;
 	int src_y_offset;
-	PP_OP_HANDLE hnd;
-	PP_OPERATION init;
 	int ret = 0;
-	vipdata_base = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
-	
-	memset(&init, 0, sizeof(init));
-	init.srcAddr 	= vipdata_base;
-	init.srcFormat	= PP_IN_FORMAT_YUV420SEMI;
-	init.srcWidth	= init.srcHStride = pcdev->zoominfo.vir_width;
-	init.srcHeight	= init.srcVStride = pcdev->zoominfo.vir_height;
-	
-	init.dstAddr 	= vb->boff;
-	init.dstFormat	= PP_OUT_FORMAT_YUV420INTERLAVE;
-	init.dstWidth	= init.dstHStride = pcdev->icd->user_width;
-	init.dstHeight	= init.dstVStride = pcdev->icd->user_height;
-
-	printk("srcWidth = %d,srcHeight = %d,dstWidth = %d,dstHeight = %d\n",init.srcWidth,init.srcHeight,init.dstWidth,init.dstHeight);
-	#if 0
-	ret = ppOpInit(&hnd, &init);
-	if (!ret) {
-		ppOpPerform(hnd);
-		ppOpSync(hnd);
-		ppOpRelease(hnd);
-	} else {
-		printk("can not create ppOp handle\n");
-	}
-	#endif
+
 	return ret;
 }
 #endif
@@ -969,414 +916,43 @@ static int rk_camera_scale_crop_rga(struct work_struct *work){
 	int rga_times = 3;
 	const struct soc_mbus_pixelfmt *fmt;
 	int ret = 0;
-	fmt = soc_mbus_get_fmtdesc(pcdev->icd->current_fmt->code);
-	vipdata_base = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
-	if((pcdev->icd->current_fmt->host_fmt->fourcc != V4L2_PIX_FMT_RGB565)
-		&& (pcdev->icd->current_fmt->host_fmt->fourcc != V4L2_PIX_FMT_RGB24)){
-		RK30_CAM_DEBUG_TRACE("RGA not support this format !\n");
-		goto do_ipp_err;
-		}
-	if ((pcdev->icd->user_width > 0x800) || (pcdev->icd->user_height > 0x800)) {
-		scale_times = MAX((pcdev->icd->user_width/0x800),(pcdev->icd->user_height/0x800));		  
-		scale_times++;
-	} else {
-		scale_times = 1;
-	}
-	session.pid = current->pid;
-	INIT_LIST_HEAD(&session.waiting);
-	INIT_LIST_HEAD(&session.running);
-	INIT_LIST_HEAD(&session.list_session);
-	init_waitqueue_head(&session.wait);
-	/* no need to protect */
-	list_add_tail(&session.list_session, &rga_service.session);
-	atomic_set(&session.task_running, 0);
-	atomic_set(&session.num_done, 0);
-	
-	memset(&req,0,sizeof(struct rga_req));
-	req.src.act_w = pcdev->zoominfo.a.c.width/scale_times;
-	req.src.act_h = pcdev->zoominfo.a.c.height/scale_times;
-
-	req.src.vir_w = pcdev->zoominfo.vir_width;
-	req.src.vir_h =pcdev->zoominfo.vir_height;
-	req.src.yrgb_addr = vipdata_base;
-	req.src.uv_addr =vipdata_base + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;;
-	req.src.v_addr = req.src.uv_addr ;
-	req.src.format =fmt->fourcc;
-	rk_pixfmt2rgafmt(fmt->fourcc,&req.src.format);
-	req.src.x_offset = pcdev->zoominfo.a.c.left;
-	req.src.y_offset = pcdev->zoominfo.a.c.top;
-
-	req.dst.act_w = pcdev->icd->user_width/scale_times;
-	req.dst.act_h = pcdev->icd->user_height/scale_times;
-
-	req.dst.vir_w = pcdev->icd->user_width;
-	req.dst.vir_h = pcdev->icd->user_height;
-	req.dst.x_offset = 0;
-	req.dst.y_offset = 0;
-	req.dst.yrgb_addr = vb->boff;
-	rk_pixfmt2rgafmt(pcdev->icd->current_fmt->host_fmt->fourcc,&req.dst.format);
-	req.clip.xmin = 0;
-	req.clip.xmax = req.dst.vir_w-1;
-	req.clip.ymin = 0;
-	req.clip.ymax = req.dst.vir_h -1;
-
-	req.rotate_mode = 1;
-	req.scale_mode = 2;
-
-	req.sina = 0;
-	req.cosa = 65536;
-	req.mmu_info.mmu_en = 0;
-
-	for (h=0; h<scale_times; h++) {
-		for (w=0; w<scale_times; w++) {
-			rga_times = 3;
-	
-			req.src.yrgb_addr = vipdata_base;
-			req.src.uv_addr =vipdata_base + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;;
-			req.src.x_offset = pcdev->zoominfo.a.c.left+w*pcdev->zoominfo.a.c.width/scale_times;
-			req.src.y_offset = pcdev->zoominfo.a.c.top+h*pcdev->zoominfo.a.c.height/scale_times;
-			req.dst.x_offset =  pcdev->icd->user_width*w/scale_times;
-			req.dst.y_offset = pcdev->icd->user_height*h/scale_times;
-			req.dst.yrgb_addr = vb->boff ;
-		//	RK30_CAM_DEBUG_TRACE("src.act_w = %d , src.act_h  = %d! vir_w = %d , vir_h = %d,off_x = %d,off_y = %d\n",req.src.act_w,req.src.act_h ,req.src.vir_w,req.src.vir_h,req.src.x_offset,req.src.y_offset);
-		//	RK30_CAM_DEBUG_TRACE("dst.act_w = %d , dst.act_h  = %d! vir_w = %d , vir_h = %d,off_x = %d,off_y = %d\n",req.dst.act_w,req.dst.act_h ,req.dst.vir_w,req.dst.vir_h,req.dst.x_offset,req.dst.y_offset);
-		//	RK30_CAM_DEBUG_TRACE("req.src.yrgb_addr = 0x%x,req.dst.yrgb_addr = 0x%x\n",req.src.yrgb_addr,req.dst.yrgb_addr);
-
-			while(rga_times-- > 0) {
-				if (rga_blit_sync(&session, &req)){
-					RK30_CAM_DEBUG_TRACE("rga do erro,do again,rga_times = %d!\n",rga_times);
-				 } else {
-					break;
-				 }
-			}
-		
-			if (rga_times <= 0) {
-				spin_lock_irqsave(&pcdev->lock, flags);
-				vb->state = VIDEOBUF_NEEDS_INIT;
-				spin_unlock_irqrestore(&pcdev->lock, flags);
-				mutex_lock(&rga_service.lock);
-				list_del(&session.list_session);
-				rga_service_session_clear(&session);
-				mutex_unlock(&rga_service.lock);
-				goto session_done;
-			}
-			}
-	}
-	session_done:
-	mutex_lock(&rga_service.lock);
-	list_del(&session.list_session);
-	rga_service_session_clear(&session);
-	mutex_unlock(&rga_service.lock);
 
-	do_ipp_err:
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
 
 		return ret;
 	
 }
 
 #endif
-#if ((defined(CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON)) && (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_IPP))
+#if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_IPP)
 
 static int rk_camera_scale_crop_ipp(struct work_struct *work)
 {
-	struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);
-	struct videobuf_buffer *vb = camera_work->vb;
-	struct rk_camera_dev *pcdev = camera_work->pcdev;
-	int vipdata_base;
-	unsigned long int flags;
-
-	struct rk29_ipp_req ipp_req;
-	int src_y_offset,src_uv_offset,dst_y_offset,dst_uv_offset,src_y_size,dst_y_size;
-	int scale_times,w,h;
-	int ret = 0;
-    /*
-    *ddl@rock-chips.com: 
-    * IPP Dest image resolution is 2047x1088, so scale operation break up some times
-    */
-    if ((pcdev->icd->user_width > 0x7f0) || (pcdev->icd->user_height > 0x430)) {
-        scale_times = MAX((pcdev->icd->user_width/0x7f0),(pcdev->icd->user_height/0x430));        
-        scale_times++;
-    } else {
-        scale_times = 1;
-    }
-    memset(&ipp_req, 0, sizeof(struct rk29_ipp_req));
-#ifdef OPTIMIZE_MEMORY_USE
-    //need copy to ipp buffer?
-    if((pcdev->zoominfo.a.c.width != pcdev->zoominfo.vir_width)
-        ||(pcdev->zoominfo.a.c.height != pcdev->zoominfo.vir_height)){
-            if((pcdev->zoominfo.vir_width != pcdev->icd->user_width) || (pcdev->zoominfo.vir_height != pcdev->icd->user_height)){
-                printk("OPTIMIZE_MEMORY_USE erro: src size not equal to dst size\n");
-                goto do_ipp_err;
-            }
-            ipp_req.timeout = 3000;
-            ipp_req.flag = IPP_ROT_0; 
-            ipp_req.store_clip_mode =1;
-            ipp_req.src0.w = pcdev->zoominfo.vir_width/scale_times;
-            ipp_req.src0.h = pcdev->zoominfo.vir_height/scale_times;
-            ipp_req.dst0.w = pcdev->icd->user_width/scale_times;
-            ipp_req.dst0.h = pcdev->icd->user_height/scale_times;
-            ipp_req.src_vir_w =  pcdev->zoominfo.vir_width; 
-            ipp_req.dst_vir_w = pcdev->icd->user_width; 
-            rk_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.src0.fmt);
-            rk_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.dst0.fmt);
-            vipdata_base = pcdev->vipmem_phybase;
-            src_y_size = pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;  //vipmem
-            dst_y_size = pcdev->icd->user_width*pcdev->icd->user_height;
-            for (h=0; h<scale_times; h++) {
-                for (w=0; w<scale_times; w++) {
-                    src_y_offset = (h*pcdev->zoominfo.vir_height/scale_times)* pcdev->zoominfo.vir_width 
-                                +  w*pcdev->zoominfo.vir_width/scale_times;
-        		    src_uv_offset = (h*pcdev->zoominfo.vir_height/scale_times)* pcdev->zoominfo.vir_width/2
-                                + w*pcdev->zoominfo.vir_width/scale_times;
-
-                    dst_y_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times + pcdev->icd->user_width*w/scale_times;
-                    dst_uv_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times/2 + pcdev->icd->user_width*w/scale_times;
-            		ipp_req.src0.YrgbMst = vb->boff + src_y_offset;
-            		ipp_req.src0.CbrMst = vb->boff + src_y_size + src_uv_offset;
-            		ipp_req.dst0.YrgbMst = vipdata_base + dst_y_offset;
-            		ipp_req.dst0.CbrMst = vipdata_base + dst_y_size + dst_uv_offset;
-                    if (ipp_blit_sync(&ipp_req)){
-                        RK30_CAM_DEBUG_TRACE("ipp do erro\n");
-                     }
-                 }
-             }
-            memset(&ipp_req, 0, sizeof(struct rk29_ipp_req));
-        }
-#endif
-
-    ipp_req.timeout = 3000;
-    ipp_req.flag = IPP_ROT_0; 
-    ipp_req.store_clip_mode =1;
-    ipp_req.src0.w = pcdev->zoominfo.a.c.width/scale_times;
-    ipp_req.src0.h = pcdev->zoominfo.a.c.height/scale_times;
-    ipp_req.src_vir_w = pcdev->zoominfo.vir_width; 
-    rk_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.src0.fmt);
-    ipp_req.dst0.w = pcdev->icd->user_width/scale_times;
-    ipp_req.dst0.h = pcdev->icd->user_height/scale_times;
-    ipp_req.dst_vir_w = pcdev->icd->user_width;        
-    rk_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.dst0.fmt);
-#ifdef OPTIMIZE_MEMORY_USE
-    if((pcdev->zoominfo.a.c.width != pcdev->zoominfo.vir_width)
-        ||(pcdev->zoominfo.a.c.height != pcdev->zoominfo.vir_height)){
-        vipdata_base = pcdev->vipmem_phybase;
-    }else
-        vipdata_base = vb->boff;
-
-#else
-    vipdata_base = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
-#endif
-    src_y_size = pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;  //vipmem
-    dst_y_size = pcdev->icd->user_width*pcdev->icd->user_height;
-    for (h=0; h<scale_times; h++) {
-        for (w=0; w<scale_times; w++) {
-            int ipp_times = 3;
-            src_y_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->zoominfo.vir_width 
-                        + pcdev->zoominfo.a.c.left + w*pcdev->zoominfo.a.c.width/scale_times;
-		    src_uv_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->zoominfo.vir_width/2
-                        + pcdev->zoominfo.a.c.left + w*pcdev->zoominfo.a.c.width/scale_times;
-
-            dst_y_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times + pcdev->icd->user_width*w/scale_times;
-            dst_uv_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times/2 + pcdev->icd->user_width*w/scale_times;
-
-    		ipp_req.src0.YrgbMst = vipdata_base + src_y_offset;
-    		ipp_req.src0.CbrMst = vipdata_base + src_y_size + src_uv_offset;
-    		ipp_req.dst0.YrgbMst = vb->boff + dst_y_offset;
-    		ipp_req.dst0.CbrMst = vb->boff + dst_y_size + dst_uv_offset;
-    		while(ipp_times-- > 0) {
-                if (ipp_blit_sync(&ipp_req)){
-                    RK30_CAM_DEBUG_TRACE("ipp do erro,do again,ipp_times = %d!\n",ipp_times);
-                 } else {
-                    break;
-                 }
-            }
-            
-            if (ipp_times <= 0) {
-    			spin_lock_irqsave(&pcdev->lock, flags);
-    			vb->state = VIDEOBUF_NEEDS_INIT;
-    			spin_unlock_irqrestore(&pcdev->lock, flags);
-    			RK30_CAM_DEBUG_TRACE("Capture image(vb->i:0x%x) which IPP operated is error:\n",vb->i);
-    			RK30_CAM_DEBUG_TRACE("widx:%d hidx:%d ",w,h);
-    			RK30_CAM_DEBUG_TRACE("%dx%d@(%d,%d)->%dx%d\n",pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height,pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,pcdev->icd->user_width,pcdev->icd->user_height);
-    			RK30_CAM_DEBUG_TRACE("ipp_req.src0.YrgbMst:0x%x ipp_req.src0.CbrMst:0x%x \n", ipp_req.src0.YrgbMst,ipp_req.src0.CbrMst);
-    			RK30_CAM_DEBUG_TRACE("ipp_req.src0.w:0x%x ipp_req.src0.h:0x%x \n",ipp_req.src0.w,ipp_req.src0.h);
-    			RK30_CAM_DEBUG_TRACE("ipp_req.src0.fmt:0x%x\n",ipp_req.src0.fmt);
-    			RK30_CAM_DEBUG_TRACE("ipp_req.dst0.YrgbMst:0x%x ipp_req.dst0.CbrMst:0x%x \n",ipp_req.dst0.YrgbMst,ipp_req.dst0.CbrMst);
-    			RK30_CAM_DEBUG_TRACE("ipp_req.dst0.w:0x%x ipp_req.dst0.h:0x%x \n",ipp_req.dst0.w ,ipp_req.dst0.h);
-    			RK30_CAM_DEBUG_TRACE("ipp_req.dst0.fmt:0x%x\n",ipp_req.dst0.fmt);
-    			RK30_CAM_DEBUG_TRACE("ipp_req.src_vir_w:0x%x ipp_req.dst_vir_w :0x%x\n",ipp_req.src_vir_w ,ipp_req.dst_vir_w);
-    			RK30_CAM_DEBUG_TRACE("ipp_req.timeout:0x%x ipp_req.flag :0x%x\n",ipp_req.timeout,ipp_req.flag);
-                
-    			goto do_ipp_err;
-    		}
-        }
-    }
-
-do_ipp_err:
-	return ret;    
-}
-#endif
-#if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_ARM)
-static int rk_camera_scale_crop_arm(struct work_struct *work)
-{
-    struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);	
-    struct videobuf_buffer *vb = camera_work->vb;	
-    struct rk_camera_dev *pcdev = camera_work->pcdev;	
-    struct rk29_camera_vbinfo *vb_info;        
-    unsigned char *psY,*pdY,*psUV,*pdUV; 
-    unsigned char *src,*dst;
-    unsigned long src_phy,dst_phy;
-    int srcW,srcH,cropW,cropH,dstW,dstH;
-    long zoomindstxIntInv,zoomindstyIntInv;
-    long x,y;
-    long yCoeff00,yCoeff01,xCoeff00,xCoeff01;
-    long sX,sY;
-    long r0,r1,a,b,c,d;
-    int ret = 0;
-
-    src_phy = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;    
-    src = psY = (unsigned char*)(pcdev->vipmem_virbase + vb->i*pcdev->vipmem_bsize);
-    psUV = psY + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;
-	
-    srcW = pcdev->zoominfo.vir_width;
-    srcH = pcdev->zoominfo.vir_height;
-    cropW = pcdev->zoominfo.a.c.width;
-    cropH = pcdev->zoominfo.a.c.height;
-	
-    psY = psY + pcdev->zoominfo.a.c.top*pcdev->zoominfo.vir_width+pcdev->zoominfo.a.c.left;
-    psUV = psUV + pcdev->zoominfo.a.c.top*pcdev->zoominfo.vir_width/2+pcdev->zoominfo.a.c.left; 
-    
-    vb_info = pcdev->vbinfo+vb->i; 
-    dst_phy = vb_info->phy_addr;
-    dst = pdY = (unsigned char*)vb_info->vir_addr; 
-    pdUV = pdY + pcdev->icd->user_width*pcdev->icd->user_height;
-    dstW = pcdev->icd->user_width;
-    dstH = pcdev->icd->user_height;
-
-    zoomindstxIntInv = ((unsigned long)(cropW)<<16)/dstW + 1;
-    zoomindstyIntInv = ((unsigned long)(cropH)<<16)/dstH + 1;
-    //y
-    //for(y = 0; y<dstH - 1 ; y++ ) {   
-    for(y = 0; y<dstH; y++ ) {   
-        yCoeff00 = (y*zoomindstyIntInv)&0xffff;
-        yCoeff01 = 0xffff - yCoeff00; 
-        sY = (y*zoomindstyIntInv >> 16);
-        sY = (sY >= srcH - 1)? (srcH - 2) : sY;      
-        for(x = 0; x<dstW; x++ ) {
-            xCoeff00 = (x*zoomindstxIntInv)&0xffff;
-            xCoeff01 = 0xffff - xCoeff00; 	
-            sX = (x*zoomindstxIntInv >> 16);
-            sX = (sX >= srcW -1)?(srcW- 2) : sX;
-            a = psY[sY*srcW + sX];
-            b = psY[sY*srcW + sX + 1];
-            c = psY[(sY+1)*srcW + sX];
-            d = psY[(sY+1)*srcW + sX + 1];
-
-            r0 = (a * xCoeff01 + b * xCoeff00)>>16 ;
-            r1 = (c * xCoeff01 + d * xCoeff00)>>16 ;
-            r0 = (r0 * yCoeff01 + r1 * yCoeff00)>>16;
-
-            pdY[x] = r0;
-        }
-        pdY += dstW;
-    }
-
-    dstW /= 2;
-    dstH /= 2;
-    srcW /= 2;
-    srcH /= 2;
-
-    //UV
-    //for(y = 0; y<dstH - 1 ; y++ ) {
-    for(y = 0; y<dstH; y++ ) {
-        yCoeff00 = (y*zoomindstyIntInv)&0xffff;
-        yCoeff01 = 0xffff - yCoeff00; 
-        sY = (y*zoomindstyIntInv >> 16);
-        sY = (sY >= srcH -1)? (srcH - 2) : sY;      
-        for(x = 0; x<dstW; x++ ) {
-            xCoeff00 = (x*zoomindstxIntInv)&0xffff;
-            xCoeff01 = 0xffff - xCoeff00; 	
-            sX = (x*zoomindstxIntInv >> 16);
-            sX = (sX >= srcW -1)?(srcW- 2) : sX;
-            //U
-            a = psUV[(sY*srcW + sX)*2];
-            b = psUV[(sY*srcW + sX + 1)*2];
-            c = psUV[((sY+1)*srcW + sX)*2];
-            d = psUV[((sY+1)*srcW + sX + 1)*2];
-
-            r0 = (a * xCoeff01 + b * xCoeff00)>>16 ;
-            r1 = (c * xCoeff01 + d * xCoeff00)>>16 ;
-            r0 = (r0 * yCoeff01 + r1 * yCoeff00)>>16;
-
-            pdUV[x*2] = r0;
-
-            //V
-            a = psUV[(sY*srcW + sX)*2 + 1];
-            b = psUV[(sY*srcW + sX + 1)*2 + 1];
-            c = psUV[((sY+1)*srcW + sX)*2 + 1];
-            d = psUV[((sY+1)*srcW + sX + 1)*2 + 1];
-
-            r0 = (a * xCoeff01 + b * xCoeff00)>>16 ;
-            r1 = (c * xCoeff01 + d * xCoeff00)>>16 ;
-            r0 = (r0 * yCoeff01 + r1 * yCoeff00)>>16;
-
-            pdUV[x*2 + 1] = r0;
-        }
-        pdUV += dstW*2;
-    }
-
-rk_camera_scale_crop_arm_end:
-
-    dmac_flush_range((void*)src,(void*)(src+pcdev->vipmem_bsize));
-    outer_flush_range((phys_addr_t)src_phy,(phys_addr_t)(src_phy+pcdev->vipmem_bsize));
-    
-    dmac_flush_range((void*)dst,(void*)(dst+vb_info->size));
-    outer_flush_range((phys_addr_t)dst_phy,(phys_addr_t)(dst_phy+vb_info->size));
-
-	return ret;    
+   
+	return 0;    
 }
 #endif
-
 static void rk_camera_capture_process(struct work_struct *work)
 {
     struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);    
     struct videobuf_buffer *vb = camera_work->vb;    
     struct rk_camera_dev *pcdev = camera_work->pcdev;    
-    //enum v4l2_mbus_pixelcode icd_code = pcdev->icd->current_fmt->code;    
-    struct device *control = to_soc_camera_control(pcdev->icd);
-    struct v4l2_subdev *sd=dev_get_drvdata(control);
+    /*enum v4l2_mbus_pixelcode icd_code = pcdev->icd->current_fmt->code;    */
     unsigned long flags = 0;    
-    int err = 0,i;    
+    int err = 0;    
 
-    if (!CAM_WORKQUEUE_IS_EN())        
-        goto rk_camera_capture_process_end; 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 
-    camera_work->vb->rk_code = 0x00;
-    if (pcdev->hdr_info.en) {
-		printk("rk_camera_capture_process hdr %d fps\n",camera_work->ts);
-        if (pcdev->hdr_info.frame[0].set_ts == 0) {
-            v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_HDR_EXPOSURE,(void*)pcdev->hdr_info.frame[0].code);
-            pcdev->hdr_info.frame[0].set_ts = pcdev->fps;
-            printk("set hdr %d @ %d fps\n",0,pcdev->fps);
-        } else {
-            if ((camera_work->ts - pcdev->hdr_info.frame[0].set_ts) > 1) {
-                for (i=0; i<3; i++) {
-                    if (pcdev->hdr_info.frame[i].get_ts == 0) {
-						printk("get hdr %d @ %d fps %dx%d\n",i,camera_work->ts,camera_work->vb->width,camera_work->vb->height);
-                        pcdev->hdr_info.frame[i].get_ts = camera_work->ts;
-                        RK_VIDEOBUF_CODE_SET(camera_work->vb->rk_code,pcdev->hdr_info.frame[i].code);
-                        break;
-                    }
-                }
 
-                if (i==2) {
-                    v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_HDR_EXPOSURE,(void*)RK_VIDEOBUF_HDR_EXPOSURE_FINISH);
-                    pcdev->hdr_info.en = false;
-                    printk("hdr off\n");
-                }
-            }
-        }
+    if (atomic_read(&pcdev->stop_cif)==true) {
+        err = -EINVAL;
+        goto rk_camera_capture_process_end; 
     }
     
+    if (!CAM_WORKQUEUE_IS_EN()) {
+        err = -EINVAL;
+        goto rk_camera_capture_process_end; 
+    }
     
     down(&pcdev->zoominfo.sem);
     if (pcdev->icd_cb.scale_crop_cb){
@@ -1397,132 +973,120 @@ static void rk_camera_capture_process(struct work_struct *work)
 		}
     }       
     spin_lock_irqsave(&pcdev->camera_work_lock, flags);    
-    list_add_tail(&camera_work->queue, &pcdev->camera_work_queue);
+    list_add_tail(&camera_work->queue, &pcdev->camera_work_queue);    
     spin_unlock_irqrestore(&pcdev->camera_work_lock, flags); 
-    wake_up(&(camera_work->vb->done));  
+    wake_up(&(camera_work->vb->done));     /* ddl@rock-chips.com : v0.3.9 */ 
     return;
 }
-#if defined(CONFIG_ARCH_RK3188)
-static void rk_camera_store_resore_register(struct rk_camera_dev *pcdev)
+
+static void rk_camera_cifrest_delay(struct work_struct *work)
 {
+    struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);  
+    struct rk_camera_dev *pcdev = camera_work->pcdev; 
+    unsigned long flags = 0;   
 
-	pcdev->reginfo_suspend.cifCtrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
-	pcdev->reginfo_suspend.cifCrop = read_cif_reg(pcdev->base,CIF_CIF_CROP);
-	pcdev->reginfo_suspend.cifFs = read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE);
-	pcdev->reginfo_suspend.cifIntEn = read_cif_reg(pcdev->base,CIF_CIF_INTEN);
-	pcdev->reginfo_suspend.cifFmt= read_cif_reg(pcdev->base,CIF_CIF_FOR);
-	pcdev->reginfo_suspend.cifVirWidth = read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH);
-	pcdev->reginfo_suspend.cifScale= read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL);
-	
-	cru_set_soft_reset(SOFT_RST_CIF0, true);
-	udelay(5);
-	cru_set_soft_reset(SOFT_RST_CIF0, false);
-	
-    if (pcdev->reginfo_suspend.cifCtrl&ENABLE_CAPTURE)
-        write_cif_reg(pcdev->base,CIF_CIF_CTRL, pcdev->reginfo_suspend.cifCtrl&~ENABLE_CAPTURE);
-	write_cif_reg(pcdev->base,CIF_CIF_INTEN, pcdev->reginfo_suspend.cifIntEn);
-	write_cif_reg(pcdev->base,CIF_CIF_CROP, pcdev->reginfo_suspend.cifCrop);
-	write_cif_reg(pcdev->base,CIF_CIF_SET_SIZE, pcdev->reginfo_suspend.cifFs);
-	write_cif_reg(pcdev->base,CIF_CIF_FOR, pcdev->reginfo_suspend.cifFmt);
-	write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH,pcdev->reginfo_suspend.cifVirWidth);
-	write_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL, pcdev->reginfo_suspend.cifScale);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+    
+    mdelay(1);
+    rk_camera_cif_reset(pcdev,false);
+
+    spin_lock_irqsave(&pcdev->camera_work_lock, flags);    
+    list_add_tail(&camera_work->queue, &pcdev->camera_work_queue);    
+    spin_unlock_irqrestore(&pcdev->camera_work_lock, flags); 
+
+    spin_lock_irqsave(&pcdev->lock,flags);
+    if (atomic_read(&pcdev->stop_cif) == false) {
+        write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL) | ENABLE_CAPTURE));
+        RKCAMERA_DG2("After reset cif, enable capture again!\n");
+    }
+    spin_unlock_irqrestore(&pcdev->lock,flags);
+    return;
+}
+
+static inline irqreturn_t rk_camera_cifirq(int irq, void *data)
+{
+    struct rk_camera_dev *pcdev = data;
+    struct rk_camera_work *wk;
+    unsigned int reg_cifctrl, reg_lastpix, reg_lastline;
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
+    write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0x0200);  /* clear vip interrupte single  */
+    
+    reg_cifctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
+    reg_lastpix = read_cif_reg(pcdev->base,CIF_CIF_LAST_PIX);
+    reg_lastline = read_cif_reg(pcdev->base,CIF_CIF_LAST_LINE);
 	
+    pcdev->irqinfo.cifirq_idx++;    
+    if ((reg_lastline != pcdev->host_height) /*|| (reg_lastpix != pcdev->host_width)*/) {
+        pcdev->irqinfo.cifirq_abnormal_idx = pcdev->irqinfo.cifirq_idx;
+        RKCAMERA_DG2("Cif irq-%ld is error, %dx%d != %dx%d\n",pcdev->irqinfo.cifirq_abnormal_idx,
+                    reg_lastpix,reg_lastline,pcdev->host_width,pcdev->host_height);
+    } else {
+        pcdev->irqinfo.cifirq_normal_idx = pcdev->irqinfo.cifirq_idx;
+    }
+/*    
+    if(reg_cifctrl & ENABLE_CAPTURE) {
+        write_cif_reg(pcdev->base,CIF_CIF_CTRL, (reg_cifctrl & ~ENABLE_CAPTURE));
+    } 
+*/
+    if (pcdev->irqinfo.cifirq_abnormal_idx>0) {
+        if ((pcdev->irqinfo.cifirq_idx - pcdev->irqinfo.cifirq_abnormal_idx) == 1 ) {
+            if (!list_empty(&pcdev->camera_work_queue)) {
+                RKCAMERA_DG2("Receive cif irq-%ld and queue work to cif reset\n",pcdev->irqinfo.cifirq_idx);
+                wk = list_entry(pcdev->camera_work_queue.next, struct rk_camera_work, queue);
+                list_del_init(&wk->queue);
+                INIT_WORK(&(wk->work), rk_camera_cifrest_delay);
+                wk->pcdev = pcdev;                
+                queue_work(pcdev->camera_wq, &(wk->work));
+            }  
+        }
+    }
+    
+    return IRQ_HANDLED;
 }
-#endif
 
-static irqreturn_t rk_camera_irq(int irq, void *data)
+static inline irqreturn_t rk_camera_dmairq(int irq, void *data)
 {
     struct rk_camera_dev *pcdev = data;
     struct videobuf_buffer *vb;
 	struct rk_camera_work *wk;
 	struct timeval tv;
-    unsigned long tmp_intstat;
-    unsigned long tmp_cifctrl; 
-	unsigned long tmp_cif_frmst; 
+    unsigned long reg_cifctrl;
+	unsigned long tmp_cif_frmst;	
 	struct videobuf_buffer **active = 0;
+	struct videobuf_buffer *active_buf = NULL;
 	int flag = 0;
-	 unsigned int invalid_y_addr ,invalid_uv_addr;
-#ifdef OPTIMIZE_MEMORY_USE
-	invalid_y_addr = 0/*pcdev->vipmem_phybase + pcdev->vipmem_bsize*/;
-	invalid_uv_addr = 0/*invalid_y_addr + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height*/;
-#else
-	invalid_y_addr = pcdev->vipmem_phybase + pcdev->vbinfo_count *pcdev->vipmem_bsize;
-	invalid_uv_addr = invalid_y_addr + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;
-#endif 
-    tmp_intstat = read_cif_reg(pcdev->base,CIF_CIF_INTSTAT);
-    tmp_cifctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
-	tmp_cif_frmst = read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS);
 
-#if (CONFIG_CIF_STOP_SYNC == 0)
-    if(pcdev->stop_cif == true) {
-		//RK30_CAM_DEBUG_TRACE("%s(%d): cif has stopped by app,needn't to deal this irq\n",__FUNCTION__,__LINE__);
-		write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0xFFFFFFFF);  /* clear vip interrupte single  */
-		return IRQ_HANDLED;
-	}
-#endif
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 
-    if ((tmp_intstat & 0x0200) /*&& ((tmp_intstat & 0x1)==0)*/) {//bit9 =1 ,bit0 = 0
-    	write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0x0200);  /* clear vip interrupte single  */
- //       if(tmp_cifctrl & ENABLE_CAPTURE)
- //           write_cif_reg(pcdev->base,CIF_CIF_CTRL, (tmp_cifctrl & ~ENABLE_CAPTURE));
-         return IRQ_HANDLED;
-    }
-    
-    /* ddl@rock-chps.com : Current VIP is run in One Frame Mode, Frame 1 is validate */
-    if (tmp_cif_frmst & (CIF_F0_READY | CIF_F1_READY)) {
-    	write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0x01);  /* clear vip interrupte single  */
-#if CONFIG_CIF_STOP_SYNC 
-			if(pcdev->stop_cif == true) {
-				//RK30_CAM_DEBUG_TRACE("%s(%d): cif has stopped by app,needn't to deal this irq\n",__FUNCTION__,__LINE__);
-				write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0xFFFFFFFF);	/* clear vip interrupte single	*/
-				
-#if 1
-				//		write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0);	 //capture complete interrupt enable
-						{
-#if (defined(CONFIG_ARCH_RK30) || defined(CONFIG_ARCH_RK2928))
-					mdelay(100);
-					if(IS_CIF0()){
-						cru_set_soft_reset(SOFT_RST_CIF0, true);
-						udelay(5);
-						cru_set_soft_reset(SOFT_RST_CIF0, false);
-			
-					}else{
-						cru_set_soft_reset(SOFT_RST_CIF1, true);
-						udelay(5);
-						cru_set_soft_reset(SOFT_RST_CIF1, false);
-					}
-#elif defined(CONFIG_ARCH_RK3188)
-					cru_set_soft_reset(SOFT_RST_CIF0, true);
-					udelay(5);
-					cru_set_soft_reset(SOFT_RST_CIF0, false);
-#endif
-				}
-#endif
-			    spin_lock(&pcdev->lock);
-				pcdev->cif_stopped = true;
-				wake_up(&pcdev->cif_stop_done);
-				spin_unlock(&pcdev->lock);
-				return IRQ_HANDLED;
-			}
-#endif
-        if (!pcdev->fps) {
+
+    reg_cifctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
+	tmp_cif_frmst = read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS);
+    /* ddl@rock-chps.com : Current VIP is run in Pingpong Frame Mode */
+    if (tmp_cif_frmst & (CIF_F0_READY | CIF_F1_READY)) {   //frame 0 or 1  ready yzm
+        write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0x01);  /* clear vip interrupte single  */
+
+        pcdev->irqinfo.dmairq_idx++;
+        if (pcdev->irqinfo.cifirq_abnormal_idx == pcdev->irqinfo.dmairq_idx) {
+            write_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS,  0x00000003);
+            goto end;
+        }
+
+        if (!pcdev->fps) {//
             do_gettimeofday(&pcdev->first_tv);            
         }
-process_another_frame: 
+		
         if((tmp_cif_frmst & CIF_F0_READY) && (tmp_cif_frmst & CIF_F1_READY)){
-		    printk(KERN_DEBUG"%s:f0 && f1 ready ,need to resart cif!!!!!\n",__func__);
-    	    spin_lock(&pcdev->lock);
-
-            rk_camera_store_resore_register(pcdev);
-			rk_videobuf_capture(pcdev->active0,pcdev,0);
-			rk_videobuf_capture(pcdev->active1,pcdev,1);
-			tmp_cifctrl &=~ENABLE_CAPTURE;
-		    spin_unlock(&pcdev->lock);
+		    printk("%s:f0 && f1 ready ,need to resart cif!!!!!\n",__func__);
+			reg_cifctrl &=~ENABLE_CAPTURE;
 
-			goto RK_CAMERA_IRQ_END;
+			goto end;
         }
-		pcdev->fps++;
-        
+        pcdev->fps++;
+		
 		if (tmp_cif_frmst & CIF_F0_READY){
 			active = &pcdev->active0;
 			flag = 0;
@@ -1531,105 +1095,103 @@ static irqreturn_t rk_camera_irq(int irq, void *data)
 			flag = 1;
 		} else {
 			printk("irq frame status erro \n");
-			goto RK_CAMERA_IRQ_END;
+			goto end;
 		}
-#if 0	
 		if (!(*active)){
-			goto RK_CAMERA_IRQ_END;
+			printk("active = NULL\n");
+			goto end;
 		}
-#endif
-		if (pcdev->frame_inval>0) {
-			pcdev->frame_inval--;
+		
+        if (pcdev->frame_inval>0) {//
+            pcdev->frame_inval--;
 			rk_videobuf_capture(*active,pcdev,flag);
-			goto first_frame_done;
-		} else if (pcdev->frame_inval) {
-			RK30_CAM_DEBUG_TRACE("frame_inval : %0x",pcdev->frame_inval);
-			pcdev->frame_inval = 0;
-		}
+        } else if (pcdev->frame_inval) {
+            RKCAMERA_TR("frame_inval : %0x",pcdev->frame_inval);
+            pcdev->frame_inval = 0;
+        }
         
-		if(pcdev->fps == RK30_CAM_FRAME_MEASURE) {
-			do_gettimeofday(&tv);            
-			pcdev->frame_interval = ((tv.tv_sec*1000000 + tv.tv_usec) - (pcdev->first_tv.tv_sec*1000000 + pcdev->first_tv.tv_usec))
-									/(RK30_CAM_FRAME_MEASURE-1);
+        if(pcdev->fps == RK30_CAM_FRAME_MEASURE) {//,
+            do_gettimeofday(&tv);            
+            pcdev->frame_interval = ((tv.tv_sec*1000000 + tv.tv_usec) - (pcdev->first_tv.tv_sec*1000000 + pcdev->first_tv.tv_usec))
+                /(RK30_CAM_FRAME_MEASURE-1);
+        }
+        
+        vb = *active;
+        
+        if (!vb) {
+            printk("no acticve buffer!!!\n");
+            goto end;
         }
-		
-		vb = *active;
-		
-#if 0
-		if(!vb){
-			RK30_CAM_DEBUG_TRACE("no acticve buffer!!!\n");
-			goto RK_CAMERA_IRQ_END;
-		}
 
-		if (vb->stream.prev != &(pcdev->video_vq->stream)) {
-			RK30_CAM_DEBUG_TRACE("vb(%d) isn't first node in stream list\n", vb->i);
-			goto RK_CAMERA_IRQ_END;
-		}
-#endif
-		*active = NULL;
-	    spin_lock(&pcdev->lock);
-		if (!list_empty(&pcdev->capture)) {
-			*active = list_entry(pcdev->capture.next, struct videobuf_buffer, queue);
-			if (*active) {
-				WARN_ON((*active)->state != VIDEOBUF_QUEUED); 
-				if (tmp_cif_frmst & CIF_F0_READY){
-			        pcdev->active0 = *active;
-        		} else if (tmp_cif_frmst & CIF_F1_READY){
-			        pcdev->active1 = *active;
+        if (!list_empty(&pcdev->capture)) {
+			active_buf = list_entry(pcdev->capture.next, struct videobuf_buffer, queue);
+            if (active_buf) {
+                
+                WARN_ON(active_buf->state != VIDEOBUF_QUEUED);
+				if ((flag == 0) && ((active_buf->i)%2 == 0)){					
+			        pcdev->active0 = active_buf;
+        		} else if ((flag == 1) && ((active_buf->i)%2 == 1)){
+			        pcdev->active1 = active_buf;
         		}else{
-                    printk("irq frame status erro !\n");
+                    RKCAMERA_DG1("irq frame status erro or no a suitable buf!\n");
+					goto end;
         		}
-				rk_videobuf_capture((*active),pcdev,flag);
-				list_del_init(&((*active)->queue));
-			}
-		}
-	    spin_unlock(&pcdev->lock);
-		if ((*active) == NULL) {
-		//	RK30_CAM_DEBUG_TRACE("%s video_buf queue is empty!\n",__FUNCTION__);
-			if(flag == 0){			
-			    pcdev->active0 = NULL;
-				write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y, invalid_y_addr);
-				write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV, invalid_uv_addr);
-				}else{
-			    pcdev->active1 = NULL;
-				write_cif_reg(pcdev->base,CIF_CIF_FRM1_ADDR_Y, invalid_y_addr);
-				write_cif_reg(pcdev->base,CIF_CIF_FRM1_ADDR_UV, invalid_uv_addr);
-				}
-		}
-		if(vb)
-			do_gettimeofday(&vb->ts);
-		if (CAM_WORKQUEUE_IS_EN()) {
-			if(vb){
-					if (!list_empty(&pcdev->camera_work_queue)) {
-						wk = list_entry(pcdev->camera_work_queue.next, struct rk_camera_work, queue);
-						list_del_init(&wk->queue);
-						INIT_WORK(&(wk->work), rk_camera_capture_process);
-						wk->vb = vb;
-						wk->pcdev = pcdev;
-		        		wk->ts = pcdev->fps;
-						queue_work(pcdev->camera_wq, &(wk->work));
-					}else{
-						printk("work queue is empty \n!!!!!!!!");
-					}
-				}
-		} else {
-			if ((vb->state == VIDEOBUF_QUEUED) || (vb->state == VIDEOBUF_ACTIVE)) {
-				vb->state = VIDEOBUF_DONE;    	        
-				vb->field_count++;
-			}
-			wake_up(&vb->done);
-		}
+				rk_videobuf_capture(active_buf,pcdev,flag);
+				list_del_init(&(active_buf->queue));
+            }
+        }else{
+			RKCAMERA_DG1("video_buf queue is empty!\n");
+			goto end;
+        }
+        		
+        do_gettimeofday(&vb->ts);
+        if (CAM_WORKQUEUE_IS_EN()) {
+            if (!list_empty(&pcdev->camera_work_queue)) {
+                wk = list_entry(pcdev->camera_work_queue.next, struct rk_camera_work, queue);
+                list_del_init(&wk->queue);
+                INIT_WORK(&(wk->work), rk_camera_capture_process);
+                wk->vb = vb;
+                wk->pcdev = pcdev;
+                queue_work(pcdev->camera_wq, &(wk->work));
+            }             			
+        } else {
+            if ((vb->state == VIDEOBUF_QUEUED) || (vb->state == VIDEOBUF_ACTIVE)) {
+                vb->state = VIDEOBUF_DONE;    	        
+                vb->field_count++;
+            }
+            wake_up(&vb->done);
+        }
     }
-first_frame_done:
-	if ((tmp_cif_frmst & CIF_F0_READY) && (tmp_cif_frmst & CIF_F1_READY)){
-		    printk(KERN_DEBUG"%s:f0 && f1 ready ,need to process f1 too!!!!!\n",__func__);
-            tmp_cif_frmst &=~CIF_F0_READY;
-            goto process_another_frame;
-	}
 
-RK_CAMERA_IRQ_END:
-    if((tmp_cifctrl & ENABLE_CAPTURE) == 0)
-        write_cif_reg(pcdev->base,CIF_CIF_CTRL, (tmp_cifctrl | ENABLE_CAPTURE));
+end:
+    if((reg_cifctrl & ENABLE_CAPTURE) == 0)
+        write_cif_reg(pcdev->base,CIF_CIF_CTRL, (reg_cifctrl | ENABLE_CAPTURE));
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rk_camera_irq(int irq, void *data)
+{
+    struct rk_camera_dev *pcdev = data;
+    unsigned long reg_intstat;
+
+
+    spin_lock(&pcdev->lock);
+
+    if(atomic_read(&pcdev->stop_cif) == true) {
+        write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0xffffffff);
+        goto end;
+    }
+
+    reg_intstat = read_cif_reg(pcdev->base,CIF_CIF_INTSTAT);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s() ,reg_intstat 0x%lx\n", __FILE__, __LINE__,__FUNCTION__,reg_intstat);
+    if (reg_intstat & 0x0200)
+        rk_camera_cifirq(irq,data);
+
+    if (reg_intstat & 0x01) 
+        rk_camera_dmairq(irq,data);
+
+end:    
+    spin_unlock(&pcdev->lock);
     return IRQ_HANDLED;
 }
 
@@ -1639,13 +1201,17 @@ static void rk_videobuf_release(struct videobuf_queue *vq,
 {
     struct rk_camera_buffer *buf = container_of(vb, struct rk_camera_buffer, vb);
     struct soc_camera_device *icd = vq->priv_data;
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
 #if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info =NULL;
 #endif
 
 #ifdef DEBUG
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,
             vb, vb->baddr, vb->bsize);
 
@@ -1666,26 +1232,22 @@ static void rk_videobuf_release(struct videobuf_queue *vq,
     }
 #endif
 
-	#if 0   /* ddl@rock-chips.com: this wait operation is not nessary, invalidate in v0.x.1f */
-	if (vb == pcdev->active0 || vb == pcdev->active1) {
-		RK30_CAM_DEBUG_TRACE("%s Wait for this video buf(0x%x) write finished!\n ",__FUNCTION__,(unsigned int)vb);
-		interruptible_sleep_on_timeout(&vb->done, msecs_to_jiffies(500));
-		RK30_CAM_DEBUG_TRACE("%s This video buf(0x%x) write finished, release now!!\n",__FUNCTION__,(unsigned int)vb);
-	}
-	#endif
-	flush_workqueue(pcdev->camera_wq); 
+    flush_workqueue(pcdev->camera_wq); 
+    
+    rk_videobuf_free(vq, buf);
+    
 #if CAMERA_VIDEOBUF_ARM_ACCESS
-	if ((pcdev->vbinfo) && (vb->i < pcdev->vbinfo_count)) {
-		vb_info = pcdev->vbinfo + vb->i;
+    if ((pcdev->vbinfo) && (vb->i < pcdev->vbinfo_count)) {
+        vb_info = pcdev->vbinfo + vb->i;
         
-		if (vb_info->vir_addr) {
-			iounmap(vb_info->vir_addr);
-			release_mem_region(vb_info->phy_addr, vb_info->size);
-			memset(vb_info, 0x00, sizeof(struct rk29_camera_vbinfo));
-		}
+        if (vb_info->vir_addr) {
+            iounmap(vb_info->vir_addr);
+            release_mem_region(vb_info->phy_addr, vb_info->size);
+            memset(vb_info, 0x00, sizeof(struct rk29_camera_vbinfo));
+        }       
+		
 	}
-#endif    
-	rk_videobuf_free(vq, buf);
+#endif  
 }
 
 static struct videobuf_queue_ops rk_videobuf_ops =
@@ -1699,9 +1261,12 @@ static struct videobuf_queue_ops rk_videobuf_ops =
 static void rk_camera_init_videobuf(struct videobuf_queue *q,
                                       struct soc_camera_device *icd)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     /* We must pass NULL as dev pointer, then all pci_* dma operations
      * transform to normal dma_* ones. */
     videobuf_queue_dma_contig_init(q,
@@ -1710,83 +1275,80 @@ static void rk_camera_init_videobuf(struct videobuf_queue *q,
                                    V4L2_BUF_TYPE_VIDEO_CAPTURE,
                                    V4L2_FIELD_NONE,
                                    sizeof(struct rk_camera_buffer),
-                                   icd,&icd->video_lock);
+                                   icd,&(ici->host_lock) );
 }
 
-static int rk_camera_mclk_ctrl(int cif_idx, int on, int clk_rate){
-    int err = 0,cif;
+static int rk_camera_mclk_ctrl(int cif_idx, int on, int clk_rate)
+{
+    int err = 0,cif;    
     struct rk_cif_clk *clk;
-    struct clk *cif_clk_out_div;
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
 
     cif = cif_idx - RK29_CAM_PLATFORM_DEV_ID;
     if ((cif<0)||(cif>1)) {
         RKCAMERA_TR(KERN_ERR "cif index(%d) is invalidate\n",cif_idx);
         err = -1;
         goto rk_camera_clk_ctrl_end;
-    }
+    } 
 
     clk = &cif_clk[cif];
-
+   
     if(!clk->aclk_cif || !clk->hclk_cif || !clk->cif_clk_in || !clk->cif_clk_out) {
         RKCAMERA_TR(KERN_ERR "failed to get cif clock source\n");
         err = -ENOENT;
         goto rk_camera_clk_ctrl_end;
     }
-    spin_lock(&clk->lock);
-    if (on && !clk->on) {
-        clk_enable(clk->pd_cif);
-        clk_enable(clk->aclk_cif);
-        clk_enable(clk->hclk_cif);
-        clk_enable(clk->cif_clk_in);
-        clk_enable(clk->cif_clk_out);
+   
+    //spin_lock(&clk->lock);
+    if (on && !clk->on) {  
+        clk_prepare_enable(clk->pd_cif);    /*yzm*/
+        clk_prepare_enable(clk->aclk_cif);
+    	clk_prepare_enable(clk->hclk_cif);
+    	clk_prepare_enable(clk->cif_clk_in);
+    	clk_prepare_enable(clk->cif_clk_out);
         clk_set_rate(clk->cif_clk_out,clk_rate);
-        mdelay(10);
         clk->on = true;
-        
     } else if (!on && clk->on) {
-        clk_disable(clk->aclk_cif);
-        clk_disable(clk->hclk_cif);
-        clk_disable(clk->cif_clk_in);
-
-        clk_disable(clk->cif_clk_out);
-        clk_disable(clk->pd_cif);
+		clk_set_rate(clk->cif_clk_out,36000000);/*yzm :just for close clk which base on XIN24M */
+    	msleep(100);
+        clk_disable_unprepare(clk->aclk_cif);
+    	clk_disable_unprepare(clk->hclk_cif);
+    	clk_disable_unprepare(clk->cif_clk_in);
+		if(CHIP_NAME == 3126){
+			write_cru_reg(CRU_CLKSEL29_CON, 0x007c0000);
+			write_cru_reg(CRU_CLK_OUT, 0x00800080);
+		}
+    	clk_disable_unprepare(clk->cif_clk_out);
+    	clk_disable_unprepare(clk->pd_cif);
         clk->on = false;
-        if(cif){
-            cif_clk_out_div =  clk_get(NULL, "cif1_out_div");
-        }else{
-            cif_clk_out_div =  clk_get(NULL, "cif0_out_div");
-            if(IS_ERR_OR_NULL(cif_clk_out_div)) {
-                cif_clk_out_div =  clk_get(NULL, "cif_out_div");
-            }
-        }
-
-        if(IS_ERR_OR_NULL(cif_clk_out_div)) {
-            err = clk_set_parent(clk->cif_clk_out, cif_clk_out_div);
-            clk_put(cif_clk_out_div);
-        } else {
-            err = -1;
-        }
-
-        if(err)
-           RKCAMERA_TR("WARNING %s_%s_%d: camera sensor mclk maybe not close, please check!!!\n", __FILE__, __FUNCTION__, __LINE__);
     }
-    spin_unlock(&clk->lock);
+    //spin_unlock(&clk->lock);
 rk_camera_clk_ctrl_end:
     return err;
 }
 static int rk_camera_activate(struct rk_camera_dev *pcdev, struct soc_camera_device *icd)
 {
-    write_cif_reg(pcdev->base,CIF_CIF_CTRL,AXI_BURST_16|MODE_PINGPONG|DISABLE_CAPTURE);   /* ddl@rock-chips.com : vip ahb burst 16 */
+    /*
+    * ddl@rock-chips.com : Cif clk control in rk_sensor_power which in rk_camera.c
+    */
 
-    write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0x01);    //capture complete interrupt enable
-    RK30_CAM_DEBUG_TRACE("%s..%d.. CIF_CIF_CTRL = 0x%x\n",__FUNCTION__,__LINE__,read_cif_reg(pcdev->base, CIF_CIF_CTRL));
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	
+    write_cif_reg(pcdev->base,CIF_CIF_CTRL,AXI_BURST_16|MODE_PINGPONG|DISABLE_CAPTURE);   /* ddl@rock-chips.com : vip ahb burst 16 */
+	//write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0x01);    //capture complete interrupt enable
     return 0;
-RK_CAMERA_ACTIVE_ERR:
-    return -ENODEV;
 }
 
 static void rk_camera_deactivate(struct rk_camera_dev *pcdev)
-{
+{ 
+    /*
+    * ddl@rock-chips.com : Cif clk control in rk_sensor_power which in rk_camera.c
+    */
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    
     return;
 }
 
@@ -1794,8 +1356,8 @@ static void rk_camera_deactivate(struct rk_camera_dev *pcdev)
  * there can be only one camera on RK28 quick capture interface */
 static int rk_camera_add_device(struct soc_camera_device *icd)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
+    struct rk_camera_dev *pcdev = ici->priv;    /*Initialize in rk_camra_prob*/
     struct device *control = to_soc_camera_control(icd);
     struct v4l2_subdev *sd;
     int ret,i,icd_catch;
@@ -1803,6 +1365,9 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
     struct v4l2_cropcap cropcap;
     struct v4l2_mbus_framefmt mf;
     const struct soc_camera_format_xlate *xlate = NULL;
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
     
     mutex_lock(&camera_lock);
 
@@ -1811,11 +1376,13 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
         goto ebusy;
     }
 
-    RK30_CAM_DEBUG_TRACE("%s driver attached to %s\n",RK29_CAM_DRV_NAME,dev_name(icd->pdev));
+    RKCAMERA_DG1("%s driver attached to %s\n",RK29_CAM_DRV_NAME,dev_name(icd->pdev));
 
 	pcdev->frame_inval = RK_CAM_FRAME_INVAL_INIT;
+    //pcdev->active = NULL;    
     pcdev->active0 = NULL;
 	pcdev->active1 = NULL;
+	pcdev->active_buf = 0;
     pcdev->icd = NULL;
 	pcdev->reginfo_suspend.Inval = Reg_Invalidate;
     pcdev->zoominfo.zoom_rate = 100;
@@ -1830,7 +1397,7 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
     if (ret)
         goto ebusy;
     /* ddl@rock-chips.com : v4l2_subdev is not created when ici->ops->add called in soc_camera_probe  */
-    if (control) {
+    if (control) {		//TRUE in open ,FALSE in kernel start
         sd = dev_get_drvdata(control);
 		v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_IOREQUEST,(void*)pcdev->pdata);
         #if 0
@@ -1838,8 +1405,9 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
         if (ret)
             goto ebusy;
         #endif
+		/* call generic_sensor_ioctl*/
         v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_CB_REGISTER,(void*)(&pcdev->icd_cb));
-
+		/* call generic_sensor_cropcap*/
         if (v4l2_subdev_call(sd, video, cropcap, &cropcap) == 0) {
             memcpy(&pcdev->cropinfo.bounds ,&cropcap.bounds,sizeof(struct v4l2_rect));
         } else {
@@ -1857,9 +1425,11 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
             pcdev->cropinfo.bounds.height = mf.height;
         }
     }
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
     pcdev->icd = icd;
     pcdev->icd_init = 0;
-
+    
     icd_catch = 0;
     for (i=0; i<2; i++) {
         if (pcdev->icd_frmival[i].icd == icd)
@@ -1887,37 +1457,31 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
 }
 static void rk_camera_remove_device(struct soc_camera_device *icd)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
-	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+	/*struct v4l2_subdev *sd = soc_camera_to_subdev(icd);*/
 #if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info;
     unsigned int i;
-#endif    
+#endif 
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
 
 	mutex_lock(&camera_lock);
     BUG_ON(icd != pcdev->icd);
 
-    RK30_CAM_DEBUG_TRACE("%s driver detached from %s\n",RK29_CAM_DRV_NAME,dev_name(icd->pdev));
-
-	/* ddl@rock-chips.com: Application will call VIDIOC_STREAMOFF before close device, but
+    RKCAMERA_DG1("%s driver detached from %s\n",RK29_CAM_DRV_NAME,dev_name(icd->pdev));
+    
+    /* ddl@rock-chips.com: Application will call VIDIOC_STREAMOFF before close device, but
 	   stream may be turn on again before close device, if suspend and resume happened. */
-	if (read_cif_reg(pcdev->base,CIF_CIF_CTRL) & ENABLE_CAPTURE) {
+	/*if (read_cif_reg(pcdev->base,CIF_CIF_CTRL) & ENABLE_CAPTURE) {*/
+	if ((atomic_read(&pcdev->stop_cif) == false) && pcdev->fps_timer.istarted) {       /* ddl@rock-chips.com: v0.3.0x15*/
 		rk_camera_s_stream(icd,0);
-	}
-    
-    //soft reset  the registers
-    #if 0 //has somthing wrong when suspend and resume now
-    if(IS_CIF0()){
-        write_cru_reg(CRU_CIF_RST_REG30,MASK_RST_CIF0|RQUEST_RST_CIF0 | (read_cru_reg(CRU_CIF_RST_REG30)));
-        write_cru_reg(CRU_CIF_RST_REG30,(read_cru_reg(CRU_CIF_RST_REG30)&(~RQUEST_RST_CIF0)) | MASK_RST_CIF0);
-    }else{
-        write_cru_reg(CRU_CIF_RST_REG30,MASK_RST_CIF1|RQUEST_RST_CIF1 | (read_cru_reg(CRU_CIF_RST_REG30)));
-        write_cru_reg(CRU_CIF_RST_REG30,(read_cru_reg(CRU_CIF_RST_REG30)&(~RQUEST_RST_CIF1)) | MASK_RST_CIF1);
-    }
-    #endif
-    v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_DEACTIVATE,NULL);
-    //if stream off is not been executed,timer is running.
+	} 
+	/* move DEACTIVATE into generic_sensor_s_power*/
+    /* v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_DEACTIVATE,NULL);*/ /*yzm*/
+    /* if stream off is not been executed,timer is running.*/
     if(pcdev->fps_timer.istarted){
          hrtimer_cancel(&pcdev->fps_timer.timer);
          pcdev->fps_timer.istarted = false;
@@ -1948,8 +1512,10 @@ static void rk_camera_remove_device(struct soc_camera_device *icd)
 		pcdev->vbinfo_count = 0;
 	}
 #endif
-	pcdev->active0 = NULL;
+	//pcdev->active = NULL;
+    pcdev->active0 = NULL;
 	pcdev->active1 = NULL;
+	pcdev->active_buf = 0;
     pcdev->icd = NULL;
     pcdev->icd_cb.sensor_cb = NULL;
 	pcdev->reginfo_suspend.Inval = Reg_Invalidate;
@@ -1959,19 +1525,20 @@ static void rk_camera_remove_device(struct soc_camera_device *icd)
     INIT_LIST_HEAD(&pcdev->capture);
 
 	mutex_unlock(&camera_lock);
-	RK30_CAM_DEBUG_TRACE("%s exit\n",__FUNCTION__);
 
 	return;
 }
 static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
 {
-    unsigned long bus_flags, camera_flags, common_flags;
-    unsigned int cif_ctrl_val = 0;
+    unsigned long bus_flags, camera_flags, common_flags = 0;
+    unsigned int cif_for = 0;
 	const struct soc_mbus_pixelfmt *fmt;
 	int ret = 0;
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent); /*yzm*/
 	struct rk_camera_dev *pcdev = ici->priv;
-    RK30_CAM_DEBUG_TRACE("%s..%d..\n",__FUNCTION__,__LINE__);
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
 
 	fmt = soc_mbus_get_fmtdesc(icd->current_fmt->code);
 	if (!fmt)
@@ -1995,90 +1562,90 @@ static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
     	default:
     		return -EINVAL;
 	}
-    
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 	if (icd->ops->query_bus_param)
     	camera_flags = icd->ops->query_bus_param(icd);
 	else
 		camera_flags = 0;
 
+/**************yzm************
     common_flags = soc_camera_bus_param_compatible(camera_flags, bus_flags);
     if (!common_flags) {
         ret = -EINVAL;
         goto RK_CAMERA_SET_BUS_PARAM_END;
     }
+*/
+/***************yzm************end*/
 
+	
+	common_flags = camera_flags;
     ret = icd->ops->set_bus_param(icd, common_flags);
     if (ret < 0)
         goto RK_CAMERA_SET_BUS_PARAM_END;
 
-    cif_ctrl_val = read_cif_reg(pcdev->base,CIF_CIF_FOR);
-	RK30_CAM_DEBUG_TRACE("%s..%d..cif_ctrl_val = 0x%x\n",__FUNCTION__,__LINE__,cif_ctrl_val);
-    if (common_flags & SOCAM_PCLK_SAMPLE_FALLING) {
+    cif_for = read_cif_reg(pcdev->base,CIF_CIF_FOR);
+    
+    if (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING) {
        	if(IS_CIF0()) {
     		write_cru_reg(CRU_PCLK_REG30, read_cru_reg(CRU_PCLK_REG30) | ENANABLE_INVERT_PCLK_CIF0);
-            RK30_CAM_DEBUG_TRACE("enable cif0 pclk invert\n");
         } else {
     		write_cru_reg(CRU_PCLK_REG30, read_cru_reg(CRU_PCLK_REG30) | ENANABLE_INVERT_PCLK_CIF1);
-            RK30_CAM_DEBUG_TRACE("enable cif1 pclk invert\n");
         }
     } else {
 		if(IS_CIF0()){
 			write_cru_reg(CRU_PCLK_REG30, (read_cru_reg(CRU_PCLK_REG30) & 0xFFFFEFF ) | DISABLE_INVERT_PCLK_CIF0);
-            RK30_CAM_DEBUG_TRACE("diable cif0 pclk invert\n");
         } else {
 			write_cru_reg(CRU_PCLK_REG30, (read_cru_reg(CRU_PCLK_REG30) & 0xFFFEFFF) | DISABLE_INVERT_PCLK_CIF1);
-            RK30_CAM_DEBUG_TRACE("diable cif1 pclk invert\n");
         }
     }
-    if (common_flags & SOCAM_HSYNC_ACTIVE_LOW) {
-        cif_ctrl_val |= HSY_LOW_ACTIVE;
+    
+    if (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW) {
+        cif_for |= HSY_LOW_ACTIVE;
     } else {
-		cif_ctrl_val &= ~HSY_LOW_ACTIVE;
+		cif_for &= ~HSY_LOW_ACTIVE;
     }
-    if (common_flags & SOCAM_VSYNC_ACTIVE_HIGH) {
-        cif_ctrl_val |= VSY_HIGH_ACTIVE;
+    if (common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) {
+        cif_for |= VSY_HIGH_ACTIVE;
     } else {
-		cif_ctrl_val &= ~VSY_HIGH_ACTIVE;
+		cif_for &= ~VSY_HIGH_ACTIVE;
     }
 
-    /* ddl@rock-chips.com : Don't enable capture here, enable in stream_on */
+    // ddl@rock-chips.com : Don't enable capture here, enable in stream_on 
     //vip_ctrl_val |= ENABLE_CAPTURE;
-    write_cif_reg(pcdev->base,CIF_CIF_FOR, cif_ctrl_val);
-    RK30_CAM_DEBUG_TRACE("%s..ctrl:0x%x CIF_CIF_FOR=%x  \n",__FUNCTION__,cif_ctrl_val,read_cif_reg(pcdev->base,CIF_CIF_FOR));
+    write_cif_reg(pcdev->base,CIF_CIF_FOR, cif_for);
+    RKCAMERA_DG1("CIF_CIF_FOR: 0x%x \n",cif_for);
 
 RK_CAMERA_SET_BUS_PARAM_END:
 	if (ret)
-    	RK30_CAM_DEBUG_TRACE("\n%s..%d.. ret = %d \n",__FUNCTION__,__LINE__, ret);
+    	RKCAMERA_TR("rk_camera_set_bus_param ret = %d \n", ret);
     return ret;
 }
 
 static int rk_camera_try_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
 {
-    unsigned long bus_flags, camera_flags;
-    int ret;
+/*    unsigned long bus_flags, camera_flags;*/
+/*    int ret;*/
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+/**********yzm***********
 
     bus_flags = RK_CAM_BUS_PARAM;
 	if (icd->ops->query_bus_param) {
-        camera_flags = icd->ops->query_bus_param(icd);
+        camera_flags = icd->ops->query_bus_param(icd);  //generic_sensor_query_bus_param()
 	} else {
 		camera_flags = 0;
 	}
     ret = soc_camera_bus_param_compatible(camera_flags, bus_flags) ;
 
-	/* rockchip BUGBUG
-		if (ret < 0)
-			dev_warn(icd->dev.parent,
-				 "Flags incompatible: camera %lx, host %lx\n",
-				 camera_flags, bus_flags);
-	*/
-	if(!ret){
-		dev_warn(icd->dev.parent, "Flags incompatible: camera %lx, host %lx\n", camera_flags, bus_flags);
-		ret = -EINVAL;
-	}
-	else{
-		ret = 0;
-	}
+    if (ret < 0)
+        dev_warn(icd->dev.parent,
+			 "Flags incompatible: camera %lx, host %lx\n",
+			 camera_flags, bus_flags);
+
     return ret;
+*///************yzm **************end
+	return 0;
+
 }
 
 static const struct soc_mbus_pixelfmt rk_camera_formats[] = {
@@ -2119,11 +1686,12 @@ static const struct soc_mbus_pixelfmt rk_camera_formats[] = {
 		.packing		= SOC_MBUS_PACKING_2X8_PADHI,
 		.order			= SOC_MBUS_ORDER_LE,
 	}
+
 };
 
 static void rk_camera_setup_format(struct soc_camera_device *icd, __u32 host_pixfmt, enum v4l2_mbus_pixelcode icd_code, struct v4l2_rect *rect)
 {
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
     unsigned int cif_fs = 0,cif_crop = 0;
     unsigned int cif_fmt_val = read_cif_reg(pcdev->base,CIF_CIF_FOR) | INPUT_MODE_YUV|YUV_INPUT_422|INPUT_420_ORDER_EVEN|OUTPUT_420_ORDER_EVEN;
@@ -2131,6 +1699,9 @@ static void rk_camera_setup_format(struct soc_camera_device *icd, __u32 host_pix
 	const struct soc_mbus_pixelfmt *fmt;
 	fmt = soc_mbus_get_fmtdesc(icd_code);
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 	if((host_pixfmt == V4L2_PIX_FMT_RGB565) || (host_pixfmt == V4L2_PIX_FMT_RGB24)){
 		if(fmt->fourcc == V4L2_PIX_FMT_NV12)
 			host_pixfmt = V4L2_PIX_FMT_NV12;
@@ -2187,47 +1758,22 @@ static void rk_camera_setup_format(struct soc_camera_device *icd, __u32 host_pix
 			cif_fmt_val = YUV_INPUT_ORDER_YUYV(cif_fmt_val);
             break;
     }
-#if 1
-        {
-#if (defined(CONFIG_ARCH_RK30) || defined(CONFIG_ARCH_RK2928))
-           mdelay(100);
-            if(IS_CIF0()){
-        //		pmu_set_idle_request(IDLE_REQ_VIO, true);
-        		cru_set_soft_reset(SOFT_RST_CIF0, true);
-        		udelay(5);
-        		cru_set_soft_reset(SOFT_RST_CIF0, false);
-        //		pmu_set_idle_request(IDLE_REQ_VIO, false);
-
-            }else{
-        //	 	pmu_set_idle_request(IDLE_REQ_VIO, true);
-        		cru_set_soft_reset(SOFT_RST_CIF1, true);
-        		udelay(5);
-        		cru_set_soft_reset(SOFT_RST_CIF1, false);
-        //		pmu_set_idle_request(IDLE_REQ_VIO, false);  
-            }
-#elif defined(CONFIG_ARCH_RK3188)
-//		pmu_set_idle_request(IDLE_REQ_VIO, true);
-		cru_set_soft_reset(SOFT_RST_CIF0, true);
-		udelay(5);
-		cru_set_soft_reset(SOFT_RST_CIF0, false);
-//		pmu_set_idle_request(IDLE_REQ_VIO, false);
 
-#endif
-        }
+    mdelay(100);
+    rk_camera_cif_reset(pcdev,true);
+    
     write_cif_reg(pcdev->base,CIF_CIF_CTRL,AXI_BURST_16|MODE_PINGPONG|DISABLE_CAPTURE);   /* ddl@rock-chips.com : vip ahb burst 16 */
-    write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0x01|0x200);    //capture complete interrupt enable
-#endif
+    //write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0x01|0x200);    /*capture complete interrupt enable*/
+
     write_cif_reg(pcdev->base,CIF_CIF_FOR,cif_fmt_val);         /* ddl@rock-chips.com: VIP capture mode and capture format must be set before FS register set */
 
-   // read_cif_reg(pcdev->base,CIF_CIF_INTSTAT);                /* clear vip interrupte single  */
-    write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0xFFFFFFFF);
-	/* 
-    if((read_cif_reg(pcdev->base,CIF_CIF_CTRL) & MODE_PINGPONG)
+    write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0xFFFFFFFF); 
+    /*if((read_cif_reg(pcdev->base,CIF_CIF_CTRL) & MODE_PINGPONG)
 		||(read_cif_reg(pcdev->base,CIF_CIF_CTRL) & MODE_LINELOOP)) {
 	    BUG();	
-    } else*/{ // this is one frame mode
-	    cif_crop = (rect->left+ (rect->top<<16));
-	    cif_fs	= ((rect->width ) + (rect->height<<16));
+    } else*/{ /* this is one frame mode*/
+	    cif_crop = (rect->left + (rect->top <<16));
+	    cif_fs	= (rect->width + (rect->height <<16));
 	}
 
 	write_cif_reg(pcdev->base,CIF_CIF_CROP, cif_crop);
@@ -2235,9 +1781,9 @@ static void rk_camera_setup_format(struct soc_camera_device *icd, __u32 host_pix
 	write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH, rect->width);
 	write_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS,  0x00000003);
 
-    //MUST bypass scale 
+    /*MUST bypass scale */
 	write_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL,0x10);
-    RK30_CAM_DEBUG_TRACE("%s.. crop:0x%x fs:0x%x cif_fmt_val:0x%x CIF_CIF_FOR:0x%x\n",__FUNCTION__,cif_crop,cif_fs,cif_fmt_val,read_cif_reg(pcdev->base,CIF_CIF_FOR));
+    RKCAMERA_DG1("CIF_CIF_CROP:0x%x  CIF_CIF_FS:0x%x  CIF_CIF_FOR:0x%x\n",cif_crop,cif_fs,cif_fmt_val);
 	return;
 }
 
@@ -2245,12 +1791,15 @@ static int rk_camera_get_formats(struct soc_camera_device *icd, unsigned int idx
 				  struct soc_camera_format_xlate *xlate)
 {
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-    struct device *dev = icd->dev.parent;
+	struct device *dev = icd->parent;/*yzm*/
     int formats = 0, ret;
 	enum v4l2_mbus_pixelcode code;
 	const struct soc_mbus_pixelfmt *fmt;
 
-	ret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
+	ret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);  /*call generic_sensor_enum_fmt()*/
 	if (ret < 0)
 		/* No more formats */
 		return 0;
@@ -2266,66 +1815,69 @@ static int rk_camera_get_formats(struct soc_camera_device *icd, unsigned int idx
         return 0;
 
     switch (code) {
-            case V4L2_MBUS_FMT_UYVY8_2X8:
-            case V4L2_MBUS_FMT_YUYV8_2X8:
-            case V4L2_MBUS_FMT_YVYU8_2X8:
-            case V4L2_MBUS_FMT_VYUY8_2X8:
+        case V4L2_MBUS_FMT_UYVY8_2X8:
+        case V4L2_MBUS_FMT_YUYV8_2X8:
+        case V4L2_MBUS_FMT_YVYU8_2X8:
+        case V4L2_MBUS_FMT_VYUY8_2X8:
+        {
+        
 #if (CONFIG_CAMERA_SCALE_CROP_MACHINE != RK_CAM_SCALE_CROP_RGA)
-		formats++;
-		if (xlate) {
-			xlate->host_fmt = &rk_camera_formats[0];
-			xlate->code = code;
-			xlate++;
-			dev_dbg(dev, "Providing format %s using code %d\n",
-				rk_camera_formats[0].name,code);
-		}
-		
-		formats++;
-		if (xlate) {
-			xlate->host_fmt = &rk_camera_formats[1];
-			xlate->code = code;
-			xlate++;
-			dev_dbg(dev, "Providing format %s using code %d\n",
-				rk_camera_formats[1].name,code);
-		}
-		
-		formats++;
-		if (xlate) {
-			xlate->host_fmt = &rk_camera_formats[2];
-			xlate->code = code;
-			xlate++;
-			dev_dbg(dev, "Providing format %s using code %d\n",
-				rk_camera_formats[2].name,code);
-		} 
-		
-		formats++;
-		if (xlate) {
-			xlate->host_fmt = &rk_camera_formats[3];
-			xlate->code = code;
-			xlate++;
-			dev_dbg(dev, "Providing format %s using code %d\n",
-				rk_camera_formats[3].name,code);
-		}
-		break;	
+    		formats++;
+    		if (xlate) {
+    			xlate->host_fmt = &rk_camera_formats[0];
+    			xlate->code = code;
+    			xlate++;
+    			dev_dbg(dev, "Providing format %s using code %d\n",
+    				rk_camera_formats[0].name,code);
+    		}
+    		
+    		formats++;
+    		if (xlate) {
+    			xlate->host_fmt = &rk_camera_formats[1];
+    			xlate->code = code;
+    			xlate++;
+    			dev_dbg(dev, "Providing format %s using code %d\n",
+    				rk_camera_formats[1].name,code);
+    		}
+    		
+    		formats++;
+    		if (xlate) {
+    			xlate->host_fmt = &rk_camera_formats[2];
+    			xlate->code = code;
+    			xlate++;
+    			dev_dbg(dev, "Providing format %s using code %d\n",
+    				rk_camera_formats[2].name,code);
+    		} 
+    		
+    		formats++;
+    		if (xlate) {
+    			xlate->host_fmt = &rk_camera_formats[3];
+    			xlate->code = code;
+    			xlate++;
+    			dev_dbg(dev, "Providing format %s using code %d\n",
+    				rk_camera_formats[3].name,code);
+    		}
+    		break;	
 #else 
-		formats++;
-		if (xlate) {
-			xlate->host_fmt = &rk_camera_formats[4];
-			xlate->code = code;
-			xlate++;
-			dev_dbg(dev, "Providing format %s using code %d\n",
-				rk_camera_formats[4].name,code);
-		}
-		formats++;
-		if (xlate) {
-			xlate->host_fmt = &rk_camera_formats[5];
-			xlate->code = code;
-			xlate++;
-			dev_dbg(dev, "Providing format %s using code %d\n",
-				rk_camera_formats[5].name,code);
-		}
+    		formats++;
+    		if (xlate) {
+    			xlate->host_fmt = &rk_camera_formats[4];
+    			xlate->code = code;
+    			xlate++;
+    			dev_dbg(dev, "Providing format %s using code %d\n",
+    				rk_camera_formats[4].name,code);
+    		}
+    		formats++;
+    		if (xlate) {
+    			xlate->host_fmt = &rk_camera_formats[5];
+    			xlate->code = code;
+    			xlate++;
+    			dev_dbg(dev, "Providing format %s using code %d\n",
+    				rk_camera_formats[5].name,code);
+    		}
 			break;		
 #endif			
+        }
         default:
             break;
     }
@@ -2335,13 +1887,34 @@ static int rk_camera_get_formats(struct soc_camera_device *icd, unsigned int idx
 
 static void rk_camera_put_formats(struct soc_camera_device *icd)
 {
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
 	return;
 }
+static int rk_camera_cropcap(struct soc_camera_device *icd, struct v4l2_cropcap *cropcap)
+{
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+    int ret=0;
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+    ret = v4l2_subdev_call(sd, video, cropcap, cropcap);
+    if (ret != 0)
+        goto end;
+    /* ddl@rock-chips.com: driver decide the cropping rectangle */
+    memset(&cropcap->defrect,0x00,sizeof(struct v4l2_rect));
+end:    
+    return ret;
+}
 static int rk_camera_get_crop(struct soc_camera_device *icd,struct v4l2_crop *crop)
 {
-    struct soc_camera_host *ici =to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     spin_lock(&pcdev->cropinfo.lock);
     memcpy(&crop->c,&pcdev->cropinfo.c,sizeof(struct v4l2_rect));
     spin_unlock(&pcdev->cropinfo.lock);
@@ -2349,46 +1922,55 @@ static int rk_camera_get_crop(struct soc_camera_device *icd,struct v4l2_crop *cr
     return 0;
 }
 static int rk_camera_set_crop(struct soc_camera_device *icd,
-			       struct v4l2_crop *a)
+			       const struct v4l2_crop *crop)
 {
-    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-	struct v4l2_mbus_framefmt mf;
-	u32 fourcc = icd->current_fmt->host_fmt->fourcc;
-    int ret;
-
-    ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
-    if (ret < 0)
-        return ret;
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
+    struct rk_camera_dev *pcdev = ici->priv;
 
-    if ((mf.width < (a->c.left + a->c.width)) || (mf.height < (a->c.top + a->c.height)))  {
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
 
-        mf.width = a->c.left + a->c.width;
-        mf.height = a->c.top + a->c.height;
 
-        v4l_bound_align_image(&mf.width, RK_CAM_W_MIN, RK_CAM_W_MAX, 1,
-            &mf.height, RK_CAM_H_MIN, RK_CAM_H_MAX, 0,
-            fourcc == V4L2_PIX_FMT_NV16 ?4 : 0);
+    spin_lock(&pcdev->cropinfo.lock);
+    memcpy(&pcdev->cropinfo.c,&crop->c,sizeof(struct v4l2_rect));
+    spin_unlock(&pcdev->cropinfo.lock);
+    return 0;
+}
+static bool rk_camera_fmt_capturechk(struct v4l2_format *f)
+{
+    bool ret = false;
 
-        ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
-        if (ret < 0)
-            return ret;
-    }
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
 
-    rk_camera_setup_format(icd, fourcc, mf.code, &a->c);
 
-    icd->user_width = mf.width;
-    icd->user_height = mf.height;
+    if (f->fmt.pix.priv == 0xfefe5a5a) {
+        ret = true;
+    }   
+   
+	if ((f->fmt.pix.width == 1024) && (f->fmt.pix.height == 768)) {
+		ret = true;
+	} else if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 1024)) {
+		ret = true;
+	} else if ((f->fmt.pix.width == 1600) && (f->fmt.pix.height == 1200)) {
+		ret = true;
+	} else if ((f->fmt.pix.width == 2048) && (f->fmt.pix.height == 1536)) {
+		ret = true;
+	} else if ((f->fmt.pix.width == 2592) && (f->fmt.pix.height == 1944)) {
+		ret = true;
+	} else if ((f->fmt.pix.width == 3264) && (f->fmt.pix.height == 2448)) {
+		ret = true;
+	}
 
-    return 0;
+	if (ret == true)
+		RKCAMERA_DG1("%dx%d is capture format\n",f->fmt.pix.width, f->fmt.pix.height);
+	return ret;
 }
-
 static int rk_camera_set_fmt(struct soc_camera_device *icd,
 			      struct v4l2_format *f)
 {
-    struct device *dev = icd->dev.parent;
+	struct device *dev = icd->parent;/*yzm*/
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     const struct soc_camera_format_xlate *xlate = NULL;
-	struct soc_camera_host *ici =to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
     struct v4l2_pix_format *pix = &f->fmt.pix;
     struct v4l2_mbus_framefmt mf;
@@ -2396,11 +1978,14 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     int ret,usr_w,usr_h,sensor_w,sensor_h;
     int stream_on = 0;
     int ratio, bounds_aspect;
-    
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	
 	usr_w = pix->width;
 	usr_h = pix->height;
     
-    RK30_CAM_DEBUG_TRACE("enter width:%d  height:%d\n",usr_w,usr_h);
+    RKCAMERA_DG1("enter width:%d  height:%d\n",usr_w,usr_h);
     xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
     if (!xlate) {
         dev_err(dev, "Format %x not found\n", pix->pixelformat);
@@ -2410,9 +1995,9 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     
     /* ddl@rock-chips.com: sensor init code transmit in here after open */
     if (pcdev->icd_init == 0) {
-        v4l2_subdev_call(sd,core, init, 0); 
+        v4l2_subdev_call(sd,core, init, 0);  /*call generic_sensor_init()*/
         pcdev->icd_init = 1;
-        return 0;
+        return 0;							/*directly return !!!!!!*/
     }
     stream_on = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
     if (stream_on & ENABLE_CAPTURE)
@@ -2426,7 +2011,7 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     mf.reserved[0] = pix->priv;              /* ddl@rock-chips.com : v0.3.3 */
     mf.reserved[1] = 0;
 
-    ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
+    ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);  /*generic_sensor_s_fmt*/
     if (mf.code != xlate->code)
 		return -EINVAL;    		
 
@@ -2434,7 +2019,7 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
         (pcdev->cropinfo.c.height == pcdev->cropinfo.bounds.height)) {
         bounds_aspect = (pcdev->cropinfo.bounds.width*10/pcdev->cropinfo.bounds.height);
         if ((mf.width*10/mf.height) != bounds_aspect) {
-            RK30_CAM_DEBUG_TRACE("User request fov unchanged in %dx%d, But sensor %dx%d is croped, so switch to full resolution %dx%d\n",
+            RKCAMERA_DG1("User request fov unchanged in %dx%d, But sensor %dx%d is croped, so switch to full resolution %dx%d\n",
                         usr_w,usr_h,mf.width, mf.height,pcdev->cropinfo.bounds.width,pcdev->cropinfo.bounds.height);
             
             mf.width	= pcdev->cropinfo.bounds.width/4;
@@ -2455,10 +2040,10 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     sensor_w = mf.width;
     sensor_h = mf.height;
 
-    ratio = ((mf.width*mf.reserved[1])/100)&(~0x03);      // 4 align
+    ratio = ((mf.width*mf.reserved[1])/100)&(~0x03);      /* 4 align*/
     mf.width -= ratio;
 
-    ratio = ((ratio*mf.height/mf.width)+1)&(~0x01);       // 2 align
+    ratio = ((ratio*mf.height/mf.width)+1)&(~0x01);       /* 2 align*/
     mf.height -= ratio;
 
 	if ((mf.width != usr_w) || (mf.height != usr_h)) {
@@ -2477,7 +2062,7 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
 		spin_lock(&pcdev->cropinfo.lock);
 		if (((mf.width*10/mf.height) != (usr_w*10/usr_h))) {  
             if ((pcdev->cropinfo.c.width == 0)&&(pcdev->cropinfo.c.height == 0)) {        
-                //Scale + Crop center is for keep aspect ratio unchange
+                /*Scale + Crop center is for keep aspect ratio unchange*/
                 ratio = ((mf.width*10/usr_w) >= (mf.height*10/usr_h))?(mf.height*10/usr_h):(mf.width*10/usr_w);
                 pcdev->host_width = ratio*usr_w/10;
                 pcdev->host_height = ratio*usr_h/10;
@@ -2487,7 +2072,7 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
                 pcdev->host_left = ((sensor_w-pcdev->host_width )>>1);
                 pcdev->host_top = ((sensor_h-pcdev->host_height)>>1);
             } else {    
-                //Scale + crop(user define)
+                /*Scale + crop(user define)*/
                 pcdev->host_width = pcdev->cropinfo.c.width*mf.width/pcdev->cropinfo.bounds.width;
                 pcdev->host_height = pcdev->cropinfo.c.height*mf.height/pcdev->cropinfo.bounds.height;
                 pcdev->host_left = (pcdev->cropinfo.c.left*mf.width/pcdev->cropinfo.bounds.width);
@@ -2498,13 +2083,13 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
             pcdev->host_top &= (~0x01);
         } else { 
             if ((pcdev->cropinfo.c.width == 0)&&(pcdev->cropinfo.c.height == 0)) {
-                //Crop Center for cif can work , then scale
+                /*Crop Center for cif can work , then scale*/
                 pcdev->host_width = mf.width;
                 pcdev->host_height = mf.height;
                 pcdev->host_left = ((sensor_w - mf.width)>>1)&(~0x01);
                 pcdev->host_top = ((sensor_h - mf.height)>>1)&(~0x01);
             } else {
-                //Crop center for cif can work + crop(user define), then scale 
+                /*Crop center for cif can work + crop(user define), then scale */
                 pcdev->host_width = pcdev->cropinfo.c.width*mf.width/pcdev->cropinfo.bounds.width;
                 pcdev->host_height = pcdev->cropinfo.c.height*mf.height/pcdev->cropinfo.bounds.height;
                 pcdev->host_left = (pcdev->cropinfo.c.left*mf.width/pcdev->cropinfo.bounds.width)+((sensor_w - mf.width)>>1);
@@ -2539,7 +2124,7 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     	rect.top = pcdev->host_top;
         
         down(&pcdev->zoominfo.sem);
-#if CIF_DO_CROP   // this crop is only for digital zoom
+#if CIF_DO_CROP   /* this crop is only for digital zoom*/
         pcdev->zoominfo.a.c.left = 0;
         pcdev->zoominfo.a.c.top = 0;
         pcdev->zoominfo.a.c.width = pcdev->host_width*100/pcdev->zoominfo.zoom_rate;
@@ -2548,7 +2133,7 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
         pcdev->zoominfo.a.c.height &= ~CROP_ALIGN_BYTES;
         pcdev->zoominfo.vir_width = pcdev->zoominfo.a.c.width;
         pcdev->zoominfo.vir_height = pcdev->zoominfo.a.c.height;
-        //recalculate the CIF width & height
+        /*recalculate the CIF width & height*/
         rect.width = pcdev->zoominfo.a.c.width ;
         rect.height = pcdev->zoominfo.a.c.height;
         rect.left = ((((pcdev->host_width - pcdev->zoominfo.a.c.width)>>1))+pcdev->host_left)&(~0x01);
@@ -2558,7 +2143,7 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
         pcdev->zoominfo.a.c.width &= ~CROP_ALIGN_BYTES;
         pcdev->zoominfo.a.c.height = pcdev->host_height*100/pcdev->zoominfo.zoom_rate;
         pcdev->zoominfo.a.c.height &= ~CROP_ALIGN_BYTES;
-        //now digital zoom use ipp to do crop and scale
+        /*now digital zoom use ipp to do crop and scale*/
         if(pcdev->zoominfo.zoom_rate != 100){
             pcdev->zoominfo.a.c.left = ((pcdev->host_width - pcdev->zoominfo.a.c.width)>>1)&(~0x01);
             pcdev->zoominfo.a.c.top = ((pcdev->host_height - pcdev->zoominfo.a.c.height)>>1)&(~0x01);
@@ -2588,13 +2173,14 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
             }
         }
         
-        RK30_CAM_DEBUG_TRACE("%s CIF Host:%dx%d@(%d,%d) Sensor:%dx%d->%dx%d User crop:(%d,%d,%d,%d)in(%d,%d) (zoom: %dx%d@(%d,%d)->%dx%d)\n",xlate->host_fmt->name,
+        RKCAMERA_DG1("%s CIF Host:%dx%d@(%d,%d) Sensor:%dx%d->%dx%d User crop:(%d,%d,%d,%d)in(%d,%d) (zoom: %dx%d@(%d,%d)->%dx%d)\n",xlate->host_fmt->name,
 			           pcdev->host_width,pcdev->host_height,pcdev->host_left,pcdev->host_top,
 			           sensor_w,sensor_h,mf.width,mf.height,
 			           pcdev->cropinfo.c.left,pcdev->cropinfo.c.top,pcdev->cropinfo.c.width,pcdev->cropinfo.c.height,
 			           pcdev->cropinfo.bounds.width,pcdev->cropinfo.bounds.height,
 			           pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height, pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,
 			           pix->width, pix->height);
+			           
         rk_camera_setup_format(icd, pix->pixelformat, mf.code, &rect); 
         
 		if (CAM_IPPWORK_IS_EN()) {
@@ -2616,39 +2202,18 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     	RKCAMERA_TR("\n%s..%d.. ret = %d  \n",__FUNCTION__,__LINE__, ret);
     return ret;
 }
-static bool rk_camera_fmt_capturechk(struct v4l2_format *f)
-{
-    bool ret = false;
-
-	if ((f->fmt.pix.width == 1024) && (f->fmt.pix.height == 768)) {
-		ret = true;
-	} else if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 1024)) {
-		ret = true;
-	} else if ((f->fmt.pix.width == 1600) && (f->fmt.pix.height == 1200)) {
-		ret = true;
-	} else if ((f->fmt.pix.width == 2048) && (f->fmt.pix.height == 1536)) {
-		ret = true;
-	} else if ((f->fmt.pix.width == 2592) && (f->fmt.pix.height == 1944)) {
-		ret = true;
-	} else if ((f->fmt.pix.width == 3264) && (f->fmt.pix.height == 2448)) {
-		ret = true;
-	}
 
-	if (ret == true)
-		RK30_CAM_DEBUG_TRACE("%s %dx%d is capture format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
-	return ret;
-}
 static int rk_camera_try_fmt(struct soc_camera_device *icd,
                                    struct v4l2_format *f)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
 	struct rk_camera_dev *pcdev = ici->priv;
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     const struct soc_camera_format_xlate *xlate;
     struct v4l2_pix_format *pix = &f->fmt.pix;
     __u32 pixfmt = pix->pixelformat;
     int ret,usr_w,usr_h,i;
-	bool is_capture = rk_camera_fmt_capturechk(f);
+	bool is_capture = rk_camera_fmt_capturechk(f);  /* testing f is in line with the already set*/
 	bool vipmem_is_overflow = false;
     struct v4l2_mbus_framefmt mf;
     int bytes_per_line_host;
@@ -2656,15 +2221,18 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
 	usr_w = pix->width;
 	usr_h = pix->height;
     
-    xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);  
     if (!xlate) {
-        dev_err(icd->dev.parent, "Format (%c%c%c%c) not found\n", pixfmt & 0xFF, (pixfmt >> 8) & 0xFF,
+        /*dev_err(icd->dev.parent, "Format (%c%c%c%c) not found\n", pixfmt & 0xFF, (pixfmt >> 8) & 0xFF,*/
+		dev_err(icd->parent, "Format (%c%c%c%c) not found\n", pixfmt & 0xFF, (pixfmt >> 8) & 0xFF,/*yzm*/
 			(pixfmt >> 16) & 0xFF, (pixfmt >> 24) & 0xFF);
         ret = -EINVAL;
-        RK30_CAM_DEBUG_TRACE("%s(version:%c%c%c) support format:\n",rk_cam_driver_description,(RK_CAM_VERSION_CODE&0xff0000)>>16,
+        RKCAMERA_TR("%s(version:%c%c%c) support format:\n",rk_cam_driver_description,(RK_CAM_VERSION_CODE&0xff0000)>>16,
             (RK_CAM_VERSION_CODE&0xff00)>>8,(RK_CAM_VERSION_CODE&0xff));
         for (i = 0; i < icd->num_user_formats; i++)
-		    RK30_CAM_DEBUG_TRACE("(%c%c%c%c)-%s\n",
+		    RKCAMERA_TR("(%c%c%c%c)-%s\n",
 		    icd->user_formats[i].host_fmt->fourcc & 0xFF, (icd->user_formats[i].host_fmt->fourcc >> 8) & 0xFF,
 			(icd->user_formats[i].host_fmt->fourcc >> 16) & 0xFF, (icd->user_formats[i].host_fmt->fourcc >> 24) & 0xFF,
 			icd->user_formats[i].host_fmt->name);
@@ -2691,39 +2259,34 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
     if ((usr_w == 10000) && (usr_h == 10000)) {
         mf.reserved[6] = 0xfefe5a5a;
     }
-
+	/* call generic_sensor_try_fmt()*/
 	ret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);
 	if (ret < 0)
 		goto RK_CAMERA_TRY_FMT_END;
     
-	//query resolution.
+	/*query resolution.*/
 	if((usr_w == 10000) && (usr_h == 10000)) {
 		pix->width = mf.width;
         pix->height = mf.height;
-        RK30_CAM_DEBUG_TRACE("%s: Sensor resolution : %dx%d\n",__FUNCTION__,mf.width,mf.height);
+        RKCAMERA_DG1("Sensor resolution : %dx%d\n",mf.width,mf.height);
 		goto RK_CAMERA_TRY_FMT_END;
 	} else {
-        RK30_CAM_DEBUG_TRACE("%s: user demand: %dx%d  sensor output: %dx%d \n",__FUNCTION__,usr_w,usr_h,mf.width,mf.height);
-	}
-    
-	#ifdef CONFIG_VIDEO_RK29_WORK_IPP       
+        RKCAMERA_DG1("user demand: %dx%d  sensor output: %dx%d \n",usr_w,usr_h,mf.width,mf.height);
+	}    
+	    
 	if ((mf.width != usr_w) || (mf.height != usr_h)) {
         bytes_per_line_host = soc_mbus_bytes_per_line(mf.width,icd->current_fmt->host_fmt); 
-        #ifndef OPTIMIZE_MEMORY_USE
 		if (is_capture) {
 			vipmem_is_overflow = (PAGE_ALIGN(bytes_per_line_host*mf.height) > pcdev->vipmem_size);
 		} else {
 			/* Assume preview buffer minimum is 4 */
 			vipmem_is_overflow = (PAGE_ALIGN(bytes_per_line_host*mf.height)*4 > pcdev->vipmem_size);
-		}
-		#else
-		    vipmem_is_overflow =false;
-		#endif
+		}        
 		if (vipmem_is_overflow == false) {
 			pix->width = usr_w;
 			pix->height = usr_h;
 		} else {
-			RK30_CAM_DEBUG_TRACE("vipmem for IPP is overflow, This resolution(%dx%d -> %dx%d) is invalidate!\n",mf.width,mf.height,usr_w,usr_h);
+			/*RKCAMERA_TR("vipmem for IPP is overflow, This resolution(%dx%d -> %dx%d) is invalidate!\n",mf.width,mf.height,usr_w,usr_h);*/ /*yzm*/
             pix->width = mf.width;
             pix->height = mf.height;            
 		}
@@ -2731,24 +2294,14 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
         #if 0     
         if ((mf.width < usr_w) || (mf.height < usr_h)) {
             if (((usr_w>>1) > mf.width) || ((usr_h>>1) > mf.height)) {
-                RK30_CAM_DEBUG_TRACE("The aspect ratio(%dx%d/%dx%d) is bigger than 2 !\n",mf.width,mf.height,usr_w,usr_h);
+                RKCAMERA_TR("The aspect ratio(%dx%d/%dx%d) is bigger than 2 !\n",mf.width,mf.height,usr_w,usr_h);
                 pix->width = mf.width;
                 pix->height = mf.height;
             }
         }    
         #endif
 	}
-	#else
-	//need to change according to crop and scale capablicity
-	if ((mf.width > usr_w) && (mf.height > usr_h)) {
-			pix->width = usr_w;
-			pix->height = usr_h;
-	    } else if ((mf.width < usr_w) && (mf.height < usr_h)) {
-			RK30_CAM_DEBUG_TRACE("%dx%d can't scale up to %dx%d!\n",mf.width,mf.height,usr_w,usr_h);
-            pix->width	= mf.width;
-        	pix->height	= mf.height;	
-        }
-    #endif
+	
     pix->colorspace	= mf.colorspace;    
 
     switch (mf.field) {
@@ -2758,14 +2311,14 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
 		break;
 	default:
 		/* TODO: support interlaced at least in pass-through mode */
-		dev_err(icd->dev.parent, "Field type %d unsupported.\n",
+		dev_err(icd->parent, "Field type %d unsupported.\n",
 			mf.field);
 		goto RK_CAMERA_TRY_FMT_END;
 	}
 
 RK_CAMERA_TRY_FMT_END:
-	if (ret)
-    	RK30_CAM_DEBUG_TRACE("\n%s..%d.. ret = %d  \n",__FUNCTION__,__LINE__, ret);
+	if (ret<0)
+    	RKCAMERA_TR("\n%s..%d.. ret = %d  \n",__FUNCTION__,__LINE__, ret);
     return ret;
 }
 
@@ -2774,6 +2327,9 @@ static int rk_camera_reqbufs(struct soc_camera_device *icd,
 {
     int i;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     /* This is for locking debugging only. I removed spinlocks and now I
      * check whether .prepare is ever called on a linked buffer, or whether
      * a dma IRQ can occur for an in-work or unlinked buffer. Until now
@@ -2793,6 +2349,9 @@ static unsigned int rk_camera_poll(struct file *file, poll_table *pt)
     struct soc_camera_device *icd = file->private_data;
     struct rk_camera_buffer *buf;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     buf = list_entry(icd->vb_vidq.stream.next, struct rk_camera_buffer,
                     vb.stream);
 
@@ -2804,6 +2363,10 @@ static unsigned int rk_camera_poll(struct file *file, poll_table *pt)
 
     return 0;
 }
+/*
+*card:  sensor name _ facing _ device index - orientation _ fov horizontal _ fov vertical
+*           10          5           1            3              3                3         + 5 < 32           
+*/
 
 static int rk_camera_querycap(struct soc_camera_host *ici,
                                 struct v4l2_capability *cap)
@@ -2814,49 +2377,49 @@ static int rk_camera_querycap(struct soc_camera_host *ici,
     char fov[9];
     int i;
 
-    strlcpy(cap->card, dev_name(pcdev->icd->pdev), 20);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
+    strlcpy(cap->card, dev_name(pcdev->icd->pdev), 18);       
     memset(orientation,0x00,sizeof(orientation));
-    for (i=0; i<RK_CAM_NUM;i++) {
-        if ((pcdev->pdata->info[i].dev_name!=NULL) && (strcmp(dev_name(pcdev->icd->pdev), pcdev->pdata->info[i].dev_name) == 0)) {
-            sprintf(orientation,"-%d",pcdev->pdata->info[i].orientation);
-            sprintf(fov,"_50_50");
-        }
-    }
 
     i=0;
     new_camera = pcdev->pdata->register_dev_new;
-    while (strstr(new_camera->dev_name,"end")==NULL) {
+    while(new_camera != NULL){
         if (strcmp(dev_name(pcdev->icd->pdev), new_camera->dev_name) == 0) {
             sprintf(orientation,"-%d",new_camera->orientation);
             sprintf(fov,"_%d_%d",new_camera->fov_h,new_camera->fov_v);
         }
-        new_camera++;
+        new_camera = new_camera->next_camera;
     }
-
+    
     if (orientation[0] != '-') {
         RKCAMERA_TR("%s: %s is not registered in rk29_camera_platform_data, orientation apply default value",__FUNCTION__,dev_name(pcdev->icd->pdev));
-        if (strstr(dev_name(pcdev->icd->pdev),"front"))
+        if (strstr(dev_name(pcdev->icd->pdev),"front")) 
             strcat(cap->card,"-270");
-        else
+        else 
             strcat(cap->card,"-90");
     } else {
-        strcat(cap->card,orientation);
+        strcat(cap->card,orientation); 
     }
-
+    
     strcat(cap->card,fov);                          /* ddl@rock-chips.com: v0.3.f */
     cap->version = RK_CAM_VERSION_CODE;
     cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 
     return 0;
 }
 static int rk_camera_suspend(struct soc_camera_device *icd, pm_message_t state)
 {
-    struct soc_camera_host *ici =
-                    to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
 	struct v4l2_subdev *sd;
     int ret = 0;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 	mutex_lock(&camera_lock);
 	if ((pcdev->icd == icd) && (icd->ops->suspend)) {
 		rk_camera_s_stream(icd, 0);
@@ -2875,9 +2438,9 @@ static int rk_camera_suspend(struct soc_camera_device *icd, pm_message_t state)
 		pcdev->reginfo_suspend.Inval = Reg_Validate;
 		rk_camera_deactivate(pcdev);
 
-		RK30_CAM_DEBUG_TRACE("%s Enter Success...\n", __FUNCTION__);
+		RKCAMERA_DG1("%s Enter Success...\n", __FUNCTION__);
 	} else {
-		RK30_CAM_DEBUG_TRACE("%s icd has been deattach, don't need enter suspend\n", __FUNCTION__);
+		RKCAMERA_DG1("%s icd has been deattach, don't need enter suspend\n", __FUNCTION__);
 	}
 	mutex_unlock(&camera_lock);
     return ret;
@@ -2885,12 +2448,14 @@ static int rk_camera_suspend(struct soc_camera_device *icd, pm_message_t state)
 
 static int rk_camera_resume(struct soc_camera_device *icd)
 {
-    struct soc_camera_host *ici =
-                    to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
 	struct v4l2_subdev *sd;
     int ret = 0;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 	mutex_lock(&camera_lock);
 	if ((pcdev->icd == icd) && (icd->ops->resume)) {
 		if (pcdev->reginfo_suspend.Inval == Reg_Validate) {
@@ -2902,12 +2467,13 @@ static int rk_camera_resume(struct soc_camera_device *icd)
 			write_cif_reg(pcdev->base,CIF_CIF_FOR, pcdev->reginfo_suspend.cifFmt);
 			write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH,pcdev->reginfo_suspend.cifVirWidth);
 			write_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL, pcdev->reginfo_suspend.cifScale);
+			//rk_videobuf_capture(pcdev->active,pcdev);			
 			rk_videobuf_capture(pcdev->active0,pcdev,0);
-			rk_videobuf_capture(pcdev->active0,pcdev,1);
+			rk_videobuf_capture(pcdev->active1,pcdev,1);
 			rk_camera_s_stream(icd, 1);
 			pcdev->reginfo_suspend.Inval = Reg_Invalidate;
 		} else {
-			RK30_CAM_DEBUG_TRACE("Resume fail, vip register recored is invalidate!!\n");
+			RKCAMERA_TR("Resume fail, vip register recored is invalidate!!\n");
 			goto rk_camera_resume_end;
 		}
 
@@ -2915,9 +2481,9 @@ static int rk_camera_resume(struct soc_camera_device *icd)
 		sd = soc_camera_to_subdev(icd);
 		v4l2_subdev_call(sd, video, s_stream, 1);
 
-		RK30_CAM_DEBUG_TRACE("%s Enter success\n",__FUNCTION__);
+		RKCAMERA_DG1("%s Enter success\n",__FUNCTION__);
 	} else {
-		RK30_CAM_DEBUG_TRACE("%s icd has been deattach, don't need enter resume\n", __FUNCTION__);
+		RKCAMERA_DG1("%s icd has been deattach, don't need enter resume\n", __FUNCTION__);
 	}
 
 rk_camera_resume_end:
@@ -2930,56 +2496,94 @@ static void rk_camera_reinit_work(struct work_struct *work)
     struct v4l2_subdev *sd;
 	struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);
 	struct rk_camera_dev *pcdev = camera_work->pcdev;
-    struct soc_camera_link *tmp_soc_cam_link;
+    /*struct soc_camera_link *tmp_soc_cam_link;*/
+    struct v4l2_mbus_framefmt mf;
     int index = 0;
 	unsigned long flags = 0;
+    int ctrl;
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+	//return;
+	
     if(pcdev->icd == NULL)
         return;
     sd = soc_camera_to_subdev(pcdev->icd);
-    tmp_soc_cam_link = to_soc_camera_link(pcdev->icd);
-	//dump regs
+    /*tmp_soc_cam_desc = to_soc_camera_link(pcdev->icd);*/ /*yzm*/
+	/*dump regs*/
 	{
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_CTRL = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_CTRL));
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_INTEN = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_INTEN));
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_INTSTAT = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_INTSTAT));
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_FOR = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_FOR));
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_CROP = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_CROP));
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_SET_SIZE = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE));
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_SCL_CTRL = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL));
-		RK30_CAM_DEBUG_TRACE("CRU_PCLK_REG30 = 0X%x\n",read_cru_reg(CRU_PCLK_REG30));
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_LAST_LINE = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_LINE));
+		RKCAMERA_TR("CIF_CIF_CTRL = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_CTRL));
+		RKCAMERA_TR("CIF_CIF_INTEN = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_INTEN));
+		RKCAMERA_TR("CIF_CIF_INTSTAT = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_INTSTAT));
+		RKCAMERA_TR("CIF_CIF_FOR = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_FOR));
+		RKCAMERA_TR("CIF_CIF_CROP = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_CROP));
+		RKCAMERA_TR("CIF_CIF_SET_SIZE = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE));
+		RKCAMERA_TR("CIF_CIF_SCL_CTRL = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL));
+		RKCAMERA_TR("CRU_PCLK_REG30 = 0X%lx\n",read_cru_reg(CRU_PCLK_REG30));
+		RKCAMERA_TR("CIF_CIF_LAST_LINE = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_LINE));
 		
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_LAST_PIX = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_PIX));
-		RK30_CAM_DEBUG_TRACE("CIF_CIF_VIR_LINE_WIDTH = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH));
-    	RK30_CAM_DEBUG_TRACE("CIF_CIF_LINE_NUM_ADDR = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LINE_NUM_ADDR));
-    	RK30_CAM_DEBUG_TRACE("CIF_CIF_FRM0_ADDR_Y = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y));
-    	RK30_CAM_DEBUG_TRACE("CIF_CIF_FRM0_ADDR_UV = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV));
-    	RK30_CAM_DEBUG_TRACE("CIF_CIF_FRAME_STATUS = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS));
+		RKCAMERA_TR("CIF_CIF_LAST_PIX = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_PIX));
+		RKCAMERA_TR("CIF_CIF_VIR_LINE_WIDTH = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH));
+    	RKCAMERA_TR("CIF_CIF_LINE_NUM_ADDR = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_LINE_NUM_ADDR));
+    	RKCAMERA_TR("CIF_CIF_FRM0_ADDR_Y = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y));
+    	RKCAMERA_TR("CIF_CIF_FRM0_ADDR_UV = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV));
+    	RKCAMERA_TR("CIF_CIF_FRAME_STATUS = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS));
+    	RKCAMERA_TR("CIF_CIF_SCL_VALID_NUM = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_SCL_VALID_NUM));
+    	RKCAMERA_TR("CIF_CIF_CUR_DST = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_CUR_DST));
+    	RKCAMERA_TR("CIF_CIF_LINE_NUM_ADDR = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_LINE_NUM_ADDR));
 	}
-    return;
-    pcdev->stop_cif = true;
-	write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)&(~ENABLE_CAPTURE)));
-	RK30_CAM_DEBUG_TRACE("the reinit times = %d\n",pcdev->reinit_times);
-   if(pcdev->video_vq && pcdev->video_vq->irqlock){
-   	spin_lock_irqsave(pcdev->video_vq->irqlock, flags);
-    	for (index = 0; index < VIDEO_MAX_FRAME; index++) {
-    		if (NULL == pcdev->video_vq->bufs[index])
-    			continue;
+	
+    ctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);          /*ddl@rock-chips.com v0.3.0x13*/
+    if (pcdev->reinit_times == 1) {
+        if (ctrl & ENABLE_CAPTURE) {        
+            RKCAMERA_TR("Sensor data transfer may be error, so reset CIF and reinit sensor for resume!\n");
+            pcdev->irqinfo.cifirq_idx = pcdev->irqinfo.dmairq_idx;
+            rk_camera_cif_reset(pcdev,false);
+
+            
+            v4l2_subdev_call(sd,core, init, 0); 
+            
+            mf.width	= pcdev->icd_width;
+            mf.height	= pcdev->icd_height;
+            mf.field	= V4L2_FIELD_NONE;            
+            mf.code		= pcdev->icd->current_fmt->code;
+            mf.reserved[0] = 0x5a5afefe;              
+            mf.reserved[1] = 0;
+
+            v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
             
-    		if (pcdev->video_vq->bufs[index]->state == VIDEOBUF_QUEUED) 
-            {
-    			list_del_init(&pcdev->video_vq->bufs[index]->queue);
-    			pcdev->video_vq->bufs[index]->state = VIDEOBUF_NEEDS_INIT;
-    			wake_up_all(&pcdev->video_vq->bufs[index]->done);
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)|ENABLE_CAPTURE));
+        } else if (pcdev->irqinfo.cifirq_idx != pcdev->irqinfo.dmairq_idx) { 
+            RKCAMERA_TR("CIF may be error, so reset cif for resume\n");
+            pcdev->irqinfo.cifirq_idx = pcdev->irqinfo.dmairq_idx;
+            rk_camera_cif_reset(pcdev,false);
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)|ENABLE_CAPTURE));
+        }
+        return;
+    }
+    
+    atomic_set(&pcdev->stop_cif,true);
+	write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)&(~ENABLE_CAPTURE)));
+	RKCAMERA_DG1("the reinit times = %d\n",pcdev->reinit_times);
+	
+    if(pcdev->video_vq && pcdev->video_vq->irqlock){
+        spin_lock_irqsave(pcdev->video_vq->irqlock, flags);
+        for (index = 0; index < VIDEO_MAX_FRAME; index++) {
+            if (NULL == pcdev->video_vq->bufs[index])
+                continue;
+
+            if (pcdev->video_vq->bufs[index]->state == VIDEOBUF_QUEUED) {
+                list_del_init(&pcdev->video_vq->bufs[index]->queue);
+                pcdev->video_vq->bufs[index]->state = VIDEOBUF_NEEDS_INIT;
+                wake_up_all(&pcdev->video_vq->bufs[index]->done);
                 printk("wake up video buffer index = %d  !!!\n",index);
-    		}
-    	}
-    	spin_unlock_irqrestore(pcdev->video_vq->irqlock, flags); 
+            }
+        }
+        spin_unlock_irqrestore(pcdev->video_vq->irqlock, flags); 
     }else{
-    RK30_CAM_DEBUG_TRACE("video queue has somthing wrong !!\n");
+        RKCAMERA_TR("video queue has somthing wrong !!\n");
     }
 
-	RK30_CAM_DEBUG_TRACE("the %d reinit times ,wake up video buffers!\n ",pcdev->reinit_times);
+	RKCAMERA_TR("the %d reinit times ,wake up video buffers!\n ",pcdev->reinit_times);
 }
 static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
 {
@@ -2987,17 +2591,20 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
 	struct rk_camera_timer *fps_timer = container_of(timer, struct rk_camera_timer, timer);
 	struct rk_camera_dev *pcdev = fps_timer->pcdev;
     int rec_flag,i;
-   // static unsigned int last_fps = 0;
-    struct soc_camera_link *tmp_soc_cam_link;
-    tmp_soc_cam_link = to_soc_camera_link(pcdev->icd);
+	/*static unsigned int last_fps = 0;*/
+	/*struct soc_camera_link *tmp_soc_cam_link;*/ /*yzm*/
+	/*tmp_soc_cam_link = to_soc_camera_link(pcdev->icd);*/ /*yzm*/
 
-	RK30_CAM_DEBUG_TRACE("rk_camera_fps_func fps:%d\n",(pcdev->fps - pcdev->last_fps)/3);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+	RKCAMERA_DG1("rk_camera_fps_func fps:0x%x\n",pcdev->fps);
 	if ((pcdev->fps < 1) || (pcdev->last_fps == pcdev->fps)) {
-		RK30_CAM_DEBUG_TRACE("Camera host haven't recevie data from sensor,Reinit sensor delay,last fps = %d,pcdev->fps = %d!\n",pcdev->last_fps,pcdev->fps);
+		RKCAMERA_TR("Camera host haven't recevie data from sensor,last fps = %d,pcdev->fps = %d,cif_irq: %ld,dma_irq: %ld!\n",
+		            pcdev->last_fps,pcdev->fps,pcdev->irqinfo.cifirq_idx, pcdev->irqinfo.dmairq_idx);
 		pcdev->camera_reinit_work.pcdev = pcdev;
-		//INIT_WORK(&(pcdev->camera_reinit_work.work), rk_camera_reinit_work);
+		/*INIT_WORK(&(pcdev->camera_reinit_work.work), rk_camera_reinit_work);*/
         pcdev->reinit_times++;
-		queue_work(pcdev->camera_wq,&(pcdev->camera_reinit_work.work));
+		queue_work(pcdev->camera_wq,&(pcdev->camera_reinit_work.work));//
 	} else if(!pcdev->timer_get_fps) {
 	    pcdev->timer_get_fps = true;
 	    for (i=0; i<2; i++) {
@@ -3010,7 +2617,7 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
         fival_pre = fival_nxt;
         while (fival_nxt != NULL) {
 
-            RK30_CAM_DEBUG_TRACE("%s %c%c%c%c %dx%d framerate : %d/%d\n", dev_name(&pcdev->icd->dev),
+            RKCAMERA_DG1("%s %c%c%c%c %dx%d framerate : %d/%d\n", dev_name(pcdev->icd->control), /*yzm*/
                 fival_nxt->fival.pixel_format & 0xFF, (fival_nxt->fival.pixel_format >> 8) & 0xFF,
 			    (fival_nxt->fival.pixel_format >> 16) & 0xFF, (fival_nxt->fival.pixel_format >> 24),
 			    fival_nxt->fival.width, fival_nxt->fival.height, fival_nxt->fival.discrete.denominator,
@@ -3057,10 +2664,14 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
             }
         }
 	}
+
+    if ((pcdev->last_fps != pcdev->fps) && (pcdev->reinit_times))             /*ddl@rock-chips.com v0.3.0x13*/
+        pcdev->reinit_times = 0;
+	
     pcdev->last_fps = pcdev->fps ;
     pcdev->fps_timer.timer.node.expires= ktime_add_us(pcdev->fps_timer.timer.node.expires, ktime_to_us(ktime_set(3, 0)));
     pcdev->fps_timer.timer._softexpires= ktime_add_us(pcdev->fps_timer.timer._softexpires, ktime_to_us(ktime_set(3, 0)));
-    //return HRTIMER_NORESTART;
+    /*return HRTIMER_NORESTART;*/
     if(pcdev->reinit_times >=2)
         return HRTIMER_NORESTART;
     else
@@ -3068,65 +2679,80 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
 }
 static int rk_camera_s_stream(struct soc_camera_device *icd, int enable)
 {
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-	struct rk_camera_dev *pcdev = ici->priv;
-	int cif_ctrl_val;
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
+    struct rk_camera_dev *pcdev = ici->priv;
+    int cif_ctrl_val;
 	int ret;
 	unsigned long flags;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);	
+
 	WARN_ON(pcdev->icd != icd);
 
 	cif_ctrl_val = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
 	if (enable) {
 		pcdev->fps = 0;
-		pcdev->last_fps = 0;
-		pcdev->frame_interval = 0;
+        pcdev->last_fps = 0;
+        pcdev->frame_interval = 0;
 		hrtimer_cancel(&(pcdev->fps_timer.timer));
 		pcdev->fps_timer.pcdev = pcdev;
-		pcdev->timer_get_fps = false;
-		pcdev->reinit_times  = 0;
-		pcdev->stop_cif = false;
-		pcdev->cif_stopped = false;
-		//	hrtimer_start(&(pcdev->fps_timer.timer),ktime_set(3, 0),HRTIMER_MODE_REL);
+        pcdev->timer_get_fps = false;
+        pcdev->reinit_times  = 0;
+
+        spin_lock_irqsave(&pcdev->lock,flags);
+        atomic_set(&pcdev->stop_cif,false);
+        pcdev->irqinfo.cifirq_idx = 0;
+        pcdev->irqinfo.cifirq_normal_idx = 0;
+        pcdev->irqinfo.cifirq_abnormal_idx = 0;
+        pcdev->irqinfo.dmairq_idx = 0;
+		
+		write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0x01|0x200);    /*capture complete interrupt enable*/
 		cif_ctrl_val |= ENABLE_CAPTURE;
-		write_cif_reg(pcdev->base,CIF_CIF_CTRL, cif_ctrl_val);
+        write_cif_reg(pcdev->base,CIF_CIF_CTRL, cif_ctrl_val);
+        spin_unlock_irqrestore(&pcdev->lock,flags);
+        printk("%s:stream enable CIF_CIF_CTRL 0x%lx\n",__func__,read_cif_reg(pcdev->base,CIF_CIF_CTRL));
 		hrtimer_start(&(pcdev->fps_timer.timer),ktime_set(3, 0),HRTIMER_MODE_REL);
-		pcdev->fps_timer.istarted = true;
+        pcdev->fps_timer.istarted = true;
 	} else {
-	    //cancel timer before stop cif
+	    /*cancel timer before stop cif*/
 		ret = hrtimer_cancel(&pcdev->fps_timer.timer);
         pcdev->fps_timer.istarted = false;
         flush_work(&(pcdev->camera_reinit_work.work));
+        
         cif_ctrl_val &= ~ENABLE_CAPTURE;
 		spin_lock_irqsave(&pcdev->lock, flags);
-		//	write_cif_reg(pcdev->base,CIF_CIF_CTRL, cif_ctrl_val);
-        pcdev->stop_cif = true;
+    	write_cif_reg(pcdev->base,CIF_CIF_CTRL, cif_ctrl_val);
+        atomic_set(&pcdev->stop_cif,true);
+		write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0x0); 
     	spin_unlock_irqrestore(&pcdev->lock, flags);
-#if CONFIG_CIF_STOP_SYNC
-				init_waitqueue_head(&pcdev->cif_stop_done);
-				if (wait_event_timeout(pcdev->cif_stop_done, pcdev->cif_stopped, msecs_to_jiffies(1000)) == 0) {
-					RKCAMERA_DG("%s:%d, wait cif stop timeout!",__func__,__LINE__);
-				}
-#endif
-		//mdelay(35);
 		flush_workqueue((pcdev->camera_wq));
-		RK30_CAM_DEBUG_TRACE("STREAM_OFF cancel timer and flush work:0x%x \n", ret);
+		msleep(100);
 	}
-    //must be reinit,or will be somthing wrong in irq process.
+    /*must be reinit,or will be somthing wrong in irq process.*/
     if(enable == false) {
+        //pcdev->active = NULL;        
         pcdev->active0 = NULL;
 		pcdev->active1 = NULL;
+		pcdev->active_buf = 0;
         INIT_LIST_HEAD(&pcdev->capture);
-	}
+    }
+	RKCAMERA_DG1("s_stream: enable : 0x%x , CIF_CIF_CTRL = 0x%lx\n",enable,read_cif_reg(pcdev->base,CIF_CIF_CTRL));
 	return 0;
 }
 int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frmivalenum *fival)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
     struct rk_camera_dev *pcdev = ici->priv;
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     struct rk_camera_frmivalenum *fival_list = NULL;
     struct v4l2_frmivalenum *fival_head = NULL;
+    struct rkcamera_platform_data *new_camera;
     int i,ret = 0,index;
+    const struct soc_camera_format_xlate *xlate;
+    struct v4l2_mbus_framefmt mf;
+    __u32 pixfmt;
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);	
     
     index = fival->index & 0x00ffffff;
     if ((fival->index & 0xff000000) == 0xff000000) {   /* ddl@rock-chips.com: detect framerate */ 
@@ -3155,139 +2781,181 @@ int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frm
                 ret = -EINVAL;
             }
         } else {
-            RK30_CAM_DEBUG_TRACE("%s: fival_list is NULL\n",__FUNCTION__);
+            RKCAMERA_TR("%s: fival_list is NULL\n",__FUNCTION__);
             ret = -EINVAL;
         }
     }  else {  
 
-        for (i=0; i<RK_CAM_NUM; i++) {
-            if (pcdev->pdata->info[i].dev_name && (strcmp(dev_name(pcdev->icd->pdev),pcdev->pdata->info[i].dev_name) == 0)) {
-                fival_head = pcdev->pdata->info[i].fival;
-            }
-        }
-        
-        if (fival_head == NULL) {
-            RK30_CAM_DEBUG_TRACE("%s: %s is not registered in rk_camera_platform_data!!",__FUNCTION__,dev_name(pcdev->icd->pdev));
-            ret = -EINVAL;
-            goto rk_camera_enum_frameintervals_end;
-        }
-        
-        i = 0;
-        while (fival_head->width && fival_head->height) {
-            if ((fival->pixel_format == fival_head->pixel_format)
-                && (fival->height == fival_head->height) 
-                && (fival->width == fival_head->width)) {
-                if (i == index) {
-                    break;
+        if (fival_head) {
+            i = 0;
+            while (fival_head->width && fival_head->height) {
+                if ((fival->pixel_format == fival_head->pixel_format)
+                    && (fival->height == fival_head->height) 
+                    && (fival->width == fival_head->width)) {
+                    if (i == index) {
+                        break;
+                    }
+                    i++;
                 }
-                i++;
+                fival_head++;  
             }
-            fival_head++;  
-        }
 
-        if ((i == index) && (fival->height == fival_head->height) && (fival->width == fival_head->width)) {
-            memcpy(fival, fival_head, sizeof(struct v4l2_frmivalenum));
-            RK30_CAM_DEBUG_TRACE("%s %dx%d@%c%c%c%c framerate : %d/%d\n", dev_name(pcdev->icd->pdev),
-                fival->width, fival->height,
-                fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
-			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
-			     fival->discrete.denominator,fival->discrete.numerator);			    
-        } else {
-            if (index == 0)
-                RK30_CAM_DEBUG_TRACE("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(pcdev->icd->pdev),
-                    fival->width,fival->height, 
-                    fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
-    			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
-    			    index);
-            else
-                RK30_CAM_DEBUG_TRACE("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(pcdev->icd->pdev),
-                    fival->width,fival->height, 
+            if ((i == index) && (fival->height == fival_head->height) && (fival->width == fival_head->width)) {
+                memcpy(fival, fival_head, sizeof(struct v4l2_frmivalenum));
+
+                pixfmt = fival->pixel_format;     /* ddl@rock-chips.com: v0.3.9 */
+                xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
+                memset(&mf,0x00,sizeof(struct v4l2_mbus_framefmt));
+            	mf.width	= fival->width;
+            	mf.height	= fival->height;            	
+            	mf.code		= xlate->code;                
+
+            	v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);
+                
+                fival->reserved[1] = (mf.width<<16)|(mf.height);
+                
+                RKCAMERA_DG1("%s %dx%d@%c%c%c%c framerate : %d/%d\n", dev_name(pcdev->icd->pdev),
+                    fival->width, fival->height,
                     fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
     			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
-    			    index);
-            ret = -EINVAL;
+    			     fival->discrete.denominator,fival->discrete.numerator);			    
+            } else {
+                if (index == 0)
+                    RKCAMERA_TR("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(pcdev->icd->pdev),
+                        fival->width,fival->height, 
+                        fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
+        			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
+        			    index);
+                else
+                    RKCAMERA_DG1("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(pcdev->icd->pdev),
+                        fival->width,fival->height, 
+                        fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
+        			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
+        			    index);
+                ret = -EINVAL;
+                goto rk_camera_enum_frameintervals_end;
+            }
+        } else {
+            i = 0x00;
+            new_camera = pcdev->pdata->register_dev_new;
+            while(new_camera != NULL){
+                if (strcmp(new_camera->dev_name, dev_name(pcdev->icd->pdev)) == 0) {
+                    i = 0x01;                
+                    break;
+                }
+                new_camera = new_camera->next_camera;
+            }
+
+            if (i == 0x00) {
+                printk(KERN_ERR "%s(%d): %s have not found in new_camera[] and rk_camera_platform_data!",
+                    __FUNCTION__,__LINE__,dev_name(pcdev->icd->pdev));
+            } else {
+
+                pixfmt = fival->pixel_format;     /* ddl@rock-chips.com: v0.3.9 */
+                xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
+                memset(&mf,0x00,sizeof(struct v4l2_mbus_framefmt));
+            	mf.width	= fival->width;
+            	mf.height	= fival->height;            	
+            	mf.code		= xlate->code;                
+
+            	v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);
+                
+                fival->discrete.numerator= 1000;
+                fival->discrete.denominator = 15000;
+                fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+                fival->reserved[1] = (mf.width<<16)|(mf.height);                
+            }
         }
     }
 rk_camera_enum_frameintervals_end:
     return ret;
 }
 
-#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
 static int rk_camera_set_digit_zoom(struct soc_camera_device *icd,
 								const struct v4l2_queryctrl *qctrl, int zoom_rate)
 {
 	struct v4l2_crop a;
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
 	struct rk_camera_dev *pcdev = ici->priv;
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 #if CIF_DO_CROP    
 	unsigned long tmp_cifctrl; 
 #endif	
 
-	//change the crop and scale parameters
+	/*change the crop and scale parameters*/
 	
 #if CIF_DO_CROP
-	a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	//a.c.width = pcdev->host_width*100/zoom_rate;
-	a.c.width = pcdev->host_width*100/zoom_rate;
-	a.c.width &= ~CROP_ALIGN_BYTES;    
-	a.c.height = pcdev->host_height*100/zoom_rate;
-	a.c.height &= ~CROP_ALIGN_BYTES;
-	a.c.left = (((pcdev->host_width - a.c.width)>>1)+pcdev->host_left)&(~0x01);
-	a.c.top = (((pcdev->host_height - a.c.height)>>1)+pcdev->host_top)&(~0x01);
-	pcdev->stop_cif = true;
-	tmp_cifctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
-	write_cif_reg(pcdev->base,CIF_CIF_CTRL, (tmp_cifctrl & ~ENABLE_CAPTURE));
-	hrtimer_cancel(&(pcdev->fps_timer.timer));
-	flush_workqueue((pcdev->camera_wq));
-	down(&pcdev->zoominfo.sem);
-	pcdev->zoominfo.a.c.left = 0;
-	pcdev->zoominfo.a.c.top = 0;
-	pcdev->zoominfo.a.c.width = a.c.width;
-	pcdev->zoominfo.a.c.height = a.c.height;
-	pcdev->zoominfo.vir_width = pcdev->zoominfo.a.c.width;
-	pcdev->zoominfo.vir_height = pcdev->zoominfo.a.c.height;
-	pcdev->frame_inval = 1;
-	write_cif_reg(pcdev->base,CIF_CIF_CROP, (a.c.left + (a.c.top<<16)));
-	write_cif_reg(pcdev->base,CIF_CIF_SET_SIZE, ((a.c.width ) + (a.c.height<<16)));
-	write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH, a.c.width);
-	write_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS,  0x00000002);//frame1 has been ready to receive data,frame 2 is not used
+    a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    /*a.c.width = pcdev->host_width*100/zoom_rate;*/
+    a.c.width = pcdev->host_width*100/zoom_rate;
+    a.c.width &= ~CROP_ALIGN_BYTES;    
+    a.c.height = pcdev->host_height*100/zoom_rate;
+    a.c.height &= ~CROP_ALIGN_BYTES;
+    a.c.left = (((pcdev->host_width - a.c.width)>>1)+pcdev->host_left)&(~0x01);
+    a.c.top = (((pcdev->host_height - a.c.height)>>1)+pcdev->host_top)&(~0x01);
+    atomic_set(&pcdev->stop_cif,true);
+    tmp_cifctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
+    write_cif_reg(pcdev->base,CIF_CIF_CTRL, (tmp_cifctrl & ~ENABLE_CAPTURE));
+    hrtimer_cancel(&(pcdev->fps_timer.timer));
+    flush_workqueue((pcdev->camera_wq));
+    
+    down(&pcdev->zoominfo.sem);
+    pcdev->zoominfo.a.c.left = 0;
+    pcdev->zoominfo.a.c.top = 0;
+    pcdev->zoominfo.a.c.width = a.c.width;
+    pcdev->zoominfo.a.c.height = a.c.height;
+    pcdev->zoominfo.vir_width = pcdev->zoominfo.a.c.width;
+    pcdev->zoominfo.vir_height = pcdev->zoominfo.a.c.height;
+    pcdev->frame_inval = 1;
+    write_cif_reg(pcdev->base,CIF_CIF_CROP, (a.c.left + (a.c.top<<16)));
+    write_cif_reg(pcdev->base,CIF_CIF_SET_SIZE, ((a.c.width ) + (a.c.height<<16)));
+    write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH, a.c.width);
+    write_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS,  0x00000002);//frame1 has been ready to receive data,frame 2 is not used
+    //if(pcdev->active)
+        //rk_videobuf_capture(pcdev->active,pcdev);        
 	if(pcdev->active0)
 		rk_videobuf_capture(pcdev->active0,pcdev,0);
 	if(pcdev->active1)
 		rk_videobuf_capture(pcdev->active1,pcdev,1);
-	if(tmp_cifctrl & ENABLE_CAPTURE)
-		write_cif_reg(pcdev->base,CIF_CIF_CTRL, (tmp_cifctrl | ENABLE_CAPTURE));
-	up(&pcdev->zoominfo.sem);
-	pcdev->stop_cif = false;
-	hrtimer_start(&(pcdev->fps_timer.timer),ktime_set(3, 0),HRTIMER_MODE_REL);
-	RK30_CAM_DEBUG_TRACE("%s..zoom_rate:%d (%dx%d at (%d,%d)-> %dx%d)\n",__FUNCTION__, zoom_rate,a.c.width, a.c.height, a.c.left, a.c.top, icd->user_width, icd->user_height );
+    if(tmp_cifctrl & ENABLE_CAPTURE)
+        write_cif_reg(pcdev->base,CIF_CIF_CTRL, (tmp_cifctrl | ENABLE_CAPTURE));
+    up(&pcdev->zoominfo.sem);
+    
+    atomic_set(&pcdev->stop_cif,false);
+    hrtimer_start(&(pcdev->fps_timer.timer),ktime_set(3, 0),HRTIMER_MODE_REL);
+    RKCAMERA_DG1("zoom_rate:%d (%dx%d at (%d,%d)-> %dx%d)\n", zoom_rate,a.c.width, a.c.height, a.c.left, a.c.top, icd->user_width, icd->user_height );
 #else
-	a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	a.c.width = pcdev->host_width*100/zoom_rate;
-	a.c.width &= ~CROP_ALIGN_BYTES;    
-	a.c.height = pcdev->host_height*100/zoom_rate;
-	a.c.height &= ~CROP_ALIGN_BYTES;
-	a.c.left = (pcdev->host_width - a.c.width)>>1;
-	a.c.top = (pcdev->host_height - a.c.height)>>1;
-	down(&pcdev->zoominfo.sem);
-	pcdev->zoominfo.a.c.height = a.c.height;
-	pcdev->zoominfo.a.c.width = a.c.width;
-	pcdev->zoominfo.a.c.top = a.c.top;
-	pcdev->zoominfo.a.c.left = a.c.left;
-	pcdev->zoominfo.vir_width = pcdev->host_width;
-	pcdev->zoominfo.vir_height= pcdev->host_height;
-	up(&pcdev->zoominfo.sem);
-	RK30_CAM_DEBUG_TRACE("%s..zoom_rate:%d (%dx%d at (%d,%d)-> %dx%d)\n",__FUNCTION__, zoom_rate,a.c.width, a.c.height, a.c.left, a.c.top, icd->user_width, icd->user_height );
+    a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    a.c.width = pcdev->host_width*100/zoom_rate;
+    a.c.width &= ~CROP_ALIGN_BYTES;    
+    a.c.height = pcdev->host_height*100/zoom_rate;
+    a.c.height &= ~CROP_ALIGN_BYTES;
+    a.c.left = (pcdev->host_width - a.c.width)>>1;
+    a.c.top = (pcdev->host_height - a.c.height)>>1;
+    
+    down(&pcdev->zoominfo.sem);
+    pcdev->zoominfo.a.c.height = a.c.height;
+    pcdev->zoominfo.a.c.width = a.c.width;
+    pcdev->zoominfo.a.c.top = a.c.top;
+    pcdev->zoominfo.a.c.left = a.c.left;
+    pcdev->zoominfo.vir_width = pcdev->host_width;
+    pcdev->zoominfo.vir_height= pcdev->host_height;
+    up(&pcdev->zoominfo.sem);
+    
+    RKCAMERA_DG1("zoom_rate:%d (%dx%d at (%d,%d)-> %dx%d)\n", zoom_rate,a.c.width, a.c.height, a.c.left, a.c.top, icd->user_width, icd->user_height );
 #endif	
 
 	return 0;
 }
-#endif
+
 static inline struct v4l2_queryctrl const *rk_camera_soc_camera_find_qctrl(
 	struct soc_camera_host_ops *ops, int id)
 {
-	int i;
 
+	int i;
 	for (i = 0; i < ops->num_controls; i++)
 		if (ops->controls[i].id == id)
 			return &ops->controls[i];
@@ -3299,31 +2967,28 @@ static inline struct v4l2_queryctrl const *rk_camera_soc_camera_find_qctrl(
 static int rk_camera_set_ctrl(struct soc_camera_device *icd,
 								struct v4l2_control *sctrl)
 {
-
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);/*yzm*/
 	const struct v4l2_queryctrl *qctrl;
-#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON    
     struct rk_camera_dev *pcdev = ici->priv;
-#endif
+
     int ret = 0;
 
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
 	qctrl = rk_camera_soc_camera_find_qctrl(ici->ops, sctrl->id);
 	if (!qctrl) {
 		ret = -ENOIOCTLCMD;
         goto rk_camera_set_ctrl_end;
 	}
-	
-    if ((sctrl->value < qctrl->minimum) || (sctrl->value > qctrl->maximum)){
-		ret = -EINVAL;
-        goto rk_camera_set_ctrl_end;
-	}
-	
+
 	switch (sctrl->id)
 	{
-	#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
 		case V4L2_CID_ZOOM_ABSOLUTE:
 		{
-			
+			if ((sctrl->value < qctrl->minimum) || (sctrl->value > qctrl->maximum)){
+        		ret = -EINVAL;
+                goto rk_camera_set_ctrl_end;
+        	}
             ret = rk_camera_set_digit_zoom(icd, qctrl, sctrl->value);
 			if (ret == 0) {
 				pcdev->zoominfo.zoom_rate = sctrl->value;
@@ -3332,32 +2997,6 @@ static int rk_camera_set_ctrl(struct soc_camera_device *icd,
             }
 			break;
 		}
-    #endif
-
-        case V4L2_CID_HDR:
-        {            
-            if (pcdev->hdr_info.en != sctrl->value) {
-                pcdev->hdr_info.en = sctrl->value;
-                if (sctrl->value) {
-					struct device *control = to_soc_camera_control(pcdev->icd);
-					struct v4l2_subdev *sd=dev_get_drvdata(control);
-
-                    printk("hdr on\n");
-                    pcdev->hdr_info.frame[0].code = RK_VIDEOBUF_HDR_EXPOSURE_MINUS_1;
-                    pcdev->hdr_info.frame[0].set_ts = 0;
-                    pcdev->hdr_info.frame[0].get_ts = 0;
-                    pcdev->hdr_info.frame[1].code = RK_VIDEOBUF_HDR_EXPOSURE_NORMAL;
-                    pcdev->hdr_info.frame[1].set_ts = 0;
-                    pcdev->hdr_info.frame[1].get_ts = 0;
-                    pcdev->hdr_info.frame[2].code = RK_VIDEOBUF_HDR_EXPOSURE_PLUS_1;
-                    pcdev->hdr_info.frame[2].set_ts = 0;
-                    pcdev->hdr_info.frame[2].get_ts = 0;
-                    v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_HDR_EXPOSURE,RK_VIDEOBUF_HDR_EXPOSURE_NORMAL);
-                }
-            }
-            break;
-        }
-    
 		default:
 			ret = -ENOIOCTLCMD;
 			break;
@@ -3366,16 +3005,6 @@ static int rk_camera_set_ctrl(struct soc_camera_device *icd,
 	return ret;
 }
 
-int rk_camera_enum_fsizes(struct soc_camera_device *icd, struct v4l2_frmsizeenum *fsize)
-{
-    struct device *control = to_soc_camera_control(icd);
-    struct v4l2_subdev *sd;
-
-    sd = dev_get_drvdata(control);
-    return v4l2_subdev_call(sd, video, enum_framesizes, fsize);
-
-}
-
 static struct soc_camera_host_ops rk_soc_camera_host_ops =
 {
     .owner		= THIS_MODULE,
@@ -3384,8 +3013,9 @@ static struct soc_camera_host_ops rk_soc_camera_host_ops =
     .suspend	= rk_camera_suspend,
     .resume		= rk_camera_resume,
     .enum_frameinervals = rk_camera_enum_frameintervals,
-    .enum_fsizes = rk_camera_enum_fsizes,
+    .cropcap    = rk_camera_cropcap,
     .set_crop	= rk_camera_set_crop,
+    .get_crop   = rk_camera_get_crop,
     .get_formats	= rk_camera_get_formats, 
     .put_formats	= rk_camera_put_formats,
     .set_fmt	= rk_camera_set_fmt,
@@ -3401,94 +3031,83 @@ static struct soc_camera_host_ops rk_soc_camera_host_ops =
     .num_controls = ARRAY_SIZE(rk_camera_controls)
 };
 
-static void rk_camera_cif_iomux(int cif_index)
+/**********yzm***********/
+static int rk_camera_cif_iomux(struct device *dev)
 {
-#if defined(CONFIG_ARCH_RK3066B) || defined(CONFIG_ARCH_RK3188)
-    switch(cif_index){
-        case 0:
-			iomux_set(CIF0_CLKOUT);
-            write_grf_reg(GRF_IO_CON3, (CIF_DRIVER_STRENGTH_MASK|CIF_DRIVER_STRENGTH_4MA));
-            write_grf_reg(GRF_IO_CON4, (CIF_CLKOUT_AMP_MASK|CIF_CLKOUT_AMP_1V8));
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & (RK_CAM_INPUT_FMT_RAW10|RK_CAM_INPUT_FMT_RAW12))
-	        iomux_set(CIF0_D0);
-	        iomux_set(CIF0_D1);
-            #endif
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & RK_CAM_INPUT_FMT_RAW12)
-	        iomux_set(CIF0_D10);
-	        iomux_set(CIF0_D11);
-            RK30_CAM_DEBUG_TRACE("%s(%d): WARNING: Cif 0 is configurated that support RAW 12bit, so I2C3 is invalidate!!\n",__FUNCTION__,__LINE__);
-            #endif
-            
-            break;
-        default:
-            RK30_CAM_DEBUG_TRACE("%s(%d): Cif index(%d) is invalidate!!!\n",__FUNCTION__,__LINE__, cif_index);
-            break;
+
+    struct pinctrl      *pinctrl;
+    struct pinctrl_state    *state;
+    int retval = 0;
+    char state_str[20] = {0};
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+    strcpy(state_str,"cif_pin_jpe");
+
+	/*__raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);*/
+
+
+    /*mux CIF0_CLKOUT*/
+
+    pinctrl = devm_pinctrl_get(dev);
+    if (IS_ERR(pinctrl)) {
+        printk(KERN_EMERG "%s:Get pinctrl failed!\n",__func__);
+        return -1;
     }
-#elif defined(CONFIG_ARCH_RK30)
-    switch(cif_index){
-        case 0:
-            rk30_mux_api_set(GPIO1B3_CIF0CLKOUT_NAME, GPIO1B_CIF0_CLKOUT);
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & (RK_CAM_INPUT_FMT_RAW10|RK_CAM_INPUT_FMT_RAW12))
-	        rk30_mux_api_set(GPIO1B4_CIF0DATA0_NAME, GPIO1B_CIF0_DATA0);
-	        rk30_mux_api_set(GPIO1B5_CIF0DATA1_NAME, GPIO1B_CIF0_DATA1);
-            #endif
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & RK_CAM_INPUT_FMT_RAW12)
-	        rk30_mux_api_set(GPIO1B6_CIFDATA10_NAME, GPIO1B_CIF_DATA10);
-	        rk30_mux_api_set(GPIO1B7_CIFDATA11_NAME, GPIO1B_CIF_DATA11);
-            #endif
-            break;
-        case 1:
-            rk30_mux_api_set(GPIO1C0_CIF1DATA2_RMIICLKOUT_RMIICLKIN_NAME,GPIO1C_CIF1_DATA2);
-            rk30_mux_api_set(GPIO1C1_CIFDATA3_RMIITXEN_NAME,GPIO1C_CIF_DATA3);
-            rk30_mux_api_set(GPIO1C2_CIF1DATA4_RMIITXD1_NAME,GPIO1C_CIF1_DATA4);
-            rk30_mux_api_set(GPIO1C3_CIFDATA5_RMIITXD0_NAME,GPIO1C_CIF_DATA5);
-            rk30_mux_api_set(GPIO1C4_CIFDATA6_RMIIRXERR_NAME,GPIO1C_CIF_DATA6);
-            rk30_mux_api_set(GPIO1C5_CIFDATA7_RMIICRSDVALID_NAME,GPIO1C_CIF_DATA7);
-            rk30_mux_api_set(GPIO1C6_CIFDATA8_RMIIRXD1_NAME,GPIO1C_CIF_DATA8);
-            rk30_mux_api_set(GPIO1C7_CIFDATA9_RMIIRXD0_NAME,GPIO1C_CIF_DATA9);
-            
-            rk30_mux_api_set(GPIO1D0_CIF1VSYNC_MIIMD_NAME,GPIO1D_CIF1_VSYNC);
-            rk30_mux_api_set(GPIO1D1_CIF1HREF_MIIMDCLK_NAME,GPIO1D_CIF1_HREF);
-            rk30_mux_api_set(GPIO1D2_CIF1CLKIN_NAME,GPIO1D_CIF1_CLKIN);
-            rk30_mux_api_set(GPIO1D3_CIF1DATA0_NAME,GPIO1D_CIF1_DATA0);
-            rk30_mux_api_set(GPIO1D4_CIF1DATA1_NAME,GPIO1D_CIF1_DATA1);
-            rk30_mux_api_set(GPIO1D5_CIF1DATA10_NAME,GPIO1D_CIF1_DATA10);
-            rk30_mux_api_set(GPIO1D6_CIF1DATA11_NAME,GPIO1D_CIF1_DATA11);
-            rk30_mux_api_set(GPIO1D7_CIF1CLKOUT_NAME,GPIO1D_CIF1_CLKOUT);
-            break;
-        default:
-            RK30_CAM_DEBUG_TRACE("%s(%d): Cif index(%d) is invalidate!!!\n",__FUNCTION__,__LINE__, cif_index);
-            break;
+    state = pinctrl_lookup_state(pinctrl,
+                         state_str);
+    if (IS_ERR(state)){
+        dev_err(dev, "%s:could not get %s pinstate\n",__func__,state_str);
+        return -1;
         }
-#endif
-                
+
+    if (!IS_ERR(state)) {
+        retval = pinctrl_select_state(pinctrl, state);
+        if (retval){
+            dev_err(dev,
+                "%s:could not set %s pins\n",__func__,state_str);
+                return -1;
+
+                }
+    }
+    return 0;
             
 }
+/***********yzm***********/
 static int rk_camera_probe(struct platform_device *pdev)
 {
     struct rk_camera_dev *pcdev;
     struct resource *res;
     struct rk_camera_frmivalenum *fival_list,*fival_nxt;
-    struct rk29camera_mem_res *meminfo_ptr,*meminfo_ptrr;
     int irq,i;
     int err = 0;
     struct rk_cif_clk *clk=NULL;
+	struct device *dev_cif = ((struct rk29camera_platform_data*)pdev->dev.platform_data)->cif_dev;/*yzm*/
 
-    printk("%s version: v%d.%d.%d  Zoom by %s\n",RK29_CAM_DRV_NAME,(RK_CAM_VERSION_CODE&0xff0000)>>16,
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+	RKCAMERA_TR("%s version: v%d.%d.%d  Zoom by %s",RK29_CAM_DRV_NAME,(RK_CAM_VERSION_CODE&0xff0000)>>16,
         (RK_CAM_VERSION_CODE&0xff00)>>8,RK_CAM_VERSION_CODE&0xff,CAMERA_SCALE_CROP_MACHINE);    
 
     if ((pdev->id == RK_CAM_PLATFORM_DEV_ID_1) && (RK_SUPPORT_CIF1 == 0)) {
-        RK30_CAM_DEBUG_TRACE("%s(%d): This chip is not support CIF1!!\n",__FUNCTION__,__LINE__);
+        RKCAMERA_TR("%s(%d): This chip is not support CIF1!!\n",__FUNCTION__,__LINE__);
         BUG();
     }
 
     if ((pdev->id == RK_CAM_PLATFORM_DEV_ID_0) && (RK_SUPPORT_CIF0 == 0)) {
-        RK30_CAM_DEBUG_TRACE("%s(%d): This chip is not support CIF0!!\n",__FUNCTION__,__LINE__);
+        RKCAMERA_TR("%s(%d): This chip is not support CIF0!!\n",__FUNCTION__,__LINE__);
         BUG();
     }
-    
+
+/***********yzm**********/
+	rk_camera_diffchips(((struct rk29camera_platform_data*)pdev->dev.platform_data)->rockchip_name);
+
     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
     irq = platform_get_irq(pdev, 0);
+
+	/*	irq = irq_of_parse_and_map(dev_cif->of_node, 0);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n res = [%x--%x] \n",res->start , res->end);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n irq_num = %d\n", irq);
+	*/
     if (!res || irq < 0) {
         err = -ENODEV;
         goto exit;
@@ -3500,70 +3119,53 @@ static int rk_camera_probe(struct platform_device *pdev)
         goto exit_alloc;
     }
 
-	pcdev->zoominfo.zoom_rate = 100;
-	pcdev->hostid = pdev->id;
-    /*config output clk*/ // must modify start
-    if(IS_CIF0()){
+    pcdev->zoominfo.zoom_rate = 100;
+    pcdev->hostid = pdev->id;        /* get host id*/
+    #ifdef CONFIG_SOC_RK3028
+    pcdev->chip_id = rk3028_version_val();
+    #else
+    pcdev->chip_id = -1;
+    #endif
+
+	/***********yzm***********/
+	if (IS_CIF0()) {
+		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/is_cif0\n");
         clk = &cif_clk[0];
-        cif_clk[0].pd_cif = clk_get(NULL, "pd_cif0");
-        cif_clk[0].aclk_cif = clk_get(NULL, "aclk_cif0");
-        cif_clk[0].hclk_cif = clk_get(NULL, "hclk_cif0");
-        cif_clk[0].cif_clk_in = clk_get(NULL, "cif0_in");
-        cif_clk[0].cif_clk_out = clk_get(NULL, "cif0_out");
-        spin_lock_init(&cif_clk[0].lock);
+        cif_clk[0].pd_cif = devm_clk_get(dev_cif, "pd_cif0");
+        cif_clk[0].aclk_cif = devm_clk_get(dev_cif, "aclk_cif0");
+        cif_clk[0].hclk_cif = devm_clk_get(dev_cif, "hclk_cif0");
+        cif_clk[0].cif_clk_in = devm_clk_get(dev_cif, "cif0_in");
+        cif_clk[0].cif_clk_out = devm_clk_get(dev_cif, "cif0_out");
+        //spin_lock_init(&cif_clk[0].lock);
         cif_clk[0].on = false;
-        rk_camera_cif_iomux(0);
+        rk_camera_cif_iomux(dev_cif);/*yzm*/
     } else {
-        clk = &cif_clk[1];
-        cif_clk[1].pd_cif = clk_get(NULL, "pd_cif1");
-        cif_clk[1].aclk_cif = clk_get(NULL, "aclk_cif1");
-        cif_clk[1].hclk_cif = clk_get(NULL, "hclk_cif1");
-        cif_clk[1].cif_clk_in = clk_get(NULL, "cif1_in");
-        cif_clk[1].cif_clk_out = clk_get(NULL, "cif1_out");
-        spin_lock_init(&cif_clk[1].lock);
+    	clk = &cif_clk[1];
+        cif_clk[1].pd_cif = devm_clk_get(dev_cif, "pd_cif0");/*cif0  only yzm*/
+        cif_clk[1].aclk_cif = devm_clk_get(dev_cif, "aclk_cif0");
+        cif_clk[1].hclk_cif = devm_clk_get(dev_cif, "hclk_cif0");
+        cif_clk[1].cif_clk_in = devm_clk_get(dev_cif, "cif0_in");
+        cif_clk[1].cif_clk_out = devm_clk_get(dev_cif, "cif0_out");
+        //spin_lock_init(&cif_clk[1].lock);
         cif_clk[1].on = false;
-        
-        rk_camera_cif_iomux(1);
+        rk_camera_cif_iomux(dev_cif);/*yzm*/
     }
-    
-    
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+	/***********yzm**********/
     dev_set_drvdata(&pdev->dev, pcdev);
     pcdev->res = res;
     pcdev->pdata = pdev->dev.platform_data;             /* ddl@rock-chips.com : Request IO in init function */
-	pcdev->pdata->sensor_mclk = rk_camera_mclk_ctrl;
+					/*= rk_camera_platform_data */
 	if (pcdev->pdata && pcdev->pdata->io_init) {
-        pcdev->pdata->io_init();
-    }
-	#ifdef CONFIG_VIDEO_RK29_WORK_IPP
-    meminfo_ptr = IS_CIF0()? (&pcdev->pdata->meminfo):(&pcdev->pdata->meminfo_cif1);
-    meminfo_ptrr = IS_CIF0()? (&pcdev->pdata->meminfo_cif1):(&pcdev->pdata->meminfo);
-    
-    if (meminfo_ptr->vbase == NULL) {
-
-        if ((meminfo_ptr->start == meminfo_ptrr->start)
-            && (meminfo_ptr->size == meminfo_ptrr->size) && meminfo_ptrr->vbase) {
+		
+        pcdev->pdata->io_init();/* call rk_sensor_io_init()*/
 
-            meminfo_ptr->vbase = meminfo_ptrr->vbase;
-        } else {        
-        
-            if (!request_mem_region(meminfo_ptr->start,meminfo_ptr->size,"rk29_vipmem")) {
-                err = -EBUSY;
-                RK30_CAM_DEBUG_TRACE("%s(%d): request_mem_region(start:0x%x size:0x%x) failed \n",__FUNCTION__,__LINE__, pcdev->pdata->meminfo.start,pcdev->pdata->meminfo.size);
-                goto exit_ioremap_vipmem;
-            }
-            meminfo_ptr->vbase = pcdev->vipmem_virbase = ioremap_cached(meminfo_ptr->start,meminfo_ptr->size);
-            if (pcdev->vipmem_virbase == NULL) {
-                RK30_CAM_DEBUG_TRACE("%s(%d): ioremap of CIF internal memory(Ex:IPP process/raw process) failed\n",__FUNCTION__,__LINE__);
-                err = -ENXIO;
-                goto exit_ioremap_vipmem;
-            }
-        }
+        if (pcdev->pdata->sensor_mclk == NULL)
+            pcdev->pdata->sensor_mclk = rk_camera_mclk_ctrl;
     }
-    
-    pcdev->vipmem_phybase = meminfo_ptr->start;
-	pcdev->vipmem_size = meminfo_ptr->size;
-    pcdev->vipmem_virbase = meminfo_ptr->vbase;
-	#endif
+
     INIT_LIST_HEAD(&pcdev->capture);
     INIT_LIST_HEAD(&pcdev->camera_work_queue);
     spin_lock_init(&pcdev->lock);
@@ -3590,13 +3192,13 @@ static int rk_camera_probe(struct platform_device *pdev)
         }
     }
 	
-    pcdev->irq = irq;
+    pcdev->irqinfo.irq = irq;
     pcdev->dev = &pdev->dev;
 
     /* config buffer address */
     /* request irq */
     if(irq > 0){
-        err = request_irq(pcdev->irq, rk_camera_irq, 0, RK29_CAM_DRV_NAME,
+        err = request_irq(pcdev->irqinfo.irq, rk_camera_irq, 0, RK29_CAM_DRV_NAME,
                           pcdev);
         if (err) {
             dev_err(pcdev->dev, "Camera interrupt register failed \n");
@@ -3604,15 +3206,15 @@ static int rk_camera_probe(struct platform_device *pdev)
         }
    	}
    
-//#ifdef CONFIG_VIDEO_RK29_WORK_IPP
     if(IS_CIF0()) {
     	pcdev->camera_wq = create_workqueue("rk_cam_wkque_cif0");
     } else {
     	pcdev->camera_wq = create_workqueue("rk_cam_wkque_cif1");
     }
-    if (pcdev->camera_wq == NULL)
-    	goto exit_free_irq;
-//#endif
+    if (pcdev->camera_wq == NULL) {
+        RKCAMERA_TR("%s(%d): Create workqueue failed!\n",__FUNCTION__,__LINE__);
+        goto exit_free_irq;
+    }
 
 	pcdev->camera_reinit_work.pcdev = pcdev;
 	INIT_WORK(&(pcdev->camera_reinit_work.work), rk_camera_reinit_work);
@@ -3624,18 +3226,23 @@ static int rk_camera_probe(struct platform_device *pdev)
     }
     pcdev->soc_host.drv_name	= RK29_CAM_DRV_NAME;
     pcdev->soc_host.ops		= &rk_soc_camera_host_ops;
-    pcdev->soc_host.priv		= pcdev;
+    pcdev->soc_host.priv		= pcdev;        /*to itself,csll in rk_camera_add_device*/
     pcdev->soc_host.v4l2_dev.dev	= &pdev->dev;
     pcdev->soc_host.nr		= pdev->id;
-
+	debug_printk("/$$$$$$$$$$$$$$$$$$$$$$/next soc_camera_host_register\n");
     err = soc_camera_host_register(&pcdev->soc_host);
-    if (err)
+
+
+    if (err) {
+        RKCAMERA_TR("%s(%d): soc_camera_host_register failed\n",__FUNCTION__,__LINE__);
         goto exit_free_irq;
+    }
 	pcdev->fps_timer.pcdev = pcdev;
 	hrtimer_init(&(pcdev->fps_timer.timer), CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 	pcdev->fps_timer.timer.function = rk_camera_fps_func;
     pcdev->icd_cb.sensor_cb = NULL;
-#if ((defined(CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON)) && (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_IPP))
+
+#if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_IPP)
     pcdev->icd_cb.scale_crop_cb = rk_camera_scale_crop_ipp;
 #elif (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_ARM)
     pcdev->icd_cb.scale_crop_cb = rk_camera_scale_crop_arm;
@@ -3644,7 +3251,6 @@ static int rk_camera_probe(struct platform_device *pdev)
 #elif(CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_PP)
 	pcdev->icd_cb.scale_crop_cb = rk_camera_scale_crop_pp; 
 #endif
-    RK30_CAM_DEBUG_TRACE("%s(%d) Exit  \n",__FUNCTION__,__LINE__);
     return 0;
 
 exit_free_irq:
@@ -3659,7 +3265,7 @@ static int rk_camera_probe(struct platform_device *pdev)
         }
     }
     
-    free_irq(pcdev->irq, pcdev);
+    free_irq(pcdev->irqinfo.irq, pcdev);
 	if (pcdev->camera_wq) {
 		destroy_workqueue(pcdev->camera_wq);
 		pcdev->camera_wq = NULL;
@@ -3668,20 +3274,19 @@ static int rk_camera_probe(struct platform_device *pdev)
     iounmap(pcdev->base);
 exit_ioremap_vip:
     release_mem_region(res->start, res->end - res->start + 1);
-exit_ioremap_vipmem:
-    if (pcdev->vipmem_virbase)
-        iounmap(pcdev->vipmem_virbase);
-    release_mem_region(pcdev->vipmem_phybase,pcdev->vipmem_size);
 exit_reqmem_vip:
-    if(pcdev->aclk_cif)
-        pcdev->aclk_cif = NULL;
-    if(pcdev->hclk_cif)
-        pcdev->hclk_cif = NULL;
-    if(pcdev->cif_clk_in)
-        pcdev->cif_clk_in = NULL;
-    if(pcdev->cif_clk_out)
-        pcdev->cif_clk_out = NULL;
-
+    if (clk) {
+        if (clk->pd_cif)
+            clk_put(clk->pd_cif);
+        if (clk->aclk_cif)
+            clk_put(clk->aclk_cif);
+        if (clk->hclk_cif)
+            clk_put(clk->hclk_cif);
+        if (clk->cif_clk_in)
+            clk_put(clk->cif_clk_in);
+        if (clk->cif_clk_out)
+            clk_put(clk->cif_clk_out);
+    }
     kfree(pcdev);
 exit_alloc:
 
@@ -3689,15 +3294,17 @@ static int rk_camera_probe(struct platform_device *pdev)
     return err;
 }
 
-static int __devexit rk_camera_remove(struct platform_device *pdev)
+static int __exit rk_camera_remove(struct platform_device *pdev)
 {
     struct rk_camera_dev *pcdev = platform_get_drvdata(pdev);
     struct resource *res;
     struct rk_camera_frmivalenum *fival_list,*fival_nxt;
-    struct rk29camera_mem_res *meminfo_ptr,*meminfo_ptrr;
     int i;
-    
-    free_irq(pcdev->irq, pcdev);
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	
+    free_irq(pcdev->irqinfo.irq, pcdev);
 
 	if (pcdev->camera_wq) {
 		destroy_workqueue(pcdev->camera_wq);
@@ -3716,18 +3323,6 @@ static int __devexit rk_camera_remove(struct platform_device *pdev)
 
     soc_camera_host_unregister(&pcdev->soc_host);
 
-    meminfo_ptr = IS_CIF0()? (&pcdev->pdata->meminfo):(&pcdev->pdata->meminfo_cif1);
-    meminfo_ptrr = IS_CIF0()? (&pcdev->pdata->meminfo_cif1):(&pcdev->pdata->meminfo);
-    if (meminfo_ptr->vbase) {
-        if (meminfo_ptr->vbase == meminfo_ptrr->vbase) {
-            meminfo_ptr->vbase = NULL;
-        } else {
-            iounmap((void __iomem*)pcdev->vipmem_virbase);
-            release_mem_region(pcdev->vipmem_phybase, pcdev->vipmem_size);
-            meminfo_ptr->vbase = NULL;
-        }
-    }
-
     res = pcdev->res;
     iounmap((void __iomem*)pcdev->base);
     release_mem_region(res->start, res->end - res->start + 1);
@@ -3746,27 +3341,34 @@ static int __devexit rk_camera_remove(struct platform_device *pdev)
 static struct platform_driver rk_camera_driver =
 {
     .driver 	= {
-        .name	= RK29_CAM_DRV_NAME,
+        .name	= RK29_CAM_DRV_NAME,       /*host */      
     },
     .probe		= rk_camera_probe,
-    .remove		= __devexit_p(rk_camera_remove),
+    .remove		= (rk_camera_remove),
 };
 
 static int rk_camera_init_async(void *unused)
 {
-    platform_driver_register(&rk_camera_driver);
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+    platform_driver_register(&rk_camera_driver);	
     return 0;
 }
 
-static int __devinit rk_camera_init(void)
+static int __init rk_camera_init(void)
 {
-    RK30_CAM_DEBUG_TRACE("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
     kthread_run(rk_camera_init_async, NULL, "rk_camera_init");
+	
     return 0;
 }
 
 static void __exit rk_camera_exit(void)
 {
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
     platform_driver_unregister(&rk_camera_driver);
 }
 
@@ -3776,4 +3378,3 @@ module_exit(rk_camera_exit);
 MODULE_DESCRIPTION("RKSoc Camera Host driver");
 MODULE_AUTHOR("ddl <ddl@rock-chips>");
 MODULE_LICENSE("GPL");
-#endif
-- 
2.35.3

