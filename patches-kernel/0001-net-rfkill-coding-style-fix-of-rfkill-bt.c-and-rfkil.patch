From 5a7879bb74896464ceb01ed4d8af1b7dc84e0c77 Mon Sep 17 00:00:00 2001
From: Weiguo Hu <hwg@rock-chips.com>
Date: Thu, 21 Nov 2019 15:50:58 +0800
Subject: [PATCH] net: rfkill: coding style fix of rfkill-bt.c and
 rfkill-wlan.c

Change-Id: I8ccd3623431cad27fabed8241ad8f7bf59b2e175
Signed-off-by: Weiguo Hu <hwg@rock-chips.com>
---
 net/rfkill/rfkill-bt.c   | 878 ++++++++++++++++++++-------------------
 net/rfkill/rfkill-wlan.c | 717 +++++++++++++++++---------------
 2 files changed, 824 insertions(+), 771 deletions(-)

diff --git a/net/rfkill/rfkill-bt.c b/net/rfkill/rfkill-bt.c
index d74e03574da4..77f81c256560 100644
--- a/net/rfkill/rfkill-bt.c
+++ b/net/rfkill/rfkill-bt.c
@@ -41,96 +41,99 @@
 #endif
 
 #if 0
-#define DBG(x...)   printk(KERN_INFO "[BT_RFKILL]: "x)
+#define DBG(x...) pr_info("[BT_RFKILL]: " x)
 #else
 #define DBG(x...)
 #endif
 
-#define LOG(x...)   printk(KERN_INFO "[BT_RFKILL]: "x)
+#define LOG(x...) pr_info("[BT_RFKILL]: " x)
 
-#define BT_WAKEUP_TIMEOUT           10000
-#define BT_IRQ_WAKELOCK_TIMEOUT     10*1000
+#define BT_WAKEUP_TIMEOUT 10000
+#define BT_IRQ_WAKELOCK_TIMEOUT (10 * 1000)
 
-#define BT_BLOCKED     true
-#define BT_UNBLOCK     false
-#define BT_SLEEP       true
-#define BT_WAKEUP      false
+#define BT_BLOCKED true
+#define BT_UNBLOCK false
+#define BT_SLEEP true
+#define BT_WAKEUP false
 
 enum {
-    IOMUX_FNORMAL=0,
-    IOMUX_FGPIO,
-    IOMUX_FMUX,
+	IOMUX_FNORMAL = 0,
+	IOMUX_FGPIO,
+	IOMUX_FMUX,
 };
 
 struct rfkill_rk_data {
-	struct rfkill_rk_platform_data	*pdata;
-    struct platform_device      *pdev;
-	struct rfkill				*rfkill_dev;
-    struct wake_lock            bt_irq_wl;
-    struct delayed_work         bt_sleep_delay_work;
+	struct rfkill_rk_platform_data *pdata;
+	struct platform_device *pdev;
+	struct rfkill *rfkill_dev;
+	struct wake_lock bt_irq_wl;
+	struct delayed_work bt_sleep_delay_work;
 };
 
 static struct rfkill_rk_data *g_rfkill = NULL;
 
-static const char bt_name[] = 
-#if defined (CONFIG_BCM4330)
-    #if defined (CONFIG_BT_MODULE_NH660)
-        "nh660"
-    #else
-        "bcm4330"
-    #endif
-#elif defined (CONFIG_RK903)
-    #if defined(CONFIG_RKWIFI_26M)
-        "rk903_26M"
-    #else
-        "rk903"
-    #endif
+static const char bt_name[] =
+#if defined(CONFIG_BCM4330)
+#if defined(CONFIG_BT_MODULE_NH660)
+	"nh660"
+#else
+	"bcm4330"
+#endif
+#elif defined(CONFIG_RK903)
+#if defined(CONFIG_RKWIFI_26M)
+	"rk903_26M"
+#else
+	"rk903"
+#endif
 #elif defined(CONFIG_BCM4329)
-        "bcm4329"
+	"bcm4329"
 #elif defined(CONFIG_MV8787)
-        "mv8787"
+	"mv8787"
 #elif defined(CONFIG_AP6210)
-    #if defined(CONFIG_RKWIFI_26M)
-        "ap6210"
-    #else
-        "ap6210_24M"
-    #endif
+#if defined(CONFIG_RKWIFI_26M)
+	"ap6210"
+#else
+	"ap6210_24M"
+#endif
 #elif defined(CONFIG_AP6330)
-		"ap6330"
+	"ap6330"
 #elif defined(CONFIG_AP6476)
-		"ap6476"
+	"ap6476"
 #elif defined(CONFIG_AP6493)
-		"ap6493"
+	"ap6493"
 #elif defined(CONFIG_AP6441)
-        "ap6441"
+	"ap6441"
 #elif defined(CONFIG_AP6335)
-        "ap6335"
+	"ap6335"
 #elif defined(CONFIG_GB86302I)
-        "gb86302i"
+	"gb86302i"
 #else
-        "bt_default"
+	"bt_default"
 #endif
-;
+	;
 
 static irqreturn_t rfkill_rk_wake_host_irq(int irq, void *dev)
 {
-    struct rfkill_rk_data *rfkill = dev;
-    LOG("BT_WAKE_HOST IRQ fired\n");
-    
-    DBG("BT IRQ wakeup, request %dms wakelock\n", BT_IRQ_WAKELOCK_TIMEOUT);
-
-    wake_lock_timeout(&rfkill->bt_irq_wl, 
-                    msecs_to_jiffies(BT_IRQ_WAKELOCK_TIMEOUT));
-    
+	struct rfkill_rk_data *rfkill = dev;
+
+	LOG("BT_WAKE_HOST IRQ fired\n");
+
+	DBG("BT IRQ wakeup, request %dms wakelock\n", BT_IRQ_WAKELOCK_TIMEOUT);
+
+	wake_lock_timeout(&rfkill->bt_irq_wl,
+			  msecs_to_jiffies(BT_IRQ_WAKELOCK_TIMEOUT));
+
 	return IRQ_HANDLED;
 }
 
-static int rfkill_rk_setup_gpio(struct platform_device *pdev, struct rfkill_rk_gpio* gpio, 
-	const char* prefix, const char* name)
+static int rfkill_rk_setup_gpio(struct platform_device *pdev,
+				struct rfkill_rk_gpio *gpio, const char *prefix,
+				const char *name)
 {
 	if (gpio_is_valid(gpio->io)) {
-        int ret=0;
-        sprintf(gpio->name, "%s_%s", prefix, name);
+		int ret = 0;
+
+		sprintf(gpio->name, "%s_%s", prefix, name);
 		ret = devm_gpio_request(&pdev->dev, gpio->io, gpio->name);
 		if (ret) {
 			LOG("Failed to get %s gpio.\n", gpio->name);
@@ -138,109 +141,111 @@ static int rfkill_rk_setup_gpio(struct platform_device *pdev, struct rfkill_rk_g
 		}
 	}
 
-    return 0;
+	return 0;
 }
 
-static int rfkill_rk_setup_wake_irq(struct rfkill_rk_data* rfkill)
+static int rfkill_rk_setup_wake_irq(struct rfkill_rk_data *rfkill)
 {
-    int ret=0;
-    struct rfkill_rk_irq* irq = &(rfkill->pdata->wake_host_irq);
-    
-    ret = rfkill_rk_setup_gpio(rfkill->pdev, &irq->gpio, rfkill->pdata->name, "wake_host");
-    if (ret) goto fail1;
-    if (gpio_is_valid(irq->gpio.io))
-    {
-        //ret = gpio_pull_updown(irq->gpio.io, (irq->gpio.enable==GPIO_ACTIVE_LOW)?GPIOPullUp:GPIOPullDown);
-        //if (ret) goto fail2;
-        LOG("Request irq for bt wakeup host\n");
-        irq->irq = gpio_to_irq(irq->gpio.io);
-        sprintf(irq->name, "%s_irq", irq->gpio.name);
-        ret = request_irq(irq->irq,
-                    rfkill_rk_wake_host_irq,
-                    (irq->gpio.enable==GPIO_ACTIVE_LOW)?IRQF_TRIGGER_FALLING:IRQF_TRIGGER_RISING,
-                    irq->name,
-                    rfkill);
-        if (ret) goto fail2;
-        LOG("** disable irq\n");
-        disable_irq(irq->irq);
-        ret = enable_irq_wake(irq->irq);
-        if (ret) goto fail3;
-    }
-
-    return ret;
+	int ret = 0;
+	struct rfkill_rk_irq *irq = &rfkill->pdata->wake_host_irq;
+
+	ret = rfkill_rk_setup_gpio(rfkill->pdev, &irq->gpio,
+				   rfkill->pdata->name, "wake_host");
+	if (ret)
+		goto fail1;
+	if (gpio_is_valid(irq->gpio.io)) {
+		LOG("Request irq for bt wakeup host\n");
+		irq->irq = gpio_to_irq(irq->gpio.io);
+		sprintf(irq->name, "%s_irq", irq->gpio.name);
+		ret = request_irq(irq->irq, rfkill_rk_wake_host_irq,
+				  (irq->gpio.enable == GPIO_ACTIVE_LOW) ?
+					  IRQF_TRIGGER_FALLING :
+					  IRQF_TRIGGER_RISING,
+				  irq->name, rfkill);
+		if (ret)
+			goto fail2;
+		LOG("** disable irq\n");
+		disable_irq(irq->irq);
+		ret = enable_irq_wake(irq->irq);
+		if (ret)
+			goto fail3;
+	}
+
+	return ret;
 
 fail3:
-    free_irq(irq->gpio.io, rfkill);
+	free_irq(irq->gpio.io, rfkill);
 fail2:
-    gpio_free(irq->gpio.io);
+	gpio_free(irq->gpio.io);
 fail1:
-    return ret;
+	return ret;
 }
 
-static inline void rfkill_rk_sleep_bt_internal(struct rfkill_rk_data *rfkill, bool sleep)
+static inline void rfkill_rk_sleep_bt_internal(struct rfkill_rk_data *rfkill,
+					       bool sleep)
 {
-    struct rfkill_rk_gpio *wake = &rfkill->pdata->wake_gpio;
-    
-    DBG("*** bt sleep: %d ***\n", sleep);
+	struct rfkill_rk_gpio *wake = &rfkill->pdata->wake_gpio;
+
+	DBG("*** bt sleep: %d ***\n", sleep);
 #ifndef CONFIG_BK3515A_COMBO
-    gpio_direction_output(wake->io, sleep?!wake->enable:wake->enable);
+	gpio_direction_output(wake->io, sleep ? !wake->enable : wake->enable);
 #else
-    if(!sleep)
-    {
-        DBG("HOST_UART0_TX pull down 10us\n");
-        if (rfkill_rk_setup_gpio(rfkill->pdev, wake, rfkill->pdata->name, "wake") != 0) {
-            return;
-        }
-
-        gpio_direction_output(wake->io, wake->enable);
-        udelay(10);
-        gpio_direction_output(wake->io, !wake->enable);
-
-        gpio_free(wake->io);
-    }
+	if (!sleep) {
+		DBG("HOST_UART0_TX pull down 10us\n");
+		if (rfkill_rk_setup_gpio(rfkill->pdev, wake,
+					 rfkill->pdata->name, "wake") != 0) {
+			return;
+		}
+
+		gpio_direction_output(wake->io, wake->enable);
+		usleep_range(10, 20);
+		gpio_direction_output(wake->io, !wake->enable);
+
+		gpio_free(wake->io);
+	}
 #endif
 }
 
 static void rfkill_rk_delay_sleep_bt(struct work_struct *work)
 {
-    struct rfkill_rk_data *rfkill = NULL;
-    DBG("Enter %s\n",__FUNCTION__);
+	struct rfkill_rk_data *rfkill = NULL;
+
+	DBG("Enter %s\n", __func__);
 
-    rfkill = container_of(work, struct rfkill_rk_data, bt_sleep_delay_work.work);
+	rfkill = container_of(work, struct rfkill_rk_data,
+			      bt_sleep_delay_work.work);
 
-    rfkill_rk_sleep_bt_internal(rfkill, BT_SLEEP);
+	rfkill_rk_sleep_bt_internal(rfkill, BT_SLEEP);
 }
 
 void rfkill_rk_sleep_bt(bool sleep)
 {
-    struct rfkill_rk_data *rfkill = g_rfkill;
-    struct rfkill_rk_gpio *wake;
-    bool ret;
-    DBG("Enter %s\n",__FUNCTION__);
-    
-    if (rfkill==NULL)
-    {
-        LOG("*** RFKILL is empty???\n");
-        return;
-    }
-
-    wake = &rfkill->pdata->wake_gpio;
-    if (!gpio_is_valid(wake->io))
-    {
-        DBG("*** Not support bt wakeup and sleep\n");
-        return;
-    }
-
-    ret = cancel_delayed_work_sync(&rfkill->bt_sleep_delay_work);
-
-    rfkill_rk_sleep_bt_internal(rfkill, sleep);
+	struct rfkill_rk_data *rfkill = g_rfkill;
+	struct rfkill_rk_gpio *wake;
+	bool ret;
+
+	DBG("Enter %s\n", __func__);
+
+	if (!rfkill) {
+		LOG("*** RFKILL is empty???\n");
+		return;
+	}
+
+	wake = &rfkill->pdata->wake_gpio;
+	if (!gpio_is_valid(wake->io)) {
+		DBG("*** Not support bt wakeup and sleep\n");
+		return;
+	}
+
+	ret = cancel_delayed_work_sync(&rfkill->bt_sleep_delay_work);
+
+	rfkill_rk_sleep_bt_internal(rfkill, sleep);
 
 #ifdef CONFIG_BT_AUTOSLEEP
-    if (sleep==BT_WAKEUP)
-    {
-        schedule_delayed_work(&rfkill->bt_sleep_delay_work, 
-                            msecs_to_jiffies(BT_WAKEUP_TIMEOUT));
-    }
+	if (sleep == BT_WAKEUP) {
+		schedule_delayed_work(&rfkill->bt_sleep_delay_work,
+				      msecs_to_jiffies(BT_WAKEUP_TIMEOUT));
+	}
 #endif
 }
 EXPORT_SYMBOL(rfkill_rk_sleep_bt);
@@ -248,78 +253,81 @@ EXPORT_SYMBOL(rfkill_rk_sleep_bt);
 static int bt_power_state = 0;
 int rfkill_get_bt_power_state(int *power, bool *toggle)
 {
-    struct rfkill_rk_data *mrfkill = g_rfkill;
+	struct rfkill_rk_data *mrfkill = g_rfkill;
 
-    if (mrfkill == NULL) {
-        LOG("%s: rfkill-bt driver has not Successful initialized\n", __func__);
-        return -1;
-    }
+	if (!mrfkill) {
+		LOG("%s: rfkill-bt driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
 
-    *toggle = mrfkill->pdata->power_toggle;
-    *power = bt_power_state;
+	*toggle = mrfkill->pdata->power_toggle;
+	*power = bt_power_state;
 
-    return 0;
+	return 0;
 }
 
 static int rfkill_rk_set_power(void *data, bool blocked)
 {
 	struct rfkill_rk_data *rfkill = data;
-    struct rfkill_rk_gpio *poweron = &rfkill->pdata->poweron_gpio;
-    struct rfkill_rk_gpio *reset = &rfkill->pdata->reset_gpio;
-    struct rfkill_rk_gpio* rts = &rfkill->pdata->rts_gpio;
-    struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
-    int power = 0, vref_ctrl_enable = 0;
-    bool toggle = false;
-
-    DBG("Enter %s\n", __func__);
-
-    DBG("Set blocked:%d\n", blocked);
-
-    toggle = rfkill->pdata->power_toggle;
-    if (!rfkill_get_wifi_power_state(&power, &vref_ctrl_enable)) {
-        if (true == toggle && 1 == power) {
-            LOG("%s: bt shouldn't control the power, it was enabled by wifi!\n", __func__);
-            return 0;
-        }
-    } else {
-        LOG("%s: cannot get wifi power state!\n", __func__);
-        return -1;
-    }
-
-	if (false == blocked) { 
-
-        rfkill_rk_sleep_bt(BT_WAKEUP); // ensure bt is wakeup
-
-	if (gpio_is_valid(poweron->io)) {
-		if (gpio_get_value(poweron->io) == !poweron->enable) {
-			gpio_direction_output(poweron->io, !poweron->enable);
-			msleep(20);
-			gpio_direction_output(poweron->io, poweron->enable);
-			msleep(20);
+	struct rfkill_rk_gpio *poweron = &rfkill->pdata->poweron_gpio;
+	struct rfkill_rk_gpio *reset = &rfkill->pdata->reset_gpio;
+	struct rfkill_rk_gpio *rts = &rfkill->pdata->rts_gpio;
+	struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
+	int power = 0, vref_ctrl_enable = 0;
+	bool toggle = false;
+
+	DBG("Enter %s\n", __func__);
+
+	DBG("Set blocked:%d\n", blocked);
+
+	toggle = rfkill->pdata->power_toggle;
+	if (!rfkill_get_wifi_power_state(&power, &vref_ctrl_enable)) {
+		if (toggle && 1 == power) {
+			LOG("%s: bt shouldn't control the power\n",
+			    __func__);
+			return 0;
+		}
+	} else {
+		LOG("%s: cannot get wifi power state!\n", __func__);
+		return -1;
+	}
+
+	if (!blocked) {
+		rfkill_rk_sleep_bt(BT_WAKEUP); // ensure bt is wakeup
+
+		if (gpio_is_valid(poweron->io)) {
+			if (gpio_get_value(poweron->io) == !poweron->enable) {
+				gpio_direction_output(poweron->io,
+						      !poweron->enable);
+				msleep(20);
+				gpio_direction_output(poweron->io,
+						      poweron->enable);
+				msleep(20);
+			}
+		}
+
+		if (gpio_is_valid(reset->io)) {
+			if (gpio_get_value(reset->io) == !reset->enable) {
+				gpio_direction_output(reset->io,
+						      !reset->enable);
+				msleep(20);
+				gpio_direction_output(reset->io, reset->enable);
+			}
 		}
-        }
 
-	if (gpio_is_valid(reset->io)) {
-		if (gpio_get_value(reset->io) == !reset->enable) {
-			gpio_direction_output(reset->io, !reset->enable);
-			msleep(20);
-			gpio_direction_output(reset->io, reset->enable);
+		if (pinctrl && gpio_is_valid(rts->io)) {
+			pinctrl_select_state(pinctrl, rts->gpio_state);
+			LOG("ENABLE UART_RTS\n");
+			gpio_direction_output(rts->io, rts->enable);
+			msleep(100);
+			LOG("DISABLE UART_RTS\n");
+			gpio_direction_output(rts->io, !rts->enable);
+			pinctrl_select_state(pinctrl, rts->default_state);
 		}
-        }
-
-        if (pinctrl != NULL && gpio_is_valid(rts->io))
-        {
-            pinctrl_select_state(pinctrl, rts->gpio_state);
-            LOG("ENABLE UART_RTS\n");
-            gpio_direction_output(rts->io, rts->enable);
-            msleep(100);
-            LOG("DISABLE UART_RTS\n");
-            gpio_direction_output(rts->io, !rts->enable);
-            pinctrl_select_state(pinctrl, rts->default_state);
-        }
-
-        bt_power_state = 1;
-    	LOG("bt turn on power\n");
+
+		bt_power_state = 1;
+		LOG("bt turn on power\n");
 	} else {
 		if (gpio_is_valid(poweron->io)) {
 			if (gpio_get_value(poweron->io) == poweron->enable) {
@@ -345,188 +353,195 @@ static int rfkill_rk_set_power(void *data, bool blocked)
 
 static int rfkill_rk_pm_prepare(struct device *dev)
 {
-    struct rfkill_rk_data *rfkill = g_rfkill;
-    struct rfkill_rk_gpio* rts;
-    struct rfkill_rk_irq*  wake_host_irq;
-    struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
+	struct rfkill_rk_data *rfkill = g_rfkill;
+	struct rfkill_rk_gpio *rts;
+	struct rfkill_rk_irq *wake_host_irq;
+	struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
 
-    DBG("Enter %s\n",__FUNCTION__);
+	DBG("Enter %s\n", __func__);
 
-    if (!rfkill)
-        return 0;
+	if (!rfkill)
+		return 0;
 
-    rts = &rfkill->pdata->rts_gpio;
-    wake_host_irq = &rfkill->pdata->wake_host_irq;
+	rts = &rfkill->pdata->rts_gpio;
+	wake_host_irq = &rfkill->pdata->wake_host_irq;
 
-    //To prevent uart to receive bt data when suspended
-    if (pinctrl != NULL && gpio_is_valid(rts->io))
-    {
-        DBG("Disable UART_RTS\n");
-        pinctrl_select_state(pinctrl, rts->gpio_state);
-        gpio_direction_output(rts->io, !rts->enable);
-    }
+	//To prevent uart to receive bt data when suspended
+	if (pinctrl && gpio_is_valid(rts->io)) {
+		DBG("Disable UART_RTS\n");
+		pinctrl_select_state(pinctrl, rts->gpio_state);
+		gpio_direction_output(rts->io, !rts->enable);
+	}
 
 #ifdef CONFIG_BT_AUTOSLEEP
-    rfkill_rk_sleep_bt(BT_SLEEP);
+	rfkill_rk_sleep_bt(BT_SLEEP);
 #endif
 
-    // enable bt wakeup host
-    if (gpio_is_valid(wake_host_irq->gpio.io))
-    {
-        DBG("enable irq for bt wakeup host\n");
-        enable_irq(wake_host_irq->irq);
-    }
+	// enable bt wakeup host
+	if (gpio_is_valid(wake_host_irq->gpio.io)) {
+		DBG("enable irq for bt wakeup host\n");
+		enable_irq(wake_host_irq->irq);
+	}
 
 #ifdef CONFIG_RFKILL_RESET
-    rfkill_set_states(rfkill->rfkill_dev, BT_BLOCKED, false);
-    rfkill_rk_set_power(rfkill, BT_BLOCKED);
+	rfkill_set_states(rfkill->rfkill_dev, BT_BLOCKED, false);
+	rfkill_rk_set_power(rfkill, BT_BLOCKED);
 #endif
 
-    return 0;
+	return 0;
 }
 
 static void rfkill_rk_pm_complete(struct device *dev)
 {
-    struct rfkill_rk_data *rfkill = g_rfkill;
-    struct rfkill_rk_irq*  wake_host_irq;
-    struct rfkill_rk_gpio* rts;
-    struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
-
-    DBG("Enter %s\n",__FUNCTION__);
-
-    if (!rfkill)
-        return;
-
-    wake_host_irq = &rfkill->pdata->wake_host_irq;
-    rts = &rfkill->pdata->rts_gpio;
-
-    if (gpio_is_valid(wake_host_irq->gpio.io))
-    {
-        LOG("** disable irq\n");
-        disable_irq(wake_host_irq->irq);
-    }
-
-    if (pinctrl != NULL && gpio_is_valid(rts->io))
-    {
-        DBG("Enable UART_RTS\n");
-        gpio_direction_output(rts->io, rts->enable);
-        pinctrl_select_state(pinctrl, rts->default_state);
-    }
+	struct rfkill_rk_data *rfkill = g_rfkill;
+	struct rfkill_rk_irq *wake_host_irq;
+	struct rfkill_rk_gpio *rts;
+	struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
+
+	DBG("Enter %s\n", __func__);
+
+	if (!rfkill)
+		return;
+
+	wake_host_irq = &rfkill->pdata->wake_host_irq;
+	rts = &rfkill->pdata->rts_gpio;
+
+	if (gpio_is_valid(wake_host_irq->gpio.io)) {
+		LOG("** disable irq\n");
+		disable_irq(wake_host_irq->irq);
+	}
+
+	if (pinctrl && gpio_is_valid(rts->io)) {
+		DBG("Enable UART_RTS\n");
+		gpio_direction_output(rts->io, rts->enable);
+		pinctrl_select_state(pinctrl, rts->default_state);
+	}
 }
 
 static const struct rfkill_ops rfkill_rk_ops = {
-    .set_block = rfkill_rk_set_power,
+	.set_block = rfkill_rk_set_power,
 };
 
-#define PROC_DIR	"bluetooth/sleep"
+#define PROC_DIR "bluetooth/sleep"
 
 static struct proc_dir_entry *bluetooth_dir, *sleep_dir;
 
 static ssize_t bluesleep_read_proc_lpm(struct file *file, char __user *buffer,
 				       size_t count, loff_t *data)
 {
-    return sprintf(buffer, "unsupported to read\n");
+	return sprintf(buffer, "unsupported to read\n");
 }
 
 static ssize_t bluesleep_write_proc_lpm(struct file *file,
-					const char __user *buffer,
-					size_t count, loff_t *data)
+					const char __user *buffer, size_t count,
+					loff_t *data)
 {
-    return count;
+	return count;
 }
 
 static ssize_t bluesleep_read_proc_btwrite(struct file *file,
-					   char __user *buffer,
-					   size_t count, loff_t *data)
+					   char __user *buffer, size_t count,
+					   loff_t *data)
 {
-    return sprintf(buffer, "unsupported to read\n");
+	return sprintf(buffer, "unsupported to read\n");
 }
 
 static ssize_t bluesleep_write_proc_btwrite(struct file *file,
 					    const char __user *buffer,
 					    size_t count, loff_t *data)
 {
-    char b;
+	char b;
 
-    if (count < 1)
-        return -EINVAL;
+	if (count < 1)
+		return -EINVAL;
 
-    if (copy_from_user(&b, buffer, 1))
-        return -EFAULT;
+	if (copy_from_user(&b, buffer, 1))
+		return -EFAULT;
 
-    DBG("btwrite %c\n", b);
-    /* HCI_DEV_WRITE */
-    if (b != '0') {
-        rfkill_rk_sleep_bt(BT_WAKEUP);
-    }
+	DBG("btwrite %c\n", b);
+	/* HCI_DEV_WRITE */
+	if (b != '0')
+		rfkill_rk_sleep_bt(BT_WAKEUP);
 
-    return count;
+	return count;
 }
 
 #ifdef CONFIG_OF
 static int bluetooth_platdata_parse_dt(struct device *dev,
-                  struct rfkill_rk_platform_data *data)
+				       struct rfkill_rk_platform_data *data)
 {
-    struct device_node *node = dev->of_node;
-    int gpio;
-    enum of_gpio_flags flags;
-
-    if (!node)
-        return -ENODEV;
-
-    memset(data, 0, sizeof(*data));
-
-    if (of_find_property(node, "wifi-bt-power-toggle", NULL)) {
-        data->power_toggle = true;
-        LOG("%s: get property wifi-bt-power-toggle.\n", __func__);
-    } else {
-        data->power_toggle = false;
-    }
-
-    gpio = of_get_named_gpio_flags(node, "uart_rts_gpios", 0, &flags);
-    if (gpio_is_valid(gpio)) {
-        data->rts_gpio.io = gpio;
-        data->rts_gpio.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-        LOG("%s: get property: uart_rts_gpios = %d.\n", __func__, gpio);
-        data->pinctrl = devm_pinctrl_get(dev);
-        if (!IS_ERR(data->pinctrl)) {
-            data->rts_gpio.default_state = pinctrl_lookup_state(data->pinctrl, "default");
-            data->rts_gpio.gpio_state = pinctrl_lookup_state(data->pinctrl, "rts_gpio");
-        } else {
-            data->pinctrl = NULL;
-            LOG("%s: dts does't define the uart rts iomux.\n", __func__);
-            return -EINVAL;
-        }
-    } else {
-        data->pinctrl = NULL;
-        data->rts_gpio.io = -EINVAL;
-        LOG("%s: uart_rts_gpios is no-in-use.\n", __func__);
-    }
-
-    gpio = of_get_named_gpio_flags(node, "BT,power_gpio", 0, &flags);
-    if (gpio_is_valid(gpio)){
-        data->poweron_gpio.io = gpio;
-        data->poweron_gpio.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-        LOG("%s: get property: BT,power_gpio = %d.\n", __func__, gpio);
-    } else data->poweron_gpio.io = -1;
-    gpio = of_get_named_gpio_flags(node, "BT,reset_gpio", 0, &flags);
-    if (gpio_is_valid(gpio)){
-        data->reset_gpio.io = gpio;
-        data->reset_gpio.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-        LOG("%s: get property: BT,reset_gpio = %d.\n", __func__, gpio);
-    } else data->reset_gpio.io = -1;
-    gpio = of_get_named_gpio_flags(node, "BT,wake_gpio", 0, &flags);
-    if (gpio_is_valid(gpio)){
-        data->wake_gpio.io = gpio;
-        data->wake_gpio.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-        LOG("%s: get property: BT,wake_gpio = %d.\n", __func__, gpio);
-    } else data->wake_gpio.io = -1;
-    gpio = of_get_named_gpio_flags(node, "BT,wake_host_irq", 0, &flags);
-    if (gpio_is_valid(gpio)) {
-        data->wake_host_irq.gpio.io = gpio;
-        data->wake_host_irq.gpio.enable = flags;
-        LOG("%s: get property: BT,wake_host_irq = %d.\n", __func__, gpio);
-    } else data->wake_host_irq.gpio.io = -1;
+	struct device_node *node = dev->of_node;
+	int gpio;
+	enum of_gpio_flags flags;
+
+	if (!node)
+		return -ENODEV;
+
+	memset(data, 0, sizeof(*data));
+
+	if (of_find_property(node, "wifi-bt-power-toggle", NULL)) {
+		data->power_toggle = true;
+		LOG("%s: get property wifi-bt-power-toggle.\n", __func__);
+	} else {
+		data->power_toggle = false;
+	}
+
+	gpio = of_get_named_gpio_flags(node, "uart_rts_gpios", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->rts_gpio.io = gpio;
+		data->rts_gpio.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: uart_rts_gpios = %d.\n", __func__, gpio);
+		data->pinctrl = devm_pinctrl_get(dev);
+		if (!IS_ERR(data->pinctrl)) {
+			data->rts_gpio.default_state =
+				pinctrl_lookup_state(data->pinctrl, "default");
+			data->rts_gpio.gpio_state =
+				pinctrl_lookup_state(data->pinctrl, "rts_gpio");
+		} else {
+			data->pinctrl = NULL;
+			LOG("%s: dts does't define the uart rts iomux.\n",
+			    __func__);
+			return -EINVAL;
+		}
+	} else {
+		data->pinctrl = NULL;
+		data->rts_gpio.io = -EINVAL;
+		LOG("%s: uart_rts_gpios is no-in-use.\n", __func__);
+	}
+
+	gpio = of_get_named_gpio_flags(node, "BT,power_gpio", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->poweron_gpio.io = gpio;
+		data->poweron_gpio.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: BT,power_gpio = %d.\n", __func__, gpio);
+	} else {
+		data->poweron_gpio.io = -1;
+	}
+	gpio = of_get_named_gpio_flags(node, "BT,reset_gpio", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->reset_gpio.io = gpio;
+		data->reset_gpio.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: BT,reset_gpio = %d.\n", __func__, gpio);
+	} else {
+		data->reset_gpio.io = -1;
+	}
+	gpio = of_get_named_gpio_flags(node, "BT,wake_gpio", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->wake_gpio.io = gpio;
+		data->wake_gpio.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: BT,wake_gpio = %d.\n", __func__, gpio);
+	} else {
+		data->wake_gpio.io = -1;
+	}
+	gpio = of_get_named_gpio_flags(node, "BT,wake_host_irq", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->wake_host_irq.gpio.io = gpio;
+		data->wake_host_irq.gpio.enable = flags;
+		LOG("%s: get property: BT,wake_host_irq = %d.\n", __func__,
+		    gpio);
+	} else {
+		data->wake_host_irq.gpio.io = -1;
+	}
 
 	data->ext_clk = devm_clk_get(dev, "ext_clock");
 	if (IS_ERR(data->ext_clk)) {
@@ -539,15 +554,15 @@ static int bluetooth_platdata_parse_dt(struct device *dev,
 #endif //CONFIG_OF
 
 static const struct file_operations bluesleep_lpm = {
-    .owner = THIS_MODULE,
-    .read = bluesleep_read_proc_lpm,
-    .write = bluesleep_write_proc_lpm,
+	.owner = THIS_MODULE,
+	.read = bluesleep_read_proc_lpm,
+	.write = bluesleep_write_proc_lpm,
 };
 
 static const struct file_operations bluesleep_btwrite = {
-    .owner = THIS_MODULE,
-    .read = bluesleep_read_proc_btwrite,
-    .write = bluesleep_write_proc_btwrite,
+	.owner = THIS_MODULE,
+	.read = bluesleep_read_proc_btwrite,
+	.write = bluesleep_write_proc_btwrite,
 };
 
 static int rfkill_rk_probe(struct platform_device *pdev)
@@ -555,111 +570,124 @@ static int rfkill_rk_probe(struct platform_device *pdev)
 	struct rfkill_rk_data *rfkill;
 	struct rfkill_rk_platform_data *pdata = pdev->dev.platform_data;
 	int ret = 0;
-    struct proc_dir_entry *ent;
+	struct proc_dir_entry *ent;
 
-    DBG("Enter %s\n", __func__);
+	DBG("Enter %s\n", __func__);
 
-    if (!pdata) {
+	if (!pdata) {
 #ifdef CONFIG_OF
-        pdata = devm_kzalloc(&pdev->dev, sizeof(struct rfkill_rk_platform_data), GFP_KERNEL);
-        if (!pdata)
-            return -ENOMEM;
-
-        ret = bluetooth_platdata_parse_dt(&pdev->dev, pdata);
-        if (ret < 0) {
+		pdata = devm_kzalloc(&pdev->dev,
+				     sizeof(struct rfkill_rk_platform_data),
+				     GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+
+		ret = bluetooth_platdata_parse_dt(&pdev->dev, pdata);
+		if (ret < 0) {
 #endif
-            LOG("%s: No platform data specified\n", __func__);
-            return ret;
+			LOG("%s: No platform data specified\n", __func__);
+			return ret;
 #ifdef CONFIG_OF
-        }
+		}
 #endif
-    }
+	}
 
-    pdata->name = (char*)bt_name;
-    pdata->type = RFKILL_TYPE_BLUETOOTH;
+	pdata->name = (char *)bt_name;
+	pdata->type = RFKILL_TYPE_BLUETOOTH;
 
 	rfkill = devm_kzalloc(&pdev->dev, sizeof(*rfkill), GFP_KERNEL);
 	if (!rfkill)
 		return -ENOMEM;
 
 	rfkill->pdata = pdata;
-    rfkill->pdev = pdev;
-    g_rfkill = rfkill;
+	rfkill->pdev = pdev;
+	g_rfkill = rfkill;
 
-    bluetooth_dir = proc_mkdir("bluetooth", NULL);
-    if (bluetooth_dir == NULL) {
-        LOG("Unable to create /proc/bluetooth directory");
-        return -ENOMEM;
-    }
+	bluetooth_dir = proc_mkdir("bluetooth", NULL);
+	if (!bluetooth_dir) {
+		LOG("Unable to create /proc/bluetooth directory");
+		return -ENOMEM;
+	}
 
-    sleep_dir = proc_mkdir("sleep", bluetooth_dir);
-    if (sleep_dir == NULL) {
-        LOG("Unable to create /proc/%s directory", PROC_DIR);
-        return -ENOMEM;
-    }
+	sleep_dir = proc_mkdir("sleep", bluetooth_dir);
+	if (!sleep_dir) {
+		LOG("Unable to create /proc/%s directory", PROC_DIR);
+		return -ENOMEM;
+	}
 
 	/* read/write proc entries */
-    ent = proc_create("lpm", 0, sleep_dir, &bluesleep_lpm);
-    if (ent == NULL) {
-        LOG("Unable to create /proc/%s/lpm entry", PROC_DIR);
-        ret = -ENOMEM;
-        goto fail_alloc;
-    }
+	ent = proc_create("lpm", 0, sleep_dir, &bluesleep_lpm);
+	if (!ent) {
+		LOG("Unable to create /proc/%s/lpm entry", PROC_DIR);
+		ret = -ENOMEM;
+		goto fail_alloc;
+	}
 
-    /* read/write proc entries */
-    ent = proc_create("btwrite", 0, sleep_dir, &bluesleep_btwrite);
-    if (ent == NULL) {
-        LOG("Unable to create /proc/%s/btwrite entry", PROC_DIR);
-        ret = -ENOMEM;
-        goto fail_alloc;
-    }
+	/* read/write proc entries */
+	ent = proc_create("btwrite", 0, sleep_dir, &bluesleep_btwrite);
+	if (!ent) {
+		LOG("Unable to create /proc/%s/btwrite entry", PROC_DIR);
+		ret = -ENOMEM;
+		goto fail_alloc;
+	}
 
-    DBG("init gpio\n");
+	DBG("init gpio\n");
 
-    ret = rfkill_rk_setup_gpio(pdev, &pdata->poweron_gpio, pdata->name, "poweron");
-    if (ret) goto fail_gpio;
+	ret = rfkill_rk_setup_gpio(pdev, &pdata->poweron_gpio, pdata->name,
+				   "poweron");
+	if (ret)
+		goto fail_gpio;
 
-    ret = rfkill_rk_setup_gpio(pdev, &pdata->reset_gpio, pdata->name, "reset");
-    if (ret) goto fail_gpio;
+	ret = rfkill_rk_setup_gpio(pdev, &pdata->reset_gpio, pdata->name,
+				   "reset");
+	if (ret)
+		goto fail_gpio;
 
-    ret = rfkill_rk_setup_gpio(pdev, &pdata->wake_gpio, pdata->name, "wake");
-    if (ret) goto fail_gpio;
+	ret = rfkill_rk_setup_gpio(pdev, &pdata->wake_gpio, pdata->name,
+				   "wake");
+	if (ret)
+		goto fail_gpio;
 
-    ret = rfkill_rk_setup_gpio(pdev, &pdata->rts_gpio, rfkill->pdata->name, "rts"); 
-    if (ret) goto fail_gpio;
+	ret = rfkill_rk_setup_gpio(pdev, &pdata->rts_gpio, rfkill->pdata->name,
+				   "rts");
+	if (ret)
+		goto fail_gpio;
 
-    wake_lock_init(&(rfkill->bt_irq_wl), WAKE_LOCK_SUSPEND, "rfkill_rk_irq_wl");
+	wake_lock_init(&rfkill->bt_irq_wl, WAKE_LOCK_SUSPEND,
+		       "rfkill_rk_irq_wl");
 
-    ret = rfkill_rk_setup_wake_irq(rfkill);
-    if (ret) goto fail_gpio;
+	ret = rfkill_rk_setup_wake_irq(rfkill);
+	if (ret)
+		goto fail_gpio;
 
-    DBG("setup rfkill\n");
+	DBG("setup rfkill\n");
 	rfkill->rfkill_dev = rfkill_alloc(pdata->name, &pdev->dev, pdata->type,
-				&rfkill_rk_ops, rfkill);
+					  &rfkill_rk_ops, rfkill);
 	if (!rfkill->rfkill_dev)
 		goto fail_alloc;
 
-    rfkill_set_states(rfkill->rfkill_dev, BT_BLOCKED, false);
+	rfkill_set_states(rfkill->rfkill_dev, BT_BLOCKED, false);
 	ret = rfkill_register(rfkill->rfkill_dev);
 	if (ret < 0)
 		goto fail_rfkill;
 
-    INIT_DELAYED_WORK(&rfkill->bt_sleep_delay_work, rfkill_rk_delay_sleep_bt);
+	INIT_DELAYED_WORK(&rfkill->bt_sleep_delay_work,
+			  rfkill_rk_delay_sleep_bt);
 
-    //rfkill_rk_set_power(rfkill, BT_BLOCKED);
-    // bt turn off power
-    if (gpio_is_valid(pdata->poweron_gpio.io))
-    {
-        gpio_direction_output(pdata->poweron_gpio.io, !pdata->poweron_gpio.enable);
-    }
-    if (gpio_is_valid(pdata->reset_gpio.io))
-    {
-        gpio_direction_output(pdata->reset_gpio.io, !pdata->reset_gpio.enable);
-    }
+	//rfkill_rk_set_power(rfkill, BT_BLOCKED);
+	// bt turn off power
+	if (gpio_is_valid(pdata->poweron_gpio.io)) {
+		gpio_direction_output(pdata->poweron_gpio.io,
+				      !pdata->poweron_gpio.enable);
+	}
+	if (gpio_is_valid(pdata->reset_gpio.io)) {
+		gpio_direction_output(pdata->reset_gpio.io,
+				      !pdata->reset_gpio.enable);
+	}
 
 	platform_set_drvdata(pdev, rfkill);
 
-    LOG("%s device registered.\n", pdata->name);
+	LOG("%s device registered.\n", pdata->name);
 
 	return 0;
 
@@ -671,7 +699,7 @@ static int rfkill_rk_probe(struct platform_device *pdev)
 	remove_proc_entry("lpm", sleep_dir);
 fail_gpio:
 
-        g_rfkill = NULL;
+	g_rfkill = NULL;
 	return ret;
 }
 
@@ -679,37 +707,36 @@ static int rfkill_rk_remove(struct platform_device *pdev)
 {
 	struct rfkill_rk_data *rfkill = platform_get_drvdata(pdev);
 
-    LOG("Enter %s\n", __func__);
+	LOG("Enter %s\n", __func__);
 
 	rfkill_unregister(rfkill->rfkill_dev);
 	rfkill_destroy(rfkill->rfkill_dev);
 
-    
-    cancel_delayed_work_sync(&rfkill->bt_sleep_delay_work);
+	cancel_delayed_work_sync(&rfkill->bt_sleep_delay_work);
 
-    // free gpio
-    if (gpio_is_valid(rfkill->pdata->rts_gpio.io))
-        gpio_free(rfkill->pdata->rts_gpio.io);
-    
-    if (gpio_is_valid(rfkill->pdata->wake_host_irq.gpio.io)){
-        free_irq(rfkill->pdata->wake_host_irq.irq, rfkill);
+	// free gpio
+	if (gpio_is_valid(rfkill->pdata->rts_gpio.io))
+		gpio_free(rfkill->pdata->rts_gpio.io);
+
+	if (gpio_is_valid(rfkill->pdata->wake_host_irq.gpio.io)) {
+		free_irq(rfkill->pdata->wake_host_irq.irq, rfkill);
 #ifndef CONFIG_BK3515A_COMBO
-        gpio_free(rfkill->pdata->wake_host_irq.gpio.io);
+		gpio_free(rfkill->pdata->wake_host_irq.gpio.io);
 #endif
-    }
-    
+	}
+
 #ifndef CONFIG_BK3515A_COMBO
-    if (gpio_is_valid(rfkill->pdata->wake_gpio.io))
-        gpio_free(rfkill->pdata->wake_gpio.io);
+	if (gpio_is_valid(rfkill->pdata->wake_gpio.io))
+		gpio_free(rfkill->pdata->wake_gpio.io);
 #endif
-    
-    if (gpio_is_valid(rfkill->pdata->reset_gpio.io))
-        gpio_free(rfkill->pdata->reset_gpio.io);
-    
-    if (gpio_is_valid(rfkill->pdata->poweron_gpio.io))
+
+	if (gpio_is_valid(rfkill->pdata->reset_gpio.io))
+		gpio_free(rfkill->pdata->reset_gpio.io);
+
+	if (gpio_is_valid(rfkill->pdata->poweron_gpio.io))
 		gpio_free(rfkill->pdata->poweron_gpio.io);
 	clk_disable_unprepare(rfkill->pdata->ext_clk);
-    g_rfkill = NULL;
+	g_rfkill = NULL;
 
 	return 0;
 }
@@ -721,8 +748,8 @@ static const struct dev_pm_ops rfkill_rk_pm_ops = {
 
 #ifdef CONFIG_OF
 static struct of_device_id bt_platdata_of_match[] = {
-    { .compatible = "bluetooth-platdata" },
-    { }
+	{ .compatible = "bluetooth-platdata" },
+	{}
 };
 MODULE_DEVICE_TABLE(of, bt_platdata_of_match);
 #endif //CONFIG_OF
@@ -740,13 +767,13 @@ static struct platform_driver rfkill_rk_driver = {
 
 static int __init rfkill_rk_init(void)
 {
-    LOG("Enter %s\n", __func__);
+	LOG("Enter %s\n", __func__);
 	return platform_driver_register(&rfkill_rk_driver);
 }
 
 static void __exit rfkill_rk_exit(void)
 {
-    LOG("Enter %s\n", __func__);
+	LOG("Enter %s\n", __func__);
 	platform_driver_unregister(&rfkill_rk_driver);
 }
 
@@ -756,4 +783,3 @@ module_exit(rfkill_rk_exit);
 MODULE_DESCRIPTION("rock-chips rfkill for Bluetooth v0.3");
 MODULE_AUTHOR("cmy@rock-chips.com, gwl@rock-chips.com");
 MODULE_LICENSE("GPL");
-
diff --git a/net/rfkill/rfkill-wlan.c b/net/rfkill/rfkill-wlan.c
index 73c969ef03ba..11a973e2bf53 100644
--- a/net/rfkill/rfkill-wlan.c
+++ b/net/rfkill/rfkill-wlan.c
@@ -48,16 +48,16 @@
 #include "../../drivers/mmc/core/pwrseq.h"
 
 #if 0
-#define DBG(x...)   printk(KERN_INFO "[WLAN_RFKILL]: "x)
+#define DBG(x...) pr_info("[WLAN_RFKILL]: " x)
 #else
 #define DBG(x...)
 #endif
 
-#define LOG(x...)   printk(KERN_INFO "[WLAN_RFKILL]: "x)
+#define LOG(x...) pr_info("[WLAN_RFKILL]: " x)
 
 struct rfkill_wlan_data {
 	struct rksdmmc_gpio_wifi_moudle *pdata;
-    struct wake_lock            wlan_irq_wl;
+	struct wake_lock wlan_irq_wl;
 };
 
 static struct rfkill_wlan_data *g_rfkill = NULL;
@@ -78,94 +78,94 @@ static char wifi_chip_type_string[64];
 #endif
 //===========================
 #if BCM_STATIC_MEMORY_SUPPORT
-#define PREALLOC_WLAN_SEC_NUM           4
-#define PREALLOC_WLAN_BUF_NUM           160
-#define PREALLOC_WLAN_SECTION_HEADER    0
-#define WLAN_SKB_BUF_NUM        16
-
-#define WLAN_SECTION_SIZE_0     (12 * 1024)
-#define WLAN_SECTION_SIZE_1     (12 * 1024)
-#define WLAN_SECTION_SIZE_2     (32 * 1024)
-#define WLAN_SECTION_SIZE_3     (136* 1024)
-#define WLAN_SECTION_SIZE_4     (4  * 1024)
-#define WLAN_SECTION_SIZE_5     (64 * 1024)
-#define WLAN_SECTION_SIZE_6     (4  * 1024)
-#define WLAN_SECTION_SIZE_7     (4  * 1024)
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM+1];
+#define PREALLOC_WLAN_SEC_NUM 4
+#define PREALLOC_WLAN_BUF_NUM 160
+#define PREALLOC_WLAN_SECTION_HEADER 0
+#define WLAN_SKB_BUF_NUM 16
+
+#define WLAN_SECTION_SIZE_0 (12 * 1024)
+#define WLAN_SECTION_SIZE_1 (12 * 1024)
+#define WLAN_SECTION_SIZE_2 (32 * 1024)
+#define WLAN_SECTION_SIZE_3 (136 * 1024)
+#define WLAN_SECTION_SIZE_4 (4 * 1024)
+#define WLAN_SECTION_SIZE_5 (64 * 1024)
+#define WLAN_SECTION_SIZE_6 (4 * 1024)
+#define WLAN_SECTION_SIZE_7 (4 * 1024)
+
+static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM + 1];
 
 struct wifi_mem_prealloc {
-    void *mem_ptr;
-    unsigned long size;
+	void *mem_ptr;
+	unsigned long size;
 };
 
 static struct wifi_mem_prealloc wifi_mem_array[8] = {
-    {NULL, (WLAN_SECTION_SIZE_0)},
-    {NULL, (WLAN_SECTION_SIZE_1)},
-    {NULL, (WLAN_SECTION_SIZE_2)},
-    {NULL, (WLAN_SECTION_SIZE_3)},
-    {NULL, (WLAN_SECTION_SIZE_4)},
-    {NULL, (WLAN_SECTION_SIZE_5)},
-    {NULL, (WLAN_SECTION_SIZE_6)},
-    {NULL, (WLAN_SECTION_SIZE_7)}
+	{ NULL, (WLAN_SECTION_SIZE_0) }, { NULL, (WLAN_SECTION_SIZE_1) },
+	{ NULL, (WLAN_SECTION_SIZE_2) }, { NULL, (WLAN_SECTION_SIZE_3) },
+	{ NULL, (WLAN_SECTION_SIZE_4) }, { NULL, (WLAN_SECTION_SIZE_5) },
+	{ NULL, (WLAN_SECTION_SIZE_6) }, { NULL, (WLAN_SECTION_SIZE_7) }
 };
 
 static int rockchip_init_wifi_mem(void)
 {
-    int i;
-    int j;
+	int i;
+	int j;
 
-    for (i = 0 ; i < WLAN_SKB_BUF_NUM ; i++) {
-        wlan_static_skb[i] = dev_alloc_skb(
-               ((i < (WLAN_SKB_BUF_NUM / 2)) ? (PAGE_SIZE*1) : (PAGE_SIZE*2)));
+	for (i = 0; i < WLAN_SKB_BUF_NUM; i++) {
+		wlan_static_skb[i] =
+			dev_alloc_skb(((i < (WLAN_SKB_BUF_NUM / 2)) ?
+				(PAGE_SIZE * 1) :
+				(PAGE_SIZE * 2)));
 
-        if (!wlan_static_skb[i])
-            goto err_skb_alloc;
-    }
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+	}
 
-    wlan_static_skb[i] = dev_alloc_skb((PAGE_SIZE*4));
-    if (!wlan_static_skb[i])
-        goto err_skb_alloc;
+	wlan_static_skb[i] = dev_alloc_skb((PAGE_SIZE * 4));
+	if (!wlan_static_skb[i])
+		goto err_skb_alloc;
 
-    for (i = 0 ; i <= 7; i++) {
-        wifi_mem_array[i].mem_ptr =
-               kmalloc(wifi_mem_array[i].size, GFP_KERNEL);
+	for (i = 0; i <= 7; i++) {
+		wifi_mem_array[i].mem_ptr =
+			kmalloc(wifi_mem_array[i].size, GFP_KERNEL);
 
-        if (!wifi_mem_array[i].mem_ptr)
-            goto err_mem_alloc;
-    }
-    return 0;
+		if (!wifi_mem_array[i].mem_ptr)
+			goto err_mem_alloc;
+	}
+	return 0;
 
 err_mem_alloc:
-    pr_err("Failed to mem_alloc for WLAN\n");
-    for (j = 0 ; j < i ; j++)
-        kfree(wifi_mem_array[j].mem_ptr);
-    i = WLAN_SKB_BUF_NUM;
+	pr_err("Failed to mem_alloc for WLAN\n");
+	for (j = 0; j < i; j++)
+		kfree(wifi_mem_array[j].mem_ptr);
+	i = WLAN_SKB_BUF_NUM;
 err_skb_alloc:
-    pr_err("Failed to skb_alloc for WLAN\n");
-    for (j = 0 ; j < i ; j++)
-        dev_kfree_skb(wlan_static_skb[j]);
-    dev_kfree_skb(wlan_static_skb[j]);
+	pr_err("Failed to skb_alloc for WLAN\n");
+	for (j = 0; j < i; j++)
+		dev_kfree_skb(wlan_static_skb[j]);
+	dev_kfree_skb(wlan_static_skb[j]);
 
-    return -ENOMEM;
+	return -ENOMEM;
 }
 
 void *rockchip_mem_prealloc(int section, unsigned long size)
 {
-    //printk("rockchip_mem_prealloc: section = %d, size = %d\n", section, size);
-    if (section == PREALLOC_WLAN_SEC_NUM)
-        return wlan_static_skb;
+	if (section == PREALLOC_WLAN_SEC_NUM)
+		return wlan_static_skb;
 
-    if ((section < 0) || (section > 7))
-        return NULL;
+	if (section < 0 || section > 7)
+		return NULL;
 
-    if (wifi_mem_array[section].size < size)
-        return NULL;
+	if (wifi_mem_array[section].size < size)
+		return NULL;
 
-    return wifi_mem_array[section].mem_ptr;
+	return wifi_mem_array[section].mem_ptr;
 }
 #else
-void *rockchip_mem_prealloc(int section, unsigned long size) { return NULL;}
+void *rockchip_mem_prealloc(int section, unsigned long size)
+{
+	return NULL;
+}
 #endif
 EXPORT_SYMBOL(rockchip_mem_prealloc);
 
@@ -177,16 +177,17 @@ EXPORT_SYMBOL(rockchip_mem_prealloc);
 static int wifi_power_state = 0;
 int rfkill_get_wifi_power_state(int *power, int *vref_ctrl_enable)
 {
-    struct rfkill_wlan_data *mrfkill = g_rfkill;
+	struct rfkill_wlan_data *mrfkill = g_rfkill;
 
-    if (mrfkill == NULL) {
-        LOG("%s: rfkill-wlan driver has not Successful initialized\n", __func__);
-        return -1;
-    }
+	if (!mrfkill) {
+		LOG("%s: rfkill-wlan driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
 
-    *power = wifi_power_state;
+	*power = wifi_power_state;
 
-    return 0;
+	return 0;
 }
 
 /**************************************************************************
@@ -199,70 +200,70 @@ int rfkill_get_wifi_power_state(int *power, int *vref_ctrl_enable)
 int rockchip_wifi_power(int on)
 {
 	struct rfkill_wlan_data *mrfkill = g_rfkill;
-    struct rksdmmc_gpio *poweron, *reset;
-    struct regulator *ldo = NULL;
-    int power = 0;
-    bool toggle = false;
+	struct rksdmmc_gpio *poweron, *reset;
+	struct regulator *ldo = NULL;
+	int power = 0;
+	bool toggle = false;
 
-    LOG("%s: %d\n", __func__, on);
+	LOG("%s: %d\n", __func__, on);
 
 	if (!on && primary_sdio_host)
 		mmc_pwrseq_power_off(primary_sdio_host);
 
-    if (mrfkill == NULL) {
-        LOG("%s: rfkill-wlan driver has not Successful initialized\n", __func__);
-        return -1;
-    }
-
-    if (mrfkill->pdata->wifi_power_remain && power_set_time) {
-        LOG("%s: wifi power is setted to be remain on. skip anything to the power control", __func__);
-        return 0;
-    } else power_set_time++;
-
-    if (!rfkill_get_bt_power_state(&power, &toggle)) {
-        if (toggle == true && power == 1) {
-            LOG("%s: wifi shouldn't control the power, it was enabled by BT!\n", __func__);
-            return 0;
-        }
-    }
-
-    if (mrfkill->pdata->mregulator.power_ctrl_by_pmu) {
-        int ret = -1;
-        char *ldostr;
-        int level = mrfkill->pdata->mregulator.enable;
-
-        ldostr = mrfkill->pdata->mregulator.pmu_regulator;
-        if (ldostr == NULL) {
-            LOG("%s: wifi power set to be controled by pmic, but which one?\n", __func__);
-            return -1;
-        }
-        ldo = regulator_get(NULL, ldostr);
-        if (ldo == NULL || IS_ERR(ldo)) {
-            LOG("\n\n\n%s get ldo error,please mod this\n\n\n", __func__);
-            return -1;
-        } else {
-			if (on == level) {
-				regulator_set_voltage(ldo, 3000000, 3000000);
-			    LOG("%s: %s enabled\n", __func__, ldostr);
-				ret = regulator_enable(ldo);
-                wifi_power_state = 1;
-			    LOG("wifi turn on power.\n");
-            } else {
-				LOG("%s: %s disabled\n", __func__, ldostr);
-                while (regulator_is_enabled(ldo) > 0) {
-				    ret = regulator_disable(ldo);
-                }
-                wifi_power_state = 0;
-			    LOG("wifi shut off power.\n");
-			}
-			regulator_put(ldo);
-			msleep(100);
+	if (!mrfkill) {
+		LOG("%s: rfkill-wlan driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
+
+	if (mrfkill->pdata->wifi_power_remain && power_set_time) {
+		LOG("%s: wifi power is setted to be remain on.", __func__);
+		return 0;
+	}
+	power_set_time++;
+
+	if (!rfkill_get_bt_power_state(&power, &toggle)) {
+		if (toggle && power == 1) {
+			LOG("%s: wifi shouldn't control the power\n",
+			    __func__);
+			return 0;
+		}
+	}
+
+	if (mrfkill->pdata->mregulator.power_ctrl_by_pmu) {
+		int ret = -1;
+		char *ldostr;
+		int level = mrfkill->pdata->mregulator.enable;
+
+		ldostr = mrfkill->pdata->mregulator.pmu_regulator;
+		if (!ldostr)
+			return -1;
+		ldo = regulator_get(NULL, ldostr);
+		if (!ldo || IS_ERR(ldo)) {
+			LOG("\n\n\n%s get ldo error,please mod this\n\n\n",
+			    __func__);
+			return -1;
 		}
-    } else {
+		if (on == level) {
+			regulator_set_voltage(ldo, 3000000, 3000000);
+			LOG("%s: %s enabled\n", __func__, ldostr);
+			ret = regulator_enable(ldo);
+			wifi_power_state = 1;
+			LOG("wifi turn on power.\n");
+		} else {
+			LOG("%s: %s disabled\n", __func__, ldostr);
+			while (regulator_is_enabled(ldo) > 0)
+				ret = regulator_disable(ldo);
+			wifi_power_state = 0;
+			LOG("wifi shut off power.\n");
+		}
+		regulator_put(ldo);
+		msleep(100);
+	} else {
 		poweron = &mrfkill->pdata->power_n;
 		reset = &mrfkill->pdata->reset_n;
 
-		if (on){
+		if (on) {
 			if (gpio_is_valid(poweron->io)) {
 				gpio_set_value(poweron->io, poweron->enable);
 				msleep(100);
@@ -273,9 +274,9 @@ int rockchip_wifi_power(int on)
 				msleep(100);
 			}
 
-            wifi_power_state = 1;
+			wifi_power_state = 1;
 			LOG("wifi turn on power. %d\n", poweron->io);
-		}else{
+		} else {
 			if (gpio_is_valid(poweron->io)) {
 				gpio_set_value(poweron->io, !(poweron->enable));
 				msleep(100);
@@ -285,12 +286,12 @@ int rockchip_wifi_power(int on)
 				gpio_set_value(reset->io, !(reset->enable));
 			}
 
-            wifi_power_state = 0;
+			wifi_power_state = 0;
 			LOG("wifi shut off power.\n");
 		}
-    }
+	}
 
-    return 0;
+	return 0;
 }
 EXPORT_SYMBOL(rockchip_wifi_power);
 
@@ -313,25 +314,26 @@ EXPORT_SYMBOL(rockchip_wifi_set_carddetect);
  *************************************************************************/
 int rockchip_wifi_get_oob_irq(void)
 {
-    struct rfkill_wlan_data *mrfkill = g_rfkill;
-    struct rksdmmc_gpio *wifi_int_irq;
-
-    LOG("%s: Enter\n", __func__);
-
-    if (mrfkill == NULL) {
-        LOG("%s: rfkill-wlan driver has not Successful initialized\n", __func__);
-        return -1;
-    }
-    
-    wifi_int_irq = &mrfkill->pdata->wifi_int_b;
-    if (gpio_is_valid(wifi_int_irq->io)) {
-        return gpio_to_irq(wifi_int_irq->io);
-        //return wifi_int_irq->io;
-    } else {
-        LOG("%s: wifi OOB pin isn't defined.\n", __func__);
-    }
-    
-    return -1;
+	struct rfkill_wlan_data *mrfkill = g_rfkill;
+	struct rksdmmc_gpio *wifi_int_irq;
+
+	LOG("%s: Enter\n", __func__);
+
+	if (!mrfkill) {
+		LOG("%s: rfkill-wlan driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
+
+	wifi_int_irq = &mrfkill->pdata->wifi_int_b;
+	if (gpio_is_valid(wifi_int_irq->io)) {
+		return gpio_to_irq(wifi_int_irq->io);
+		//return wifi_int_irq->io;
+	} else {
+		LOG("%s: wifi OOB pin isn't defined.\n", __func__);
+	}
+
+	return -1;
 }
 EXPORT_SYMBOL(rockchip_wifi_get_oob_irq);
 
@@ -358,7 +360,7 @@ EXPORT_SYMBOL(rockchip_wifi_get_oob_irq_flag);
  *************************************************************************/
 int rockchip_wifi_reset(int on)
 {
-    return 0;
+	return 0;
 }
 EXPORT_SYMBOL(rockchip_wifi_reset);
 
@@ -369,7 +371,7 @@ EXPORT_SYMBOL(rockchip_wifi_reset);
  *************************************************************************/
 #include <linux/etherdevice.h>
 #include <linux/errno.h>
-u8 wifi_custom_mac_addr[6] = {0,0,0,0,0,0};
+u8 wifi_custom_mac_addr[6] = { 0, 0, 0, 0, 0, 0 };
 
 //#define RANDOM_ADDRESS_SAVE
 static int get_wifi_addr_vendor(unsigned char *addr)
@@ -391,13 +393,12 @@ static int get_wifi_addr_vendor(unsigned char *addr)
 		random_ether_addr(addr);
 		LOG("%s: generate random wifi mac address: "
 		    "%02x:%02x:%02x:%02x:%02x:%02x\n",
-		    __func__, addr[0], addr[1], addr[2],
-		    addr[3], addr[4], addr[5]);
+		    __func__, addr[0], addr[1], addr[2], addr[3], addr[4],
+		    addr[5]);
 		ret = rk_vendor_write(WIFI_MAC_ID, addr, 6);
 		if (ret != 0) {
-			LOG("%s: rk_vendor_write"
-				" wifi mac address failed (%d)\n",
-				__func__, ret);
+			LOG("%s: rk_vendor_write failed %d\n"
+			    __func__, ret);
 			memset(addr, 0, 6);
 			return -1;
 		}
@@ -407,15 +408,15 @@ static int get_wifi_addr_vendor(unsigned char *addr)
 	} else {
 		LOG("%s: rk_vendor_read wifi mac address: "
 		    "%02x:%02x:%02x:%02x:%02x:%02x\n",
-		    __func__, addr[0], addr[1], addr[2],
-		    addr[3], addr[4], addr[5]);
+		    __func__, addr[0], addr[1], addr[2], addr[3], addr[4],
+		    addr[5]);
 	}
 	return 0;
 }
 
 int rockchip_wifi_mac_addr(unsigned char *buf)
 {
-	char mac_buf[20] = {0};
+	char mac_buf[20] = { 0 };
 
 	LOG("%s: enter.\n", __func__);
 
@@ -451,130 +452,156 @@ EXPORT_SYMBOL(rockchip_wifi_mac_addr);
  *
  *************************************************************************/
 struct cntry_locales_custom {
-    char iso_abbrev[4];  /* ISO 3166-1 country abbreviation */
-    char custom_locale[4];   /* Custom firmware locale */
-    int custom_locale_rev;        /* Custom local revisin default -1 */
+	char iso_abbrev[4]; /* ISO 3166-1 country abbreviation */
+	char custom_locale[4]; /* Custom firmware locale */
+	int custom_locale_rev; /* Custom local revisin default -1 */
 };
 
 static struct cntry_locales_custom country_cloc;
 
 void *rockchip_wifi_country_code(char *ccode)
 {
-    struct cntry_locales_custom *mcloc;
+	struct cntry_locales_custom *mcloc;
 
-    LOG("%s: set country code [%s]\n", __func__, ccode);
-    mcloc = &country_cloc;
-    memcpy(mcloc->custom_locale, ccode, 4);
-    mcloc->custom_locale_rev = 0;
+	LOG("%s: set country code [%s]\n", __func__, ccode);
+	mcloc = &country_cloc;
+	memcpy(mcloc->custom_locale, ccode, 4);
+	mcloc->custom_locale_rev = 0;
 
-    return mcloc;
+	return mcloc;
 }
 EXPORT_SYMBOL(rockchip_wifi_country_code);
 /**************************************************************************/
 
-static int rfkill_rk_setup_gpio(struct rksdmmc_gpio *gpio, const char* prefix, const char* name)
+static int rfkill_rk_setup_gpio(struct rksdmmc_gpio *gpio, const char *prefix,
+				const char *name)
 {
-    if (gpio_is_valid(gpio->io)) {
-        int ret=0;
-        sprintf(gpio->name, "%s_%s", prefix, name);
-        ret = gpio_request(gpio->io, gpio->name);
-        if (ret) {
-            LOG("Failed to get %s gpio.\n", gpio->name);
-            return -1;
-        }
-    }
-
-    return 0;
+	if (gpio_is_valid(gpio->io)) {
+		int ret = 0;
+
+		sprintf(gpio->name, "%s_%s", prefix, name);
+		ret = gpio_request(gpio->io, gpio->name);
+		if (ret) {
+			LOG("Failed to get %s gpio.\n", gpio->name);
+			return -1;
+		}
+	}
+
+	return 0;
 }
 
 #ifdef CONFIG_OF
 static int wlan_platdata_parse_dt(struct device *dev,
-                  struct rksdmmc_gpio_wifi_moudle *data)
+				  struct rksdmmc_gpio_wifi_moudle *data)
 {
-    struct device_node *node = dev->of_node;
-    const char *strings;
-    u32 value;
-    int gpio,ret;
-    enum of_gpio_flags flags;
+	struct device_node *node = dev->of_node;
+	const char *strings;
+	u32 value;
+	int gpio, ret;
+	enum of_gpio_flags flags;
 	u32 ext_clk_value = 0;
 
-    if (!node)
-        return -ENODEV;
+	if (!node)
+		return -ENODEV;
 
-    memset(data, 0, sizeof(*data));
+	memset(data, 0, sizeof(*data));
 
 #ifdef CONFIG_MFD_SYSCON
-    data->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
-    if (IS_ERR(data->grf)) {
-            LOG("can't find rockchip,grf property\n");
-            //return -1;
-    }
+	data->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
+	if (IS_ERR(data->grf)) {
+		LOG("can't find rockchip,grf property\n");
+		//return -1;
+	}
 #endif
 
-    ret = of_property_read_string(node, "wifi_chip_type", &strings);
-    if (ret) {
-        LOG("%s: Can not read wifi_chip_type, set default to rkwifi.\n", __func__);
-        strcpy(wifi_chip_type_string, "rkwifi");
-    } else {
-        strcpy(wifi_chip_type_string, strings);
-    }
-    LOG("%s: wifi_chip_type = %s\n", __func__, wifi_chip_type_string);
-
-    if (of_find_property(node, "keep_wifi_power_on", NULL)) {
-        data->wifi_power_remain = true;
-        LOG("%s: wifi power will enabled while kernel starting and keep on.\n", __func__);
-    } else {
-        data->wifi_power_remain = false;
-        LOG("%s: enable wifi power control.\n", __func__);
-    }
-
-    if (of_find_property(node, "power_ctrl_by_pmu", NULL)) {
-        data->mregulator.power_ctrl_by_pmu = true;
-        ret = of_property_read_string(node, "power_pmu_regulator", &strings);
-        if (ret) {
-            LOG("%s: Can not read property: power_pmu_regulator.\n", __func__);
-            data->mregulator.power_ctrl_by_pmu = false;
-        } else {
-            LOG("%s: wifi power controled by pmu(%s).\n", __func__, strings);
-            sprintf(data->mregulator.pmu_regulator, "%s", strings);
-        }
-        ret = of_property_read_u32(node, "power_pmu_enable_level", &value);
-        if (ret) {
-            LOG("%s: Can not read property: power_pmu_enable_level.\n", __func__);
-            data->mregulator.power_ctrl_by_pmu = false;
-        } else {
-            LOG("%s: wifi power controled by pmu(level = %s).\n", __func__, (value == 1)?"HIGH":"LOW");
-            data->mregulator.enable = value;
-        }
+	ret = of_property_read_string(node, "wifi_chip_type", &strings);
+	if (ret) {
+		LOG("%s: Can not read wifi_chip_type, set default to rkwifi.\n",
+		    __func__);
+		strcpy(wifi_chip_type_string, "rkwifi");
+	} else {
+		strcpy(wifi_chip_type_string, strings);
+	}
+	LOG("%s: wifi_chip_type = %s\n", __func__, wifi_chip_type_string);
+
+	if (of_find_property(node, "keep_wifi_power_on", NULL)) {
+		data->wifi_power_remain = true;
+		LOG("%s: wifi power remain\n", __func__);
+	} else {
+		data->wifi_power_remain = false;
+		LOG("%s: enable wifi power control.\n", __func__);
+	}
+
+	if (of_find_property(node, "power_ctrl_by_pmu", NULL)) {
+		data->mregulator.power_ctrl_by_pmu = true;
+		ret = of_property_read_string(node, "power_pmu_regulator",
+					      &strings);
+		if (ret) {
+			LOG("%s: Can not read property: power_pmu_regulator.\n",
+			    __func__);
+			data->mregulator.power_ctrl_by_pmu = false;
+		} else {
+			LOG("%s: wifi power controlled by pmu(%s).\n", __func__,
+			    strings);
+			sprintf(data->mregulator.pmu_regulator, "%s", strings);
+		}
+		ret = of_property_read_u32(node, "power_pmu_enable_level",
+					   &value);
+		if (ret) {
+			LOG("%s: Can not read: power_pmu_enable_level.\n",
+			    __func__);
+			data->mregulator.power_ctrl_by_pmu = false;
+		} else {
+			LOG("%s: wifi power controlled by pmu(level = %s).\n",
+			    __func__, (value == 1) ? "HIGH" : "LOW");
+			data->mregulator.enable = value;
+		}
 	} else {
 		data->mregulator.power_ctrl_by_pmu = false;
 		LOG("%s: wifi power controled by gpio.\n", __func__);
-        gpio = of_get_named_gpio_flags(node, "WIFI,poweren_gpio", 0, &flags);
-        if (gpio_is_valid(gpio)){
+		gpio = of_get_named_gpio_flags(node, "WIFI,poweren_gpio", 0,
+					       &flags);
+		if (gpio_is_valid(gpio)) {
 			data->power_n.io = gpio;
-			data->power_n.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-			LOG("%s: get property: WIFI,poweren_gpio = %d, flags = %d.\n", __func__, gpio, flags);
-        } else data->power_n.io = -1;
-	gpio = of_get_named_gpio_flags(node, "WIFI,vbat_gpio", 0, &flags);
-	if (gpio_is_valid(gpio)) {
+			data->power_n.enable =
+				(flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+			LOG("%s: WIFI,poweren_gpio = %d flags = %d.\n",
+			    __func__, gpio, flags);
+		} else {
+			data->power_n.io = -1;
+		}
+		gpio = of_get_named_gpio_flags(node, "WIFI,vbat_gpio", 0,
+					       &flags);
+		if (gpio_is_valid(gpio)) {
 			data->vbat_n.io = gpio;
-			data->vbat_n.enable = (flags == GPIO_ACTIVE_HIGH) ? 1:0;
-			LOG("%s: get property: WIFI,vbat_gpio = %d, flags = %d.\n", __func__, gpio, flags);
-	} else {
-		data->vbat_n.io = -1;
-	}
-        gpio = of_get_named_gpio_flags(node, "WIFI,reset_gpio", 0, &flags);
-        if (gpio_is_valid(gpio)){
+			data->vbat_n.enable =
+				(flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+			LOG("%s: WIFI,vbat_gpio = %d, flags = %d.\n",
+			    __func__, gpio, flags);
+		} else {
+			data->vbat_n.io = -1;
+		}
+		gpio = of_get_named_gpio_flags(node, "WIFI,reset_gpio", 0,
+					       &flags);
+		if (gpio_is_valid(gpio)) {
 			data->reset_n.io = gpio;
-			data->reset_n.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-			LOG("%s: get property: WIFI,reset_gpio = %d, flags = %d.\n", __func__, gpio, flags);
-        } else data->reset_n.io = -1;
-        gpio = of_get_named_gpio_flags(node, "WIFI,host_wake_irq", 0, &flags);
-        if (gpio_is_valid(gpio)){
+			data->reset_n.enable =
+				(flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+			LOG("%s: WIFI,reset_gpio = %d, flags = %d.\n",
+			    __func__, gpio, flags);
+		} else {
+			data->reset_n.io = -1;
+		}
+		gpio = of_get_named_gpio_flags(node, "WIFI,host_wake_irq", 0,
+					       &flags);
+		if (gpio_is_valid(gpio)) {
 			data->wifi_int_b.io = gpio;
 			data->wifi_int_b.enable = !flags;
-			LOG("%s: get property: WIFI,host_wake_irq = %d, flags = %d.\n", __func__, gpio, flags);
-        } else data->wifi_int_b.io = -1;
+			LOG("%s: WIFI,host_wake_irq = %d, flags = %d.\n",
+			    __func__, gpio, flags);
+		} else {
+			data->wifi_int_b.io = -1;
+		}
 	}
 
 	data->ext_clk = devm_clk_get(dev, "clk_wifi");
@@ -599,7 +626,7 @@ static int wlan_platdata_parse_dt(struct device *dev,
 		}
 	}
 
-    return 0;
+	return 0;
 }
 #endif //CONFIG_OF
 
@@ -608,149 +635,149 @@ static int wlan_platdata_parse_dt(struct device *dev,
 
 static void wlan_early_suspend(struct early_suspend *h)
 {
-    LOG("%s :enter\n", __func__);
+	LOG("%s :enter\n", __func__);
 
-    return;
+	return;
 }
 
 static void wlan_late_resume(struct early_suspend *h)
 {
-    LOG("%s :enter\n", __func__);
+	LOG("%s :enter\n", __func__);
 
-    return;
+	return;
 }
 
 struct early_suspend wlan_early_suspend {
-    .level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
-    .suspend = wlan_early_suspend;
-    .resume = wlan_late_resume; 
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
+	.suspend = wlan_early_suspend;
+	.resume = wlan_late_resume;
 }
 #endif
 
-static void rfkill_wlan_early_suspend(void)
+static void
+rfkill_wlan_early_suspend(void)
 {
-    //LOG("%s :enter\n", __func__);
+	//LOG("%s :enter\n", __func__);
 
-    return;
+	return;
 }
 
 static void rfkill_wlan_later_resume(void)
 {
-    //LOG("%s :enter\n", __func__);
+	//LOG("%s :enter\n", __func__);
 
-    return;
+	return;
 }
 
 static int rfkill_wlan_fb_event_notify(struct notifier_block *self,
-                       unsigned long action, void *data)
+				       unsigned long action, void *data)
 {
+	struct fb_event *event = data;
+	int blank_mode = *((int *)event->data);
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		rfkill_wlan_later_resume();
+		break;
+	case FB_BLANK_NORMAL:
+		rfkill_wlan_early_suspend();
+		break;
+	default:
+		rfkill_wlan_early_suspend();
+		break;
+	}
 
-    struct fb_event *event = data;
-    int blank_mode = *((int *)event->data);
-
-    switch (blank_mode) {
-    case FB_BLANK_UNBLANK:
-        rfkill_wlan_later_resume();
-        break;
-    case FB_BLANK_NORMAL:
-        rfkill_wlan_early_suspend();
-        break;
-    default:
-        rfkill_wlan_early_suspend();
-        break;
-    }
-
-    return 0;
+	return 0;
 }
 
 static struct notifier_block rfkill_wlan_fb_notifier = {
-    .notifier_call = rfkill_wlan_fb_event_notify,
+	.notifier_call = rfkill_wlan_fb_event_notify,
 };
 
-
 static int rfkill_wlan_probe(struct platform_device *pdev)
 {
 	struct rfkill_wlan_data *rfkill;
 	struct rksdmmc_gpio_wifi_moudle *pdata = pdev->dev.platform_data;
 	int ret = -1;
 
-    LOG("Enter %s\n", __func__);
+	LOG("Enter %s\n", __func__);
 
 	if (!pdata) {
 #ifdef CONFIG_OF
-        pdata = kzalloc(sizeof(struct rksdmmc_gpio_wifi_moudle), GFP_KERNEL);
-        if (!pdata)
-            return -ENOMEM;
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
 
-        ret = wlan_platdata_parse_dt(&pdev->dev, pdata);
-        if (ret < 0) {
+		ret = wlan_platdata_parse_dt(&pdev->dev, pdata);
+		if (ret < 0) {
 #endif
-		    LOG("%s: No platform data specified\n", __func__);
-            return ret;
+			LOG("%s: No platform data specified\n", __func__);
+			return ret;
 #ifdef CONFIG_OF
-        }
+		}
 #endif
 	}
 
 	rfkill = kzalloc(sizeof(*rfkill), GFP_KERNEL);
 	if (!rfkill)
-        goto rfkill_alloc_fail;
+		goto rfkill_alloc_fail;
 
 	rfkill->pdata = pdata;
-    g_rfkill = rfkill;
+	g_rfkill = rfkill;
+
+	LOG("%s: init gpio\n", __func__);
 
-    LOG("%s: init gpio\n", __func__);
+	if (!pdata->mregulator.power_ctrl_by_pmu) {
+		ret = rfkill_rk_setup_gpio(&pdata->vbat_n, wlan_name,
+					   "wlan_vbat");
+		if (ret)
+			goto fail_alloc;
 
-    if (!pdata->mregulator.power_ctrl_by_pmu) {
-	ret = rfkill_rk_setup_gpio(&pdata->vbat_n, wlan_name, "wlan_vbat");
-	if (ret)
-		goto fail_alloc;
+		ret = rfkill_rk_setup_gpio(&pdata->power_n, wlan_name,
+					   "wlan_poweren");
+		if (ret)
+			goto fail_alloc;
 
-        ret = rfkill_rk_setup_gpio(&pdata->power_n, wlan_name, "wlan_poweren");
-	if (ret)
-		goto fail_alloc;
+		ret = rfkill_rk_setup_gpio(&pdata->reset_n, wlan_name,
+					   "wlan_reset");
+		if (ret)
+			goto fail_alloc;
+	}
 
-        ret = rfkill_rk_setup_gpio(&pdata->reset_n, wlan_name, "wlan_reset");
-	if (ret)
-		goto fail_alloc;
-    }
+	wake_lock_init(&rfkill->wlan_irq_wl, WAKE_LOCK_SUSPEND,
+		       "rfkill_wlan_wake");
 
-    wake_lock_init(&(rfkill->wlan_irq_wl), WAKE_LOCK_SUSPEND, "rfkill_wlan_wake");
+	if (gpio_is_valid(pdata->vbat_n.io))
+		gpio_direction_output(pdata->vbat_n.io, pdata->vbat_n.enable);
 
-    if (gpio_is_valid(pdata->vbat_n.io)) {
-	gpio_direction_output(pdata->vbat_n.io, pdata->vbat_n.enable);
-    }
-    // Turn off wifi power as default
-    if (gpio_is_valid(pdata->power_n.io))
-    {
-        gpio_direction_output(pdata->power_n.io, !pdata->power_n.enable);
-    }
+	// Turn off wifi power as default
+	if (gpio_is_valid(pdata->power_n.io))
+		gpio_direction_output(pdata->power_n.io,
+				      !pdata->power_n.enable);
 
-    if (pdata->wifi_power_remain)
-    {
-        rockchip_wifi_power(1);
-    }
+	if (pdata->wifi_power_remain)
+		rockchip_wifi_power(1);
 
 #if BCM_STATIC_MEMORY_SUPPORT
-    rockchip_init_wifi_mem();
+	rockchip_init_wifi_mem();
 #endif
 
 #if defined(CONFIG_HAS_EARLYSUSPEND)
-    register_early_suspend(wlan_early_suspend);
+	register_early_suspend(wlan_early_suspend);
 #endif
-    
-    fb_register_client(&rfkill_wlan_fb_notifier);
 
-    LOG("Exit %s\n", __func__);
+	fb_register_client(&rfkill_wlan_fb_notifier);
+
+	LOG("Exit %s\n", __func__);
 
 	return 0;
 
 fail_alloc:
 	kfree(rfkill);
 rfkill_alloc_fail:
-    kfree(pdata);
+	kfree(pdata);
 
-    g_rfkill = NULL;
+	g_rfkill = NULL;
 
 	return ret;
 }
@@ -759,40 +786,40 @@ static int rfkill_wlan_remove(struct platform_device *pdev)
 {
 	struct rfkill_wlan_data *rfkill = platform_get_drvdata(pdev);
 
-    LOG("Enter %s\n", __func__);
+	LOG("Enter %s\n", __func__);
+
+	wake_lock_destroy(&rfkill->wlan_irq_wl);
 
-    wake_lock_destroy(&rfkill->wlan_irq_wl);
+	fb_unregister_client(&rfkill_wlan_fb_notifier);
 
-    fb_unregister_client(&rfkill_wlan_fb_notifier);
-    
-    if (gpio_is_valid(rfkill->pdata->power_n.io))
-        gpio_free(rfkill->pdata->power_n.io);
-    
-    if (gpio_is_valid(rfkill->pdata->reset_n.io))
-        gpio_free(rfkill->pdata->reset_n.io);
+	if (gpio_is_valid(rfkill->pdata->power_n.io))
+		gpio_free(rfkill->pdata->power_n.io);
 
-    kfree(rfkill);
-    g_rfkill = NULL;
+	if (gpio_is_valid(rfkill->pdata->reset_n.io))
+		gpio_free(rfkill->pdata->reset_n.io);
+
+	kfree(rfkill);
+	g_rfkill = NULL;
 
 	return 0;
 }
 
 static int rfkill_wlan_suspend(struct platform_device *pdev, pm_message_t state)
 {
-    LOG("Enter %s\n", __func__);
-    return 0;
+	LOG("Enter %s\n", __func__);
+	return 0;
 }
 
 static int rfkill_wlan_resume(struct platform_device *pdev)
 {
-    LOG("Enter %s\n", __func__);
-    return 0;
+	LOG("Enter %s\n", __func__);
+	return 0;
 }
 
 #ifdef CONFIG_OF
 static struct of_device_id wlan_platdata_of_match[] = {
-    { .compatible = "wlan-platdata" },
-    { }
+	{ .compatible = "wlan-platdata" },
+	{}
 };
 MODULE_DEVICE_TABLE(of, wlan_platdata_of_match);
 #endif //CONFIG_OF
@@ -811,13 +838,13 @@ static struct platform_driver rfkill_wlan_driver = {
 
 static int __init rfkill_wlan_init(void)
 {
-    LOG("Enter %s\n", __func__);
+	LOG("Enter %s\n", __func__);
 	return platform_driver_register(&rfkill_wlan_driver);
 }
 
 static void __exit rfkill_wlan_exit(void)
 {
-    LOG("Enter %s\n", __func__);
+	LOG("Enter %s\n", __func__);
 	platform_driver_unregister(&rfkill_wlan_driver);
 }
 
-- 
2.35.3

