From 0a615bbd79856e9901548ffca473aa3a381a08e5 Mon Sep 17 00:00:00 2001
From: yxj <yxj@rock-chips.com>
Date: Tue, 14 Jan 2014 21:12:20 +0800
Subject: [PATCH] rk fb:base version for linux3.10

---
 arch/arm/boot/dts/lcd-b101ew05.dtsi       |   52 +
 arch/arm/boot/dts/rk3188-tb.dts           |   15 +
 arch/arm/boot/dts/rk3188.dtsi             |   25 +
 arch/arm/configs/rockchip_defconfig       |    7 +
 drivers/video/Kconfig                     |    1 +
 drivers/video/Makefile                    |    2 +-
 drivers/video/rockchip/Kconfig            |   14 +-
 drivers/video/rockchip/lcdc/Kconfig       |    4 +-
 drivers/video/rockchip/lcdc/rk3188_lcdc.c | 1975 +++++++++----------
 drivers/video/rockchip/lcdc/rk3188_lcdc.h |    5 +-
 drivers/video/rockchip/rk_fb.c            | 2178 +++++++++++----------
 drivers/video/rockchip/rkfb_sysfs.c       |  283 ++-
 include/dt-bindings/rkfb/rk_fb.h          |   13 +
 include/linux/rk_fb.h                     |  477 +++--
 include/linux/rk_screen.h                 |    7 +-
 15 files changed, 2512 insertions(+), 2546 deletions(-)
 create mode 100644 arch/arm/boot/dts/lcd-b101ew05.dtsi
 create mode 100644 include/dt-bindings/rkfb/rk_fb.h

diff --git a/arch/arm/boot/dts/lcd-b101ew05.dtsi b/arch/arm/boot/dts/lcd-b101ew05.dtsi
new file mode 100644
index 000000000000..7bf3340a32ba
--- /dev/null
+++ b/arch/arm/boot/dts/lcd-b101ew05.dtsi
@@ -0,0 +1,52 @@
+/*
+ * RockChip. LCD_B101ew05
+ *
+ */
+
+/ {
+	 	disp_power_ctr: power_ctr {
+                        rockchip,debug = <1>;
+                        lcd_en:lcd_en {
+                                rockchip,power_type = <GPIO>;
+                                gpios = <&gpio0 GPIO_B0 1>;
+                                rockchip,delay = <10>;
+                        };
+
+                     /*   bl_en:bl_en {
+                                rockchip,power_type = <GPIO>;
+                                gpios = <&gpio0 GPIO_A2 1>;
+                                rockchip,delay = <10>;
+                        };
+
+                        bl_ctr:bl_ctr {
+                                rockchip,power_type = <GPIO>;
+                                gpios = <&gpio3 GPIO_D6 1>;
+                                rockchip,delay = <10>;
+                        };
+
+                        lcd_rst:lcd_rst {
+                                rockchip,power_type = <REGULATOR>;
+                                rockchip,delay = <5>;
+                        };*/
+
+                };
+
+		disp_timings: display-timings {
+                        native-mode = <&timing0>;
+                        timing0: timing0 {
+				clock-frequency = <71000000>;
+				hactive = <1280>;
+                                vactive = <800>;
+                                hback-porch = <100>;
+                                hfront-porch = <18>;
+                                vback-porch = <8>;
+                                vfront-porch = <6>;
+                                hsync-len = <10>;
+                                vsync-len = <2>;
+                                hsync-active = <0>;
+                                vsync-active = <0>;
+                                de-active = <1>;
+                                pixelclk-active = <0>;
+                     	};
+               };
+};
diff --git a/arch/arm/boot/dts/rk3188-tb.dts b/arch/arm/boot/dts/rk3188-tb.dts
index 845505349275..4db2927e903e 100644
--- a/arch/arm/boot/dts/rk3188-tb.dts
+++ b/arch/arm/boot/dts/rk3188-tb.dts
@@ -2,6 +2,7 @@
 
 #include "rk3188.dtsi"
 #include "rk3188-clocks.dtsi"
+#include "lcd-b101ew05.dtsi"
 
 / {
 	memory {
@@ -42,3 +43,17 @@
 &i2c3 {
 	status = "okay";
 };
+
+&fb {
+	rockchip,disp-mode = <DUAL>;
+};
+
+&lcdc0 {
+	status = "okay";
+	power_ctr = <&disp_power_ctr>;
+	display-timings = <&disp_timings>;
+};
+
+&lcdc1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/rk3188.dtsi b/arch/arm/boot/dts/rk3188.dtsi
index df2c7066fd01..989d812e9086 100755
--- a/arch/arm/boot/dts/rk3188.dtsi
+++ b/arch/arm/boot/dts/rk3188.dtsi
@@ -1,6 +1,7 @@
 
 #include "skeleton.dtsi"
 #include "rk3188-pinctrl.dtsi"
+#include <dt-bindings/rkfb/rk_fb.h>
 
 
 / {
@@ -18,6 +19,8 @@
 		i2c2 = &i2c2;
 		i2c3 = &i2c3;
 		i2c4 = &i2c4;
+		lcdc0 = &lcdc0;
+		lcdc1 = &lcdc1;
 	};
 
 	cpus {
@@ -322,4 +325,26 @@
 		rockchip,clocks-init-rate =<&clk_cpll 768000000>,<&clk_gpll 594000000>;
 		rockchip,clocks-init-parent =<&aclk_peri_mux &clk_gpll>,<&aclk_cpu &clk_gpll>;
 	};
+
+	fb: fb{
+		compatible = "rockchip,rk-fb";
+		rockchip,disp-mode = <DUAL>;
+	};
+	
+	lcdc0:lcdc@1010c000 {
+		compatible = "rockchip,rk3188-lcdc";
+		rockchip,prop = <PRMRY>;
+		reg = <0x1010c000 0x1000>;
+		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+		status = "disabled";
+	};
+
+	lcdc1:lcdc@1010e000 {
+		compatible = "rockchip,rk3188-lcdc";
+		rockchip,prop = <EXTEND>;
+		reg = <0x1010e000 0x1000>;
+		interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+		status = "disabled";
+        };
+
 };
diff --git a/arch/arm/configs/rockchip_defconfig b/arch/arm/configs/rockchip_defconfig
index bbb5d9790b47..a5493fefabfb 100644
--- a/arch/arm/configs/rockchip_defconfig
+++ b/arch/arm/configs/rockchip_defconfig
@@ -288,6 +288,13 @@ CONFIG_BACKLIGHT_LCD_SUPPORT=y
 # CONFIG_LCD_CLASS_DEVICE is not set
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 # CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_FB_ROCKCHIP=y
+CONFIG_LCDC_RK3188=y
+CONFIG_LCDC0_RK3188=y
+CONFIG_LCDC1_RK3188=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
 CONFIG_SOUND=y
 CONFIG_SND=y
 CONFIG_SND_USB_AUDIO=y
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index a3279c7def71..52b273119fb7 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2497,6 +2497,7 @@ source "drivers/video/exynos/Kconfig"
 source "drivers/video/mmp/Kconfig"
 source "drivers/video/backlight/Kconfig"
 source "drivers/video/adf/Kconfig"
+source "drivers/video/rockchip/Kconfig"
 
 if VT
 	source "drivers/video/console/Kconfig"
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 3adbd32eb091..64048533ae2f 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -152,6 +152,7 @@ obj-$(CONFIG_FB_NUC900)           += nuc900fb.o
 obj-$(CONFIG_FB_JZ4740)		  += jz4740_fb.o
 obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
 obj-$(CONFIG_FB_HYPERV)		  += hyperv_fb.o
+obj-$(CONFIG_FB_ROCKCHIP)         += rockchip/
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
@@ -169,7 +170,6 @@ obj-$(CONFIG_FB_DA8XX)		  += da8xx-fb.o
 obj-$(CONFIG_FB_MXS)		  += mxsfb.o
 obj-$(CONFIG_FB_SSD1307)	  += ssd1307fb.o
 obj-$(CONFIG_FB_SIMPLE)           += simplefb.o
-
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
 
diff --git a/drivers/video/rockchip/Kconfig b/drivers/video/rockchip/Kconfig
index bdfea2b473ef..06340ac49846 100755
--- a/drivers/video/rockchip/Kconfig
+++ b/drivers/video/rockchip/Kconfig
@@ -1,10 +1,12 @@
 menuconfig FB_ROCKCHIP
-        tristate "Frame buffer support for Rockchip "
-        depends on FB
-        select FB_CFB_FILLRECT
-        select FB_CFB_COPYAREA
-        select FB_CFB_IMAGEBLIT
-        ---help---
+	tristate "Frame buffer support for Rockchip "
+	depends on FB
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_MODE_HELPERS
+	select VIDEOMODE_HELPERS
+        help
           Framebuffer driver for rockchip based platform
 
 config FB_MIRRORING
diff --git a/drivers/video/rockchip/lcdc/Kconfig b/drivers/video/rockchip/lcdc/Kconfig
index db3dadb480d1..c2d978f1e775 100755
--- a/drivers/video/rockchip/lcdc/Kconfig
+++ b/drivers/video/rockchip/lcdc/Kconfig
@@ -61,9 +61,9 @@ config RK3066B_LCDC1_IO_18V
 
 config LCDC_RK3188
         bool "rk3188 lcdc support"
-        depends on FB_ROCKCHIP && (ARCH_RK3188 || ARCH_RK3026)
+        depends on FB_ROCKCHIP 
         help
-          Driver for rk3188 lcdc.There are two lcd controllers on rk3188
+          Driver for rk3188/rk302x/rk319x lcdc.There are two lcd controllers on rk3188
 config LCDC0_RK3188
         bool "lcdc0 support"
         depends on LCDC_RK3188
diff --git a/drivers/video/rockchip/lcdc/rk3188_lcdc.c b/drivers/video/rockchip/lcdc/rk3188_lcdc.c
index 2ce3ed5ae08d..dd768b72e960 100755
--- a/drivers/video/rockchip/lcdc/rk3188_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk3188_lcdc.c
@@ -26,459 +26,464 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
-#include <linux/earlysuspend.h>
 #include <asm/div64.h>
 #include <asm/uaccess.h>
-#include <mach/iomux.h>
+#include "../../../arch/arm/mach-rockchip/cpu.h"
 #include "rk3188_lcdc.h"
-#include <mach/gpio.h>
-
 
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
 
-static int dbg_thresd = 0;
-module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
+static int dbg_thresd;
+module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
 
-#define DBG(level,x...) do { 			\
-	if(unlikely(dbg_thresd >= level)) 	\
+#define DBG(level,x...) do {			\
+	if(unlikely(dbg_thresd >= level))	\
 		printk(KERN_INFO x);} while (0)
 
 //#define WAIT_FOR_SYNC 1
 
-static int rk3188_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen);
-static int  rk3188_lcdc_clk_enable(struct rk3188_lcdc_device *lcdc_dev)
+static int rk3188_lcdc_get_id(u32 phy_base)
+{
+	if (cpu_is_rk319x()) {
+		if(phy_base == 0xffc40000)
+			return 0;
+		else if (phy_base == 0xffc50000)
+			return 1;
+		else
+			return -EINVAL;
+	} else if (cpu_is_rk3188( )) {
+		if (phy_base == 0x1010c000)
+			return 0;
+		else if(phy_base == 0x0101e000)
+			return 1;
+		else
+			return -EINVAL;
+	} else if (cpu_is_rk3026()) {
+		if (phy_base == 0x1010e000)
+			return 0;
+		else if(phy_base == 0x01110000)
+			return 1;
+		else
+			return -EINVAL;
+	} else {
+		pr_err("un supported platform \n");
+		return -EINVAL;
+	}
+	
+}
+static int rk3188_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen);
+static int rk3188_lcdc_clk_enable(struct rk3188_lcdc_device *lcdc_dev)
 {
 
-	if(!lcdc_dev->clk_on)
-	{
-		clk_enable(lcdc_dev->hclk);
-		clk_enable(lcdc_dev->dclk);
-		clk_enable(lcdc_dev->aclk);
-		clk_enable(lcdc_dev->pd);
+	if (!lcdc_dev->clk_on) {
+		clk_prepare_enable(lcdc_dev->hclk);
+		clk_prepare_enable(lcdc_dev->dclk);
+		clk_prepare_enable(lcdc_dev->aclk);
+		//clk_enable(lcdc_dev->pd);
 		spin_lock(&lcdc_dev->reg_lock);
 		lcdc_dev->clk_on = 1;
 		spin_unlock(&lcdc_dev->reg_lock);
 	}
 
-	
-	printk("rk3188 lcdc%d clk enable...\n",lcdc_dev->id);
-	
+
 	return 0;
 }
 
 static int rk3188_lcdc_clk_disable(struct rk3188_lcdc_device *lcdc_dev)
 {
-	if(lcdc_dev->clk_on)
-	{
+	if (lcdc_dev->clk_on) {
 		spin_lock(&lcdc_dev->reg_lock);
 		lcdc_dev->clk_on = 0;
 		spin_unlock(&lcdc_dev->reg_lock);
 		mdelay(25);
-		clk_disable(lcdc_dev->dclk);
-		clk_disable(lcdc_dev->hclk);
-		clk_disable(lcdc_dev->aclk);
-		clk_disable(lcdc_dev->pd);
+		clk_disable_unprepare(lcdc_dev->dclk);
+		clk_disable_unprepare(lcdc_dev->hclk);
+		clk_disable_unprepare(lcdc_dev->aclk);
+		//clk_disable(lcdc_dev->pd);
 	}
-	
-	printk("rk3188 lcdc%d clk disable...\n",lcdc_dev->id);
-	
-	return 0;
-}
 
 
+	return 0;
+}
 
 static void rk3188_lcdc_reg_dump(struct rk3188_lcdc_device *lcdc_dev)
 {
-       int *cbase =  (int *)lcdc_dev->regs;
-       int *regsbak = (int*)lcdc_dev->regsbak;
-       int i,j;
-
-       printk("back up reg:\n");
-       for(i=0; i<=(0x90>>4);i++)
-       {
-               for(j=0;j<4;j++)
-                       printk("%08x  ",*(regsbak+i*4 +j));
-               printk("\n");
-       }
-
-       printk("lcdc reg:\n");
-       for(i=0; i<=(0x90>>4);i++)
-       {
-               for(j=0;j<4;j++)
-                       printk("%08x  ",readl_relaxed(cbase+i*4 +j));
-               printk("\n");
-       }
-       
+	int *cbase = (int *)lcdc_dev->regs;
+	int *regsbak = (int *)lcdc_dev->regsbak;
+	int i, j;
+
+	printk("back up reg:\n");
+	for (i = 0; i <= (0x90 >> 4); i++) {
+		for (j = 0; j < 4; j++)
+			printk("%08x  ", *(regsbak + i * 4 + j));
+		printk("\n");
+	}
+
+	printk("lcdc reg:\n");
+	for (i = 0; i <= (0x90 >> 4); i++) {
+		for (j = 0; j < 4; j++)
+			printk("%08x  ", readl_relaxed(cbase + i * 4 + j));
+		printk("\n");
+	}
+
 }
 
-static void rk3188_lcdc_read_reg_defalut_cfg(struct rk3188_lcdc_device *lcdc_dev)
+static void rk3188_lcdc_read_reg_defalut_cfg(struct rk3188_lcdc_device
+					     *lcdc_dev)
 {
-	int reg=0;
-	u32 value=0;
-	struct layer_par *win0 =  lcdc_dev->driver.layer_par[0];
-	struct layer_par *win1 =  lcdc_dev->driver.layer_par[1];
+	int reg = 0;
+	u32 value = 0;
+	struct layer_par *win0 = lcdc_dev->driver.layer_par[0];
+	struct layer_par *win1 = lcdc_dev->driver.layer_par[1];
 
 	spin_lock(&lcdc_dev->reg_lock);
-	for(reg = 0; reg < REG_CFG_DONE;reg += 4)
-	{
-		value = lcdc_readl(lcdc_dev,reg);
-		switch(reg)
-		{
+	for (reg = 0; reg < REG_CFG_DONE; reg += 4) {
+		value = lcdc_readl(lcdc_dev, reg);
+		switch (reg) {
 		case SYS_CTRL:
-			lcdc_dev->standby = (value & m_LCDC_STANDBY)>>17;
-			win0->state = (value & m_WIN0_EN)>>0;
-			win1->state = (value & m_WIN1_EN)>>1;
-			if(lcdc_dev->id == 0)
+			lcdc_dev->standby = (value & m_LCDC_STANDBY) >> 17;
+			win0->state = (value & m_WIN0_EN) >> 0;
+			win1->state = (value & m_WIN1_EN) >> 1;
+			if (lcdc_dev->id == 0)
 				lcdc_dev->atv_layer_cnt = win0->state;
 			else
 				lcdc_dev->atv_layer_cnt = win1->state;
-			win0->swap_rb = (value & m_WIN0_RB_SWAP)>>15;
-			win1->swap_rb = (value & m_WIN1_RB_SWAP)>>19;
-			win0->fmt_cfg = (value & m_WIN0_FORMAT)>>3;
-			win1->fmt_cfg = (value & m_WIN1_FORMAT)>>6;
-			DBG(2,"standby=%d,win0->state=%d,win1->state=%d,win0->swap_rb=%d,win1->swap_rb=%d,win0->fmt_cfg=%d,win1->fmt_cfg=%d\n",
-				   lcdc_dev->standby,win0->state,win1->state,win0->swap_rb,win1->swap_rb,win0->fmt_cfg,win1->fmt_cfg);
+			win0->swap_rb = (value & m_WIN0_RB_SWAP) >> 15;
+			win1->swap_rb = (value & m_WIN1_RB_SWAP) >> 19;
+			win0->fmt_cfg = (value & m_WIN0_FORMAT) >> 3;
+			win1->fmt_cfg = (value & m_WIN1_FORMAT) >> 6;
 			break;
 		case WIN0_SCL_FACTOR_YRGB:
-			win0->scale_yrgb_x = (value>> 0)&0xffff;
-			win0->scale_yrgb_y = (value>>16)&0xffff;
-			DBG(2,"win0->scale_yrgb_x=%d,win0->scale_yrgb_y=%d\n",win0->scale_yrgb_x,win0->scale_yrgb_y);
+			win0->scale_yrgb_x = (value >> 0) & 0xffff;
+			win0->scale_yrgb_y = (value >> 16) & 0xffff;
 			break;
 		case WIN0_SCL_FACTOR_CBR:
-			win0->scale_cbcr_x = (value>> 0)&0xffff;
-			win0->scale_cbcr_y = (value>>16)&0xffff;
-			DBG(2,"win0->scale_cbc_x=%d,win0->scale_cbcr_y=%d\n",win0->scale_cbcr_x,win0->scale_cbcr_y);
+			win0->scale_cbcr_x = (value >> 0) & 0xffff;
+			win0->scale_cbcr_y = (value >> 16) & 0xffff;
 			break;
 		case WIN0_ACT_INFO:
-			win0->xact = (((value>> 0)&0x1fff)+1);
-			win0->yact = (((value>>16)&0x1fff)+1);
-			DBG(2,"win0->xact=%d,win0->yact=%d\n",win0->xact,win0->yact);
+			win0->xact = (((value >> 0) & 0x1fff) + 1);
+			win0->yact = (((value >> 16) & 0x1fff) + 1);
 			break;
 		case WIN0_DSP_ST:
-			win0->dsp_stx = (value>> 0)&0xfff;
-			win0->dsp_sty = (value>>16)&0xfff;
-			DBG(2,"win0->dsp_stx=%d,win0->dsp_sty=%d\n",win0->dsp_stx,win0->dsp_sty);
+			win0->dsp_stx = (value >> 0) & 0xfff;
+			win0->dsp_sty = (value >> 16) & 0xfff;
 			break;
 		case WIN0_DSP_INFO:
-			win0->xsize = (((value>> 0)&0x7ff)+1);
-			win0->ysize = (((value>>16)&0x7ff)+1);
-			DBG(2,"win0->xsize=%d,win0->ysize=%d\n",win0->xsize,win0->ysize);
+			win0->xsize = (((value >> 0) & 0x7ff) + 1);
+			win0->ysize = (((value >> 16) & 0x7ff) + 1);
 			break;
 		case WIN_VIR:
-			win0->vir_stride = (value>> 0)&0x1fff;
-			win1->vir_stride = (value)&0x1fff0000;
-			DBG(2,"win0->vir_stride=%d,win1->vir_stride=%d\n",win0->vir_stride,win1->vir_stride);
+			win0->vir_stride = (value >> 0) & 0x1fff;
+			win1->vir_stride = (value) & 0x1fff0000;
 			break;
 		case WIN0_YRGB_MST0:
-			win0->y_addr = value>> 0;
-			DBG(2,"win0->y_addr=%d\n",win0->y_addr);
+			win0->y_addr = value >> 0;
 			break;
 		case WIN0_CBR_MST0:
-			win0->uv_addr = value>> 0;
-			DBG(2,"win0->uv_addr=%d\n",win0->uv_addr);
+			win0->uv_addr = value >> 0;
 			break;
 		case WIN1_DSP_INFO:
-			win1->xsize = (((value>> 0)&0x7ff)+1);
-			win1->ysize = (((value>>16)&0x7ff)+1);
-			DBG(2,"win1->xsize=%d,win1->ysize=%d\n",win1->xsize,win1->ysize);
+			win1->xsize = (((value >> 0) & 0x7ff) + 1);
+			win1->ysize = (((value >> 16) & 0x7ff) + 1);
 			break;
 		case WIN1_DSP_ST:
-			win1->dsp_stx = (value>> 0)&0xfff;
-			win1->dsp_sty = (value>>16)&0xfff;
-			DBG(2,"win1->dsp_stx=%d,win1->dsp_sty=%d\n",win1->dsp_stx,win1->dsp_sty);
+			win1->dsp_stx = (value >> 0) & 0xfff;
+			win1->dsp_sty = (value >> 16) & 0xfff;
 			break;
 		case WIN1_MST:
-			win1->y_addr =value>> 0;
-			DBG(2,"win1->y_addr=%d\n",win1->y_addr);
+			win1->y_addr = value >> 0;
 			break;
 		default:
-			DBG(2,"%s:uncare reg\n",__func__);
+			DBG(2, "%s:uncare reg\n", __func__);
 			break;
 		}
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
-	DBG(2,"%s,done\n",__func__);
 }
 
 static int rk3188_lcdc_alpha_cfg(struct rk3188_lcdc_device *lcdc_dev)
 {
 	int win0_top = 0;
-	enum data_format win0_format =  lcdc_dev->driver.layer_par[0]->format;
-	enum data_format win1_format  =  lcdc_dev->driver.layer_par[1]->format;
-
-	int win0_alpha_en = ((win0_format == ARGB888) || (win0_format == ABGR888))?1:0;
-	int win1_alpha_en = ((win1_format == ARGB888) || (win1_format == ABGR888))?1:0;
-	u32 *_pv = (u32*)lcdc_dev->regsbak;
+	enum data_format win0_format = lcdc_dev->driver.layer_par[0]->format;
+	enum data_format win1_format = lcdc_dev->driver.layer_par[1]->format;
+
+	int win0_alpha_en = ((win0_format == ARGB888)
+			     || (win0_format == ABGR888)) ? 1 : 0;
+	int win1_alpha_en = ((win1_format == ARGB888)
+			     || (win1_format == ABGR888)) ? 1 : 0;
+	u32 *_pv = (u32 *) lcdc_dev->regsbak;
 	_pv += (DSP_CTRL0 >> 2);
-	win0_top = ((*_pv)&(m_WIN0_TOP))>> 8;
-	
-	if(win0_top && (lcdc_dev->atv_layer_cnt >= 2) && (win0_alpha_en))
-	{
-		lcdc_msk_reg(lcdc_dev,ALPHA_CTRL,m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN,
-				v_WIN0_ALPHA_EN(1) | v_WIN1_ALPHA_EN(0));
-		lcdc_msk_reg(lcdc_dev,DSP_CTRL0,m_WIN0_ALPHA_MODE | m_ALPHA_MODE_SEL0 |
-			m_ALPHA_MODE_SEL1,v_WIN0_ALPHA_MODE(1) | v_ALPHA_MODE_SEL0(1) |
-			v_ALPHA_MODE_SEL1(0));//default set to per-pixel alpha	
-	}
-	else if((!win0_top) && (lcdc_dev->atv_layer_cnt >= 2) && (win1_alpha_en))
-	{
-		lcdc_msk_reg(lcdc_dev,ALPHA_CTRL,m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN,
-				v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(1));
-		lcdc_msk_reg(lcdc_dev,DSP_CTRL0,m_WIN1_ALPHA_MODE | m_ALPHA_MODE_SEL0 |
-			m_ALPHA_MODE_SEL1,v_WIN1_ALPHA_MODE(1) | v_ALPHA_MODE_SEL0(1) |
-			v_ALPHA_MODE_SEL1(0));//default set to per-pixel alpha	
+	win0_top = ((*_pv) & (m_WIN0_TOP)) >> 8;
+
+	if (win0_top && (lcdc_dev->atv_layer_cnt >= 2) && (win0_alpha_en)) {
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL,
+			     m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN,
+			     v_WIN0_ALPHA_EN(1) | v_WIN1_ALPHA_EN(0));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_ALPHA_MODE | m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1, v_WIN0_ALPHA_MODE(1) | v_ALPHA_MODE_SEL0(1) | v_ALPHA_MODE_SEL1(0));	//default set to per-pixel alpha
+	} else if ((!win0_top) && (lcdc_dev->atv_layer_cnt >= 2)
+		   && (win1_alpha_en)) {
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL,
+			     m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN,
+			     v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(1));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN1_ALPHA_MODE | m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1, v_WIN1_ALPHA_MODE(1) | v_ALPHA_MODE_SEL0(1) | v_ALPHA_MODE_SEL1(0));	//default set to per-pixel alpha
+	} else {
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL,
+			     m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN,
+			     v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(0));
 	}
-	else
-	{
-		lcdc_msk_reg(lcdc_dev,ALPHA_CTRL,m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN,
-				v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(0));
-	}
-	
 
 	return 0;
 }
 
-static int rk3188_lcdc_reg_update(struct rk_lcdc_device_driver *dev_drv)
+static int rk3188_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
 {
-	struct rk3188_lcdc_device *lcdc_dev = 
-		container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	struct layer_par *win0 =  lcdc_dev->driver.layer_par[0];
-	struct layer_par *win1 =  lcdc_dev->driver.layer_par[1];
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	struct layer_par *win0 = lcdc_dev->driver.layer_par[0];
+	struct layer_par *win1 = lcdc_dev->driver.layer_par[1];
 	int timeout;
 	unsigned long flags;
 
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL,m_LCDC_STANDBY,v_LCDC_STANDBY(lcdc_dev->standby));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN | m_WIN1_EN | m_WIN0_RB_SWAP | m_WIN1_RB_SWAP, 
-			v_WIN0_EN(win0->state) | v_WIN1_EN(win1->state) | v_WIN0_RB_SWAP(win0->swap_rb) |
-			v_WIN1_RB_SWAP(win1->swap_rb));
-		lcdc_writel(lcdc_dev,WIN0_SCL_FACTOR_YRGB,v_X_SCL_FACTOR(win0->scale_yrgb_x) | 
-			v_Y_SCL_FACTOR(win0->scale_yrgb_y));
-		lcdc_writel(lcdc_dev,WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(win0->scale_cbcr_x) | 
-			v_Y_SCL_FACTOR(win0->scale_cbcr_y));
-		lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_WIN0_FORMAT,v_WIN0_FORMAT(win0->fmt_cfg));		//(inf->video_mode==0)
-		lcdc_writel(lcdc_dev,WIN0_ACT_INFO,v_ACT_WIDTH(win0->xact) | v_ACT_HEIGHT(win0->yact));
-		lcdc_writel(lcdc_dev,WIN0_DSP_ST,v_DSP_STX(win0->dsp_stx) | v_DSP_STY(win0->dsp_sty));
-		lcdc_writel(lcdc_dev,WIN0_DSP_INFO,v_DSP_WIDTH(win0->xsize) | v_DSP_HEIGHT(win0->ysize));
-		lcdc_msk_reg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_VIR_VAL(win0->vir_stride));
-		lcdc_writel(lcdc_dev,WIN0_YRGB_MST0, win0->y_addr);
-		lcdc_writel(lcdc_dev,WIN0_CBR_MST0, win0->uv_addr);
-		lcdc_writel(lcdc_dev,WIN1_DSP_INFO,v_DSP_WIDTH(win1->xsize) | v_DSP_HEIGHT(win1->ysize));
-		lcdc_writel(lcdc_dev,WIN1_DSP_ST,v_DSP_STX(win1->dsp_stx) | v_DSP_STY(win1->dsp_sty));
-		lcdc_msk_reg(lcdc_dev,WIN_VIR,m_WIN1_VIR,win1->vir_stride);
-		lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_WIN1_FORMAT, v_WIN1_FORMAT(win1->fmt_cfg));
-		lcdc_writel(lcdc_dev,WIN1_MST,win1->y_addr);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(lcdc_dev->standby));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL,
+			     m_WIN0_EN | m_WIN1_EN | m_WIN0_RB_SWAP |
+			     m_WIN1_RB_SWAP,
+			     v_WIN0_EN(win0->state) | v_WIN1_EN(win1->state) |
+			     v_WIN0_RB_SWAP(win0->swap_rb) |
+			     v_WIN1_RB_SWAP(win1->swap_rb));
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
+			    v_X_SCL_FACTOR(win0->scale_yrgb_x) |
+			    v_Y_SCL_FACTOR(win0->scale_yrgb_y));
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,
+			    v_X_SCL_FACTOR(win0->scale_cbcr_x) |
+			    v_Y_SCL_FACTOR(win0->scale_cbcr_y));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_FORMAT, v_WIN0_FORMAT(win0->fmt_cfg));	//(inf->video_mode==0)
+		lcdc_writel(lcdc_dev, WIN0_ACT_INFO,
+			    v_ACT_WIDTH(win0->xact) | v_ACT_HEIGHT(win0->yact));
+		lcdc_writel(lcdc_dev, WIN0_DSP_ST,
+			    v_DSP_STX(win0->
+				      dsp_stx) | v_DSP_STY(win0->dsp_sty));
+		lcdc_writel(lcdc_dev, WIN0_DSP_INFO,
+			    v_DSP_WIDTH(win0->
+					xsize) | v_DSP_HEIGHT(win0->ysize));
+		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN0_VIR,
+			     v_WIN0_VIR_VAL(win0->vir_stride));
+		lcdc_writel(lcdc_dev, WIN0_YRGB_MST0, win0->y_addr);
+		lcdc_writel(lcdc_dev, WIN0_CBR_MST0, win0->uv_addr);
+		lcdc_writel(lcdc_dev, WIN1_DSP_INFO,
+			    v_DSP_WIDTH(win1->
+					xsize) | v_DSP_HEIGHT(win1->ysize));
+		lcdc_writel(lcdc_dev, WIN1_DSP_ST,
+			    v_DSP_STX(win1->
+				      dsp_stx) | v_DSP_STY(win1->dsp_sty));
+		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR, win1->vir_stride);
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_FORMAT,
+			     v_WIN1_FORMAT(win1->fmt_cfg));
+		lcdc_writel(lcdc_dev, WIN1_MST, win1->y_addr);
 		rk3188_lcdc_alpha_cfg(lcdc_dev);
 		lcdc_cfg_done(lcdc_dev);
-		
+
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
-	if(dev_drv->wait_fs)
-	{
-		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
+	if (dev_drv->wait_fs) {
+		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
 		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
-		if(!timeout&&(!dev_drv->frame_done.done))
-		{
+		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+		timeout =
+		    wait_for_completion_timeout(&dev_drv->frame_done,
+						msecs_to_jiffies
+						(dev_drv->cur_screen->ft + 5));
+		if (!timeout && (!dev_drv->frame_done.done)) {
 			printk(KERN_ERR "wait for new frame start time out!\n");
 			return -ETIMEDOUT;
 		}
 	}
-	DBG(2,"%s for lcdc%d\n",__func__,lcdc_dev->id);
+	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
 	return 0;
-	
+
 }
 
 static int rk3188_lcdc_reg_resume(struct rk3188_lcdc_device *lcdc_dev)
 {
-	memcpy((u8*)lcdc_dev->regs, (u8*)lcdc_dev->regsbak, 0x84);
-	return 0;	
+	memcpy((u8 *) lcdc_dev->regs, (u8 *) lcdc_dev->regsbak, 0x84);
+	return 0;
 }
 
-
 //enable layer,open:1,enable;0 disable
-static int win0_open(struct rk3188_lcdc_device *lcdc_dev,bool open)
+static int win0_open(struct rk3188_lcdc_device *lcdc_dev, bool open)
 {
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				printk(KERN_INFO "lcdc%d wakeup from standby!\n",lcdc_dev->id);
+	if (likely(lcdc_dev->clk_on)) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				printk(KERN_INFO
+				       "lcdc%d wakeup from standby!\n",
+				       lcdc_dev->id);
 				lcdc_dev->standby = 0;
 			}
 			lcdc_dev->atv_layer_cnt++;
-		}
-		else if((lcdc_dev->atv_layer_cnt > 0) && (!open))
-		{
+		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
 			lcdc_dev->atv_layer_cnt--;
 		}
 		lcdc_dev->driver.layer_par[0]->state = open;
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		if (!lcdc_dev->atv_layer_cnt)	//if no layer used,disable lcdc
 		{
-			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!\n",lcdc_dev->id);
+			printk(KERN_INFO
+			       "no layer of lcdc%d is used,go to standby!\n",
+			       lcdc_dev->id);
 			lcdc_dev->standby = 1;
 		}
-		//lcdc_cfg_done(lcdc_dev);	
+		//lcdc_cfg_done(lcdc_dev);
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
 
-
 	return 0;
 }
 
-static int win1_open(struct rk3188_lcdc_device *lcdc_dev,bool open)
+static int win1_open(struct rk3188_lcdc_device *lcdc_dev, bool open)
 {
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				printk(KERN_INFO "lcdc%d wakeup from standby!\n",lcdc_dev->id);
+	if (likely(lcdc_dev->clk_on)) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				printk(KERN_INFO
+				       "lcdc%d wakeup from standby!\n",
+				       lcdc_dev->id);
 				lcdc_dev->standby = 0;
 			}
 			lcdc_dev->atv_layer_cnt++;
-		}
-		else if((lcdc_dev->atv_layer_cnt > 0) && (!open))
-		{
+		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
 			lcdc_dev->atv_layer_cnt--;
 		}
 		lcdc_dev->driver.layer_par[1]->state = open;
-		
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+
+		if (!lcdc_dev->atv_layer_cnt)	//if no layer used,disable lcdc
 		{
-			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!\n",lcdc_dev->id);
+			printk(KERN_INFO
+			       "no layer of lcdc%d is used,go to standby!\n",
+			       lcdc_dev->id);
 			lcdc_dev->standby = 1;
 		}
 		//lcdc_cfg_done(lcdc_dev);
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
-	
+
 	return 0;
 }
 
-static int rk3188_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
+static int rk3188_lcdc_open(struct rk_lcdc_driver *dev_drv, int layer_id,
+			    bool open)
 {
-	int i=0;
+	int i = 0;
 	int __iomem *c;
 	int v;
-	struct rk3188_lcdc_device *lcdc_dev = 
-		container_of(dev_drv,struct rk3188_lcdc_device,driver);
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
 
-	if((open) && (!lcdc_dev->atv_layer_cnt)) //enable clk,when first layer open
+	if ((open) && (!lcdc_dev->atv_layer_cnt))	//enable clk,when first layer open
 	{
 		rk3188_lcdc_clk_enable(lcdc_dev);
-		rk3188_lcdc_reg_resume(lcdc_dev); //resume reg
-		rk3188_load_screen(dev_drv,1);
+		rk3188_lcdc_reg_resume(lcdc_dev);	//resume reg
+		rk3188_load_screen(dev_drv, 1);
 		spin_lock(&lcdc_dev->reg_lock);
-		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
+		if (dev_drv->cur_screen->dsp_lut)	//resume dsp lut
 		{
-			lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DSP_LUT_EN,v_DSP_LUT_EN(0));
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN,
+				     v_DSP_LUT_EN(0));
 			lcdc_cfg_done(lcdc_dev);
-			mdelay(25); //wait for dsp lut disabled
-			for(i=0;i<256;i++)
-			{
+			mdelay(25);	//wait for dsp lut disabled
+			for (i = 0; i < 256; i++) {
 				v = dev_drv->cur_screen->dsp_lut[i];
-				c = lcdc_dev->dsp_lut_addr_base+i;
-				writel_relaxed(v,c);
+				c = lcdc_dev->dsp_lut_addr_base + i;
+				writel_relaxed(v, c);
 
 			}
-			lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DSP_LUT_EN,v_DSP_LUT_EN(1)); //enable dsp lut
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));	//enable dsp lut
 		}
 		spin_unlock(&lcdc_dev->reg_lock);
 	}
 
-	if(layer_id == 0)
-	{
-		win0_open(lcdc_dev,open);	
-	}
-	else if(layer_id == 1)
-	{
-		win1_open(lcdc_dev,open);
-	}
-	else 
-	{
-		printk("invalid win number:%d\n",layer_id);
+	if (layer_id == 0) {
+		win0_open(lcdc_dev, open);
+	} else if (layer_id == 1) {
+		win1_open(lcdc_dev, open);
+	} else {
+		printk("invalid win number:%d\n", layer_id);
 	}
 
-	if((!open) && (!lcdc_dev->atv_layer_cnt))  //when all layer closed,disable clk
+	if ((!open) && (!lcdc_dev->atv_layer_cnt))	//when all layer closed,disable clk
 	{
-		lcdc_msk_reg(lcdc_dev,INT_STATUS,m_FS_INT_CLEAR,v_FS_INT_CLEAR(1));
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
+			     v_FS_INT_CLEAR(1));
 		rk3188_lcdc_reg_update(dev_drv);
 		rk3188_lcdc_clk_disable(lcdc_dev);
 	}
 
 	printk(KERN_INFO "lcdc%d win%d %s,atv layer:%d\n",
-		lcdc_dev->id,layer_id,open?"open":"closed",
-		lcdc_dev->atv_layer_cnt);
+	       lcdc_dev->id, layer_id, open ? "open" : "closed",
+	       lcdc_dev->atv_layer_cnt);
 	return 0;
 }
 
-static int rk3188_lcdc_init(struct rk_lcdc_device_driver *dev_drv)
+static int rk3188_lcdc_init(struct rk_lcdc_driver *dev_drv)
 {
 	int i = 0;
 	int __iomem *c;
 	int v;
-	struct rk3188_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	if(lcdc_dev->id == 0) //lcdc0
-	{
-		lcdc_dev->pd 	= clk_get(NULL,"pd_lcdc0");
-		lcdc_dev->hclk 	= clk_get(NULL,"hclk_lcdc0"); 
-		lcdc_dev->aclk 	= clk_get(NULL,"aclk_lcdc0");
-		lcdc_dev->dclk 	= clk_get(NULL,"dclk_lcdc0");
-	}
-	else if(lcdc_dev->id == 1)
-	{
-		lcdc_dev->pd 	= clk_get(NULL,"pd_lcdc1");
-		lcdc_dev->hclk 	= clk_get(NULL,"hclk_lcdc1");  
-		lcdc_dev->aclk 	= clk_get(NULL,"aclk_lcdc1");
-		lcdc_dev->dclk 	= clk_get(NULL,"dclk_lcdc1");
-	}
-	else
-	{
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	if (lcdc_dev->id == 0)	//lcdc0
+	{
+		//lcdc_dev->pd  = clk_get(NULL,"pd_lcdc0");
+		lcdc_dev->hclk = clk_get(NULL, "g_h_lcdc0");
+		lcdc_dev->aclk = clk_get(NULL, "aclk_lcdc0");
+		lcdc_dev->dclk = clk_get(NULL, "dclk_lcdc0");
+	} else if (lcdc_dev->id == 1) {
+		//lcdc_dev->pd  = clk_get(NULL,"pd_lcdc1");
+		lcdc_dev->hclk = clk_get(NULL, "g_h_lcdc1");
+		lcdc_dev->aclk = clk_get(NULL, "aclk_lcdc1");
+		lcdc_dev->dclk = clk_get(NULL, "dclk_lcdc1");
+	} else {
 		printk(KERN_ERR "invalid lcdc device!\n");
 		return -EINVAL;
 	}
-	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
-    	{
-       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
-   	}
-	if(!support_uboot_display())
-	{
-		rk3188_lcdc_clk_enable(lcdc_dev);
+	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk))
+	    || (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
+		printk(KERN_ERR "failed to get lcdc%d clk source\n",
+		       lcdc_dev->id);
 	}
-	else
-	{
+	if (!support_uboot_display()) {
+		rk3188_lcdc_clk_enable(lcdc_dev);
+	} else {
 		lcdc_dev->clk_on = 1;
 	}
 
 	rk3188_lcdc_read_reg_defalut_cfg(lcdc_dev);
-	#if defined(CONFIG_ARCH_RK3188)
-	if(lcdc_dev->id == 0)
-	{
-		#if defined(CONFIG_LCDC0_IO_18V)
-			v = 0x40004000;               //bit14: 1,1.8v;0,3.3v
-			writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
-		#else
-			v = 0x40000000;
-			writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
-		#endif
+#if defined(CONFIG_ARCH_RK3188)
+	if (lcdc_dev->id == 0) {
+#if defined(CONFIG_LCDC0_IO_18V)
+		v = 0x40004000;	//bit14: 1,1.8v;0,3.3v
+		writel_relaxed(v, RK30_GRF_BASE + GRF_IO_CON4);
+#else
+		v = 0x40000000;
+		writel_relaxed(v, RK30_GRF_BASE + GRF_IO_CON4);
+#endif
 	}
-	if(lcdc_dev->id == 1) //iomux for lcdc1
+	if (lcdc_dev->id == 1)	//iomux for lcdc1
 	{
-		#if defined(CONFIG_LCDC1_IO_18V)
-		v = 0x80008000;               //bit14: 1,1.8v;0,3.3v
-		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
-		#else
+#if defined(CONFIG_LCDC1_IO_18V)
+		v = 0x80008000;	//bit14: 1,1.8v;0,3.3v
+		writel_relaxed(v, RK30_GRF_BASE + GRF_IO_CON4);
+#else
 		v = 0x80000000;
-		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
-		#endif
+		writel_relaxed(v, RK30_GRF_BASE + GRF_IO_CON4);
+#endif
 		iomux_set(LCDC1_DCLK);
 		iomux_set(LCDC1_DEN);
 		iomux_set(LCDC1_HSYNC);
@@ -508,64 +513,58 @@ static int rk3188_lcdc_init(struct rk_lcdc_device_driver *dev_drv)
 		iomux_set(LCDC1_D22);
 		iomux_set(LCDC1_D23);
 	}
-	#endif
-	lcdc_set_bit(lcdc_dev,SYS_CTRL,m_AUTO_GATING_EN);//eanble axi-clk auto gating for low power
+#endif
+	lcdc_set_bit(lcdc_dev, SYS_CTRL, m_AUTO_GATING_EN);	//eanble axi-clk auto gating for low power
 	//lcdc_set_bit(lcdc_dev,DSP_CTRL0,m_WIN0_TOP);
-        if(dev_drv->cur_screen->dsp_lut)
-        {
-        	lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DSP_LUT_EN,v_DSP_LUT_EN(0));
+	if (dev_drv->cur_screen->dsp_lut) {
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
 		lcdc_cfg_done(lcdc_dev);
 		msleep(25);
-		for(i=0;i<256;i++)
-		{
+		for (i = 0; i < 256; i++) {
 			v = dev_drv->cur_screen->dsp_lut[i];
-			c = lcdc_dev->dsp_lut_addr_base+i;
-			writel_relaxed(v,c);
-			
+			c = lcdc_dev->dsp_lut_addr_base + i;
+			writel_relaxed(v, c);
+
 		}
-		lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DSP_LUT_EN,v_DSP_LUT_EN(1));
-        }
-	
-	lcdc_cfg_done(lcdc_dev);  // write any value to  REG_CFG_DONE let config become effective
-	if((!support_uboot_display())||(dev_drv->screen_ctr_info->prop == EXTEND))
-	{
-		rk3188_lcdc_clk_disable(lcdc_dev);
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
 	}
-	
+
+	lcdc_cfg_done(lcdc_dev);	// write any value to  REG_CFG_DONE let config become effective
+	/*if((!support_uboot_display())||(dev_drv->screen_ctr_info->prop == EXTEND))
+	   {
+	   rk3188_lcdc_clk_disable(lcdc_dev);
+	   } */
+
 	return 0;
 }
 
-
-static void rk3188_lcdc_deint(struct rk3188_lcdc_device * lcdc_dev)
+static void rk3188_lcdc_deint(struct rk3188_lcdc_device *lcdc_dev)
 {
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
+	if (likely(lcdc_dev->clk_on)) {
 		lcdc_dev->clk_on = 0;
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR, v_FS_INT_CLEAR(1));
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_HS_INT_EN | m_FS_INT_EN | 
-			m_LF_INT_EN | m_BUS_ERR_INT_EN,v_HS_INT_EN(0) | v_FS_INT_EN(0) | 
-			v_LF_INT_EN(0) | v_BUS_ERR_INT_EN(0));  //disable all lcdc interrupt
-		lcdc_set_bit(lcdc_dev,SYS_CTRL,m_LCDC_STANDBY);
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
+			     v_FS_INT_CLEAR(1));
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_HS_INT_EN | m_FS_INT_EN | m_LF_INT_EN | m_BUS_ERR_INT_EN, v_HS_INT_EN(0) | v_FS_INT_EN(0) | v_LF_INT_EN(0) | v_BUS_ERR_INT_EN(0));	//disable all lcdc interrupt
+		lcdc_set_bit(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY);
 		lcdc_cfg_done(lcdc_dev);
 		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else   //clk already disabled 
+	} else			//clk already disabled
 	{
 		spin_unlock(&lcdc_dev->reg_lock);
 	}
 	mdelay(1);
-	
+
 }
 
 //set lcdc according the screen info
-static int rk3188_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
+static int rk3188_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
 {
 	int ret = -EINVAL;
 	int fps;
 	u16 face = 0;
-	struct rk3188_lcdc_device *lcdc_dev = 
-				container_of(dev_drv,struct rk3188_lcdc_device,driver);
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
 	rk_screen *screen = dev_drv->cur_screen;
 	u16 right_margin = screen->right_margin;
 	u16 left_margin = screen->left_margin;
@@ -575,44 +574,50 @@ static int rk3188_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initsc
 	u16 y_res = screen->y_res;
 
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(screen->type==SCREEN_MCU)
-		{
-	    		printk("MUC¡¡screen not supported now!\n");
+	if (likely(lcdc_dev->clk_on)) {
+		if (screen->type == SCREEN_MCU) {
+			printk("MUC¡¡screen not supported now!\n");
 			return -EINVAL;
 		}
 
-		switch (screen->face)
-		{
+		switch (screen->face) {
 		case OUT_P565:
-			face = OUT_P565;  //dither down to rgb565
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				 m_DITHER_DOWN_SEL,v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-				 v_DITHER_DOWN_SEL(1));
+			face = OUT_P565;	//dither down to rgb565
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+				     m_DITHER_DOWN_SEL,
+				     v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0)
+				     | v_DITHER_DOWN_SEL(1));
 			break;
 		case OUT_P666:
-			face = OUT_P666; //dither down to rgb666
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-				v_DITHER_DOWN_SEL(1));
+			face = OUT_P666;	//dither down to rgb666
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+				     m_DITHER_DOWN_SEL,
+				     v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1)
+				     | v_DITHER_DOWN_SEL(1));
 			break;
 		case OUT_D888_P565:
 			face = OUT_P888;
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-				v_DITHER_DOWN_SEL(1));
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+				     m_DITHER_DOWN_SEL,
+				     v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0)
+				     | v_DITHER_DOWN_SEL(1));
 			break;
 		case OUT_D888_P666:
 			face = OUT_P888;
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-				v_DITHER_DOWN_SEL(1));
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+				     m_DITHER_DOWN_SEL,
+				     v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1)
+				     | v_DITHER_DOWN_SEL(1));
 			break;
 		case OUT_P888:
 			face = OUT_P888;
-			lcdc_msk_reg(lcdc_dev,DSP_CTRL0,m_DITHER_DOWN_EN | m_DITHER_UP_EN,
-					v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0));
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_DITHER_DOWN_EN | m_DITHER_UP_EN,
+				     v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0));
 			break;
 		default:
 			printk("unsupported display output interface!\n");
@@ -620,31 +625,50 @@ static int rk3188_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initsc
 		}
 
 		//use default overlay,set vsyn hsync den dclk polarity
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0,m_DSP_OUT_FORMAT | m_HSYNC_POL | m_VSYNC_POL |
-	     		     m_DEN_POL |m_DCLK_POL,v_DSP_OUT_FORMAT(face) | v_HSYNC_POL(screen->pin_hsync) | 
-	     		     v_VSYNC_POL(screen->pin_vsync) | v_DEN_POL(screen->pin_den) | v_DCLK_POL(screen->pin_dclk));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+			     m_DSP_OUT_FORMAT | m_HSYNC_POL | m_VSYNC_POL |
+			     m_DEN_POL | m_DCLK_POL,
+			     v_DSP_OUT_FORMAT(face) |
+			     v_HSYNC_POL(screen->pin_hsync) |
+			     v_VSYNC_POL(screen->
+					 pin_vsync) | v_DEN_POL(screen->pin_den)
+			     | v_DCLK_POL(screen->pin_dclk));
 
-		
 		//set background color to black,set swap according to the screen panel,disable blank mode
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BG_COLOR| m_DSP_BG_SWAP | m_DSP_RB_SWAP | 
-			     m_DSP_RG_SWAP | m_DSP_DELTA_SWAP | m_DSP_DUMMY_SWAP | m_BLANK_EN,
-			     v_BG_COLOR(0x000000) | v_DSP_BG_SWAP(screen->swap_gb) | 
-			     v_DSP_RB_SWAP(screen->swap_rb) | v_DSP_RG_SWAP(screen->swap_rg) | 
-			     v_DSP_DELTA_SWAP(screen->swap_delta) | v_DSP_DUMMY_SWAP(screen->swap_dumy) |
-			     v_BLANK_EN(0) | v_BLACK_EN(0));
-		lcdc_writel(lcdc_dev,DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
-			    v_HORPRD(screen->hsync_len + left_margin + x_res + right_margin));
-		lcdc_writel(lcdc_dev,DSP_HACT_ST_END,v_HAEP(screen->hsync_len + left_margin + x_res) |
-			    v_HASP(screen->hsync_len + left_margin));
-
-		lcdc_writel(lcdc_dev,DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
-			    v_VERPRD(screen->vsync_len + upper_margin + y_res + lower_margin));
-		lcdc_writel(lcdc_dev,DSP_VACT_ST_END,v_VAEP(screen->vsync_len + upper_margin+y_res)|
-			    v_VASP(screen->vsync_len + screen->upper_margin));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1,
+			     m_BG_COLOR | m_DSP_BG_SWAP | m_DSP_RB_SWAP |
+			     m_DSP_RG_SWAP | m_DSP_DELTA_SWAP | m_DSP_DUMMY_SWAP
+			     | m_BLANK_EN,
+			     v_BG_COLOR(0x000000) |
+			     v_DSP_BG_SWAP(screen->swap_gb) |
+			     v_DSP_RB_SWAP(screen->swap_rb) |
+			     v_DSP_RG_SWAP(screen->swap_rg) |
+			     v_DSP_DELTA_SWAP(screen->swap_delta) |
+			     v_DSP_DUMMY_SWAP(screen->swap_dumy) | v_BLANK_EN(0)
+			     | v_BLACK_EN(0));
+		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END,
+			    v_HSYNC(screen->
+				    hsync_len) | v_HORPRD(screen->hsync_len +
+							  left_margin + x_res +
+							  right_margin));
+		lcdc_writel(lcdc_dev, DSP_HACT_ST_END,
+			    v_HAEP(screen->hsync_len + left_margin +
+				   x_res) | v_HASP(screen->hsync_len +
+						   left_margin));
+
+		lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END,
+			    v_VSYNC(screen->
+				    vsync_len) | v_VERPRD(screen->vsync_len +
+							  upper_margin + y_res +
+							  lower_margin));
+		lcdc_writel(lcdc_dev, DSP_VACT_ST_END,
+			    v_VAEP(screen->vsync_len + upper_margin +
+				   y_res) | v_VASP(screen->vsync_len +
+						   screen->upper_margin));
 	}
- 	spin_unlock(&lcdc_dev->reg_lock);
-	#if defined(CONFIG_ARCH_RK3026)
-	if(dev_drv->screen0->type == SCREEN_RGB) //iomux for RGB screen
+	spin_unlock(&lcdc_dev->reg_lock);
+#if defined(CONFIG_ARCH_RK3026)
+	if (dev_drv->screen0->type == SCREEN_RGB)	//iomux for RGB screen
 	{
 		iomux_set(LCDC0_DCLK);
 		iomux_set(LCDC0_HSYNC);
@@ -658,64 +682,61 @@ static int rk3188_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initsc
 		iomux_set(LCDC0_D15);
 		iomux_set(LCDC0_D16);
 		iomux_set(LCDC0_D17);
-		if(!((dev_drv->screen0->face == OUT_P666)||(dev_drv->screen0->face == OUT_P565)))
-		{
+		if (!((dev_drv->screen0->face == OUT_P666)
+		      || (dev_drv->screen0->face == OUT_P565))) {
 			iomux_set(LCDC0_D18);
 			iomux_set(LCDC0_D19);
-			iomux_set(LCDC0_D20);//iomux uart2 in
-			iomux_set(LCDC0_D21);//iomux uart2 out
+			iomux_set(LCDC0_D20);	//iomux uart2 in
+			iomux_set(LCDC0_D21);	//iomux uart2 out
 			iomux_set(LCDC0_D22);
 			iomux_set(LCDC0_D23);
 		}
 	}
-	#endif
+#endif
 	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
-	if(ret)
-	{
-        	dev_err(dev_drv->dev,"set lcdc%d dclk failed\n",lcdc_dev->id);
+	if (ret) {
+		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
 	}
-    	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	
-	fps = rk_fb_calc_fps(screen,lcdc_dev->pixclock);
-	screen->ft = 1000/fps;
-    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk),fps);
-
-    	if(screen->init)
-    	{
-    		screen->init();
-    	}
-	
-	dev_info(dev_drv->dev,"%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
+	lcdc_dev->driver.pixclock = lcdc_dev->pixclock =
+	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+
+	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
+	screen->ft = 1000 / fps;
+	printk("%s: dclk:%lu>>fps:%d ", lcdc_dev->driver.name,
+	       clk_get_rate(lcdc_dev->dclk), fps);
+
+	if (screen->init) {
+		screen->init();
+	}
+
+	dev_info(dev_drv->dev, "%s for lcdc%d ok!\n", __func__, lcdc_dev->id);
 	return 0;
 }
 
-
-static  int win0_set_par(struct rk3188_lcdc_device *lcdc_dev,rk_screen *screen,
-			    struct layer_par *par )
+static int win0_set_par(struct rk3188_lcdc_device *lcdc_dev, rk_screen * screen,
+			struct layer_par *par)
 {
 	u32 xact, yact, xvir, yvir, xpos, ypos;
 	u32 ScaleYrgbX = 0x1000;
 	u32 ScaleYrgbY = 0x1000;
 	u32 ScaleCbrX = 0x1000;
 	u32 ScaleCbrY = 0x1000;
-	u8 fmt_cfg =0 ; //data format register config value
+	u8 fmt_cfg = 0;		//data format register config value
 	char fmt[9] = "NULL";
-	xact = par->xact;			    //active (origin) picture window width/height		
+	xact = par->xact;	//active (origin) picture window width/height
 	yact = par->yact;
-	xvir = par->xvir;			   // virtual resolution		
+	xvir = par->xvir;	// virtual resolution
 	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	xpos = par->xpos + screen->left_margin + screen->hsync_len;
+	ypos = par->ypos + screen->upper_margin + screen->vsync_len;
 
-	
-	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
+	ScaleYrgbX = CalScale(xact, par->xsize);	//both RGB and yuv need this two factor
 	ScaleYrgbY = CalScale(yact, par->ysize);
-	switch (par->format)
-	{
+	switch (par->format) {
 	case ARGB888:
 	case XBGR888:
 	case ABGR888:
-	     	fmt_cfg = 0;
+		fmt_cfg = 0;
 		break;
 	case RGB888:
 		fmt_cfg = 1;
@@ -723,32 +744,34 @@ static  int win0_set_par(struct rk3188_lcdc_device *lcdc_dev,rk_screen *screen,
 	case RGB565:
 		fmt_cfg = 2;
 		break;
-	case YUV422:// yuv422
+	case YUV422:		// yuv422
 		fmt_cfg = 5;
-		ScaleCbrX = CalScale((xact/2), par->xsize);
+		ScaleCbrX = CalScale((xact / 2), par->xsize);
 		ScaleCbrY = CalScale(yact, par->ysize);
 		break;
-	case YUV420: // yuv420
+	case YUV420:		// yuv420
 		fmt_cfg = 4;
-		ScaleCbrX = CalScale(xact/2, par->xsize);
-		ScaleCbrY = CalScale(yact/2, par->ysize);
+		ScaleCbrX = CalScale(xact / 2, par->xsize);
+		ScaleCbrY = CalScale(yact / 2, par->ysize);
 		break;
-	case YUV444:// yuv444
+	case YUV444:		// yuv444
 		fmt_cfg = 6;
 		ScaleCbrX = CalScale(xact, par->xsize);
 		ScaleCbrY = CalScale(yact, par->ysize);
 		break;
 	default:
-		dev_err(lcdc_dev->driver.dev,"%s:un supported format!\n",__func__);
+		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
+			__func__);
 		break;
 	}
 
-	DBG(1,"lcdc%d>>%s>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		lcdc_dev->id,__func__,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-	
+	DBG(1,
+	    "lcdc%d>>%s>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+	    lcdc_dev->id, __func__, get_format_string(par->format, fmt), xact,
+	    yact, par->xsize, par->ysize, xvir, yvir, xpos, ypos);
+
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
+	if (likely(lcdc_dev->clk_on)) {
 		par->scale_yrgb_x = ScaleYrgbX;
 		par->scale_yrgb_y = ScaleYrgbY;
 		par->scale_cbcr_x = ScaleCbrX;
@@ -756,8 +779,7 @@ static  int win0_set_par(struct rk3188_lcdc_device *lcdc_dev,rk_screen *screen,
 		par->fmt_cfg = fmt_cfg;
 		par->dsp_stx = xpos;
 		par->dsp_sty = ypos;
-		switch(par->format) 
-		{
+		switch (par->format) {
 		case XBGR888:
 		case ABGR888:
 			par->vir_stride = v_ARGB888_VIRWIDTH(xvir);
@@ -767,11 +789,11 @@ static  int win0_set_par(struct rk3188_lcdc_device *lcdc_dev,rk_screen *screen,
 			par->vir_stride = v_ARGB888_VIRWIDTH(xvir);
 			par->swap_rb = 0;
 			break;
-		case RGB888:  //rgb888
+		case RGB888:	//rgb888
 			par->vir_stride = v_RGB888_VIRWIDTH(xvir);
 			par->swap_rb = 0;
 			break;
-		case RGB565:  //rgb565
+		case RGB565:	//rgb565
 			par->vir_stride = v_RGB565_VIRWIDTH(xvir);
 			par->swap_rb = 0;
 			break;
@@ -782,42 +804,41 @@ static  int win0_set_par(struct rk3188_lcdc_device *lcdc_dev,rk_screen *screen,
 			par->swap_rb = 0;
 			break;
 		default:
-			dev_err(lcdc_dev->driver.dev,"%s:un supported format!\n",__func__);
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n", __func__);
 			break;
 		}
 
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
 
-    return 0;
+	return 0;
 
 }
 
-static int win1_set_par(struct rk3188_lcdc_device *lcdc_dev,rk_screen *screen,
-			   struct layer_par *par )
+static int win1_set_par(struct rk3188_lcdc_device *lcdc_dev, rk_screen * screen,
+			struct layer_par *par)
 {
 	u32 xact, yact, xvir, yvir, xpos, ypos;
 	u8 fmt_cfg;
 	char fmt[9] = "NULL";
-	xact = par->xact;			
+	xact = par->xact;
 	yact = par->yact;
-	xvir = par->xvir;		
+	xvir = par->xvir;
 	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	xpos = par->xpos + screen->left_margin + screen->hsync_len;
+	ypos = par->ypos + screen->upper_margin + screen->vsync_len;
 
-	
-	DBG(1,"lcdc%d>>%s>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		lcdc_dev->id,__func__,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+	DBG(1,
+	    "lcdc%d>>%s>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+	    lcdc_dev->id, __func__, get_format_string(par->format, fmt), xact,
+	    yact, par->xsize, par->ysize, xvir, yvir, xpos, ypos);
 
-	
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
+	if (likely(lcdc_dev->clk_on)) {
 		par->dsp_stx = xpos;
 		par->dsp_sty = ypos;
-		switch(par->format)
-		{
+		switch (par->format) {
 		case XBGR888:
 		case ABGR888:
 			fmt_cfg = 0;
@@ -828,20 +849,21 @@ static int win1_set_par(struct rk3188_lcdc_device *lcdc_dev,rk_screen *screen,
 			fmt_cfg = 0;
 			par->vir_stride = v_WIN1_ARGB888_VIRWIDTH(xvir);
 			par->swap_rb = 0;
-			
+
 			break;
-		case RGB888:  //rgb888
+		case RGB888:	//rgb888
 			fmt_cfg = 1;
 			par->vir_stride = v_WIN1_RGB888_VIRWIDTH(xvir);
 			par->swap_rb = 0;
 			break;
-		case RGB565:  //rgb565
+		case RGB565:	//rgb565
 			fmt_cfg = 2;
 			par->vir_stride = v_WIN1_RGB565_VIRWIDTH(xvir);
 			par->swap_rb = 0;
 			break;
 		default:
-			dev_err(lcdc_dev->driver.dev,"%s:un supported format!\n",__func__);
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n", __func__);
 			break;
 		}
 		par->fmt_cfg = fmt_cfg;
@@ -852,69 +874,64 @@ static int win1_set_par(struct rk3188_lcdc_device *lcdc_dev,rk_screen *screen,
 	return 0;
 }
 
-
-static int rk3188_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+static int rk3188_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int layer_id)
 {
-	struct rk3188_lcdc_device *lcdc_dev = 
-			container_of(dev_drv,struct rk3188_lcdc_device,driver);
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
 	struct layer_par *par = NULL;
 	rk_screen *screen = dev_drv->cur_screen;
 
-	if(!screen)
-	{
-		dev_err(dev_drv->dev,"screen is null!\n");
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
 		return -ENOENT;
 	}
-	if(layer_id==0)
-	{
+	if (layer_id == 0) {
 		par = dev_drv->layer_par[0];
-		win0_set_par(lcdc_dev,screen,par);
-	}
-	else if(layer_id==1)
-	{
+		win0_set_par(lcdc_dev, screen, par);
+	} else if (layer_id == 1) {
 		par = dev_drv->layer_par[1];
-		win1_set_par(lcdc_dev,screen,par);
-	}
-	else
-	{
-		dev_err(dev_drv->dev,"unsupported win number:%d\n",layer_id);
+		win1_set_par(lcdc_dev, screen, par);
+	} else {
+		dev_err(dev_drv->dev, "unsupported win number:%d\n", layer_id);
 		return -EINVAL;
 	}
-	
+
 	return 0;
 }
 
-static  int win0_display(struct rk3188_lcdc_device *lcdc_dev,struct layer_par *par )
+static int win0_display(struct rk3188_lcdc_device *lcdc_dev,
+			struct layer_par *par)
 {
 	u32 y_addr;
 	u32 uv_addr;
 	y_addr = par->smem_start + par->y_offset;
 	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,"lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n", lcdc_dev->id, __func__,
+	    y_addr, uv_addr);
 
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
+	if (likely(lcdc_dev->clk_on)) {
 		par->y_addr = y_addr;
 		par->uv_addr = uv_addr;
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
 
 	return 0;
-	
+
 }
 
-static  int win1_display(struct rk3188_lcdc_device *lcdc_dev,struct layer_par *par )
+static int win1_display(struct rk3188_lcdc_device *lcdc_dev,
+			struct layer_par *par)
 {
 	u32 y_addr;
 	u32 uv_addr;
 	y_addr = par->smem_start + par->y_offset;
 	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,"lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n", lcdc_dev->id,
+	    __func__, y_addr, uv_addr);
 
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
+	if (likely(lcdc_dev->clk_on)) {
 		par->y_addr = y_addr;
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
@@ -922,167 +939,170 @@ static  int win1_display(struct rk3188_lcdc_device *lcdc_dev,struct layer_par *p
 	return 0;
 }
 
-static int rk3188_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
+static int rk3188_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int layer_id)
 {
-	struct rk3188_lcdc_device *lcdc_dev = 
-				container_of(dev_drv,struct rk3188_lcdc_device,driver);
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
 	struct layer_par *par = NULL;
 	rk_screen *screen = dev_drv->cur_screen;
 #if defined(WAIT_FOR_SYNC)
 	int timeout;
 	unsigned long flags;
 #endif
-	if(!screen)
-	{
-		dev_err(dev_drv->dev,"screen is null!\n");
-		return -ENOENT;	
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
 	}
-	if(layer_id==0)
-	{
+	if (layer_id == 0) {
 		par = dev_drv->layer_par[0];
-		win0_display(lcdc_dev,par);
-	}
-	else if(layer_id==1)
-	{
+		win0_display(lcdc_dev, par);
+	} else if (layer_id == 1) {
 		par = dev_drv->layer_par[1];
-		win1_display(lcdc_dev,par);
-	}
-	else 
-	{
-		dev_err(dev_drv->dev,"invalid win number:%d!\n",layer_id);
+		win1_display(lcdc_dev, par);
+	} else {
+		dev_err(dev_drv->dev, "invalid win number:%d!\n", layer_id);
 		return -EINVAL;
 	}
-	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
-	{
+
+	/*this is the first frame of the system ,enable frame start interrupt*/
+	if ((dev_drv->first_frame)) {
 		dev_drv->first_frame = 0;
-		lcdc_msk_reg(lcdc_dev,INT_STATUS,m_HS_INT_CLEAR | m_HS_INT_EN |
-			m_FS_INT_CLEAR | m_FS_INT_EN | m_LF_INT_EN | m_LF_INT_CLEAR |
-			m_LF_INT_NUM | m_BUS_ERR_INT_CLEAR | m_BUS_ERR_INT_EN,
-			v_FS_INT_CLEAR(1) | v_FS_INT_EN(1) | v_HS_INT_CLEAR(1) |
-			v_HS_INT_EN(0) | v_LF_INT_CLEAR(1) | v_LF_INT_EN(1) |
-			v_LF_INT_NUM(screen->vsync_len + screen->upper_margin+screen->y_res -1));
-		lcdc_cfg_done(lcdc_dev);  // write any value to  REG_CFG_DONE let config become effective
-		 
+		lcdc_msk_reg(lcdc_dev, INT_STATUS,
+			     m_HS_INT_CLEAR | m_HS_INT_EN | m_FS_INT_CLEAR |
+			     m_FS_INT_EN | m_LF_INT_EN | m_LF_INT_CLEAR |
+			     m_LF_INT_NUM | m_BUS_ERR_INT_CLEAR |
+			     m_BUS_ERR_INT_EN,
+			     v_FS_INT_CLEAR(1) | v_FS_INT_EN(1) |
+			     v_HS_INT_CLEAR(1) | v_HS_INT_EN(0) |
+			     v_LF_INT_CLEAR(1) | v_LF_INT_EN(1) |
+			     v_LF_INT_NUM(screen->vsync_len +
+					  screen->upper_margin + screen->y_res -
+					  1));
+		lcdc_cfg_done(lcdc_dev);
 	}
-
 #if defined(WAIT_FOR_SYNC)
-	spin_lock_irqsave(&dev_drv->cpl_lock,flags);
+	spin_lock_irqsave(&dev_drv->cpl_lock, flags);
 	init_completion(&dev_drv->frame_done);
-	spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
-	timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
-	if(!timeout&&(!dev_drv->frame_done.done))
-	{
-		printk(KERN_ERR "wait for new frame start time out!\n");
+	spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+	timeout =
+	    wait_for_completion_timeout(&dev_drv->frame_done,
+					msecs_to_jiffies(dev_drv->
+							 cur_screen->ft + 5));
+	if (!timeout && (!dev_drv->frame_done.done)) {
+		dev_info(dev_drv->dev, "wait for new frame start time out!\n");
 		return -ETIMEDOUT;
 	}
 #endif
 	return 0;
 }
 
-static int rk3188_lcdc_blank(struct rk_lcdc_device_driver *dev_drv,
-				int layer_id,int blank_mode)
+static int rk3188_lcdc_blank(struct rk_lcdc_driver *dev_drv,
+			     int layer_id, int blank_mode)
 {
-	struct rk3188_lcdc_device * lcdc_dev = 
-		container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		switch(blank_mode)
-		{
+	if (likely(lcdc_dev->clk_on)) {
+		switch (blank_mode) {
 		case FB_BLANK_UNBLANK:
-			lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_EN ,v_BLANK_EN(0));
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
+				     v_BLANK_EN(0));
 			break;
 		case FB_BLANK_NORMAL:
-			lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_EN ,v_BLANK_EN(1));
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
+				     v_BLANK_EN(1));
 			break;
 		default:
-			lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_EN ,v_BLANK_EN(1));
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
+				     v_BLANK_EN(1));
 			break;
 		}
 		lcdc_cfg_done(lcdc_dev);
-		
+
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
 
-	dev_info(dev_drv->dev,"blank mode:%d\n",blank_mode);
+	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
 
-    	return 0;
+	return 0;
 }
 
-
-static int rk3188_lcdc_ioctl(struct rk_lcdc_device_driver *dev_drv, unsigned int cmd,unsigned long arg,int layer_id)
+static int rk3188_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
+			     unsigned long arg, int layer_id)
 {
-	struct rk3188_lcdc_device *lcdc_dev = 
-		container_of(dev_drv,struct rk3188_lcdc_device,driver);
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
 	u32 panel_size[2];
 	void __user *argp = (void __user *)arg;
 	struct color_key_cfg clr_key_cfg;
-	
-	switch(cmd)
-	{
-		case RK_FBIOGET_PANEL_SIZE:    //get panel size
-                	panel_size[0] = lcdc_dev->screen->x_res;
-                	panel_size[1] = lcdc_dev->screen->y_res;
-            		if(copy_to_user(argp, panel_size, 8)) 
-				return -EFAULT;
-			break;
-		case RK_FBIOPUT_COLOR_KEY_CFG:
-			if(copy_from_user(&clr_key_cfg,argp,sizeof(struct color_key_cfg ))) 
-				return -EFAULT;
-			lcdc_writel(lcdc_dev,WIN0_COLOR_KEY,clr_key_cfg.win0_color_key_cfg);
-			lcdc_writel(lcdc_dev,WIN1_COLOR_KEY,clr_key_cfg.win1_color_key_cfg);
-			break;
-			
-		default:
-			break;
+
+	switch (cmd) {
+	case RK_FBIOGET_PANEL_SIZE:
+		panel_size[0] = lcdc_dev->screen->x_res;
+		panel_size[1] = lcdc_dev->screen->y_res;
+		if (copy_to_user(argp, panel_size, 8))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_COLOR_KEY_CFG:
+		if (copy_from_user
+		    (&clr_key_cfg, argp, sizeof(struct color_key_cfg)))
+			return -EFAULT;
+		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
+			    clr_key_cfg.win0_color_key_cfg);
+		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
+			    clr_key_cfg.win1_color_key_cfg);
+		break;
+
+	default:
+		break;
 	}
 	return 0;
 }
 
-static int rk3188_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
+static int rk3188_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
 {
 
-	struct rk3188_lcdc_device *lcdc_dev = 
-		container_of(dev_drv,struct rk3188_lcdc_device,driver);
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
 
-	if(dev_drv->screen0->standby)
+	if (dev_drv->screen0->standby)
 		dev_drv->screen0->standby(1);
-	if(dev_drv->screen_ctr_info->io_disable)
+	if (dev_drv->screen_ctr_info->io_disable)
 		dev_drv->screen_ctr_info->io_disable();
 
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_msk_reg(lcdc_dev,INT_STATUS,m_FS_INT_CLEAR,v_FS_INT_CLEAR(1));
-		lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_DSP_OUT_ZERO ,v_DSP_OUT_ZERO(1));
-		lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
+			     v_FS_INT_CLEAR(1));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(1));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(1));
 		lcdc_cfg_done(lcdc_dev);
 		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else  //clk already disabled
-	{
+	} else {
 		spin_unlock(&lcdc_dev->reg_lock);
 		return 0;
 	}
 	rk3188_lcdc_clk_disable(lcdc_dev);
 #if defined(CONFIG_ARCH_RK3026)
 	int gpio_dclk = iomux_mode_to_gpio(LCDC0_DCLK);
-	int ret = gpio_request(gpio_dclk,NULL);
-	if(unlikely(ret < 0)){
-		printk("Failed to request gpio:lcdc dclk\n");
+	int ret = gpio_request(gpio_dclk, NULL);
+	if (unlikely(ret < 0)) {
+		dev_info(dev_drv->dev, "Failed to request gpio:lcdc dclk\n");
 		return ret;
 	}
-	gpio_direction_output(gpio_dclk,GPIO_LOW);
+	gpio_direction_output(gpio_dclk, GPIO_LOW);
 #endif
 	return 0;
 }
 
-static int rk3188_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
+static int rk3188_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
 {
-	struct rk3188_lcdc_device *lcdc_dev = 
-		container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	int i=0;
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	int i = 0;
 	int __iomem *c;
 	int v;
 #if defined(CONFIG_ARCH_RK3026)
@@ -1090,71 +1110,65 @@ static int rk3188_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
 	gpio_free(gpio_dclk);
 	iomux_set(LCDC0_DCLK);
 #endif
-	if(dev_drv->screen_ctr_info->io_enable) 		//power on
+	if (dev_drv->screen_ctr_info->io_enable)
 		dev_drv->screen_ctr_info->io_enable();
-	
 
-	if(lcdc_dev->atv_layer_cnt) //only resume the lcdc that need to use
-	{
+	if (lcdc_dev->atv_layer_cnt) {
 		rk3188_lcdc_clk_enable(lcdc_dev);
-		
-		rk3188_lcdc_reg_resume(lcdc_dev);  //resume reg
+		rk3188_lcdc_reg_resume(lcdc_dev);
 
 		spin_lock(&lcdc_dev->reg_lock);
-		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
-		{
-			lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DSP_LUT_EN,v_DSP_LUT_EN(0));
+		if (dev_drv->cur_screen->dsp_lut) {
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN,
+				     v_DSP_LUT_EN(0));
 			lcdc_cfg_done(lcdc_dev);
 			mdelay(25);
-			for(i=0;i<256;i++)
-			{
+			for (i = 0; i < 256; i++) {
 				v = dev_drv->cur_screen->dsp_lut[i];
-				c = lcdc_dev->dsp_lut_addr_base+i;
-				writel_relaxed(v,c);
+				c = lcdc_dev->dsp_lut_addr_base + i;
+				writel_relaxed(v, c);
 			}
-			lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DSP_LUT_EN,v_DSP_LUT_EN(1));
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN,
+				     v_DSP_LUT_EN(1));
 		}
-		
-		
-		lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_DSP_OUT_ZERO ,v_DSP_OUT_ZERO(0));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(0));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(0));
 		lcdc_cfg_done(lcdc_dev);
-		
+
 		spin_unlock(&lcdc_dev->reg_lock);
 	}
 
-	
+	if (dev_drv->screen0->standby)
+		dev_drv->screen0->standby(0);
 
-	if(dev_drv->screen0->standby)
-		dev_drv->screen0->standby(0);	      //screen wake up
-	
 	return 0;
 }
 
-static int rk3188_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+static int rk3188_lcdc_get_layer_state(struct rk_lcdc_driver *dev_drv,
+				       int layer_id)
 {
 	return 0;
 }
 
-static int rk3188_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
+static int rk3188_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
+			       bool set)
 {
-	struct rk3188_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3188_lcdc_device,driver);
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
 	int ovl;
 	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(set)  //set overlay
-		{
-			lcdc_msk_reg(lcdc_dev,DSP_CTRL0,m_WIN0_TOP,v_WIN0_TOP(swap));
+	if (lcdc_dev->clk_on) {
+		if (set) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_TOP,
+				     v_WIN0_TOP(swap));
 			ovl = swap;
+		} else {
+			ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
 		}
-		else  //get overlay
-		{
-			ovl = lcdc_read_bit(lcdc_dev,DSP_CTRL0,m_WIN0_TOP);
-		}
-	}
-	else
-	{
+	} else {
 		ovl = -EPERM;
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
@@ -1162,399 +1176,370 @@ static int rk3188_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bo
 	return ovl;
 }
 
-
-static ssize_t rk3188_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id)
+static ssize_t rk3188_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
+					 char *buf, int layer_id)
 {
-	
-	struct rk3188_lcdc_device *lcdc_dev = 
-		container_of(dev_drv,struct rk3188_lcdc_device,driver);
-
-        char format_w0[9]= "NULL";
-	char format_w1[9]= "NULL";
-	char status_w0[9]= "NULL";
-	char status_w1[9]= "NULL";
-        u32 fmt_id = lcdc_readl(lcdc_dev,SYS_CTRL);
-        u32 act_info,dsp_info,dsp_st,factor;
-        u16 xvir_w0,x_act_w0,y_act_w0,x_dsp_w0,y_dsp_w0,x_st_w0,y_st_w0,x_factor,y_factor;
-	u16 xvir_w1,x_dsp_w1,y_dsp_w1,x_st_w1,y_st_w1;
-        u16 x_scale,y_scale;
-	int ovl = lcdc_read_bit(lcdc_dev,DSP_CTRL0,m_WIN0_TOP);
-	
-        switch((fmt_id&m_WIN0_FORMAT)>>3)
-        {
-                case 0:
-                        strcpy(format_w0,"ARGB888");
-                        break;
-                case 1:
-                        strcpy(format_w0,"RGB888");
-                        break;
-                case 2:
-                        strcpy(format_w0,"RGB565");
-                        break;
-                case 4:
-                        strcpy(format_w0,"YCbCr420");
-                        break;
-                case 5:
-                        strcpy(format_w0,"YCbCr422");
-                        break;
-                case 6:
-                        strcpy(format_w0,"YCbCr444");
-                        break;
-                default:
-                        strcpy(format_w0,"invalid\n");
-                        break;
-        }
-
-	 switch((fmt_id&m_WIN1_FORMAT)>>6)
-        {
-                case 0:
-                        strcpy(format_w1,"ARGB888");
-                        break;
-                case 1:
-                        strcpy(format_w1,"RGB888");
-                        break;
-                case 2:
-                        strcpy(format_w1,"RGB565");
-                        break;
-                case 4:
-                        strcpy(format_w1,"8bpp");
-                        break;
-                case 5:
-	                strcpy(format_w1,"4bpp");
-	                break;
-                case 6:
-                        strcpy(format_w1,"2bpp");
-                        break;
-                case 7:
-                        strcpy(format_w1,"1bpp");
-                        break;
-                default:
-                        strcpy(format_w1,"invalid\n");
-                        break;
-        }
-
-	if(fmt_id&m_WIN0_EN)
-	{
-		strcpy(status_w0,"enabled");
-	}
-	else
-	{
-		strcpy(status_w0,"disabled");
+
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+
+	char format_w0[9] = "NULL";
+	char format_w1[9] = "NULL";
+	char status_w0[9] = "NULL";
+	char status_w1[9] = "NULL";
+	u32 fmt_id = lcdc_readl(lcdc_dev, SYS_CTRL);
+	u32 act_info, dsp_info, dsp_st, factor;
+	u16 xvir_w0, x_act_w0, y_act_w0, x_dsp_w0, y_dsp_w0, x_st_w0, y_st_w0,
+	    x_factor, y_factor;
+	u16 xvir_w1, x_dsp_w1, y_dsp_w1, x_st_w1, y_st_w1;
+	u16 x_scale, y_scale;
+	int ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
+
+	switch ((fmt_id & m_WIN0_FORMAT) >> 3) {
+	case 0:
+		strcpy(format_w0, "ARGB888");
+		break;
+	case 1:
+		strcpy(format_w0, "RGB888");
+		break;
+	case 2:
+		strcpy(format_w0, "RGB565");
+		break;
+	case 4:
+		strcpy(format_w0, "YCbCr420");
+		break;
+	case 5:
+		strcpy(format_w0, "YCbCr422");
+		break;
+	case 6:
+		strcpy(format_w0, "YCbCr444");
+		break;
+	default:
+		strcpy(format_w0, "invalid\n");
+		break;
 	}
 
-	if((fmt_id&m_WIN1_EN)>>1)
-	{
-		strcpy(status_w1,"enabled");
+	switch ((fmt_id & m_WIN1_FORMAT) >> 6) {
+	case 0:
+		strcpy(format_w1, "ARGB888");
+		break;
+	case 1:
+		strcpy(format_w1, "RGB888");
+		break;
+	case 2:
+		strcpy(format_w1, "RGB565");
+		break;
+	case 4:
+		strcpy(format_w1, "8bpp");
+		break;
+	case 5:
+		strcpy(format_w1, "4bpp");
+		break;
+	case 6:
+		strcpy(format_w1, "2bpp");
+		break;
+	case 7:
+		strcpy(format_w1, "1bpp");
+		break;
+	default:
+		strcpy(format_w1, "invalid\n");
+		break;
 	}
+
+	if (fmt_id & m_WIN0_EN)
+		strcpy(status_w0, "enabled");
 	else
-	{
-		strcpy(status_w1,"disabled");
-	}
+		strcpy(status_w0, "disabled");
 
-        xvir_w0 = lcdc_readl(lcdc_dev,WIN_VIR)&0x1fff;
-        act_info = lcdc_readl(lcdc_dev,WIN0_ACT_INFO);
-        dsp_info = lcdc_readl(lcdc_dev,WIN0_DSP_INFO);
-        dsp_st = lcdc_readl(lcdc_dev,WIN0_DSP_ST);
-        factor = lcdc_readl(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
-        x_act_w0= (act_info&0x1fff) + 1;
-        y_act_w0= ((act_info>>16)&0x1fff) + 1;
-        x_dsp_w0= (dsp_info&0x7ff) + 1;
-        y_dsp_w0= ((dsp_info>>16)&0x7ff) + 1;
-	x_st_w0 = dsp_st&0xffff;
-        y_st_w0 = dsp_st>>16;
-	x_factor = factor&0xffff;
-        y_factor = factor>>16;
-        x_scale = 4096*100/x_factor;
-        y_scale = 4096*100/y_factor;
-
-	xvir_w1= (lcdc_readl(lcdc_dev,WIN_VIR)>> 16)&0x1fff;
-        dsp_info = lcdc_readl(lcdc_dev,WIN1_DSP_INFO);
-        dsp_st = lcdc_readl(lcdc_dev,WIN1_DSP_ST);
-        x_dsp_w1= (dsp_info&0x7ff) + 1;
-        y_dsp_w1= ((dsp_info>>16)&0x7ff) + 1;
-	x_st_w1 = dsp_st&0xffff;
-        y_st_w1 = dsp_st>>16;
-        return snprintf(buf,PAGE_SIZE,
-		"win0:%s\n"
-		"xvir:%d\n"
-		"xact:%d\n"
-		"yact:%d\n"
-		"xdsp:%d\n"
-		"ydsp:%d\n"
-		"x_st:%d\n"
-		"y_st:%d\n"
-		"x_scale:%d.%d\n"
-		"y_scale:%d.%d\n"
-		"format:%s\n"
-		"YRGB buffer addr:0x%08x\n"
-		"CBR buffer addr:0x%08x\n\n"
-		"win1:%s\n"
-		"xvir:%d\n"
-		"xdsp:%d\n"
-		"ydsp:%d\n"
-		"x_st:%d\n"
-		"y_st:%d\n"
-		"format:%s\n"
-		"YRGB buffer addr:0x%08x\n"
-		"overlay:%s\n",
-		status_w0,
-                xvir_w0,
-                x_act_w0,
-                y_act_w0,
-                x_dsp_w0,
-                y_dsp_w0,
-               	x_st_w0,
-               	y_st_w0,
-                x_scale/100,
-                x_scale%100,
-                y_scale/100,
-                y_scale%100,
-                format_w0,
-                lcdc_readl(lcdc_dev,WIN0_YRGB_MST0),
-		lcdc_readl(lcdc_dev,WIN0_CBR_MST0),
-                status_w1,
-                xvir_w1,
-                x_dsp_w1,
-                y_dsp_w1,
-                x_st_w1,
-                y_st_w1,
-                format_w1,
-                lcdc_readl(lcdc_dev,WIN1_MST),
-                ovl ? "win0 on the top of win1\n":"win1 on the top of win0\n");
+	if ((fmt_id & m_WIN1_EN) >> 1)
+		strcpy(status_w1, "enabled");
+	else
+		strcpy(status_w1, "disabled");
+
+	xvir_w0 = lcdc_readl(lcdc_dev, WIN_VIR) & 0x1fff;
+	act_info = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
+	dsp_info = lcdc_readl(lcdc_dev, WIN0_DSP_INFO);
+	dsp_st = lcdc_readl(lcdc_dev, WIN0_DSP_ST);
+	factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_YRGB);
+	x_act_w0 = (act_info & 0x1fff) + 1;
+	y_act_w0 = ((act_info >> 16) & 0x1fff) + 1;
+	x_dsp_w0 = (dsp_info & 0x7ff) + 1;
+	y_dsp_w0 = ((dsp_info >> 16) & 0x7ff) + 1;
+	x_st_w0 = dsp_st & 0xffff;
+	y_st_w0 = dsp_st >> 16;
+	x_factor = factor & 0xffff;
+	y_factor = factor >> 16;
+	x_scale = 4096 * 100 / x_factor;
+	y_scale = 4096 * 100 / y_factor;
+
+	xvir_w1 = (lcdc_readl(lcdc_dev, WIN_VIR) >> 16) & 0x1fff;
+	dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO);
+	dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST);
+	x_dsp_w1 = (dsp_info & 0x7ff) + 1;
+	y_dsp_w1 = ((dsp_info >> 16) & 0x7ff) + 1;
+	x_st_w1 = dsp_st & 0xffff;
+	y_st_w1 = dsp_st >> 16;
+	return snprintf(buf, PAGE_SIZE,
+			"win0:%s\n"
+			"xvir:%d\n"
+			"xact:%d\n"
+			"yact:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"x_scale:%d.%d\n"
+			"y_scale:%d.%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n"
+			"CBR buffer addr:0x%08x\n\n"
+			"win1:%s\n"
+			"xvir:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n"
+			"overlay:%s\n",
+			status_w0,
+			xvir_w0,
+			x_act_w0,
+			y_act_w0,
+			x_dsp_w0,
+			y_dsp_w0,
+			x_st_w0,
+			y_st_w0,
+			x_scale / 100,
+			x_scale % 100,
+			y_scale / 100,
+			y_scale % 100,
+			format_w0,
+			lcdc_readl(lcdc_dev, WIN0_YRGB_MST0),
+			lcdc_readl(lcdc_dev, WIN0_CBR_MST0),
+			status_w1,
+			xvir_w1,
+			x_dsp_w1,
+			y_dsp_w1,
+			x_st_w1,
+			y_st_w1,
+			format_w1,
+			lcdc_readl(lcdc_dev, WIN1_MST),
+			ovl ? "win0 on the top of win1\n" :
+			"win1 on the top of win0\n");
 
 }
 
-
-static int rk3188_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
+static int rk3188_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
+			       bool set)
 {
-	struct rk3188_lcdc_device *lcdc_dev = 
-		container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	rk_screen * screen = dev_drv->cur_screen;
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	rk_screen *screen = dev_drv->cur_screen;
 	u64 ft = 0;
 	u32 dotclk;
 	int ret;
 	u32 pixclock;
-	if(set)
-	{
-		ft = div_u64(1000000000000llu,fps);
-		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
-		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
+	u32 x_total, y_total;
+	if (set) {
+		ft = div_u64(1000000000000llu, fps);
+		x_total = screen->upper_margin + screen->lower_margin +
+				screen->y_res + screen->vsync_len;
+		y_total = screen->left_margin + screen->right_margin +
+				screen->x_res + screen->hsync_len;
+		dev_drv->pixclock = div_u64(ft, x_total * y_total);
+		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
 		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-		if(ret)
-		{
-	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-			return 0;
-		}			
 	}
-	
-	
+
 	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
 	dev_drv->pixclock = lcdc_dev->pixclock = pixclock;
-	fps = rk_fb_calc_fps(lcdc_dev->screen,pixclock);
-	screen->ft = 1000/fps ;  //one frame time in ms
+	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
+	screen->ft = 1000 / fps;	/*one frame time in ms*/
+
+	if (set)
+		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
+			 clk_get_rate(lcdc_dev->dclk), fps);
 
-	if(set)
-		dev_info(dev_drv->dev,"%s:dclk:%lu,fps:%d\n",__func__,clk_get_rate(lcdc_dev->dclk),fps);
-	
 	return fps;
 }
 
-
-static int rk3188_fb_layer_remap(struct rk_lcdc_device_driver *dev_drv,
-	enum fb_win_map_order order)
+static int rk3188_fb_layer_remap(struct rk_lcdc_driver *dev_drv,
+				 enum fb_win_map_order order)
 {
 	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if(order == FB_DEFAULT_ORDER )
-	{
+	if (order == FB_DEFAULT_ORDER)
 		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
-	}
-	dev_drv->fb2_win_id  = order/100;
-	dev_drv->fb1_win_id = (order/10)%10;
-	dev_drv->fb0_win_id = order%10;
+	dev_drv->fb2_win_id = order / 100;
+	dev_drv->fb1_win_id = (order / 10) % 10;
+	dev_drv->fb0_win_id = order % 10;
 	mutex_unlock(&dev_drv->fb_win_id_mutex);
 
-	printk("fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
-	       dev_drv->fb2_win_id);
-
-       return 0;
+	dev_info(dev_drv->dev, "fb0:win%d\n"
+				"fb1:win%d\n"
+				"fb2:win%d\n",
+				dev_drv->fb0_win_id,
+				dev_drv->fb1_win_id,
+				dev_drv->fb2_win_id);
+	return 0;
 }
 
-static int rk3188_fb_get_layer(struct rk_lcdc_device_driver *dev_drv,const char *id)
+static int rk3188_fb_get_layer(struct rk_lcdc_driver *dev_drv, const char *id)
 {
-       int layer_id = 0;
-       mutex_lock(&dev_drv->fb_win_id_mutex);
-       if(!strcmp(id,"fb0")||!strcmp(id,"fb2"))
-       {
-               layer_id = dev_drv->fb0_win_id;
-       }
-       else if(!strcmp(id,"fb1")||!strcmp(id,"fb3"))
-       {
-               layer_id = dev_drv->fb1_win_id;
-       }
-       mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-       return  layer_id;
+	int layer_id = 0;
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (!strcmp(id, "fb0") || !strcmp(id, "fb2"))
+		layer_id = dev_drv->fb0_win_id;
+	else if (!strcmp(id, "fb1") || !strcmp(id, "fb3"))
+		layer_id = dev_drv->fb1_win_id;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return layer_id;
 }
 
-static int rk3188_set_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
+static int rk3188_set_dsp_lut(struct rk_lcdc_driver *dev_drv, int *lut)
 {
-	int i=0;
+	int i = 0;
 	int __iomem *c;
 	int v;
 	int ret = 0;
 
-	struct rk3188_lcdc_device *lcdc_dev = 
-				container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DSP_LUT_EN,v_DSP_LUT_EN(0));
+	struct rk3188_lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
 	lcdc_cfg_done(lcdc_dev);
 	msleep(25);
-	if(dev_drv->cur_screen->dsp_lut)
-	{
-		for(i=0;i<256;i++)
-		{
+	if (dev_drv->cur_screen->dsp_lut) {
+		for (i = 0; i < 256; i++) {
 			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
-			c = lcdc_dev->dsp_lut_addr_base+i;
-			writel_relaxed(v,c);
-			
+			c = lcdc_dev->dsp_lut_addr_base + i;
+			writel_relaxed(v, c);
+
 		}
+	} else {
+		dev_err(dev_drv->dev, "no buffer to backup lut data!\n");
+		ret = -1;
 	}
-	else
-	{
-		dev_err(dev_drv->dev,"no buffer to backup lut data!\n");
-		ret =  -1;
-	}
-	lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DSP_LUT_EN,v_DSP_LUT_EN(1));
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
 	lcdc_cfg_done(lcdc_dev);
 
 	return ret;
 }
 
-static int rk3188_lcdc_dpi_open(struct rk_lcdc_device_driver *dev_drv,bool open)
+static int rk3188_lcdc_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
 {
 	struct rk3188_lcdc_device *lcdc_dev =
-			container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DIRECT_PATCH_EN,v_DIRECT_PATCH_EN(open));
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATCH_EN,
+		     v_DIRECT_PATCH_EN(open));
 	lcdc_cfg_done(lcdc_dev);
 	return 0;
 }
 
-static int rk3188_lcdc_dpi_layer_sel(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+static int rk3188_lcdc_dpi_layer_sel(struct rk_lcdc_driver *dev_drv,
+				     int layer_id)
 {
 	struct rk3188_lcdc_device *lcdc_dev =
-			container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	lcdc_msk_reg(lcdc_dev,SYS_CTRL,m_DIRECT_PATH_LAY_SEL,v_DIRECT_PATH_LAY_SEL(layer_id));
+	    container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_LAY_SEL,
+		     v_DIRECT_PATH_LAY_SEL(layer_id));
 	lcdc_cfg_done(lcdc_dev);
 	return 0;
 
 }
-static int rk3188_lcdc_dpi_status(struct rk_lcdc_device_driver *dev_drv)
+
+static int rk3188_lcdc_dpi_status(struct rk_lcdc_driver *dev_drv)
 {
 	struct rk3188_lcdc_device *lcdc_dev =
-			container_of(dev_drv,struct rk3188_lcdc_device,driver);
-	int ovl = lcdc_read_bit(lcdc_dev,SYS_CTRL,m_DIRECT_PATCH_EN);
+		container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	int ovl = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_DIRECT_PATCH_EN);
 	return ovl;
 }
 
-int rk3188_lcdc_poll_vblank(struct rk_lcdc_device_driver * dev_drv)
+int rk3188_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
 {
-	struct rk3188_lcdc_device *lcdc_dev = 
-				container_of(dev_drv,struct rk3188_lcdc_device,driver);    
-        u32 int_reg ;
+	struct rk3188_lcdc_device *lcdc_dev =
+			container_of(dev_drv, struct rk3188_lcdc_device, driver);
+	u32 int_reg;
 	int ret;
-	//spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		int_reg = lcdc_readl(lcdc_dev,INT_STATUS);
-	        if(int_reg & m_LF_INT_STA)
-	        {
-	              lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,v_LF_INT_CLEAR(1));              
-	              ret =  RK_LF_STATUS_FC;
-	        }
-	        else
-	             ret = RK_LF_STATUS_FR;
-	}
-	else
-	{
+
+	if (lcdc_dev->clk_on) {
+		int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
+		if (int_reg & m_LF_INT_STA) {
+			lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
+				     v_LF_INT_CLEAR(1));
+			ret = RK_LF_STATUS_FC;
+		} else
+			ret = RK_LF_STATUS_FR;
+	} else {
 		ret = RK_LF_STATUS_NC;
-	}	
-	//spin_unlock(&lcdc_dev->reg_lock);
+	}
 
 	return ret;
 }
 
 static struct layer_par lcdc_layer[] = {
 	[0] = {
-		.name  		= "win0",
-		.id		= 0,
-		.support_3d	= true,
-	},
+	       .name = "win0",
+	       .id = 0,
+	       .support_3d = true,
+	       },
 	[1] = {
-		.name  		= "win1",
-		.id		= 1,
-		.support_3d	= false,
-	},
+	       .name = "win1",
+	       .id = 1,
+	       .support_3d = false,
+	       },
 };
 
-static struct rk_lcdc_device_driver lcdc_driver = {
-	.name			= "lcdc",
-	.def_layer_par		= lcdc_layer,
-	.num_layer		= ARRAY_SIZE(lcdc_layer),
-	.open			= rk3188_lcdc_open,
-	.init_lcdc		= rk3188_lcdc_init,
-	.load_screen		= rk3188_load_screen,
-	.set_par       		= rk3188_lcdc_set_par,
-	.pan_display            = rk3188_lcdc_pan_display,
-	.lcdc_reg_update	= rk3188_lcdc_reg_update,
-	.blank         		= rk3188_lcdc_blank,
-	.ioctl			= rk3188_lcdc_ioctl,
-	.suspend		= rk3188_lcdc_early_suspend,
-	.resume			= rk3188_lcdc_early_resume,
-	.get_layer_state	= rk3188_lcdc_get_layer_state,
-	.ovl_mgr		= rk3188_lcdc_ovl_mgr,
-	.get_disp_info		= rk3188_lcdc_get_disp_info,
-	.fps_mgr		= rk3188_lcdc_fps_mgr,
-	.fb_get_layer           = rk3188_fb_get_layer,
-	.fb_layer_remap         = rk3188_fb_layer_remap,
-	.set_dsp_lut            = rk3188_set_dsp_lut,
-	.poll_vblank		= rk3188_lcdc_poll_vblank,
-	.dpi_open               = rk3188_lcdc_dpi_open,
-	.dpi_layer_sel          = rk3188_lcdc_dpi_layer_sel,
-	.dpi_status          	= rk3188_lcdc_dpi_status,
+static struct rk_lcdc_drv_ops lcdc_drv_ops = {
+	.open = rk3188_lcdc_open,
+	.init_lcdc = rk3188_lcdc_init,
+	.load_screen = rk3188_load_screen,
+	.set_par = rk3188_lcdc_set_par,
+	.pan_display = rk3188_lcdc_pan_display,
+	.lcdc_reg_update = rk3188_lcdc_reg_update,
+	.blank = rk3188_lcdc_blank,
+	.ioctl = rk3188_lcdc_ioctl,
+	.suspend = rk3188_lcdc_early_suspend,
+	.resume = rk3188_lcdc_early_resume,
+	.get_layer_state = rk3188_lcdc_get_layer_state,
+	.ovl_mgr = rk3188_lcdc_ovl_mgr,
+	.get_disp_info = rk3188_lcdc_get_disp_info,
+	.fps_mgr = rk3188_lcdc_fps_mgr,
+	.fb_get_layer = rk3188_fb_get_layer,
+	.fb_layer_remap = rk3188_fb_layer_remap,
+	.set_dsp_lut = rk3188_set_dsp_lut,
+	.poll_vblank = rk3188_lcdc_poll_vblank,
+	.dpi_open = rk3188_lcdc_dpi_open,
+	.dpi_layer_sel = rk3188_lcdc_dpi_layer_sel,
+	.dpi_status = rk3188_lcdc_dpi_status,
 };
 
 static irqreturn_t rk3188_lcdc_isr(int irq, void *dev_id)
 {
-	struct rk3188_lcdc_device *lcdc_dev = 
-				(struct rk3188_lcdc_device *)dev_id;
+	struct rk3188_lcdc_device *lcdc_dev = (struct rk3188_lcdc_device *)dev_id;
 	ktime_t timestamp = ktime_get();
-	u32 int_reg = lcdc_readl(lcdc_dev,INT_STATUS);
-                
-	if(int_reg & m_FS_INT_STA)
-	{
+	u32 int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
+
+	if (int_reg & m_FS_INT_STA) {
 		timestamp = ktime_get();
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,v_FS_INT_CLEAR(1));
-		if(lcdc_dev->driver.wait_fs)  //three buffer ,no need to wait for sync
-		{
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR, v_FS_INT_CLEAR(1));
+		if (lcdc_dev->driver.wait_fs) {
 			spin_lock(&(lcdc_dev->driver.cpl_lock));
 			complete(&(lcdc_dev->driver.frame_done));
 			spin_unlock(&(lcdc_dev->driver.cpl_lock));
 		}
 		lcdc_dev->driver.vsync_info.timestamp = timestamp;
 		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-		
-	}
-	else if(int_reg & m_LF_INT_STA)
-	{
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,v_LF_INT_CLEAR(1));
+
+	} else if (int_reg & m_LF_INT_STA) {
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR, v_LF_INT_CLEAR(1));
 	}
 	return IRQ_HANDLED;
 }
 
-
 #if defined(CONFIG_PM)
-static int rk3188_lcdc_suspend(struct platform_device *pdev,
-					pm_message_t state)
+static int rk3188_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	return 0;
 }
@@ -1567,165 +1552,82 @@ static int rk3188_lcdc_resume(struct platform_device *pdev)
 #define rk3188_lcdc_suspend NULL
 #define rk3188_lcdc_resume  NULL
 #endif
-static int __devinit rk3188_lcdc_probe(struct platform_device *pdev)
+
+static int rk3188_lcdc_probe(struct platform_device *pdev)
 {
 	struct rk3188_lcdc_device *lcdc_dev = NULL;
+	struct rk_lcdc_driver *dev_drv;
 	struct device *dev = &pdev->dev;
-	rk_screen *screen;
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-	rk_screen *screen1;
-#endif
-	struct rk29fb_info *screen_ctr_info;
-	struct resource *res = NULL;
-	struct resource *mem = NULL;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	int prop;
 	int ret = 0;
-	
-	lcdc_dev = devm_kzalloc(dev,sizeof(struct rk3188_lcdc_device), GFP_KERNEL);
-	if(!lcdc_dev)
-	{
-		dev_err(&pdev->dev, ">>rk3188 lcdc device kmalloc fail!");
+
+	/*if the primary lcdc has not registered ,the extend lcdc register later*/
+	of_property_read_u32(np, "rockchip,prop", &prop);
+	if (prop == EXTEND) { 
+		if (!is_prmry_rk_lcdc_registered())
+			return -EPROBE_DEFER;
+	}
+	lcdc_dev = devm_kzalloc(dev, sizeof(struct rk3188_lcdc_device), GFP_KERNEL);
+	if (!lcdc_dev) {
+		dev_err(&pdev->dev, "rk3188 lcdc device kmalloc fail!");
 		return -ENOMEM;
 	}
 	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->id = pdev->id;
-	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
-	screen =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
-	if(!screen_ctr_info)
-	{
-		dev_err(dev, "no platform data specified for screen control info!\n");
-		ret = -EINVAL;
-		goto err0;
-	}
-	if(!screen)
-	{
-		dev_err(&pdev->dev, "rk screen kmalloc fail!");
-		ret = -ENOMEM;
-		goto err0;
-	}
-	else
-	{
-		lcdc_dev->screen = screen;
-	}
-	screen->lcdc_id = lcdc_dev->id;
-	screen->screen_id = 0;
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&&  (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
-	screen1 =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
-	if(!screen1)
-	{
-		dev_err(&pdev->dev, ">>rk3066b lcdc screen1 kmalloc fail!");
-        	ret =  -ENOMEM;
-		goto err0;
-	}
-	screen1->lcdc_id = 1;
-	screen1->screen_id = 1;
-	printk("use lcdc%d and jetta implemention dual display!\n",lcdc_dev->id);
-	
-#endif
 	
-	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
-	if (res == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to get register resource for lcdc%d \n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-	
-    	lcdc_dev->reg_phy_base = res->start;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	lcdc_dev->reg_phy_base = res->start;
 	lcdc_dev->len = resource_size(res);
-    	mem = request_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len, pdev->name);
-    	if (!mem)
-    	{
-        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-	lcdc_dev->regs = ioremap(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	if (!lcdc_dev->regs)
-	{
-		dev_err(&pdev->dev, "cannot map register for lcdc%d\n",lcdc_dev->id);
-		ret = -ENXIO;
-		goto err2;
-	}
-	
-	lcdc_dev->regsbak = kzalloc(lcdc_dev->len,GFP_KERNEL);
-	if(!lcdc_dev->regsbak)
-	{
-		dev_err(&pdev->dev, "failed to map memory for reg backup!\n");
-		ret = -ENOMEM;
-		goto err3;
-	}
+	lcdc_dev->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lcdc_dev->regs))
+		return PTR_ERR(lcdc_dev->regs);
+
+	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
+	if (IS_ERR(lcdc_dev->regsbak))
+		return PTR_ERR(lcdc_dev->regsbak);
 	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + DSP_LUT_ADDR);
-	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->regs);
-	lcdc_dev->driver.dev = dev;
-	lcdc_dev->driver.screen0 = screen;
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
-	lcdc_dev->driver.screen1 = screen1;
-#endif
-	lcdc_dev->driver.cur_screen = screen;
-	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
-	
+	dev_info(dev, "lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",
+		 lcdc_dev->id, lcdc_dev->reg_phy_base, lcdc_dev->regs);
+
+	lcdc_dev->dev = dev;
+	lcdc_dev->id = rk3188_lcdc_get_id(lcdc_dev->reg_phy_base);
+	dev_drv = &lcdc_dev->driver;
+	dev_drv->dev = dev;
+	dev_drv->prop = prop;
+	dev_drv->id = lcdc_dev->id;
+	dev_drv->ops = &lcdc_drv_ops;
+	dev_drv->num_layer = ARRAY_SIZE(lcdc_layer);
 	spin_lock_init(&lcdc_dev->reg_lock);
-	
+
 	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if(lcdc_dev->irq < 0)
-	{
-		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",lcdc_dev->id);
-		goto err3;
-	}
-	ret = devm_request_irq(dev,lcdc_dev->irq, rk3188_lcdc_isr, IRQF_DISABLED,dev_name(dev),lcdc_dev);
-	if (ret)
-	{
-	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
-	       ret = -EBUSY;
-	       goto err3;
+	if (lcdc_dev->irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n", lcdc_dev->id);
+		return -ENXIO;
 	}
 
-	if(screen_ctr_info->set_screen_info)
-	{
-		screen_ctr_info->set_screen_info(screen,screen_ctr_info->lcd_info);
-		if(SCREEN_NULL==screen->type)
-		{
-			printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
-			ret = -ENODEV;
-		}
-		if(screen_ctr_info->io_init)
-			screen_ctr_info->io_init(NULL);
-	}
-	else
-	{
-		printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
-		ret = -ENODEV;
-		goto err3;
-	}
-	
-	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
-	if(ret < 0)
-	{
-		dev_err(dev,"register fb for lcdc%d failed!\n",lcdc_dev->id);
-		goto err4;
+	ret = devm_request_irq(dev, lcdc_dev->irq, rk3188_lcdc_isr,
+			       IRQF_DISABLED, dev_name(dev), lcdc_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
+			lcdc_dev->irq, ret);
+		return ret;
 	}
-	
-	printk("rk3188 lcdc%d probe ok!\n",lcdc_dev->id);
-	
-	return 0;
 
-err4:
-err3:
-	iounmap(lcdc_dev->regs);
-err2:
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-err1:
-	kfree(screen);
-err0:
-	platform_set_drvdata(pdev, NULL);
+	ret = rk_fb_register(dev_drv, lcdc_layer, lcdc_dev->id);
+	if (ret < 0) {
+		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
+		return ret;
+	}
+	dev_info(dev, "lcdc%d probe ok\n", lcdc_dev->id);
 
-	return ret;
+	return 0;
 }
 
-static int __devexit rk3188_lcdc_remove(struct platform_device *pdev)
+static int rk3188_lcdc_remove(struct platform_device *pdev)
 {
 	struct rk3188_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	rk3188_lcdc_deint(lcdc_dev);	
+	rk3188_lcdc_deint(lcdc_dev);
 	rk_fb_unregister(&(lcdc_dev->driver));
 
 	return 0;
@@ -1734,24 +1636,34 @@ static int __devexit rk3188_lcdc_remove(struct platform_device *pdev)
 static void rk3188_lcdc_shutdown(struct platform_device *pdev)
 {
 	struct rk3188_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	if(lcdc_dev->driver.cur_screen->standby) //standby the screen if necessary
+	if (lcdc_dev->driver.cur_screen->standby)	/*standby the screen if necessary */
 		lcdc_dev->driver.cur_screen->standby(1);
-	if(lcdc_dev->driver.screen_ctr_info->io_disable) //power off the screen if necessary
+	if (lcdc_dev->driver.screen_ctr_info->io_disable)	/*power off the screen if necessary */
 		lcdc_dev->driver.screen_ctr_info->io_disable();
 	rk3188_lcdc_deint(lcdc_dev);
-	//rk_fb_unregister(&(lcdc_dev->driver));	
+	/*rk_fb_unregister(&(lcdc_dev->driver));     */
 }
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk3188_lcdc_dt_ids[] = {
+	{.compatible = "rockchip,rk3188-lcdc",},
+	{}
+};
+#endif
+
 static struct platform_driver rk3188_lcdc_driver = {
-	.probe		= rk3188_lcdc_probe,
-	.remove		= __devexit_p(rk3188_lcdc_remove),
-	.driver		= {
-		.name 	= "rk30-lcdc",
-		.owner  = THIS_MODULE,
-	},
-	.suspend 	= rk3188_lcdc_suspend,
-	.resume  	= rk3188_lcdc_resume,
-	.shutdown 	= rk3188_lcdc_shutdown,
+	.probe = rk3188_lcdc_probe,
+	.remove = rk3188_lcdc_remove,
+	.driver = {
+		   .name = "rk3188-lcdc",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rk3188_lcdc_dt_ids),
+		   },
+	.suspend = rk3188_lcdc_suspend,
+	.resume = rk3188_lcdc_resume,
+	.shutdown = rk3188_lcdc_shutdown,
 };
+
 static int __init rk3188_lcdc_module_init(void)
 {
 	return platform_driver_register(&rk3188_lcdc_driver);
@@ -1761,5 +1673,6 @@ static void __exit rk3188_lcdc_module_exit(void)
 {
 	platform_driver_unregister(&rk3188_lcdc_driver);
 }
+
 fs_initcall(rk3188_lcdc_module_init);
 module_exit(rk3188_lcdc_module_exit);
diff --git a/drivers/video/rockchip/lcdc/rk3188_lcdc.h b/drivers/video/rockchip/lcdc/rk3188_lcdc.h
index c26d8cf96b4c..381408f9babb 100755
--- a/drivers/video/rockchip/lcdc/rk3188_lcdc.h
+++ b/drivers/video/rockchip/lcdc/rk3188_lcdc.h
@@ -321,11 +321,12 @@
 
 struct rk3188_lcdc_device{
 	int id;
-	struct rk_lcdc_device_driver driver;
+	struct rk_lcdc_driver driver;
+	struct device *dev;
 	rk_screen *screen;
 
 	void __iomem *regs;
-	void *regsbak;		//back up reg
+	void *regsbak;			//back up reg
 	u32 reg_phy_base;       	// physical basic address of lcdc register
 	u32 len;               		// physical map length of lcdc register
 	spinlock_t  reg_lock;		//one time only one process allowed to config the register
diff --git a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.c
index 3f3696d6c7d1..d9f537f09222 100755
--- a/drivers/video/rockchip/rk_fb.c
+++ b/drivers/video/rockchip/rk_fb.c
@@ -1,9 +1,8 @@
 /*
  * drivers/video/rockchip/rk_fb.c
  *
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *Author:yzq<yzq@rock-chips.com>
- 	yxj<yxj@rock-chips.com>
+ * Copyright (C) ROCKCHIP, Inc.
+ *Author:yxj<yxj@rock-chips.com>
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
  * may be copied, distributed, and modified under those terms.
@@ -25,80 +24,225 @@
 #include <linux/kthread.h>
 #include <linux/fb.h>
 #include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/earlysuspend.h>
 #include <asm/div64.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/rk_fb.h>
-#include <plat/ipp.h>
-#include "hdmi/rk_hdmi.h"
 #include <linux/linux_logo.h>
+#include <linux/dma-mapping.h>
+#include "hdmi/rk_hdmi.h"
 
-#include <mach/clock.h>
-#include <linux/clk.h>
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <video/of_display_timing.h>
+#include <video/display_timing.h>
+#include <dt-bindings/rkfb/rk_fb.h>
+#endif
 
-void rk29_backlight_set(bool on);
-bool rk29_get_backlight_status(void);
 
-static int hdmi_switch_complete = 0;
 
+static int hdmi_switch_complete;
+static struct platform_device *fb_pdev;
 
-#if defined(CONFIG_FB_MIRRORING)
 
-int (*video_data_to_mirroring)(struct fb_info *info,u32 yuv_phy[2]) = NULL;
+#if defined(CONFIG_FB_MIRRORING)
+int (*video_data_to_mirroring)(struct fb_info *info, u32 yuv_phy[2]);
 EXPORT_SYMBOL(video_data_to_mirroring);
-
 #endif
-static struct platform_device *g_fb_pdev;
 
-static struct rk_fb_rgb def_rgb_16 = {
-     red:    { offset: 11, length: 5, },
-     green:  { offset: 5,  length: 6, },
-     blue:   { offset: 0,  length: 5, },
-     transp: { offset: 0,  length: 0, },
-};
 
 
-char * get_format_string(enum data_format format,char *fmt)
+
+/* rk display power control parse from dts
+ *
+*/
+int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)
+{
+	struct device_node *root  = of_find_node_by_name(dev_drv->dev->of_node,
+				"power_ctr");
+	struct device_node *child;
+	struct rk_disp_pwr_ctr_list *pwr_ctr;
+	struct list_head *pos;
+	enum of_gpio_flags flags;
+	u32 val = 0;
+	u32 debug = 0;
+	int ret;
+
+	INIT_LIST_HEAD(&dev_drv->pwrlist_head);
+	if (!root) {
+		dev_err(dev_drv->dev, "can't find power_ctr node for lcdc:%d\n",dev_drv->id);
+		return -ENODEV;
+	}
+
+	for_each_child_of_node(root, child) {
+		pwr_ctr = kmalloc(sizeof(struct rk_disp_pwr_ctr_list), GFP_KERNEL);
+		strcpy(pwr_ctr->pwr_ctr.name, child->name);
+		if (!of_property_read_u32(child, "rockchip,power_type", &val)) {
+			if (val == GPIO) {
+				pwr_ctr->pwr_ctr.type = GPIO;
+				pwr_ctr->pwr_ctr.gpio = of_get_gpio_flags(child, 0, &flags);
+				if (!gpio_is_valid(pwr_ctr->pwr_ctr.gpio)) {
+					dev_err(dev_drv->dev, "%s ivalid gpio\n", child->name);
+					return -EINVAL;
+				} 
+				pwr_ctr->pwr_ctr.atv_val = flags & OF_GPIO_ACTIVE_LOW;
+				ret = gpio_request(pwr_ctr->pwr_ctr.gpio,child->name);
+				if (ret) {
+					dev_err(dev_drv->dev, "request %s gpio fail\n", 
+						child->name);
+				}
+				
+			} else {
+				pwr_ctr->pwr_ctr.type = REGULATOR;
+				
+			}
+		};
+		of_property_read_u32(child, "rockchip,delay", &val);
+		pwr_ctr->pwr_ctr.delay = val;
+		list_add_tail(&pwr_ctr->list, &dev_drv->pwrlist_head);
+	}
+
+	of_property_read_u32(root, "rockchip,debug", &debug);
+
+	if (debug) {
+		list_for_each(pos, &dev_drv->pwrlist_head) {
+			pwr_ctr = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
+			printk(KERN_INFO "pwr_ctr_name:%s\n"
+					 "pwr_type:%s\n"
+					 "gpio:%d\n"
+					 "atv_val:%d\n"
+					 "delay:%d\n\n",
+					 pwr_ctr->pwr_ctr.name,
+					 (pwr_ctr->pwr_ctr.type == GPIO) ? "gpio" : "regulator",
+					 pwr_ctr->pwr_ctr.gpio,
+					 pwr_ctr->pwr_ctr.atv_val,
+					 pwr_ctr->pwr_ctr.delay);
+		}
+	}
+	
+	return 0;
+	
+}
+
+int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv)
 {
-	if(!fmt)
+	struct list_head *pos;
+	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
+	struct pwr_ctr *pwr_ctr;
+	if (list_empty(&dev_drv->pwrlist_head)) 
+		return 0;
+	list_for_each(pos, &dev_drv->pwrlist_head) {
+		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
+		pwr_ctr = &pwr_ctr_list->pwr_ctr;
+		if (pwr_ctr->type == GPIO) {
+			gpio_direction_output(pwr_ctr->gpio,pwr_ctr->atv_val);
+			mdelay(pwr_ctr->delay);
+		}
+	}
+
+	return 0;
+}
+
+int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv)
+{
+	struct list_head *pos;
+	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
+	struct pwr_ctr *pwr_ctr;
+	if (list_empty(&dev_drv->pwrlist_head)) 
+		return 0;
+	list_for_each(pos, &dev_drv->pwrlist_head) {
+		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
+		pwr_ctr = &pwr_ctr_list->pwr_ctr;
+		if (pwr_ctr->type == GPIO) {
+			gpio_set_value(pwr_ctr->gpio,pwr_ctr->atv_val);
+		}
+	}
+
+	return 0;
+}
+
+
+int rk_disp_prase_timing_dt(struct rk_lcdc_driver *dev_drv)
+{
+	struct display_timings *disp_timing;
+	struct display_timing *dt;
+	rk_screen *screen = dev_drv->cur_screen;
+	disp_timing = of_get_display_timings(dev_drv->dev->of_node);
+	if (!disp_timing) {
+		dev_err(dev_drv->dev, "parse display timing err\n");
+		return -EINVAL;
+	}
+	dt = display_timings_get(disp_timing, 0);
+	
+	screen->pixclock = dt->pixelclock.typ;
+	screen->left_margin = dt->hback_porch.typ;
+	screen->right_margin = dt->hfront_porch.typ;
+	screen->x_res = dt->hactive.typ;
+	screen->hsync_len = dt->hsync_len.typ;
+	screen->upper_margin = dt->vback_porch.typ;
+	screen->lower_margin = dt->vfront_porch.typ;
+	screen->y_res = dt->vactive.typ;
+	screen->vsync_len = dt->vsync_len.typ;
+	printk(KERN_INFO "dclk:%d\n"
+			 "hactive:%d\n"
+			 "hback_porch:%d\n"
+			 "hfront_porch:%d\n"
+			 "hsync_len:%d\n"
+			 "vactive:%d\n"
+			 "vback_porch:%d\n"
+			 "vfront_porch:%d\n"
+			 "vsync_len:%d\n",
+			dt->pixelclock.typ,
+			dt->hactive.typ,
+			dt->hback_porch.typ,
+			dt->hfront_porch.typ,
+			dt->hsync_len.typ,
+			dt->vactive.typ,
+			dt->vback_porch.typ,
+			dt->vfront_porch.typ,
+			dt->vsync_len.typ);
+	return 0;
+		
+}
+char *get_format_string(enum data_format format, char *fmt)
+{
+	if (!fmt)
 		return NULL;
-	switch(format)
-	{
+	switch (format) {
 	case ARGB888:
-		strcpy(fmt,"ARGB888");
+		strcpy(fmt, "ARGB888");
 		break;
 	case RGB888:
-		strcpy(fmt,"RGB888");
+		strcpy(fmt, "RGB888");
 		break;
 	case RGB565:
-		strcpy(fmt,"RGB565");
+		strcpy(fmt, "RGB565");
 		break;
 	case YUV420:
-		strcpy(fmt,"YUV420");
+		strcpy(fmt, "YUV420");
 		break;
 	case YUV422:
-		strcpy(fmt,"YUV422");
+		strcpy(fmt, "YUV422");
 		break;
 	case YUV444:
-		strcpy(fmt,"YUV444");
+		strcpy(fmt, "YUV444");
 		break;
 	case XRGB888:
-		strcpy(fmt,"XRGB888");
+		strcpy(fmt, "XRGB888");
 		break;
 	case XBGR888:
-		strcpy(fmt,"XBGR888");
+		strcpy(fmt, "XBGR888");
 		break;
 	case ABGR888:
-		strcpy(fmt,"XBGR888");
+		strcpy(fmt, "XBGR888");
 		break;
 	default:
-		strcpy(fmt,"invalid");
+		strcpy(fmt, "invalid");
 		break;
 	}
 
 	return fmt;
-	
+
 }
 
 
@@ -107,34 +251,31 @@ char * get_format_string(enum data_format format,char *fmt)
 this is for hdmi
 name: lcdc device name ,lcdc0 , lcdc1
 ***********************************************************************/
-struct rk_lcdc_device_driver * rk_get_lcdc_drv(char *name)
+struct rk_lcdc_driver *rk_get_lcdc_drv(char *name)
 {
-	struct rk_fb_inf *inf =  platform_get_drvdata(g_fb_pdev);
+	struct rk_fb *inf =  platform_get_drvdata(fb_pdev);
 	int i = 0;
-	for( i = 0; i < inf->num_lcdc; i++)
-	{
-		if(!strcmp(inf->lcdc_dev_drv[i]->name,name))
+	for (i = 0; i < inf->num_lcdc; i++) {
+		if (!strcmp(inf->lcdc_dev_drv[i]->name, name))
 			break;
 	}
 	return inf->lcdc_dev_drv[i];
-	
+
 }
 
-static struct rk_lcdc_device_driver * rk_get_prmry_lcdc_drv(void)
+static struct rk_lcdc_driver *rk_get_prmry_lcdc_drv(void)
 {
-	struct rk_fb_inf *inf = NULL; 
-	struct rk_lcdc_device_driver *dev_drv = NULL;
+	struct rk_fb *inf = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
 	int i = 0;
 
-	if(likely(g_fb_pdev))
-		inf = platform_get_drvdata(g_fb_pdev);
+	if (likely(fb_pdev))
+		inf = platform_get_drvdata(fb_pdev);
 	else
 		return NULL;
-	
-	for(i = 0; i < inf->num_lcdc;i++)
-	{
-		if(inf->lcdc_dev_drv[i]->screen_ctr_info->prop ==  PRMRY)
-		{
+
+	for (i = 0; i < inf->num_lcdc; i++) {
+		if (inf->lcdc_dev_drv[i]->screen_ctr_info->prop ==  PRMRY) {
 			dev_drv = inf->lcdc_dev_drv[i];
 			break;
 		}
@@ -143,45 +284,40 @@ static struct rk_lcdc_device_driver * rk_get_prmry_lcdc_drv(void)
 	return dev_drv;
 }
 
-//get one frame time
+
 int rk_fb_get_prmry_screen_ft(void)
 {
-        struct rk_lcdc_device_driver *dev_drv = rk_get_prmry_lcdc_drv();
-        
-        uint32_t pix_count,ft_us,dclk_mhz;
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+	uint32_t htotal, vtotal, pix_total, ft_us, dclk_mhz;
 
-        if (0 == dev_drv->id)
-                dclk_mhz = clk_get_rate(clk_get(NULL, "dclk_lcdc0"))/(1000*1000);
-        else 
-                dclk_mhz = clk_get_rate(clk_get(NULL, "dclk_lcdc1"))/(1000*1000);
+	if (unlikely(!dev_drv))
+		return 0;
 
-        pix_count = (dev_drv->cur_screen->upper_margin + dev_drv->cur_screen->lower_margin + dev_drv->cur_screen->y_res +dev_drv->cur_screen->vsync_len)*
-        (dev_drv->cur_screen->left_margin + dev_drv->cur_screen->right_margin + dev_drv->cur_screen->x_res + dev_drv->cur_screen->hsync_len);       // one frame time ,(pico seconds)
-        
-        ft_us = pix_count / dclk_mhz;
+	dclk_mhz = dev_drv->pixclock/(1000*1000);
 
-        if(likely(dev_drv))
-            return ft_us;
-        else
-            return 0;
+	htotal = (dev_drv->cur_screen->upper_margin + dev_drv->cur_screen->lower_margin +
+		dev_drv->cur_screen->y_res + dev_drv->cur_screen->vsync_len);
+	vtotal = (dev_drv->cur_screen->left_margin + dev_drv->cur_screen->right_margin +
+		dev_drv->cur_screen->x_res + dev_drv->cur_screen->hsync_len);
+	pix_total = htotal*vtotal;
+	ft_us = pix_total / dclk_mhz;
 
+	return ft_us;
 }
 
-static struct rk_lcdc_device_driver * rk_get_extend_lcdc_drv(void)
+static struct rk_lcdc_driver  *rk_get_extend_lcdc_drv(void)
 {
-	struct rk_fb_inf *inf = NULL; 
-	struct rk_lcdc_device_driver *dev_drv = NULL;
+	struct rk_fb *inf = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
 	int i = 0;
-	
-	if(likely(g_fb_pdev))
-		inf = platform_get_drvdata(g_fb_pdev);
+
+	if (likely(fb_pdev))
+		inf = platform_get_drvdata(fb_pdev);
 	else
 		return NULL;
-	
-	for(i = 0; i < inf->num_lcdc; i++)
-	{
-		if(inf->lcdc_dev_drv[i]->screen_ctr_info->prop == EXTEND)
-		{
+
+	for (i = 0; i < inf->num_lcdc; i++) {
+		if (inf->lcdc_dev_drv[i]->screen_ctr_info->prop == EXTEND) {
 			dev_drv = inf->lcdc_dev_drv[i];
 			break;
 		}
@@ -192,94 +328,80 @@ static struct rk_lcdc_device_driver * rk_get_extend_lcdc_drv(void)
 
 rk_screen *rk_fb_get_prmry_screen(void)
 {
-	struct rk_lcdc_device_driver *dev_drv = rk_get_prmry_lcdc_drv();
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
 	return dev_drv->screen0;
-	
+
 }
 
 u32 rk_fb_get_prmry_screen_pixclock(void)
 {
-	struct rk_lcdc_device_driver *dev_drv = rk_get_prmry_lcdc_drv();
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
 	return dev_drv->pixclock;
 }
 
 int rk_fb_poll_prmry_screen_vblank(void)
 {
-	struct rk_lcdc_device_driver *dev_drv = rk_get_prmry_lcdc_drv();
-	if(likely(dev_drv))
-	{
-		if(dev_drv->poll_vblank)
-			return dev_drv->poll_vblank(dev_drv);
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+	if (likely(dev_drv)) {
+		if (dev_drv->ops->poll_vblank)
+			return dev_drv->ops->poll_vblank(dev_drv);
 		else
-			return RK_LF_STATUS_NC;	
-	}
-	else
+			return RK_LF_STATUS_NC;
+	} else
 		return RK_LF_STATUS_NC;
 }
 
 bool rk_fb_poll_wait_frame_complete(void)
 {
 	uint32_t timeout = RK_LF_MAX_TIMEOUT;
-	if(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_NC)
+	if (rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_NC)
 		return false;
 
-	while( !(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_FR)  &&  --timeout);
-	while( !(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_FC)  &&  --timeout);
+	while (!(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_FR)  &&  --timeout);
+	while (!(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_FC)  &&  --timeout);
 
 	return true;
 }
-static int rk_fb_open(struct fb_info *info,int user)
+static int rk_fb_open(struct fb_info *info, int user)
 {
-    struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )info->par;
-    int layer_id;
-  
-    layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
-    if(dev_drv->layer_par[layer_id]->state)
-    {
-    	return 0;    // if this layer aready opened ,no need to reopen
-    }
-    else
-    {
-    	dev_drv->open(dev_drv,layer_id,1);
-    }
-    
-    return 0;
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)info->par;
+	int layer_id;
+
+	layer_id = dev_drv->ops->fb_get_layer(dev_drv, info->fix.id);
+	if (dev_drv->layer_par[layer_id]->state)
+		return 0;    /* if this layer aready opened ,no need to reopen*/
+	else
+		dev_drv->ops->open(dev_drv, layer_id, 1);
+	return 0;
 }
 
-static int  get_extend_fb_id(char *id )
+static int  get_extend_fb_id(struct fb_info *info)
 {
 	int fb_id = 0;
-	if(!strcmp(id,"fb0"))
-	{
+	char *id = info->fix.id;
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)info->par;
+	if (!strcmp(id, "fb0"))
 		fb_id = 0;
-	}
-	else if(!strcmp(id,"fb1"))
-	{
+	else if (!strcmp(id, "fb1"))
 		fb_id = 1;
-	}
-#if defined(CONFIG_LCDC_RK30)	//only rk30 lcdc has three windows layer now
-	else if(!strcmp(id,"fb2"))
-        {
-               fb_id = 2;
-        }
-#endif
+	else if (!strcmp(id, "fb2") && (dev_drv->num_layer > 2))
+		fb_id = 2;
 	return fb_id;
 }
 
-static int rk_fb_close(struct fb_info *info,int user)
+static int rk_fb_close(struct fb_info *info, int user)
 {
-	struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )info->par;
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)info->par;
 	struct layer_par *par = NULL;
-	int layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
-	if(layer_id >= 0)
-	{
+	int layer_id = dev_drv->ops->fb_get_layer(dev_drv, info->fix.id);
+	if (layer_id >= 0) {
 		par = dev_drv->layer_par[layer_id];
 		info->fix.smem_start = par->reserved;
 
 		info->var.xres = dev_drv->screen0->x_res;
 		info->var.yres = dev_drv->screen0->y_res;
 		info->var.grayscale |= (info->var.xres<<8) + (info->var.yres<<20);
-#ifdef  CONFIG_LOGO_LINUX_BMP
+#if defined(CONFIG_LOGO_LINUX_BMP)
 		info->var.bits_per_pixel = 32;
 #else
 		info->var.bits_per_pixel = 16;
@@ -296,33 +418,33 @@ static int rk_fb_close(struct fb_info *info,int user)
 		info->var.lower_margin = dev_drv->screen0->lower_margin;
 		info->var.vsync_len = dev_drv->screen0->vsync_len;
 		info->var.hsync_len = dev_drv->screen0->hsync_len;
-    }
-	
-    	return 0;
+	}
+
+	return 0;
 }
 
 
+#if defined(CONFIG_RK29_IPP)
 static int get_ipp_format(int fmt)
 {
 	int ipp_fmt = IPP_XRGB_8888;
-	switch (fmt)
-	{
-	case HAL_PIXEL_FORMAT_RGBX_8888: 
-	case HAL_PIXEL_FORMAT_RGBA_8888 :     
-	case HAL_PIXEL_FORMAT_BGRA_8888 :     
-	case HAL_PIXEL_FORMAT_RGB_888 :
+	switch (fmt) {
+	case HAL_PIXEL_FORMAT_RGBX_8888:
+	case HAL_PIXEL_FORMAT_RGBA_8888:
+	case HAL_PIXEL_FORMAT_BGRA_8888:
+	case HAL_PIXEL_FORMAT_RGB_888:
 		ipp_fmt = IPP_XRGB_8888;
 		break;
-	case HAL_PIXEL_FORMAT_RGB_565:  	//RGB565
+	case HAL_PIXEL_FORMAT_RGB_565:
 		ipp_fmt = IPP_RGB_565;
-	    	break;
-	case HAL_PIXEL_FORMAT_YCbCr_422_SP : 	// yuv422
+		break;
+	case HAL_PIXEL_FORMAT_YCbCr_422_SP:
 		ipp_fmt = IPP_Y_CBCR_H2V1;
-	    	break;
-	case HAL_PIXEL_FORMAT_YCrCb_NV12: 	// YUV420---uvuvuv
+		break;
+	case HAL_PIXEL_FORMAT_YCrCb_NV12:
 		ipp_fmt = IPP_Y_CBCR_H2V2;
-	    	break;
-	case HAL_PIXEL_FORMAT_YCrCb_444 : // yuv444
+		break;
+	case HAL_PIXEL_FORMAT_YCrCb_444:
 		ipp_fmt = IPP_Y_CBCR_H1V1;
 		break;
 	default:
@@ -333,99 +455,76 @@ static int get_ipp_format(int fmt)
 	return ipp_fmt;
 }
 
-static void ipp_par_check(int* dst_w, int* dst_h, int* dst_vir_w, 
+static void ipp_par_check(int *dst_w, int *dst_h, int *dst_vir_w,
 				int rotation, int fmt)
 {
 	int align16 = 2;
 	int align64 = 8;
-	
-	
 
-	if(fmt == IPP_XRGB_8888) //XRGB,32bits per pixel
-	{
+
+	if (fmt == IPP_XRGB_8888) {
 		align16 = 1;
 		align64 = 2;
-	}
-
-	if(fmt == IPP_RGB_565) //RGB565 ,16bits per pixel
-	{
+	} else if (fmt == IPP_RGB_565) {
 		align16 = 1;
 		align64 = 4;
-	}
-	else  //yuv
-	{
+	} else {
 		align16 = 2;
 		align64 = 8;
 	}
-	align16 -= 1;  //for YUV, 1
-	align64 -= 1;  //for YUV, 7
-	
-	if(rotation == IPP_ROT_0)//no rotation
-	{
-		if(fmt > IPP_RGB_565)//only YUV need to align
-		{
-			if((*dst_w & 1) != 0)
-			{
+	align16 -= 1;  /*for YUV, 1*/
+	align64 -= 1;  /*for YUV, 7*/
+
+	if (rotation == IPP_ROT_0) {
+		if (fmt > IPP_RGB_565) {
+			if ((*dst_w & 1) != 0)
 				*dst_w = *dst_w+1;
-			}
-			if((*dst_h & 1) != 0)
-			{
+			if ((*dst_h & 1) != 0)
 				*dst_h = *dst_h+1;
-			}
-			if(*dst_vir_w < *dst_w)
-			{
+			if (*dst_vir_w < *dst_w)
 				*dst_vir_w = *dst_w;
-			}
 		}
-	}
-	else//rotaion
-	{
+	} else {
 
-		if((*dst_w & align64) != 0)
-		{
+		if ((*dst_w & align64) != 0)
 			*dst_w = (*dst_w+align64)&(~align64);
-		}
-		if((fmt > IPP_RGB_565) && ((*dst_h & 1) == 1)) //for yuv ,must 2 pix align
-		{
+		if ((fmt > IPP_RGB_565) && ((*dst_h & 1) == 1))
 			*dst_h = *dst_h+1;
-		}
-		if(*dst_vir_w < *dst_w)
-		{
+		if (*dst_vir_w < *dst_w)
 			*dst_vir_w = *dst_w;
-		}
 	}
 
 }
 
-static void fb_copy_by_ipp(struct fb_info *dst_info, struct fb_info *src_info,int offset)
+static void fb_copy_by_ipp(struct fb_info *dst_info,
+		struct fb_info *src_info, int offset)
 {
 	struct rk29_ipp_req ipp_req;
- 	uint32_t  rotation = 0;
-	int dst_w,dst_h,dst_vir_w;
+	uint32_t  rotation = 0;
+	int dst_w, dst_h, dst_vir_w;
 	int ipp_fmt;
 	u8 data_format = (dst_info->var.nonstd)&0xff;
-	
+
 	memset(&ipp_req, 0, sizeof(struct rk29_ipp_req));
 #if defined(CONFIG_FB_ROTATE)
 	int orientation = 270 - CONFIG_ROTATE_ORIENTATION;
-	switch(orientation)
-	{
-		case 0:
-			rotation = IPP_ROT_0;
-			break;
-		case 90:
-			rotation = IPP_ROT_90;
-			break;
-		case 180:
-			rotation = IPP_ROT_180;
-			break;
-		case 270:
-			rotation = IPP_ROT_270;
-			break;
-		default:
-			rotation = IPP_ROT_270;
-			break;
-			
+	switch (orientation) {
+	case 0:
+		rotation = IPP_ROT_0;
+		break;
+	case 90:
+		rotation = IPP_ROT_90;
+		break;
+	case 180:
+		rotation = IPP_ROT_180;
+		break;
+	case 270:
+		rotation = IPP_ROT_270;
+		break;
+	default:
+		rotation = IPP_ROT_270;
+		break;
+
 	}
 #endif
 
@@ -433,275 +532,258 @@ static void fb_copy_by_ipp(struct fb_info *dst_info, struct fb_info *src_info,in
 	dst_h = dst_info->var.yres;
 	dst_vir_w = dst_info->var.xres_virtual;
 	ipp_fmt = get_ipp_format(data_format);
-	ipp_par_check(&dst_w,&dst_h,&dst_vir_w,rotation,ipp_fmt);
+	ipp_par_check(&dst_w, &dst_h, &dst_vir_w, rotation, ipp_fmt);
 	ipp_req.src0.YrgbMst = src_info->fix.smem_start + offset;
 	ipp_req.src0.w = src_info->var.xres;
 	ipp_req.src0.h = src_info->var.yres;
 	ipp_req.src_vir_w = src_info->var.xres_virtual;
 	ipp_req.src0.fmt = ipp_fmt;
-	
+
 	ipp_req.dst0.YrgbMst = dst_info->fix.smem_start + offset;
 	ipp_req.dst0.w = dst_w;
 	ipp_req.dst0.h = dst_h;
 	ipp_req.dst_vir_w = dst_vir_w;
 	ipp_req.dst0.fmt = ipp_fmt;
 
-	
+
 	ipp_req.timeout = 100;
 	ipp_req.flag = rotation;
 	ipp_blit_sync(&ipp_req);
-	
-}
 
-#if 0
-
-static void hdmi_post_work(struct work_struct *work)
-{	
-	struct rk_fb_inf *inf = container_of(to_delayed_work(work), struct rk_fb_inf, delay_work);
-	struct fb_info * info2 = inf->fb[2];    
-	struct fb_info * info = inf->fb[0];     
-	struct rk_lcdc_device_driver * dev_drv1  = (struct rk_lcdc_device_driver * )info2->par;
-	struct rk_lcdc_device_driver * dev_drv  = (struct rk_lcdc_device_driver * )info->par;
-	struct layer_par *par = dev_drv->layer_par[1];
-	struct layer_par *par2 = dev_drv1->layer_par[1];  	
-	struct fb_var_screeninfo *var = &info->var;   
-	u32 xvir = var->xres_virtual;	
-	dev_drv1->xoffset = var->xoffset;             // offset from virtual to visible 
-	dev_drv1->yoffset += var->yres; 
-	if(dev_drv1->yoffset >= 3*var->yres)
-		dev_drv1->yoffset = 0;++	
-		rk_bufferoffset_tran(dev_drv1->xoffset, dev_drv1->yoffset, xvir , par2);
-	fb_copy_by_ipp(info2,info,par->y_offset,par2->y_offset);
-	dev_drv1->pan_display(dev_drv1,1);
-	complete(&(dev_drv1->ipp_done));
 }
+
 #endif
 
+
+static int rk_fb_rotate(struct fb_info *dst_info,
+				struct fb_info *src_info, int offset)
+{
+	#if defined(CONFIG_RK29_IPP)
+		fb_copy_by_ipp(dst_info, src_info, offset);
+	#else
+		return -1;
+	#endif
+		return 0;
+}
 static int rk_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
 {
-	struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )info->par;
-    	struct layer_par *par = NULL;
-#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
-	struct rk_fb_inf *inf = dev_get_drvdata(info->device);
-	struct layer_par *par2 = NULL;
-	struct fb_info * info2 = NULL; 
-	int layer_id2 = 0;
-	int extend_fb_id = 0;
-	struct rk_lcdc_device_driver * dev_drv1  = NULL;
-#endif
-    	int layer_id = 0;
-	u32 xoffset = var->xoffset;		// offset from virtual to visible 
-	u32 yoffset = var->yoffset;				
+	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
+	struct rk_lcdc_driver *dev_drv  = (struct rk_lcdc_driver *)info->par;
+	int fb_id = 0;
+	struct fb_info *extend_info = NULL;
+	struct rk_lcdc_driver *extend_dev_drv = NULL;
+	int extend_layer_id = 0;
+	struct layer_par *extend_par = NULL;
+	struct layer_par *par = NULL;
+	
+
+	int layer_id = 0;
+	u32 xoffset = var->xoffset;
+	u32 yoffset = var->yoffset;
 	u32 xvir = var->xres_virtual;
 	u8 data_format = var->nonstd&0xff;
-	
-	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
-	if(layer_id < 0)
-	{
+
+	layer_id = dev_drv->ops->fb_get_layer(dev_drv, info->fix.id);
+	if (layer_id < 0)
 		return  -ENODEV;
-	}
 	else
-	{
-		 par = dev_drv->layer_par[layer_id];
+		par = dev_drv->layer_par[layer_id];
+	
+	if (rk_fb->disp_mode == DUAL) {
+		fb_id = get_extend_fb_id(info);
+		extend_info = rk_fb->fb[(rk_fb->num_fb>>1) + fb_id];
+		extend_dev_drv  = (struct rk_lcdc_driver *)extend_info->par;
+		extend_layer_id = dev_drv->ops->fb_get_layer(extend_dev_drv, extend_info->fix.id);
+		extend_par= extend_dev_drv->layer_par[extend_layer_id];
 	}
-	switch (par->format)
-    	{
-    		case XBGR888:
-		case ARGB888:
-		case ABGR888:
-			par->y_offset = (yoffset*xvir + xoffset)*4;
-			break;
-		case  RGB888:
-			par->y_offset = (yoffset*xvir + xoffset)*3;
-			break;
-		case RGB565:
-			par->y_offset = (yoffset*xvir + xoffset)*2;
-	            	break;
-		case  YUV422:
-			par->y_offset = yoffset*xvir + xoffset;
-			par->c_offset = par->y_offset;
-	            	break;
-		case  YUV420:
-			par->y_offset = yoffset*xvir + xoffset;
-			par->c_offset = (yoffset>>1)*xvir + xoffset;
-	            	break;
-		case  YUV444 : // yuv444
-			par->y_offset = yoffset*xvir + xoffset;
-			par->c_offset = yoffset*2*xvir +(xoffset<<1);
-			break;
-		default:
-			printk("un supported format:0x%x\n",data_format);
-            		return -EINVAL;
-    	}
-
-	dev_drv->pan_display(dev_drv,layer_id);
-	#if defined(CONFIG_RK_HDMI)
-		#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
-			if((hdmi_get_hotplug() == HDMI_HPD_ACTIVED) && (hdmi_switch_complete))
-			{
-				if(inf->num_fb >= 2)
-				{
-					extend_fb_id = get_extend_fb_id(info->fix.id);
-					info2 = inf->fb[(inf->num_fb>>1) + extend_fb_id];
-					dev_drv1 = (struct rk_lcdc_device_driver * )info2->par;
-					layer_id2 = dev_drv1->fb_get_layer(dev_drv1,info2->fix.id);
-					par2 = dev_drv1->layer_par[layer_id2];
-					par2->y_offset = par->y_offset;
-					//memcpy(info2->screen_base+par2->y_offset,info->screen_base+par->y_offset,
-					//	var->xres*var->yres*var->bits_per_pixel>>3);
-					#if defined(CONFIG_FB_ROTATE) || !defined(CONFIG_THREE_FB_BUFFER)
-					fb_copy_by_ipp(info2,info,par->y_offset);
-					#endif
-					dev_drv1->pan_display(dev_drv1,layer_id2);
-					//queue_delayed_work(inf->workqueue, &inf->delay_work,0);
-				}
-			}
+	
+	switch (par->format) {
+	case XBGR888:
+	case ARGB888:
+	case ABGR888:
+		par->y_offset = (yoffset*xvir + xoffset)*4;
+		break;
+	case  RGB888:
+		par->y_offset = (yoffset*xvir + xoffset)*3;
+		break;
+	case RGB565:
+		par->y_offset = (yoffset*xvir + xoffset)*2;
+		break;
+	case  YUV422:
+		par->y_offset = yoffset*xvir + xoffset;
+		par->c_offset = par->y_offset;
+		break;
+	case  YUV420:
+		par->y_offset = yoffset*xvir + xoffset;
+		par->c_offset = (yoffset>>1)*xvir + xoffset;
+		break;
+	case  YUV444:
+		par->y_offset = yoffset*xvir + xoffset;
+		par->c_offset = yoffset*2*xvir + (xoffset<<1);
+		break;
+	default:
+		printk(KERN_ERR "%s un supported format:0x%x\n",
+			__func__, data_format);
+		return -EINVAL;
+	}
+
+	dev_drv->ops->pan_display(dev_drv, layer_id);
+	if (rk_fb->disp_mode == DUAL) {
+		if (extend_par->state && (hdmi_switch_complete)) {
+			extend_par->y_offset = par->y_offset;
+		#if defined(CONFIG_FB_ROTATE) || !defined(CONFIG_THREE_FB_BUFFER)
+			rk_fb_rotate(extend_info, info, par->y_offset);
 		#endif
-	#endif
+			extend_dev_drv->ops->pan_display(extend_dev_drv, extend_layer_id);
+		}
+	}
 
 	#ifdef	CONFIG_FB_MIRRORING
-	if(video_data_to_mirroring!=NULL)
-		video_data_to_mirroring(info,NULL);
- 	#endif
+	if (video_data_to_mirroring)
+		video_data_to_mirroring(info, NULL);
+	#endif
 	return 0;
 }
-static int rk_fb_ioctl(struct fb_info *info, unsigned int cmd,unsigned long arg)
+
+static int rk_fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 {
+	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
 	struct fb_fix_screeninfo *fix = &info->fix;
-	struct rk_lcdc_device_driver *dev_drv = (struct rk_lcdc_device_driver * )info->par;
-#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
-	struct rk_fb_inf *inf = dev_get_drvdata(info->device);
-	struct fb_info * info2 = NULL;
-	int extend_fb_id = 0;
-	struct rk_lcdc_device_driver * dev_drv1  = NULL;
-#endif
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)info->par;
+	int fb_id = 0;
+	struct fb_info *extend_info = NULL;
+	struct rk_lcdc_driver *extend_dev_drv = NULL;
+	struct layer_par *extend_par = NULL;
+	int extend_layer_id = 0;
+	
 	u32 yuv_phy[2];
-	int  layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
-	int enable; // enable fb:1 enable;0 disable 
-	int ovl;	//overlay:0 win1 on the top of win0;1,win0 on the top of win1
-	int num_buf; //buffer_number
+	int  layer_id = dev_drv->ops->fb_get_layer(dev_drv, info->fix.id);
+	int enable; /* enable fb:1 enable;0 disable*/
+	int ovl;   /*overlay:0 win1 on the top of win0;1,win0 on the top of win1*/
+	int num_buf; /*buffer_number*/
 	int ret;
 	void __user *argp = (void __user *)arg;
-	
-	switch(cmd)
-	{
- 		case FBIOPUT_FBPHYADD:
-			return fix->smem_start;
-			break;
-		case RK_FBIOSET_YUV_ADDR:   //when in video mode, buff alloc by android
-			{
-				if (copy_from_user(yuv_phy, argp, 8))
-					return -EFAULT;
-				fix->smem_start = yuv_phy[0];  //four y
-				fix->mmio_start = yuv_phy[1];  //four uv
-			}
-			break;
-		case RK_FBIOSET_ENABLE:
-			if (copy_from_user(&enable, argp, sizeof(enable)))
-				return -EFAULT;
-			dev_drv->open(dev_drv,layer_id,enable);
-			break;
-		case RK_FBIOGET_ENABLE:
-			enable = dev_drv->get_layer_state(dev_drv,layer_id);
-			if(copy_to_user(argp,&enable,sizeof(enable)))
-				return -EFAULT;
-			break;
-		case RK_FBIOSET_OVERLAY_STATE:
-			if (copy_from_user(&ovl, argp, sizeof(ovl)))
-				return -EFAULT;
-			dev_drv->ovl_mgr(dev_drv,ovl,1);
-			break;
-		case RK_FBIOGET_OVERLAY_STATE:
-			ovl = dev_drv->ovl_mgr(dev_drv,0,0);
-			if (copy_to_user(argp, &ovl, sizeof(ovl)))
-				return -EFAULT;
-			break;
-		case RK_FBIOPUT_NUM_BUFFERS:
-			if (copy_from_user(&num_buf, argp, sizeof(num_buf)))
-				return -EFAULT;
-			dev_drv->num_buf = num_buf;
-			printk("rk fb use %d buffers\n",num_buf);
-			break;
-		case RK_FBIOSET_VSYNC_ENABLE:
-			if (copy_from_user(&enable, argp, sizeof(enable)))
-				return -EFAULT;
-			dev_drv->vsync_info.active = enable;
-			break;
-		case RK_FBIOSET_CONFIG_DONE:
-			ret = copy_from_user(&(dev_drv->wait_fs),argp,sizeof(dev_drv->wait_fs));
-			if(dev_drv->lcdc_reg_update)
-				dev_drv->lcdc_reg_update(dev_drv);
-	#if defined(CONFIG_RK_HDMI)
-		#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
-			if((hdmi_get_hotplug() == HDMI_HPD_ACTIVED) && (hdmi_switch_complete))
-			{
-				if(inf->num_fb >= 2)
-				{
-					extend_fb_id = get_extend_fb_id(info->fix.id);
-					info2 = inf->fb[(inf->num_fb>>1) + extend_fb_id];
-					dev_drv1 = (struct rk_lcdc_device_driver * )info2->par;
-					if(dev_drv1->lcdc_reg_update)
-						dev_drv1->lcdc_reg_update(dev_drv1);
-				}
+
+	if (rk_fb->disp_mode == DUAL) {
+		fb_id = get_extend_fb_id(info);
+		extend_info = rk_fb->fb[(rk_fb->num_fb>>1) + fb_id];
+		extend_dev_drv  = (struct rk_lcdc_driver *)extend_info->par;
+		extend_layer_id = dev_drv->ops->fb_get_layer(extend_dev_drv, extend_info->fix.id);
+		extend_par= extend_dev_drv->layer_par[extend_layer_id];
+	}
+
+	switch (cmd) {
+	case RK_FBIOSET_YUV_ADDR:
+		if (copy_from_user(yuv_phy, argp, 8))
+			return -EFAULT;
+		fix->smem_start = yuv_phy[0];
+		fix->mmio_start = yuv_phy[1];
+		break;
+	case RK_FBIOSET_ENABLE:
+		if (copy_from_user(&enable, argp, sizeof(enable)))
+			return -EFAULT;
+		dev_drv->ops->open(dev_drv, layer_id, enable);
+		break;
+	case RK_FBIOGET_ENABLE:
+		enable = dev_drv->ops->get_layer_state(dev_drv, layer_id);
+		if (copy_to_user(argp, &enable, sizeof(enable)))
+			return -EFAULT;
+		break;
+	case RK_FBIOSET_OVERLAY_STATE:
+		if (copy_from_user(&ovl, argp, sizeof(ovl)))
+			return -EFAULT;
+		dev_drv->ops->ovl_mgr(dev_drv, ovl, 1);
+		break;
+	case RK_FBIOGET_OVERLAY_STATE:
+		ovl = dev_drv->ops->ovl_mgr(dev_drv, 0, 0);
+		if (copy_to_user(argp, &ovl, sizeof(ovl)))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_NUM_BUFFERS:
+		if (copy_from_user(&num_buf, argp, sizeof(num_buf)))
+			return -EFAULT;
+		dev_drv->num_buf = num_buf;
+		break;
+	case RK_FBIOSET_VSYNC_ENABLE:
+		if (copy_from_user(&enable, argp, sizeof(enable)))
+			return -EFAULT;
+		dev_drv->vsync_info.active = enable;
+		break;
+	case RK_FBIOSET_CONFIG_DONE:
+		ret = copy_from_user(&(dev_drv->wait_fs), argp, sizeof(dev_drv->wait_fs));
+		if (dev_drv->ops->lcdc_reg_update)
+			dev_drv->ops->lcdc_reg_update(dev_drv);
+	if (rk_fb->disp_mode == DUAL) {
+		if (extend_par->state && (hdmi_switch_complete)) {
+			if (rk_fb->num_fb >= 2) {
+				if (extend_dev_drv->ops->lcdc_reg_update)
+					extend_dev_drv->ops->lcdc_reg_update(extend_dev_drv);
 			}
-		#endif 
-	#endif
-			break;
-        	default:
-			dev_drv->ioctl(dev_drv,cmd,arg,layer_id);
-            		break;
-    }
-    return 0;
+		}
+	}
+		break;
+	default:
+		dev_drv->ops->ioctl(dev_drv, cmd, arg, layer_id);
+		break;
+	}
+	return 0;
 }
 
 static int rk_fb_blank(int blank_mode, struct fb_info *info)
 {
-    	struct rk_lcdc_device_driver *dev_drv = (struct rk_lcdc_device_driver * )info->par;
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)info->par;
 	struct fb_fix_screeninfo *fix = &info->fix;
 	int layer_id;
-	
-	layer_id = dev_drv->fb_get_layer(dev_drv,fix->id);
-	if(layer_id < 0)
-	{
+
+	layer_id = dev_drv->ops->fb_get_layer(dev_drv, fix->id);
+	if (layer_id < 0)
 		return  -ENODEV;
-	}
 #if defined(CONFIG_RK_HDMI)
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-	if(hdmi_get_hotplug() == HDMI_HPD_ACTIVED){
-		printk("hdmi is connect , not blank lcdc\n");
-	}else
-#endif
+	if ((rk_fb->disp_mode == ONE_DUAL ) && (hdmi_get_hotplug() == HDMI_HPD_ACTIVED)) {
+		printk(KERN_INFO "hdmi is connect , not blank lcdc\n");
+	} else
 #endif
 	{
-		dev_drv->blank(dev_drv,layer_id,blank_mode);
+		dev_drv->ops->blank(dev_drv, layer_id, blank_mode);
 	}
 	return 0;
 }
 
 static int rk_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
-	
-	if( 0==var->xres_virtual || 0==var->yres_virtual ||
-		 0==var->xres || 0==var->yres || var->xres<16 ||
-		 ((16!=var->bits_per_pixel)&&(32!=var->bits_per_pixel)) )
-	 {
-		 printk("%s check var fail 1!!! \n",info->fix.id);
-		 printk("xres_vir:%d>>yres_vir:%d\n", var->xres_virtual,var->yres_virtual);
-		 printk("xres:%d>>yres:%d\n", var->xres,var->yres);
-		 printk("bits_per_pixel:%d \n", var->bits_per_pixel);
-		 return -EINVAL;
-	 }
- 
-	 if( ((var->xoffset+var->xres) > var->xres_virtual) ||
-	     ((var->yoffset+var->yres) > (var->yres_virtual)) )
-	 {
-		 printk("%s check_var fail 2!!! \n",info->fix.id);
-		 printk("xoffset:%d>>xres:%d>>xres_vir:%d\n",var->xoffset,var->xres,var->xres_virtual);
-		 printk("yoffset:%d>>yres:%d>>yres_vir:%d\n",var->yoffset,var->yres,var->yres_virtual);
-		 return -EINVAL;
-	 }
-
-    return 0;
+
+	if ((0 == var->xres_virtual) || (0 == var->yres_virtual) ||
+		(0 == var->xres) || (0 == var->yres) || (var->xres < 16) ||
+		((16 != var->bits_per_pixel) && (32 != var->bits_per_pixel))) {
+		dev_err(info->dev, "%s check var fail 1:\n"
+				"xres_vir:%d>>yres_vir:%d\n"
+				"xres:%d>>yres:%d\n"
+				"bits_per_pixel:%d\n",
+				info->fix.id,
+				var->xres_virtual,
+				var->yres_virtual,
+				var->xres,
+				var->yres,
+				var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	if (((var->xoffset+var->xres) > var->xres_virtual) ||
+		((var->yoffset+var->yres) > (var->yres_virtual))) {
+		dev_err(info->dev, "%s check_var fail 2:\n"
+				"xoffset:%d>>xres:%d>>xres_vir:%d\n"
+				"yoffset:%d>>yres:%d>>yres_vir:%d\n",
+				info->fix.id,
+				var->xoffset,
+				var->xres,
+				var->xres_virtual,
+				var->yoffset,
+				var->yres,
+				var->yres_virtual);
+		return -EINVAL;
+	}
+
+	return 0;
 }
 
 static ssize_t rk_fb_read(struct fb_info *info, char __user *buf,
@@ -712,31 +794,26 @@ static ssize_t rk_fb_read(struct fb_info *info, char __user *buf,
 	u8 __iomem *src;
 	int c, cnt = 0, err = 0;
 	unsigned long total_size;
-	struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )info->par;
+	struct rk_lcdc_driver *dev_drv =
+			(struct rk_lcdc_driver *)info->par;
 	struct layer_par *par = NULL;
 	int layer_id = 0;
 
-	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
-	if(layer_id < 0)
-	{
+	layer_id = dev_drv->ops->fb_get_layer(dev_drv, info->fix.id);
+	if (layer_id < 0)
 		return  -ENODEV;
-	}
 	else
-	{
 		par = dev_drv->layer_par[layer_id];
-	}
 
-	if(par->format == RGB565)
-	{
-		total_size = par->xact*par->yact<<1; //only read the current frame buffer
-	}
+	if (par->format == RGB565)
+		total_size = par->xact*par->yact<<1; /*only read the current frame buffer*/
 	else
 		total_size = par->xact*par->yact<<2;
-	
-	
+
+
 	if (p >= total_size)
 		return 0;
-	
+
 	if (count >= total_size)
 		count = total_size;
 
@@ -747,7 +824,7 @@ static ssize_t rk_fb_read(struct fb_info *info, char __user *buf,
 			 GFP_KERNEL);
 	if (!buffer)
 		return -ENOMEM;
-	
+
 	src = (u8 __iomem *) (info->screen_base + p + par->y_offset);
 
 	while (count) {
@@ -780,27 +857,21 @@ static ssize_t rk_fb_write(struct fb_info *info, const char __user *buf,
 	u8 __iomem *dst;
 	int c, cnt = 0, err = 0;
 	unsigned long total_size;
-	struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )info->par;
+	struct rk_lcdc_driver *dev_drv =(struct rk_lcdc_driver *)info->par;
 	struct layer_par *par = NULL;
 	int layer_id = 0;
 
-	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
-	if(layer_id < 0)
-	{
+	layer_id = dev_drv->ops->fb_get_layer(dev_drv, info->fix.id);
+	if (layer_id < 0)
 		return  -ENODEV;
-	}
 	else
-	{
 		par = dev_drv->layer_par[layer_id];
-	}
 
-	if(par->format == RGB565)
-	{
-		total_size = par->xact*par->yact<<1; //write the current frame buffer
-	}
+	if (par->format == RGB565)
+		total_size = par->xact*par->yact<<1; /*write the current frame buffer*/
 	else
 		total_size = par->xact*par->yact<<2;
-	
+
 	if (p > total_size)
 		return -EFBIG;
 
@@ -844,133 +915,139 @@ static ssize_t rk_fb_write(struct fb_info *info, const char __user *buf,
 	kfree(buffer);
 
 	return (cnt) ? cnt : err;
-	
+
 }
 
 static int rk_fb_set_par(struct fb_info *info)
 {
-    	struct fb_var_screeninfo *var = &info->var;
-    	struct fb_fix_screeninfo *fix = &info->fix;
-    	struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )info->par;
-    	struct layer_par *par = NULL;
-   	rk_screen *screen =dev_drv->cur_screen;
-    	int layer_id = 0;	
-    	u32 cblen = 0,crlen = 0;
-    	u16 xsize =0,ysize = 0;              //winx display window height/width --->LCDC_WINx_DSP_INFO
-    	u32 xoffset = var->xoffset;		// offset from virtual to visible 
-	u32 yoffset = var->yoffset;		//resolution			
-	u16 xpos = (var->nonstd>>8) & 0xfff; //visiable pos in panel
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)info->par;
+	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
+	int fb_id;
+	struct fb_info *extend_info = NULL;
+	struct rk_lcdc_driver *extend_dev_drv = NULL;
+	int extend_layer_id = 0;
+	struct layer_par *extend_par = NULL;
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	int layer_id = 0;
+	u32 cblen = 0, crlen = 0;
+	u16 xsize = 0, ysize = 0;                 /*winx display window height/width --->LCDC_WINx_DSP_INFO*/
+	u32 xoffset = var->xoffset;		/* offset from virtual to visible*/
+	u32 yoffset = var->yoffset;
+	u16 xpos = (var->nonstd>>8) & 0xfff;   /*visiable pos in panel*/
 	u16 ypos = (var->nonstd>>20) & 0xfff;
 	u32 xvir = var->xres_virtual;
 	u32 yvir = var->yres_virtual;
 	u8 data_format = var->nonstd&0xff;
+
+
+	
 	var->pixclock = dev_drv->pixclock;
- 	
-	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
-	if(layer_id < 0)
-	{
+	layer_id = dev_drv->ops->fb_get_layer(dev_drv, info->fix.id);
+	if (layer_id < 0)
 		return  -ENODEV;
-	}
 	else
-	{
 		par = dev_drv->layer_par[layer_id];
+
+	if (rk_fb->disp_mode == DUAL) {
+		fb_id = get_extend_fb_id(info);
+		extend_info = rk_fb->fb[(rk_fb->num_fb>>1) + fb_id];
+		extend_dev_drv  = (struct rk_lcdc_driver *)extend_info->par;
+		extend_layer_id = dev_drv->ops->fb_get_layer(extend_dev_drv, extend_info->fix.id);
+		extend_par= extend_dev_drv->layer_par[extend_layer_id];
 	}
-	
-	if(var->grayscale>>8)  //if the application has specific the horizontal and vertical display size
-	{
-		xsize = (var->grayscale>>8) & 0xfff;  //visiable size in panel ,for vide0
+	if (var->grayscale>>8) { /*if the application has specific the horizontal and vertical display size*/
+		xsize = (var->grayscale>>8) & 0xfff;
 		ysize = (var->grayscale>>20) & 0xfff;
-	}
-	else  //ohterwise  full  screen display
-	{
+	} else  { /*ohterwise  full  screen display*/
 		xsize = screen->x_res;
 		ysize = screen->y_res;
 	}
 
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF) || defined(CONFIG_NO_DUAL_DISP)
-	if(screen->screen_id == 0) //this is for device like rk2928 ,whic have one lcdc but two display outputs
-	{			   //save parameter set by android
+/*this is for device like rk2928 ,whic have one lcdc but two display outputs*/
+/*save parameter set by android*/
+if (rk_fb->disp_mode != DUAL) {
+	if (screen->screen_id == 0) { 
+					
 		dev_drv->screen0->xsize = xsize;
 		dev_drv->screen0->ysize = ysize;
 		dev_drv->screen0->xpos  = xpos;
 		dev_drv->screen0->ypos = ypos;
-	}
-	else
-	{
-		xsize = dev_drv->screen1->xsize; 
+	} else {
+		xsize = dev_drv->screen1->xsize;
 		ysize = dev_drv->screen1->ysize;
 		xpos = dev_drv->screen1->xpos;
 		ypos = dev_drv->screen1->ypos;
 	}
-#endif
-	/* calculate y_offset,c_offset,line_length,cblen and crlen  */
+}
+
 #if 1
-	switch (data_format)
-	{
-		case HAL_PIXEL_FORMAT_RGBX_8888: 
-			par->format = XBGR888;
-			fix->line_length = 4 * xvir;
-			par->y_offset = (yoffset*xvir + xoffset)*4;
-			break;
-		case HAL_PIXEL_FORMAT_RGBA_8888 :      // rgb
-			par->format = ABGR888;
-			fix->line_length = 4 * xvir;
-			par->y_offset = (yoffset*xvir + xoffset)*4;
-			break;
-		case HAL_PIXEL_FORMAT_BGRA_8888 :      // rgb
-			par->format = ARGB888;
-			fix->line_length = 4 * xvir;
-			par->y_offset = (yoffset*xvir + xoffset)*4;
-			break;
-		case HAL_PIXEL_FORMAT_RGB_888 :
-			par->format = RGB888;
-			fix->line_length = 3 * xvir;
-			par->y_offset = (yoffset*xvir + xoffset)*3;
-			break;
-		case HAL_PIXEL_FORMAT_RGB_565:  //RGB565
-			par->format = RGB565;
-			fix->line_length = 2 * xvir;
-			par->y_offset = (yoffset*xvir + xoffset)*2;
-		    	break;
-		case HAL_PIXEL_FORMAT_YCbCr_422_SP : // yuv422
-			par->format = YUV422;
-			fix->line_length = xvir;
-			cblen = crlen = (xvir*yvir)>>1;
-			par->y_offset = yoffset*xvir + xoffset;
-			par->c_offset = par->y_offset;
-		    	break;
-		case HAL_PIXEL_FORMAT_YCrCb_NV12   : // YUV420---uvuvuv
-			par->format = YUV420;
-			fix->line_length = xvir;
-			cblen = crlen = (xvir*yvir)>>2;
-			par->y_offset = yoffset*xvir + xoffset;
-			par->c_offset = (yoffset>>1)*xvir + xoffset;
-		    	break;
-		case HAL_PIXEL_FORMAT_YCrCb_444 : // yuv444
-			par->format = 5;
-			fix->line_length = xvir<<2;
-			par->y_offset = yoffset*xvir + xoffset;
-			par->c_offset = yoffset*2*xvir +(xoffset<<1);
-			cblen = crlen = (xvir*yvir);
-			break;
-		default:
-			printk("%s:un supported format:0x%x\n",__func__,data_format);
-		    return -EINVAL;
+	switch (data_format) {
+	case HAL_PIXEL_FORMAT_RGBX_8888:
+		par->format = XBGR888;
+		fix->line_length = 4 * xvir;
+		par->y_offset = (yoffset*xvir + xoffset)*4;
+		break;
+	case HAL_PIXEL_FORMAT_RGBA_8888:
+		par->format = ABGR888;
+		fix->line_length = 4 * xvir;
+		par->y_offset = (yoffset*xvir + xoffset)*4;
+		break;
+	case HAL_PIXEL_FORMAT_BGRA_8888:
+		par->format = ARGB888;
+		fix->line_length = 4 * xvir;
+		par->y_offset = (yoffset*xvir + xoffset)*4;
+		break;
+	case HAL_PIXEL_FORMAT_RGB_888:
+		par->format = RGB888;
+		fix->line_length = 3 * xvir;
+		par->y_offset = (yoffset*xvir + xoffset)*3;
+		break;
+	case HAL_PIXEL_FORMAT_RGB_565:
+		par->format = RGB565;
+		fix->line_length = 2 * xvir;
+		par->y_offset = (yoffset*xvir + xoffset)*2;
+		break;
+	case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+		par->format = YUV422;
+		fix->line_length = xvir;
+		cblen = crlen = (xvir*yvir)>>1;
+		par->y_offset = yoffset*xvir + xoffset;
+		par->c_offset = par->y_offset;
+		break;
+	case HAL_PIXEL_FORMAT_YCrCb_NV12:
+		par->format = YUV420;
+		fix->line_length = xvir;
+		cblen = crlen = (xvir*yvir)>>2;
+		par->y_offset = yoffset*xvir + xoffset;
+		par->c_offset = (yoffset>>1)*xvir + xoffset;
+		break;
+	case HAL_PIXEL_FORMAT_YCrCb_444:
+		par->format = 5;
+		fix->line_length = xvir<<2;
+		par->y_offset = yoffset*xvir + xoffset;
+		par->c_offset = yoffset*2*xvir + (xoffset<<1);
+		cblen = crlen = (xvir*yvir);
+		break;
+	default:
+		printk(KERN_ERR "%s:un supported format:0x%x\n", __func__, data_format);
+		return -EINVAL;
 	}
 #else
-	switch(var->bits_per_pixel)
-	{
-		case 32:
-			par->format = ARGB888;
-			fix->line_length = 4 * xvir;
-			par->y_offset = (yoffset*xvir + xoffset)*4;
-			break;
-		case 16:
-			par->format = RGB565;
-			fix->line_length = 2 * xvir;
-			par->y_offset = (yoffset*xvir + xoffset)*2;
-	    		break;
-			
+	switch (var->bits_per_pixel) {
+	case 32:
+		par->format = ARGB888;
+		fix->line_length = 4 * xvir;
+		par->y_offset = (yoffset*xvir + xoffset)*4;
+		break;
+	case 16:
+		par->format = RGB565;
+		fix->line_length = 2 * xvir;
+		par->y_offset = (yoffset*xvir + xoffset)*2;
+		break;
+
 	}
 #endif
 
@@ -979,51 +1056,38 @@ static int rk_fb_set_par(struct fb_info *info)
 	par->xsize = xsize;
 	par->ysize = ysize;
 
-	par->smem_start =fix->smem_start;
+	par->smem_start = fix->smem_start;
 	par->cbr_start = fix->mmio_start;
-	par->xact = var->xres;              //winx active window height,is a part of vir
+	par->xact = var->xres;              /*winx active window height,is a part of vir*/
 	par->yact = var->yres;
-	par->xvir =  var->xres_virtual;		// virtual resolution	 stride --->LCDC_WINx_VIR
+	par->xvir =  var->xres_virtual;	   /*virtual resolution	 stride --->LCDC_WINx_VIR*/
 	par->yvir =  var->yres_virtual;
-	#if defined(CONFIG_RK_HDMI)
-		#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
-			if((hdmi_get_hotplug() == HDMI_HPD_ACTIVED) && (hdmi_switch_complete))
-			{
-				struct rk_fb_inf *inf = dev_get_drvdata(info->device);
-				int extend_fb_id = get_extend_fb_id(info->fix.id);
-				struct fb_info * info2 = inf->fb[(inf->num_fb>>1) + extend_fb_id];
-				struct rk_lcdc_device_driver * dev_drv1  = (struct rk_lcdc_device_driver * )info2->par;
-				int layer_id2 = dev_drv->fb_get_layer(dev_drv1,info2->fix.id);
-				struct layer_par *par2 = dev_drv1->layer_par[layer_id2];
-				if(info != info2)
-				{
-					if(par->xact < par->yact)
-					{
-						par2->xact = par->yact;
-						par2->yact = par->xact;
-						par2->xvir = par->yact;
-						info2->var.xres = var->yres;
-						info2->var.yres = var->xres;
-						info2->var.xres_virtual = var->yres;
-					}
-					else
-					{
-						par2->xact = par->xact;
-						par2->yact = par->yact;
-						par2->xvir = par->xvir;
-						info2->var.xres = var->xres;
-						info2->var.yres = var->yres;
-						info2->var.xres_virtual = var->xres_virtual;
-					}
-					par2->format = par->format;
-					info2->var.nonstd &= 0xffffff00;
-					info2->var.nonstd |= data_format;
-					dev_drv1->set_par(dev_drv1,layer_id2);
+	if (rk_fb->disp_mode == DUAL) {
+		if (extend_par->state && (hdmi_switch_complete)) {
+			if (info != extend_info) {
+				if (par->xact < par->yact) {
+					extend_par->xact = par->yact;
+					extend_par->yact = par->xact;
+					extend_par->xvir = par->yact;
+					extend_info->var.xres = var->yres;
+					extend_info->var.yres = var->xres;
+					extend_info->var.xres_virtual = var->yres;
+				} else {
+					extend_par->xact = par->xact;
+					extend_par->yact = par->yact;
+					extend_par->xvir = par->xvir;
+					extend_info->var.xres = var->xres;
+					extend_info->var.yres = var->yres;
+					extend_info->var.xres_virtual = var->xres_virtual;
 				}
+				extend_par->format = par->format;
+				extend_info->var.nonstd &= 0xffffff00;
+				extend_info->var.nonstd |= data_format;
+				extend_dev_drv->ops->set_par(extend_dev_drv, extend_layer_id);
 			}
-		#endif
-	#endif
-	dev_drv->set_par(dev_drv,layer_id);
+		}
+	}
+	dev_drv->ops->set_par(dev_drv, layer_id);
 
 	return 0;
 }
@@ -1061,42 +1125,42 @@ static int fb_setcolreg(unsigned regno,
 }
 
 static struct fb_ops fb_ops = {
-    .owner          = THIS_MODULE,
-    .fb_open        = rk_fb_open,
-    .fb_release     = rk_fb_close,
-    .fb_check_var   = rk_fb_check_var,
-    .fb_set_par     = rk_fb_set_par,
-    .fb_blank       = rk_fb_blank,
-    .fb_ioctl       = rk_fb_ioctl,
-    .fb_pan_display = rk_pan_display,
-    .fb_read	    = rk_fb_read,
-    .fb_write	    = rk_fb_write,
-    .fb_setcolreg   = fb_setcolreg,
-    .fb_fillrect    = cfb_fillrect,
-    .fb_copyarea    = cfb_copyarea,
-    .fb_imageblit   = cfb_imageblit,
+	.owner          = THIS_MODULE,
+	.fb_open        = rk_fb_open,
+	.fb_release     = rk_fb_close,
+	.fb_check_var   = rk_fb_check_var,
+	.fb_set_par     = rk_fb_set_par,
+	.fb_blank       = rk_fb_blank,
+	.fb_ioctl       = rk_fb_ioctl,
+	.fb_pan_display = rk_pan_display,
+	.fb_read        = rk_fb_read,
+	.fb_write       = rk_fb_write,
+	.fb_setcolreg   = fb_setcolreg,
+	.fb_fillrect    = cfb_fillrect,
+	.fb_copyarea    = cfb_copyarea,
+	.fb_imageblit   = cfb_imageblit,
 };
 
 
 
 static struct fb_var_screeninfo def_var = {
-#ifdef  CONFIG_LOGO_LINUX_BMP
-	.red    	= {16,8,0},
-	.green  	= {8,8,0},
-	.blue   	= {0,8,0},
-	.transp 	= {0,0,0},
-	.nonstd 	= HAL_PIXEL_FORMAT_BGRA_8888,
+#if defined(CONFIG_LOGO_LINUX_BMP)
+	.red		= {16, 8, 0},
+	.green		= {8, 8, 0},
+	.blue		= {0, 8, 0},
+	.transp		= {0, 0, 0},
+	.nonstd		= HAL_PIXEL_FORMAT_BGRA_8888,
 #else
-	.red		= {11,5,0},
-	.green  	= {5,6,0},
-	.blue   	= {0,5,0},
-	.transp 	= {0,0,0},
-	.nonstd 	= HAL_PIXEL_FORMAT_RGB_565,   //(ypos<<20+xpos<<8+format) format
+	.red		= {11, 5, 0},
+	.green		= {5, 6, 0},
+	.blue		= {0, 5, 0},
+	.transp		= {0, 0, 0},
+	.nonstd		= HAL_PIXEL_FORMAT_RGB_565,   /*(ypos<<20+xpos<<8+format) format*/
 #endif
-	.grayscale	= 0,  //(ysize<<20+xsize<<8)
-	.activate    	= FB_ACTIVATE_NOW,
-	.accel_flags 	= 0,
-	.vmode       	= FB_VMODE_NONINTERLACED,
+	.grayscale	= 0,  /*(ysize<<20+xsize<<8)*/
+	.activate	= FB_ACTIVATE_NOW,
+	.accel_flags	= 0,
+	.vmode		= FB_VMODE_NONINTERLACED,
 };
 
 static struct fb_fix_screeninfo def_fix = {
@@ -1106,26 +1170,25 @@ static struct fb_fix_screeninfo def_fix = {
 	.ypanstep	 = 1,
 	.ywrapstep	 = 0,
 	.accel		 = FB_ACCEL_NONE,
-	.visual 	 = FB_VISUAL_TRUECOLOR,
-		
+	.visual		 = FB_VISUAL_TRUECOLOR,
+
 };
 
 
 static int rk_fb_wait_for_vsync_thread(void *data)
 {
-	struct rk_lcdc_device_driver  *dev_drv = data;
-	struct rk_fb_inf *inf =  platform_get_drvdata(g_fb_pdev);
-	struct fb_info *fbi = inf->fb[0];
+	struct rk_lcdc_driver  *dev_drv = data;
+	struct rk_fb *rk_fb =  platform_get_drvdata(fb_pdev);
+	struct fb_info *fbi = rk_fb->fb[0];
 
 	while (!kthread_should_stop()) {
 		ktime_t timestamp = dev_drv->vsync_info.timestamp;
 		int ret = wait_event_interruptible(dev_drv->vsync_info.wait,
 			!ktime_equal(timestamp, dev_drv->vsync_info.timestamp) &&
-			dev_drv->vsync_info.active || dev_drv->vsync_info.irq_stop);
+			(dev_drv->vsync_info.active || dev_drv->vsync_info.irq_stop));
 
-		if (!ret) {
+		if (!ret)
 			sysfs_notify(&fbi->dev->kobj, NULL, "vsync");
-		}
 	}
 
 	return 0;
@@ -1135,8 +1198,7 @@ static ssize_t rk_fb_vsync_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)fbi->par;
 	return scnprintf(buf, PAGE_SIZE, "%llu\n",
 			ktime_to_ns(dev_drv->vsync_info.timestamp));
 }
@@ -1149,18 +1211,18 @@ this two function is for other module that in the kernel which
 need show image directly through fb
 fb_id:we have 4 fb here,default we use fb0 for ui display
 *******************************************************************/
-struct fb_info * rk_get_fb(int fb_id)
+struct fb_info *rk_get_fb(int fb_id)
 {
-    struct rk_fb_inf *inf =  platform_get_drvdata(g_fb_pdev);
-    struct fb_info *fb = inf->fb[fb_id];
-    return fb;
+	struct rk_fb *inf =  platform_get_drvdata(fb_pdev);
+	struct fb_info *fb = inf->fb[fb_id];
+	return fb;
 }
 EXPORT_SYMBOL(rk_get_fb);
 
-void rk_direct_fb_show(struct fb_info * fbi)
+void rk_direct_fb_show(struct fb_info *fbi)
 {
-    rk_fb_set_par(fbi);
-    rk_pan_display(&fbi->var, fbi);
+	rk_fb_set_par(fbi);
+	rk_pan_display(&fbi->var, fbi);
 }
 EXPORT_SYMBOL(rk_direct_fb_show);
 
@@ -1168,224 +1230,186 @@ EXPORT_SYMBOL(rk_direct_fb_show);
 static int set_xact_yact_for_hdmi(struct fb_var_screeninfo *pmy_var,
 					struct fb_var_screeninfo *hdmi_var)
 {
-	if(pmy_var->xres < pmy_var->yres)  //vertical  lcd screen
-	{
+	if (pmy_var->xres < pmy_var->yres) {  /*vertical  lcd screen*/
 		hdmi_var->xres = pmy_var->yres;
 		hdmi_var->yres = pmy_var->xres;
 		hdmi_var->xres_virtual = pmy_var->yres;
-	}
-	else
-	{
+	} else {
 		hdmi_var->xres = pmy_var->xres;
 		hdmi_var->yres = pmy_var->yres;
 		hdmi_var->xres_virtual = pmy_var->xres_virtual;
 	}
 
 	return 0;
-		
+
 }
 int rk_fb_dpi_open(bool open)
 {
-	struct rk_lcdc_device_driver * dev_drv = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
 	dev_drv = rk_get_prmry_lcdc_drv();
-	dev_drv->dpi_open(dev_drv,open);
+	dev_drv->ops->dpi_open(dev_drv, open);
 
 	return 0;
 }
 int rk_fb_dpi_layer_sel(int layer_id)
 {
-	struct rk_lcdc_device_driver * dev_drv = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
 	dev_drv = rk_get_prmry_lcdc_drv();
-	dev_drv->dpi_layer_sel(dev_drv,layer_id);
+	dev_drv->ops->dpi_layer_sel(dev_drv, layer_id);
 
 	return 0;
 }
 int rk_fb_dpi_status(void)
 {
 	int ret;
-	struct rk_lcdc_device_driver * dev_drv = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
 	dev_drv = rk_get_prmry_lcdc_drv();
-	ret = dev_drv->dpi_status(dev_drv);
+	ret = dev_drv->ops->dpi_status(dev_drv);
 
 	return ret;
 }
 
 /******************************************
-function:this function will be called by hdmi,when 
-              hdmi plug in/out
-screen: the screen attached to hdmi
-enable: 1,hdmi plug in,0,hdmi plug out
-lcdc_id: the lcdc id the hdmi attached ,0 or 1
+*function:this function will be called by hdmi,when
+*             hdmi plug in/out
+*screen: the screen attached to hdmi
+*enable: 1,hdmi plug in,0,hdmi plug out
+*lcdc_id: the lcdc id the hdmi attached ,0 or 1
 ******************************************/
-int rk_fb_switch_screen(rk_screen *screen ,int enable ,int lcdc_id)
+int rk_fb_switch_screen(rk_screen *screen , int enable, int lcdc_id)
 {
-	struct rk_fb_inf *inf =  platform_get_drvdata(g_fb_pdev);
+	struct rk_fb *rk_fb =  platform_get_drvdata(fb_pdev);
 	struct fb_info *info = NULL;
-	struct rk_lcdc_device_driver * dev_drv = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
 	struct fb_var_screeninfo *hdmi_var    = NULL;
-#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
-	struct fb_var_screeninfo *pmy_var = NULL;      //var for primary screen
+	struct fb_var_screeninfo *pmy_var = NULL;      /*var for primary screen*/
 	struct fb_info *pmy_info = NULL;
 	struct fb_fix_screeninfo *pmy_fix = NULL;
-#endif
 	int i;
 	struct fb_fix_screeninfo *hdmi_fix    = NULL;
 	char name[6];
 	int ret;
 	int layer_id;
 
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF) || defined(CONFIG_NO_DUAL_DISP)
-	rk29_backlight_set(0);
-#endif
-	
-	sprintf(name, "lcdc%d",lcdc_id);
+	if (rk_fb->disp_mode != DUAL)
+		rk29_backlight_set(0);
 
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-	dev_drv = inf->lcdc_dev_drv[0];
-#else
-	for(i = 0; i < inf->num_lcdc; i++)  //find the driver for the extend display device
-	{
-		if(inf->lcdc_dev_drv[i]->screen_ctr_info->prop == EXTEND)
-		{
-			dev_drv = inf->lcdc_dev_drv[i];
-			break;
+	sprintf(name, "lcdc%d", lcdc_id);
+
+	if (rk_fb->disp_mode != DUAL) {
+		dev_drv = rk_fb->lcdc_dev_drv[0];
+	} else {
+
+		for (i = 0; i < rk_fb->num_lcdc; i++) {
+			if (rk_fb->lcdc_dev_drv[i]->prop == EXTEND) {
+				dev_drv = rk_fb->lcdc_dev_drv[i];
+				break;
+			}
+		}
+
+		if (i == rk_fb->num_lcdc) {
+			printk(KERN_ERR "%s driver not found!", name);
+			return -ENODEV;
 		}
 	}
-	
-	if(i == inf->num_lcdc)
-	{
-		printk(KERN_ERR "%s driver not found!",name);
-		return -ENODEV;
-		
-	}
-#endif
-	printk("hdmi %s lcdc%d\n",enable?"connect to":"remove from",dev_drv->id);
-	
-	if(inf->num_lcdc == 1)
-	{
-		info = inf->fb[0];
-	}
-	else if(inf->num_lcdc == 2)
-	{
-		info = inf->fb[dev_drv->num_layer]; //the main fb of lcdc1
-	}
+	printk("hdmi %s lcdc%d\n", enable ? "connect to" : "remove from", dev_drv->id);
 
-	if(dev_drv->screen1) //device like rk2928 ,have only one lcdc but two outputs
-	{
-		if(enable)
-		{
-			memcpy(dev_drv->screen1,screen,sizeof(rk_screen ));
-			dev_drv->screen1->lcdc_id = 0; //connect screen1 to output interface 0
+	if (rk_fb->num_lcdc == 1)
+		info = rk_fb->fb[0];
+	else if (rk_fb->num_lcdc == 2)
+		info = rk_fb->fb[dev_drv->num_layer]; /*the main fb of lcdc1*/
+
+	if (dev_drv->screen1) { /*device like rk2928 ,have only one lcdc but two outputs*/
+		if (enable) {
+			memcpy(dev_drv->screen1, screen, sizeof(rk_screen));
+			dev_drv->screen1->lcdc_id = 0; /*connect screen1 to output interface 0*/
 			dev_drv->screen1->screen_id = 1;
-			dev_drv->screen0->lcdc_id = 1; //connect screen0 to output interface 1
+			dev_drv->screen0->lcdc_id = 1; /*connect screen0 to output interface 1*/
 			dev_drv->cur_screen = dev_drv->screen1;
 			dev_drv->screen0->ext_screen = dev_drv->screen1;
-			if(dev_drv->screen0->sscreen_get)
-			{
+			if (dev_drv->screen0->sscreen_get) {
 				dev_drv->screen0->sscreen_get(dev_drv->screen0,
 					dev_drv->cur_screen->hdmi_resolution);
 			}
-			
-			
-		}
-		else
-		{
-			dev_drv->screen1->lcdc_id = 1; //connect screen1 to output interface 1
-			dev_drv->screen0->lcdc_id = 0; //connect screen0 to output interface 0
+
+
+		} else {
+			dev_drv->screen1->lcdc_id = 1; /*connect screen1 to output interface 1*/
+			dev_drv->screen0->lcdc_id = 0; /*connect screen0 to output interface 0*/
 			dev_drv->cur_screen = dev_drv->screen0;
 			dev_drv->screen_ctr_info->set_screen_info(dev_drv->cur_screen,
-			dev_drv->screen_ctr_info->lcd_info);
-			
-			
-		}
-	}
-	else
-	{
-		if(enable)
-		{
-			memcpy(dev_drv->cur_screen,screen,sizeof(rk_screen ));
+					dev_drv->screen_ctr_info->lcd_info);
 		}
+	} else{
+		if (enable)
+			memcpy(dev_drv->cur_screen, screen, sizeof(rk_screen));
 	}
 
-	
-	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
-	
-	if(!enable && !dev_drv->screen1) //only double lcdc device need to close
-	{
-		if(dev_drv->layer_par[layer_id]->state) 
-		{
-			dev_drv->open(dev_drv,layer_id,enable); //disable the layer which attached to this fb
-		}
+
+	layer_id = dev_drv->ops->fb_get_layer(dev_drv, info->fix.id);
+
+	if (!enable && !dev_drv->screen1) { /*only double lcdc device need to close*/
+		if (dev_drv->layer_par[layer_id]->state)
+			dev_drv->ops->open(dev_drv, layer_id, enable); /*disable the layer which attached to this fb*/
 		hdmi_switch_complete = 0;
-	
+
 		return 0;
 	}
-	
+
 	hdmi_var = &info->var;
 	hdmi_fix = &info->fix;
-	#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
-		if(likely(inf->num_lcdc == 2))
-		{
-			pmy_var = &inf->fb[0]->var;
-			pmy_fix = &inf->fb[0]->fix;
-			set_xact_yact_for_hdmi(pmy_var,hdmi_var);
+	if (rk_fb->disp_mode  == DUAL) {
+		if (likely(rk_fb->num_lcdc == 2)) {
+			pmy_var = &rk_fb->fb[0]->var;
+			pmy_fix = &rk_fb->fb[0]->fix;
+			set_xact_yact_for_hdmi(pmy_var, hdmi_var);
 			hdmi_var->nonstd &= 0xffffff00;
-			hdmi_var->nonstd |= (pmy_var->nonstd & 0xff); //use the same format as primary screen
+			hdmi_var->nonstd |= (pmy_var->nonstd & 0xff); /*use the same format as primary screen*/
+		} else {
+			printk(KERN_WARNING "%s>>only one lcdc,dual display no supported!", __func__);
 		}
-		else
-		{
-			printk(KERN_WARNING "%s>>only one lcdc,dual display no supported!",__func__);
-		}
-	#endif
+	}
 	hdmi_var->grayscale &= 0xff;
 	hdmi_var->grayscale |= (dev_drv->cur_screen->x_res<<8) + (dev_drv->cur_screen->y_res<<20);
-	if(dev_drv->screen1)  //device like rk2928,whic have one lcdc but two outputs
-	{
-	//	info->var.nonstd &= 0xff;
-	//	info->var.nonstd |= (dev_drv->cur_screen->xpos<<8) + (dev_drv->cur_screen->ypos<<20);
-	//	info->var.grayscale &= 0xff;
-	//	info->var.grayscale |= (dev_drv->cur_screen->x_res<<8) + (dev_drv->cur_screen->y_res<<20);
+	if (dev_drv->screen1) { /*device like rk2928,whic have one lcdc but two outputs*/
+	/*	info->var.nonstd &= 0xff;
+		info->var.nonstd |= (dev_drv->cur_screen->xpos<<8) + (dev_drv->cur_screen->ypos<<20);
+		info->var.grayscale &= 0xff;
+		info->var.grayscale |= (dev_drv->cur_screen->x_res<<8) + (dev_drv->cur_screen->y_res<<20);*/
 		dev_drv->screen1->xsize = dev_drv->cur_screen->x_res;
 		dev_drv->screen1->ysize = dev_drv->cur_screen->y_res;
 		dev_drv->screen1->xpos = 0;
 		dev_drv->screen1->ypos = 0;
 	}
-	ret = info->fbops->fb_open(info,1);
-	dev_drv->load_screen(dev_drv,1);
+
+	ret = info->fbops->fb_open(info, 1);
+	dev_drv->ops->load_screen(dev_drv, 1);
 	ret = info->fbops->fb_set_par(info);
-	if(dev_drv->lcdc_hdmi_process)
-		dev_drv->lcdc_hdmi_process(dev_drv,enable);
-
-	#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
-		if(likely(inf->num_lcdc == 2))
-		{
-			pmy_info = inf->fb[0];
-			pmy_info->fbops->fb_pan_display(pmy_var,pmy_info);
-		}
-		else
-		{
-			printk(KERN_WARNING "%s>>only one lcdc,dual display no supported!",__func__);
+	if (dev_drv->ops->lcdc_hdmi_process)
+		dev_drv->ops->lcdc_hdmi_process(dev_drv, enable);
+
+	if (rk_fb->disp_mode == DUAL) {
+		if (likely(rk_fb->num_lcdc == 2)) {
+			pmy_info = rk_fb->fb[0];
+			pmy_info->fbops->fb_pan_display(pmy_var, pmy_info);
+		} else {
+			printk(KERN_WARNING "%s>>only one lcdc,dual display no supported!", __func__);
 		}
-	#elif defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-		info->fbops->fb_pan_display(hdmi_var,info);
-	#endif 
-	info->fbops->fb_ioctl(info,RK_FBIOSET_CONFIG_DONE,0);
-	if(dev_drv->screen1) //for one lcdc use  scaler for dual dispaly
-	{
-		if(dev_drv->screen0->sscreen_set)
-		{
-			dev_drv->blank(dev_drv,0,FB_BLANK_NORMAL);
+	} else {
+		info->fbops->fb_pan_display(hdmi_var, info);
+	}
+	info->fbops->fb_ioctl(info, RK_FBIOSET_CONFIG_DONE, 0);
+	if (dev_drv->screen1) {
+		if (dev_drv->screen0->sscreen_set) {
+			dev_drv->ops->blank(dev_drv, 0, FB_BLANK_NORMAL);
 			msleep(100);
-			dev_drv->screen0->sscreen_set(dev_drv->screen0,enable);
-			dev_drv->blank(dev_drv,0,FB_BLANK_UNBLANK);
+			dev_drv->screen0->sscreen_set(dev_drv->screen0, enable);
+			dev_drv->ops->blank(dev_drv, 0, FB_BLANK_UNBLANK);
 		}
 	}
-#if defined(CONFIG_NO_DUAL_DISP)  //close backlight for device whic do not support dual display
-	if(!enable)
+
+	if (rk_fb->disp_mode != DUAL)
 		rk29_backlight_set(1);
-#elif defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)  //close backlight for device whic do not support dual display
-	rk29_backlight_set(1);
-#endif
 	hdmi_switch_complete = enable;
 	return 0;
 
@@ -1395,65 +1419,58 @@ int rk_fb_switch_screen(rk_screen *screen ,int enable ,int lcdc_id)
 
 
 /******************************************
-function:this function current only called by hdmi for 
+function:this function current only called by hdmi for
 	scale the display
 scale_x: scale rate of x resolution
 scale_y: scale rate of y resolution
 lcdc_id: the lcdc id the hdmi attached ,0 or 1
 ******************************************/
 
-int rk_fb_disp_scale(u8 scale_x, u8 scale_y,u8 lcdc_id)
+int rk_fb_disp_scale(u8 scale_x, u8 scale_y, u8 lcdc_id)
 {
-	struct rk_fb_inf *inf =  platform_get_drvdata(g_fb_pdev);
+	struct rk_fb *inf =  platform_get_drvdata(fb_pdev);
 	struct fb_info *info = NULL;
 	struct fb_var_screeninfo *var = NULL;
-	struct rk_lcdc_device_driver * dev_drv = NULL;
-	u16 screen_x,screen_y;
-	u16 xpos,ypos;
-	u16 xsize,ysize;
+	struct rk_lcdc_driver *dev_drv = NULL;
+	u16 screen_x, screen_y;
+	u16 xpos, ypos;
+	u16 xsize, ysize;
 	char name[6];
 	int i = 0;
-	sprintf(name, "lcdc%d",lcdc_id);
-	
+	sprintf(name, "lcdc%d", lcdc_id);
+
 #if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-		dev_drv = inf->lcdc_dev_drv[0];
+	dev_drv = inf->lcdc_dev_drv[0];
 #else
-	for(i = 0; i < inf->num_lcdc; i++)
-	{
-		if(inf->lcdc_dev_drv[i]->screen_ctr_info->prop == EXTEND)
-		{
+	for (i = 0; i < inf->num_lcdc; i++) {
+		if (inf->lcdc_dev_drv[i]->screen_ctr_info->prop == EXTEND) {
 			dev_drv = inf->lcdc_dev_drv[i];
 			break;
 		}
 	}
 
-	if(i == inf->num_lcdc)
-	{
-		printk(KERN_ERR "%s driver not found!",name);
+	if (i == inf->num_lcdc) {
+		printk(KERN_ERR "%s driver not found!", name);
 		return -ENODEV;
-		
+
 	}
 #endif
-	if(inf->num_lcdc == 1)
-	{
+	if (inf->num_lcdc == 1)
 		info = inf->fb[0];
-	}
-	else if(inf->num_lcdc == 2)
-	{
+	else if (inf->num_lcdc == 2)
 		info = inf->fb[dev_drv->num_layer];
-	}
 
 	var = &info->var;
 	screen_x = dev_drv->cur_screen->x_res;
 	screen_y = dev_drv->cur_screen->y_res;
-	
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)||defined(CONFIG_NO_DUAL_DISP)
-	if(dev_drv->cur_screen->screen_id == 1){
+
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF) || defined(CONFIG_NO_DUAL_DISP)
+	if (dev_drv->cur_screen->screen_id == 1) {
 		dev_drv->cur_screen->xpos = (screen_x-screen_x*scale_x/100)>>1;
 		dev_drv->cur_screen->ypos = (screen_y-screen_y*scale_y/100)>>1;
 		dev_drv->cur_screen->xsize = screen_x*scale_x/100;
 		dev_drv->cur_screen->ysize = screen_y*scale_y/100;
-	}else
+	} else
 #endif
 	{
 		xpos = (screen_x-screen_x*scale_x/100)>>1;
@@ -1463,184 +1480,172 @@ int rk_fb_disp_scale(u8 scale_x, u8 scale_y,u8 lcdc_id)
 		var->nonstd &= 0xff;
 		var->nonstd |= (xpos<<8) + (ypos<<20);
 		var->grayscale &= 0xff;
-		var->grayscale |= (xsize<<8) + (ysize<<20);	
+		var->grayscale |= (xsize<<8) + (ysize<<20);
 	}
 
 	info->fbops->fb_set_par(info);
-	info->fbops->fb_ioctl(info,RK_FBIOSET_CONFIG_DONE,0);
+	info->fbops->fb_ioctl(info, RK_FBIOSET_CONFIG_DONE, 0);
 	return 0;
-	
-	
+
+
 }
 
-static int rk_request_fb_buffer(struct fb_info *fbi,int fb_id)
+static int rk_request_fb_buffer(struct fb_info *fbi, int fb_id)
 {
-	struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )fbi->par;
-    	struct layer_par *par = NULL;
+	struct rk_lcdc_driver *dev_drv =
+		(struct rk_lcdc_driver *)fbi->par;
+	struct layer_par *par = NULL;
 	int layer_id;
 	struct resource *res;
 	struct resource *mem;
 	int ret = 0;
-	struct rk_fb_inf *fb_inf = platform_get_drvdata(g_fb_pdev);
-	if (!strcmp(fbi->fix.id,"fb0"))
-	{
-		res = platform_get_resource_byname(g_fb_pdev, IORESOURCE_MEM, "fb0 buf");
-		if (res == NULL)
-		{
-			dev_err(&g_fb_pdev->dev, "failed to get memory for fb0 \n");
+	struct rk_fb *fb_inf = platform_get_drvdata(fb_pdev);
+	if (!strcmp(fbi->fix.id, "fb0")) {
+	#if  1
+		dma_addr_t fb_mem_phys;
+		unsigned long fb_mem_len;
+		void *fb_mem_virt;
+		fb_mem_len = 3 * (fbi->var.xres * fbi->var.yres) << 2;
+		fb_mem_virt = dma_alloc_writecombine(fbi->dev, fb_mem_len, &fb_mem_phys,
+			GFP_KERNEL);
+		if (!fb_mem_virt) {
+			pr_err("%s: Failed to allocate framebuffer\n", __func__);
+			return -ENOMEM;
+		}
+		fbi->fix.smem_len = fb_mem_len;
+		fbi->fix.smem_start = fb_mem_phys;
+		fbi->screen_base = fb_mem_virt;
+		memset(fbi->screen_base, 0, fbi->fix.smem_len);
+		printk(KERN_INFO "fb%d:phy:%lx>>vir:%p>>len:0x%x\n", fb_id,
+		fbi->fix.smem_start, fbi->screen_base, fbi->fix.smem_len);
+	#else
+		res = platform_get_resource_byname(fb_pdev,
+				IORESOURCE_MEM, "fb0 buf");
+		if (res == NULL) {
+			dev_err(&fb_pdev->dev, "failed to get memory for fb0 \n");
 			ret = -ENOENT;
 		}
 		fbi->fix.smem_start = res->start;
 		fbi->fix.smem_len = res->end - res->start + 1;
-		mem = request_mem_region(res->start, resource_size(res), g_fb_pdev->name);
+		mem = request_mem_region(res->start, resource_size(res),
+			fb_pdev->name);
 		fbi->screen_base = ioremap(res->start, fbi->fix.smem_len);
 		memset(fbi->screen_base, 0, fbi->fix.smem_len);
-		printk("fb%d:phy:%lx>>vir:%p>>len:0x%x\n",fb_id,
-		fbi->fix.smem_start,fbi->screen_base,fbi->fix.smem_len);
-	}
-	else
-	{	
+		printk(KERN_INFO "fb%d:phy:%lx>>vir:%p>>len:0x%x\n", fb_id,
+		fbi->fix.smem_start, fbi->screen_base, fbi->fix.smem_len);
+	#endif
+	} else {
 #if defined(CONFIG_FB_ROTATE) || !defined(CONFIG_THREE_FB_BUFFER)
-		res = platform_get_resource_byname(g_fb_pdev, IORESOURCE_MEM, "fb2 buf");
-		if (res == NULL)
-		{
-			dev_err(&g_fb_pdev->dev, "failed to get win0 memory \n");
+		res = platform_get_resource_byname(fb_pdev,
+			IORESOURCE_MEM, "fb2 buf");
+		if (res == NULL) {
+			dev_err(&fb_pdev->dev, "failed to get win0 memory \n");
 			ret = -ENOENT;
 		}
 		fbi->fix.smem_start = res->start;
 		fbi->fix.smem_len = res->end - res->start + 1;
-		mem = request_mem_region(res->start, resource_size(res), g_fb_pdev->name);
+		mem = request_mem_region(res->start, resource_size(res),
+			fb_pdev->name);
 		fbi->screen_base = ioremap(res->start, fbi->fix.smem_len);
 		memset(fbi->screen_base, 0, fbi->fix.smem_len);
-#else    //three buffer no need to copy
+#else    /*three buffer no need to copy*/
 		fbi->fix.smem_start = fb_inf->fb[0]->fix.smem_start;
 		fbi->fix.smem_len   = fb_inf->fb[0]->fix.smem_len;
 		fbi->screen_base    = fb_inf->fb[0]->screen_base;
 #endif
-		printk("fb%d:phy:%lx>>vir:%p>>len:0x%x\n",fb_id,
-			fbi->fix.smem_start,fbi->screen_base,fbi->fix.smem_len);	
+		printk(KERN_INFO "fb%d:phy:%lx>>vir:%p>>len:0x%x\n", fb_id,
+			fbi->fix.smem_start, fbi->screen_base, fbi->fix.smem_len);
 	}
 
 	fbi->screen_size = fbi->fix.smem_len;
-	layer_id = dev_drv->fb_get_layer(dev_drv,fbi->fix.id);
-	if(layer_id >= 0)
-	{
+	layer_id = dev_drv->ops->fb_get_layer(dev_drv, fbi->fix.id);
+	if (layer_id >= 0) {
 		par = dev_drv->layer_par[layer_id];
 		par->reserved = fbi->fix.smem_start;
 	}
 
-    return ret;
+	return ret;
 }
 
 static int rk_release_fb_buffer(struct fb_info *fbi)
 {
-	if(!fbi)
-	{
-		printk("no need release null fb buffer!\n");
-		return -EINVAL;
-	}
-	if(!strcmp(fbi->fix.id,"fb1")||!strcmp(fbi->fix.id,"fb3"))  //buffer for fb1 and fb3 are alloc by android
+	if (!strcmp(fbi->fix.id, "fb1") || !strcmp(fbi->fix.id, "fb3"))  /*buffer for fb1 and fb3 are alloc by android*/
 		return 0;
 	iounmap(fbi->screen_base);
-	release_mem_region(fbi->fix.smem_start,fbi->fix.smem_len);
+	release_mem_region(fbi->fix.smem_start, fbi->fix.smem_len);
 	return 0;
-	
+
 }
-static int init_layer_par(struct rk_lcdc_device_driver *dev_drv)
+static int init_layer_par(struct rk_lcdc_driver *dev_drv,struct layer_par *def_layer)
 {
-       int i;
-       struct layer_par * def_par = NULL;
-       int num_par = dev_drv->num_layer;
-       for(i = 0; i < num_par; i++)
-       {
-               struct layer_par *par = NULL;
-               par =  kzalloc(sizeof(struct layer_par), GFP_KERNEL);
-               if(!par)
-               {
-                       printk(KERN_ERR "kzmalloc for layer_par fail!");
-                       return   -ENOMEM;
-                       
-               }
-	       def_par = &dev_drv->def_layer_par[i];
-               strcpy(par->name,def_par->name);
-               par->id = def_par->id;
-               par->support_3d = def_par->support_3d;
-               dev_drv->layer_par[i] = par;
-       }
-               
-       return 0;
-       
-       
+	int i;
+	struct layer_par *def_par = NULL;
+	int num_par = dev_drv->num_layer;
+	for (i = 0; i < num_par; i++) {
+		struct layer_par *par = NULL;
+		par =  kzalloc(sizeof(struct layer_par), GFP_KERNEL);
+		if (!par) {
+			dev_err(dev_drv->dev, "kzmalloc for layer_par fail!");
+			return   -ENOMEM;
+		}
+		def_par = &def_layer[i];
+		strcpy(par->name, def_par->name);
+		par->id = def_par->id;
+		par->support_3d = def_par->support_3d;
+		dev_drv->layer_par[i] = par;
+	}
+
+	return 0;
 }
 
 
-static int init_lcdc_device_driver(struct rk_lcdc_device_driver *dev_drv,
-	struct rk_lcdc_device_driver *def_drv,int id)
+static int init_lcdc_device_driver(struct rk_fb *rk_fb,
+					struct layer_par *def_layer, int index)
 {
-	if(!def_drv)
-	{
-		printk(KERN_ERR "default lcdc device driver is null!\n");
-		return -EINVAL;
+	struct rk_lcdc_driver *dev_drv = rk_fb->lcdc_dev_drv[index];
+	rk_screen *screen = devm_kzalloc(dev_drv->dev, sizeof(rk_screen), GFP_KERNEL);
+	rk_screen *screen1;
+	if (!screen) {
+		dev_err(dev_drv->dev, "malloc screen for lcdc%d fail!", dev_drv->id);
+		return -ENOMEM;
 	}
-	if(!dev_drv)
-	{
-		printk(KERN_ERR "lcdc device driver is null!\n");
-		return -EINVAL;	
+	screen->screen_id = 0;
+	screen->lcdc_id = dev_drv->id;
+	dev_drv->screen0 = screen;
+	dev_drv->cur_screen = screen;
+	/* devie use one lcdc + rk61x scaler for dual display*/
+	if (rk_fb->disp_mode == ONE_DUAL) {
+		rk_screen *screen1 = devm_kzalloc(dev_drv->dev, 
+						sizeof(rk_screen), GFP_KERNEL);
+		if (screen1) {
+			dev_err(dev_drv->dev, "malloc screen1 for lcdc%d fail!", dev_drv->id);
+			return -ENOMEM;
+		}
+		screen1->screen_id = 1;
+		screen1->lcdc_id = 1;
+		dev_drv->screen1 = screen1;
 	}
-	sprintf(dev_drv->name, "lcdc%d",id);
-	dev_drv->id		= id;
-	dev_drv->open      	= def_drv->open;
-	dev_drv->init_lcdc 	= def_drv->init_lcdc;
-	dev_drv->ioctl 		= def_drv->ioctl;
-	dev_drv->blank 		= def_drv->blank;
-	dev_drv->set_par 	= def_drv->set_par;
-	dev_drv->pan_display 	= def_drv->pan_display;
-	dev_drv->suspend 	= def_drv->suspend;
-	dev_drv->resume 	= def_drv->resume;
-	dev_drv->load_screen 	= def_drv->load_screen;
-	dev_drv->def_layer_par 	= def_drv->def_layer_par;
-	dev_drv->num_layer	= def_drv->num_layer;
-	dev_drv->get_layer_state= def_drv->get_layer_state;
-	dev_drv->get_disp_info  = def_drv->get_disp_info;
-	dev_drv->ovl_mgr	= def_drv->ovl_mgr;
-	dev_drv->fps_mgr	= def_drv->fps_mgr;
-	if(def_drv->fb_get_layer)
-		dev_drv->fb_get_layer   = def_drv->fb_get_layer;
-	if(def_drv->fb_layer_remap)
-		dev_drv->fb_layer_remap = def_drv->fb_layer_remap;
-	if(def_drv->set_dsp_lut)
-		dev_drv->set_dsp_lut    = def_drv->set_dsp_lut;
-	if(def_drv->read_dsp_lut)
-		dev_drv->read_dsp_lut   = def_drv->read_dsp_lut;
-	if(def_drv->lcdc_hdmi_process)
-		dev_drv->lcdc_hdmi_process = def_drv->lcdc_hdmi_process;
-	if(def_drv->lcdc_reg_update)
-		dev_drv->lcdc_reg_update = def_drv->lcdc_reg_update;
-	if(def_drv->poll_vblank)
-		dev_drv->poll_vblank = def_drv->poll_vblank;
-	if(def_drv->dpi_open)
-		dev_drv->dpi_open = def_drv->dpi_open;
-	if(def_drv->dpi_layer_sel)
-		dev_drv->dpi_layer_sel = def_drv->dpi_layer_sel;
-	if(def_drv->dpi_status)
-		dev_drv->dpi_status = def_drv->dpi_status;
-	init_layer_par(dev_drv);
+	sprintf(dev_drv->name, "lcdc%d", dev_drv->id);
+	init_layer_par(dev_drv,def_layer);
 	init_completion(&dev_drv->frame_done);
 	spin_lock_init(&dev_drv->cpl_lock);
 	mutex_init(&dev_drv->fb_win_id_mutex);
-	dev_drv->fb_layer_remap(dev_drv,FB_DEFAULT_ORDER); //102
+	dev_drv->ops->fb_layer_remap(dev_drv, FB_DEFAULT_ORDER);
 	dev_drv->first_frame = 1;
-	
+	rk_disp_pwr_ctr_parse_dt(dev_drv);
+	rk_disp_pwr_enable(dev_drv);
+	rk_disp_prase_timing_dt(dev_drv);
+
 	return 0;
 }
- 
+
 #ifdef CONFIG_LOGO_LINUX_BMP
 static struct linux_logo *bmp_logo;
 static int fb_prepare_bmp_logo(struct fb_info *info, int rotate)
 {
 	bmp_logo = fb_find_logo(24);
 	if (bmp_logo == NULL) {
-		printk("%s error\n", __func__);
+		printk(KERN_INFO "%s error\n", __func__);
 		return 0;
 	}
 	return 1;
@@ -1648,184 +1653,171 @@ static int fb_prepare_bmp_logo(struct fb_info *info, int rotate)
 
 static void fb_show_bmp_logo(struct fb_info *info, int rotate)
 {
-	unsigned char *src=bmp_logo->data;
-	unsigned char *dst=info->screen_base;
+	unsigned char *src = bmp_logo->data;
+	unsigned char *dst = info->screen_base;
 	int i;
-	unsigned int Needwidth=(*(src-24)<<8)|(*(src-23));
-	unsigned int Needheight=(*(src-22)<<8)|(*(src-21));
-		
-	for(i=0;i<Needheight;i++)
-		memcpy(dst+info->var.xres*i*4, src+bmp_logo->width*i*4, Needwidth*4);
-	
+	unsigned int Needwidth = (*(src-24)<<8) | (*(src-23));
+	unsigned int Needheight = (*(src-22)<<8) | (*(src-21));
+
+	for (i = 0; i < Needheight; i++)
+		memcpy(dst+info->var.xres*i*4,
+			src+bmp_logo->width*i*4, Needwidth*4);
+
 }
 #endif
 
-int rk_fb_register(struct rk_lcdc_device_driver *dev_drv,
-	struct rk_lcdc_device_driver *def_drv,int id)
+/********************************
+*check if the primary lcdc has registerd,
+the primary lcdc mas register first
+*********************************/
+bool is_prmry_rk_lcdc_registered(void)
 {
-	struct rk_fb_inf *fb_inf = platform_get_drvdata(g_fb_pdev);
-	struct fb_info *fbi;
-	int i=0,ret = 0;
-	int lcdc_id = 0;
-	if(NULL == dev_drv)
-	{
-        	printk("null lcdc device driver?");
-        	return -ENOENT;
-    	}
-    	for(i=0;i<RK30_MAX_LCDC_SUPPORT;i++)
-	{
-        	if(NULL==fb_inf->lcdc_dev_drv[i])
-		{
-            		fb_inf->lcdc_dev_drv[i] = dev_drv;
-            		fb_inf->lcdc_dev_drv[i]->id = id;
-            		fb_inf->num_lcdc++;
-            		break;
-        	}
-    	}
-    	if(i==RK30_MAX_LCDC_SUPPORT)
-	{
-        	printk("rk_fb_register lcdc out of support %d",i);
-        	return -ENOENT;
-    	}
-    	lcdc_id = i;
-	init_lcdc_device_driver(dev_drv, def_drv,id);
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+	if (rk_fb->lcdc_dev_drv[0])
+		return  true;
+	else
+		return false;
+		
 	
-	dev_drv->init_lcdc(dev_drv);
-	/************fb set,one layer one fb ***********/
-	dev_drv->fb_index_base = fb_inf->num_fb;
-	for(i=0;i<dev_drv->num_layer;i++)
-	{
-		fbi= framebuffer_alloc(0, &g_fb_pdev->dev);
-		if(!fbi)
-		{
-		    dev_err(&g_fb_pdev->dev,">> fb framebuffer_alloc fail!");
-		    fbi = NULL;
-		    ret = -ENOMEM;
+}
+int rk_fb_register(struct rk_lcdc_driver *dev_drv,
+				struct layer_par *layer_par,int id)
+{
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+	struct fb_info *fbi;
+	int i = 0, ret = 0, index = 0;
+
+	if (rk_fb->num_lcdc == RK30_MAX_LCDC_SUPPORT)
+		return -ENXIO;
+		
+	for (i = 0; i < RK30_MAX_LCDC_SUPPORT; i++) {
+		if (!rk_fb->lcdc_dev_drv[i]) {
+			rk_fb->lcdc_dev_drv[i] = dev_drv;
+			rk_fb->lcdc_dev_drv[i]->id = id;
+			rk_fb->num_lcdc++;
+			break;
+		}
+	}
+
+	index = i;
+	init_lcdc_device_driver(rk_fb, layer_par, index);
+	dev_drv->ops->init_lcdc(dev_drv);
+	dev_drv->fb_index_base = rk_fb->num_fb;
+	for (i = 0; i < dev_drv->num_layer; i++) {
+		fbi = framebuffer_alloc(0, &fb_pdev->dev);
+		if (!fbi) {
+			dev_err(&fb_pdev->dev, "fb framebuffer_alloc fail!");
+			ret = -ENOMEM;
 		}
 		fbi->par = dev_drv;
 		fbi->var = def_var;
 		fbi->fix = def_fix;
-		sprintf(fbi->fix.id,"fb%d",fb_inf->num_fb);
-		fbi->var.xres = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->x_res;
-		fbi->var.yres = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->y_res;
+		sprintf(fbi->fix.id, "fb%d", rk_fb->num_fb);
+		fbi->var.xres = dev_drv->cur_screen->x_res;
+		fbi->var.yres = dev_drv->cur_screen->y_res;
 		fbi->var.grayscale |= (fbi->var.xres<<8) + (fbi->var.yres<<20);
-#ifdef  CONFIG_LOGO_LINUX_BMP
-		fbi->var.bits_per_pixel = 32; 
+#if defined(CONFIG_LOGO_LINUX_BMP)
+		fbi->var.bits_per_pixel = 32;
 #else
-		fbi->var.bits_per_pixel = 16; 
+		fbi->var.bits_per_pixel = 16;
 #endif
 		fbi->fix.line_length  = (fbi->var.xres)*(fbi->var.bits_per_pixel>>3);
 		fbi->var.xres_virtual = fbi->var.xres;
 		fbi->var.yres_virtual = fbi->var.yres;
-		fbi->var.width =  fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->width;
-		fbi->var.height = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->height;
-		fbi->var.pixclock = fb_inf->lcdc_dev_drv[lcdc_id]->pixclock;
-		fbi->var.left_margin = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->left_margin;
-		fbi->var.right_margin = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->right_margin;
-		fbi->var.upper_margin = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->upper_margin;
-		fbi->var.lower_margin = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->lower_margin;
-		fbi->var.vsync_len = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->vsync_len;
-		fbi->var.hsync_len = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->hsync_len;
-		fbi->fbops			 = &fb_ops;
-		fbi->flags			 = FBINFO_FLAG_DEFAULT;
-		fbi->pseudo_palette  = fb_inf->lcdc_dev_drv[lcdc_id]->layer_par[i]->pseudo_pal;
-		if (i == 0) //only alloc memory for main fb
-		{
-			rk_request_fb_buffer(fbi,fb_inf->num_fb);
-		}
+		fbi->var.width = dev_drv->cur_screen->width;
+		fbi->var.height = dev_drv->cur_screen->height;
+		fbi->var.pixclock = dev_drv->pixclock;
+		fbi->var.left_margin = dev_drv->cur_screen->left_margin;
+		fbi->var.right_margin = dev_drv->cur_screen->right_margin;
+		fbi->var.upper_margin = dev_drv->cur_screen->upper_margin;
+		fbi->var.lower_margin = dev_drv->cur_screen->lower_margin;
+		fbi->var.vsync_len = dev_drv->cur_screen->vsync_len;
+		fbi->var.hsync_len = dev_drv->cur_screen->hsync_len;
+		fbi->fbops = &fb_ops;
+		fbi->flags = FBINFO_FLAG_DEFAULT;
+		fbi->pseudo_palette = dev_drv->layer_par[i]->pseudo_pal;
+		if (i == 0) /* only alloc memory for main fb*/
+			rk_request_fb_buffer(fbi, rk_fb->num_fb);
 		ret = register_framebuffer(fbi);
-		if(ret<0)
-		{
-		    printk("%s>>fb%d register_framebuffer fail!\n",__func__,fb_inf->num_fb);
-		    ret = -EINVAL;
+		if (ret < 0) {
+			dev_err(&fb_pdev->dev, "%s fb%d register_framebuffer fail!\n",
+					__func__, rk_fb->num_fb);
+			return ret;
 		}
 		rkfb_create_sysfs(fbi);
-		fb_inf->fb[fb_inf->num_fb] = fbi;
-	        printk("%s>>>>>%s\n",__func__,fb_inf->fb[fb_inf->num_fb]->fix.id);
-	        fb_inf->num_fb++;
-		
-		if(i == 0)
-		{
+		rk_fb->fb[rk_fb->num_fb] = fbi;
+		dev_info(&fb_pdev->dev, "rockchip framebuffer registerd:%s\n", fbi->fix.id);
+		rk_fb->num_fb++;
+
+		if (i == 0) {
 			init_waitqueue_head(&dev_drv->vsync_info.wait);
-			ret = device_create_file(fbi->dev,&dev_attr_vsync);
-			if (ret) 
-			{
+			ret = device_create_file(fbi->dev, &dev_attr_vsync);
+			if (ret)
 				dev_err(fbi->dev, "failed to create vsync file\n");
-			}
 			dev_drv->vsync_info.thread = kthread_run(rk_fb_wait_for_vsync_thread,
-				dev_drv, "fb-vsync");
-
-			
-			if (dev_drv->vsync_info.thread == ERR_PTR(-ENOMEM)) 
-			{
+								dev_drv, "fb-vsync");
+			if (dev_drv->vsync_info.thread == ERR_PTR(-ENOMEM)) {
 				dev_err(fbi->dev, "failed to run vsync thread\n");
 				dev_drv->vsync_info.thread = NULL;
 			}
 			dev_drv->vsync_info.active = 1;
 		}
-			
+
 	}
+
+ /*show logo for primary display device*/
 #if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)
-    if(dev_drv->screen_ctr_info->prop == PRMRY) //show logo for primary display device
-    {
-	    fb_inf->fb[0]->fbops->fb_open(fb_inf->fb[0],1);
-	    fb_inf->fb[0]->fbops->fb_set_par(fb_inf->fb[0]);
+if (dev_drv->prop == PRMRY) {
+	rk_fb->fb[0]->fbops->fb_open(rk_fb->fb[0], 1);
+	rk_fb->fb[0]->fbops->fb_set_par(rk_fb->fb[0]);
 
 #if  defined(CONFIG_LOGO_LINUX_BMP)
-		if(fb_prepare_bmp_logo(fb_inf->fb[0], FB_ROTATE_UR)) {
-			/* Start display and show logo on boot */
-			fb_set_cmap(&fb_inf->fb[0]->cmap, fb_inf->fb[0]);
-			fb_show_bmp_logo(fb_inf->fb[0], FB_ROTATE_UR);
-			fb_inf->fb[0]->fbops->fb_pan_display(&(fb_inf->fb[0]->var), fb_inf->fb[0]);
+		if (fb_prepare_bmp_logo(rk_fb->fb[0], FB_ROTATE_UR)) {
+			fb_set_cmap(&rk_fb->fb[0]->cmap, rk_fb->fb[0]);
+			fb_show_bmp_logo(rk_fb->fb[0], FB_ROTATE_UR);
+			rk_fb->fb[0]->fbops->fb_pan_display(&(rk_fb->fb[0]->var),
+							rk_fb->fb[0]);
 		}
 #else
-		if(fb_prepare_logo(fb_inf->fb[0], FB_ROTATE_UR)) {
-			/* Start display and show logo on boot */
-			fb_set_cmap(&fb_inf->fb[0]->cmap, fb_inf->fb[0]);
-			fb_show_logo(fb_inf->fb[0], FB_ROTATE_UR);
-			fb_inf->fb[0]->fbops->fb_pan_display(&(fb_inf->fb[0]->var), fb_inf->fb[0]);
+		if (fb_prepare_logo(rk_fb->fb[0], FB_ROTATE_UR)) {
+			fb_set_cmap(&rk_fb->fb[0]->cmap, rk_fb->fb[0]);
+			fb_show_logo(rk_fb->fb[0], FB_ROTATE_UR);
+			rk_fb->fb[0]->fbops->fb_pan_display(&(rk_fb->fb[0]->var),
+								rk_fb->fb[0]);
 		}
 #endif
-	fb_inf->fb[0]->fbops->fb_ioctl(fb_inf->fb[0],RK_FBIOSET_CONFIG_DONE,0);
-		
-    }
+	rk_fb->fb[0]->fbops->fb_ioctl(rk_fb->fb[0],RK_FBIOSET_CONFIG_DONE, 0);
+}
 #endif
 	return 0;
-	
-	
+
+
 }
-int rk_fb_unregister(struct rk_lcdc_device_driver *dev_drv)
+
+int rk_fb_unregister(struct rk_lcdc_driver *dev_drv)
 {
 
-	struct rk_fb_inf *fb_inf = platform_get_drvdata(g_fb_pdev);
+	struct rk_fb *fb_inf = platform_get_drvdata(fb_pdev);
 	struct fb_info *fbi;
 	int fb_index_base = dev_drv->fb_index_base;
 	int fb_num = dev_drv->num_layer;
-	int i=0;
-	if(NULL == dev_drv)
-	{
-		printk(" no need to unregister null lcdc device driver!\n");
-		return -ENOENT;
-	}
+	int i = 0;
 
-	if(fb_inf->lcdc_dev_drv[i]->vsync_info.thread){
+	if (fb_inf->lcdc_dev_drv[i]->vsync_info.thread) {
 		fb_inf->lcdc_dev_drv[i]->vsync_info.irq_stop = 1;
 		kthread_stop(fb_inf->lcdc_dev_drv[i]->vsync_info.thread);
 	}
 
-	for(i = 0; i < fb_num; i++)
-	{
+	for (i = 0; i < fb_num; i++)
 		kfree(dev_drv->layer_par[i]);
-	}
 
-	for(i=fb_index_base;i<(fb_index_base+fb_num);i++)
-	{
+	for (i = fb_index_base; i < (fb_index_base+fb_num); i++) {
 		fbi = fb_inf->fb[i];
 		unregister_framebuffer(fbi);
-		//rk_release_fb_buffer(fbi);
-		framebuffer_release(fbi);	
+		/*rk_release_fb_buffer(fbi);*/
+		framebuffer_release(fbi);
 	}
-	fb_inf->lcdc_dev_drv[dev_drv->id]= NULL;
+	fb_inf->lcdc_dev_drv[dev_drv->id] = NULL;
 	fb_inf->num_lcdc--;
 
 	return 0;
@@ -1833,23 +1825,21 @@ int rk_fb_unregister(struct rk_lcdc_device_driver *dev_drv)
 
 
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
+#if defined(CONFIG_HAS_EARLYSUSPEND)
 struct suspend_info {
 	struct early_suspend early_suspend;
-	struct rk_fb_inf *inf;
+	struct rk_fb *inf;
 };
 
 static void rkfb_early_suspend(struct early_suspend *h)
 {
 	struct suspend_info *info = container_of(h, struct suspend_info,
 						early_suspend);
-	struct rk_fb_inf *inf = info->inf;
+	struct rk_fb *inf = info->inf;
 	int i;
-	for(i = 0; i < inf->num_lcdc; i++)
-	{
+	for (i = 0; i < inf->num_lcdc; i++) {
 		if (!inf->lcdc_dev_drv[i])
 			continue;
-			
 		inf->lcdc_dev_drv[i]->suspend(inf->lcdc_dev_drv[i]);
 	}
 }
@@ -1857,14 +1847,12 @@ static void rkfb_early_resume(struct early_suspend *h)
 {
 	struct suspend_info *info = container_of(h, struct suspend_info,
 						early_suspend);
-	struct rk_fb_inf *inf = info->inf;
+	struct rk_fb *inf = info->inf;
 	int i;
-	for(i = 0; i < inf->num_lcdc; i++)
-	{
+	for (i = 0; i < inf->num_lcdc; i++) {
 		if (!inf->lcdc_dev_drv[i])
 			continue;
-		
-		inf->lcdc_dev_drv[i]->resume(inf->lcdc_dev_drv[i]);	       // data out
+		inf->lcdc_dev_drv[i]->resume(inf->lcdc_dev_drv[i]);
 	}
 
 }
@@ -1878,73 +1866,89 @@ static struct suspend_info suspend_info = {
 };
 #endif
 
-static int __devinit rk_fb_probe (struct platform_device *pdev)
+static int rk_fb_probe(struct platform_device *pdev)
 {
-	struct rk_fb_inf *fb_inf = NULL;
-	int ret = 0;
-	g_fb_pdev=pdev;
-    	/* Malloc rk_fb_inf and set it to pdev for drvdata */
-	fb_inf = kzalloc(sizeof(struct rk_fb_inf), GFP_KERNEL);
-	if(!fb_inf)
-	{
-        	dev_err(&pdev->dev, ">>fb inf kmalloc fail!");
-        	ret = -ENOMEM;
-    	}
-	platform_set_drvdata(pdev,fb_inf);
+	struct rk_fb *rk_fb = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	u32 mode;
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	suspend_info.inf = fb_inf;
+	if (!np) {
+		dev_err(&pdev->dev, "Missing device tree node.\n");
+		return -EINVAL;
+	}
+	
+	rk_fb = devm_kzalloc(&pdev->dev, sizeof(struct rk_fb), GFP_KERNEL);
+	if (!rk_fb) {
+		dev_err(&pdev->dev, "kmalloc for rk fb fail!");
+		return  -ENOMEM;
+	}
+	platform_set_drvdata(pdev, rk_fb);
+
+	if (!of_property_read_u32(np, "rockchip,disp-mode", &mode)) {
+		rk_fb->disp_mode = mode;
+		
+	} else {
+		dev_err(&pdev->dev, "no disp-mode node found!");
+		return -ENODEV;
+	}
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	suspend_info.inf = rk_fb;
 	register_early_suspend(&suspend_info.early_suspend);
 #endif
-	printk("rk fb probe ok!\n");
-    return 0;
+	fb_pdev = pdev;
+	dev_info(&pdev->dev, "rockchip framebuffer driver probe\n");
+	return 0;
 }
 
-static int __devexit rk_fb_remove(struct platform_device *pdev)
+static int rk_fb_remove(struct platform_device *pdev)
 {
-	struct rk_fb_inf *fb_inf = platform_get_drvdata(pdev);
-	kfree(fb_inf);
-    	platform_set_drvdata(pdev, NULL);
-    	return 0;
+	struct rk_fb *rk_fb = platform_get_drvdata(pdev);
+	kfree(rk_fb);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
 }
 
 static void rk_fb_shutdown(struct platform_device *pdev)
 {
-	struct rk_fb_inf *inf = platform_get_drvdata(pdev);
+	struct rk_fb *rk_fb = platform_get_drvdata(pdev);
 	int i;
-	for(i = 0; i < inf->num_lcdc; i++)
-	{
-		if (!inf->lcdc_dev_drv[i])
+	for (i = 0; i < rk_fb->num_lcdc; i++) {
+		if (!rk_fb->lcdc_dev_drv[i])
 			continue;
 
 	}
-//	kfree(fb_inf);
-//	platform_set_drvdata(pdev, NULL);
-#ifdef CONFIG_HAS_EARLYSUSPEND
+
+#if	defined(CONFIG_HAS_EARLYSUSPEND)
 	unregister_early_suspend(&suspend_info.early_suspend);
 #endif
 }
 
+
+static const struct of_device_id rkfb_dt_ids[] = {
+	{ .compatible = "rockchip,rk-fb", },
+	{}
+};
+
 static struct platform_driver rk_fb_driver = {
 	.probe		= rk_fb_probe,
-	.remove		= __devexit_p(rk_fb_remove),
+	.remove		= rk_fb_remove,
 	.driver		= {
 		.name	= "rk-fb",
 		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(rkfb_dt_ids),
 	},
 	.shutdown   = rk_fb_shutdown,
 };
 
 static int __init rk_fb_init(void)
 {
-    return platform_driver_register(&rk_fb_driver);
+	return platform_driver_register(&rk_fb_driver);
 }
 
 static void __exit rk_fb_exit(void)
 {
-    platform_driver_unregister(&rk_fb_driver);
+	platform_driver_unregister(&rk_fb_driver);
 }
 
 subsys_initcall_sync(rk_fb_init);
 module_exit(rk_fb_exit);
-
diff --git a/drivers/video/rockchip/rkfb_sysfs.c b/drivers/video/rockchip/rkfb_sysfs.c
index 5714cf10d6a2..5193fa352693 100644
--- a/drivers/video/rockchip/rkfb_sysfs.c
+++ b/drivers/video/rockchip/rkfb_sysfs.c
@@ -4,7 +4,7 @@
  * Copyright (C) 2012 Rockchip Corporation
  * Author: yxj<yxj@rock-chips.com>
  *
- * Some code and ideas taken from 
+ * Some code and ideas taken from
  *drivers/video/omap2/omapfb/omapfb-sys.c
  *driver by Tomi Valkeinen.
  *
@@ -33,69 +33,64 @@
 #include <linux/rk_screen.h>
 #include <linux/rk_fb.h>
 
-
 static ssize_t show_screen_info(struct device *dev,
-		struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
-	rk_screen * screen = dev_drv->screen0;
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)fbi->par;
+	rk_screen *screen = dev_drv->screen0;
 	int fps;
-	u64 ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-		(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	return snprintf(buf, PAGE_SIZE,"xres:%d\nyres:%d\nfps:%d\n",
-		screen->x_res,screen->y_res,fps);
+	u64 ft = (u64) (screen->upper_margin + screen->lower_margin + screen->y_res + screen->vsync_len) * (screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len) * (dev_drv->pixclock);	// one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu, ft);
+	return snprintf(buf, PAGE_SIZE, "xres:%d\nyres:%d\nfps:%d\n",
+			screen->x_res, screen->y_res, fps);
 }
 
 static ssize_t show_disp_info(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			      struct device_attribute *attr, char *buf)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
-	int layer_id = dev_drv->fb_get_layer(dev_drv,fbi->fix.id);
-	if(dev_drv->get_disp_info)
-		return dev_drv->get_disp_info(dev_drv,buf,layer_id);
+	struct rk_lcdc_driver *dev_drv = (struct rk_lcdc_driver *)fbi->par;
+	int layer_id = dev_drv->ops->fb_get_layer(dev_drv, fbi->fix.id);
+	if (dev_drv->ops->get_disp_info)
+		return dev_drv->ops->get_disp_info(dev_drv, buf, layer_id);
 
 	return 0;
 }
 
 static ssize_t show_phys(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			 struct device_attribute *attr, char *buf)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
 	return snprintf(buf, PAGE_SIZE, "0x%lx-----0x%x\n",
-		fbi->fix.smem_start,fbi->fix.smem_len);
+			fbi->fix.smem_start, fbi->fix.smem_len);
 }
 
 static ssize_t show_virt(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			 struct device_attribute *attr, char *buf)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "0x%p-----0x%x\n",
-		fbi->screen_base,fbi->fix.smem_len);
+			fbi->screen_base, fbi->fix.smem_len);
 }
 
 static ssize_t show_fb_state(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			     struct device_attribute *attr, char *buf)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
-	int layer_id = dev_drv->fb_get_layer(dev_drv,fbi->fix.id);
-	int state = dev_drv->get_layer_state(dev_drv,layer_id);
-	return snprintf(buf, PAGE_SIZE, "%s\n",state?"enabled":"disabled");
-	
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
+	int layer_id = dev_drv->ops->fb_get_layer(dev_drv, fbi->fix.id);
+	int state = dev_drv->ops->get_layer_state(dev_drv, layer_id);
+	return snprintf(buf, PAGE_SIZE, "%s\n", state ? "enabled" : "disabled");
+
 }
 
 static ssize_t show_dual_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			      struct device_attribute *attr, char *buf)
 {
-	int mode=0;
+	int mode = 0;
 #if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
 	mode = 1;
 #elif defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
@@ -103,101 +98,95 @@ static ssize_t show_dual_mode(struct device *dev,
 #else
 	mode = 0;
 #endif
-	return snprintf(buf, PAGE_SIZE, "%d\n",mode);
-	
+	return snprintf(buf, PAGE_SIZE, "%d\n", mode);
+
 }
 
-static ssize_t set_fb_state(struct device *dev,struct device_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t set_fb_state(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
-	int layer_id = dev_drv->fb_get_layer(dev_drv,fbi->fix.id);
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
+	int layer_id = dev_drv->ops->fb_get_layer(dev_drv, fbi->fix.id);
 	int state;
 	int ret;
 	ret = kstrtoint(buf, 0, &state);
-	if(ret)
-	{
+	if (ret) {
 		return ret;
 	}
-	dev_drv->open(dev_drv,layer_id,state);
+	dev_drv->ops->open(dev_drv, layer_id, state);
 	return count;
 }
 
 static ssize_t show_overlay(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			    struct device_attribute *attr, char *buf)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
 	int ovl;
-	ovl =  dev_drv->ovl_mgr(dev_drv,0,0);
-	if(ovl < 0)
-	{
+	ovl = dev_drv->ops->ovl_mgr(dev_drv, 0, 0);
+	if (ovl < 0) {
 		return ovl;
 	}
 
 	return snprintf(buf, PAGE_SIZE, "%s\n",
-		ovl?"win0 on the top of win1":"win1 on the top of win0");
-	
+			ovl ? "win0 on the top of win1" :
+			"win1 on the top of win0");
+
 }
-static ssize_t set_overlay(struct device *dev,struct device_attribute *attr,
-	const char *buf, size_t count)
+
+static ssize_t set_overlay(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
 	int ovl;
 	int ret;
 	ret = kstrtoint(buf, 0, &ovl);
-	if(ret)
-	{
+	if (ret) {
 		return ret;
 	}
-	ret = dev_drv->ovl_mgr(dev_drv,ovl,1);
-	if(ret < 0)
-	{
+	ret = dev_drv->ops->ovl_mgr(dev_drv, ovl, 1);
+	if (ret < 0) {
 		return ret;
 	}
 
 	return count;
 }
 
-
 static ssize_t show_fps(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			struct device_attribute *attr, char *buf)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
 	int fps;
-	fps =  dev_drv->fps_mgr(dev_drv,0,0);
-	if(fps < 0)
-	{
+	fps = dev_drv->ops->fps_mgr(dev_drv, 0, 0);
+	if (fps < 0) {
 		return fps;
 	}
 
-	return snprintf(buf, PAGE_SIZE, "fps:%d\n",fps);
-	
+	return snprintf(buf, PAGE_SIZE, "fps:%d\n", fps);
+
 }
 
-static ssize_t set_fps(struct device *dev,struct device_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t set_fps(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
 	int fps;
 	int ret;
 	ret = kstrtoint(buf, 0, &fps);
-	if(ret)
-	{
+	if (ret) {
 		return ret;
 	}
-	ret = dev_drv->fps_mgr(dev_drv,fps,1);
-	if(ret < 0)
-	{
+	ret = dev_drv->ops->fps_mgr(dev_drv, fps, 1);
+	if (ret < 0) {
 		return ret;
 	}
 
@@ -205,125 +194,105 @@ static ssize_t set_fps(struct device *dev,struct device_attribute *attr,
 }
 
 static ssize_t show_fb_win_map(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr, char *buf)
 {
 	int ret;
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
 
 	mutex_lock(&dev_drv->fb_win_id_mutex);
-	ret = snprintf(buf, PAGE_SIZE,"fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
-		dev_drv->fb2_win_id);
+	ret =
+	    snprintf(buf, PAGE_SIZE, "fb0:win%d\nfb1:win%d\nfb2:win%d\n",
+		     dev_drv->fb0_win_id, dev_drv->fb1_win_id,
+		     dev_drv->fb2_win_id);
 	mutex_unlock(&dev_drv->fb_win_id_mutex);
 
 	return ret;
-	
+
 }
 
-static ssize_t set_fb_win_map(struct device *dev,struct device_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t set_fb_win_map(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
 {
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
 	int order;
 	int ret;
 	ret = kstrtoint(buf, 0, &order);
-	if((order != FB0_WIN2_FB1_WIN1_FB2_WIN0) && (order != FB0_WIN1_FB1_WIN2_FB2_WIN0 ) &&
-	   (order != FB0_WIN2_FB1_WIN0_FB2_WIN1) && (order != FB0_WIN0_FB1_WIN2_FB2_WIN1 ) &&
-	   (order != FB0_WIN0_FB1_WIN1_FB2_WIN2) && (order != FB0_WIN1_FB1_WIN0_FB2_WIN2 ))
-	{
+	if ((order != FB0_WIN2_FB1_WIN1_FB2_WIN0)
+	    && (order != FB0_WIN1_FB1_WIN2_FB2_WIN0)
+	    && (order != FB0_WIN2_FB1_WIN0_FB2_WIN1)
+	    && (order != FB0_WIN0_FB1_WIN2_FB2_WIN1)
+	    && (order != FB0_WIN0_FB1_WIN1_FB2_WIN2)
+	    && (order != FB0_WIN1_FB1_WIN0_FB2_WIN2)) {
 		printk(KERN_ERR "un supported map\n"
-				"you can use the following order:\n"
-			        "201:\n"
-			        "fb0-win1\n"
-			        "fb1-win0\n"
-			        "fb2-win2\n"
-			        "210:\n"
-			        "fb0-win0\n"
-			        "fb1-win1\n"
-			        "fb2-win2\n"			  
-				"120:\n"
-				"fb0-win0\n"
-				"fb1-win2\n"
-				"fb2-win1\n"			  
-				"102:\n"
-				"fb0-win2\n"
-				"fb1-win0\n"
-				"fb2-win1\n"			   
-				"021:\n"
-				"fb0-win1\n"
-				"fb1-win2\n"
-				"fb2-win0\n"			   
-				"012:\n"
-				"fb0-win2\n"
-				"fb1-win1\n"
-				"fb2-win0\n");
+		       "you can use the following order:\n" "201:\n"
+		       "fb0-win1\n" "fb1-win0\n" "fb2-win2\n" "210:\n"
+		       "fb0-win0\n" "fb1-win1\n" "fb2-win2\n" "120:\n"
+		       "fb0-win0\n" "fb1-win2\n" "fb2-win1\n" "102:\n"
+		       "fb0-win2\n" "fb1-win0\n" "fb2-win1\n" "021:\n"
+		       "fb0-win1\n" "fb1-win2\n" "fb2-win0\n" "012:\n"
+		       "fb0-win2\n" "fb1-win1\n" "fb2-win0\n");
 		return count;
-	}
-	else
-	{
-		dev_drv->fb_layer_remap(dev_drv,order);
+	} else {
+		dev_drv->ops->fb_layer_remap(dev_drv, order);
 	}
 
 	return count;
-	
-	
+
 }
 
 static ssize_t show_dsp_lut(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			    struct device_attribute *attr, char *buf)
 {
 
-	return 0;	
+	return 0;
 }
-static ssize_t set_dsp_lut(struct device *dev,struct device_attribute *attr,
-	const char *buf, size_t count)
+
+static ssize_t set_dsp_lut(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	int dsp_lut[256];
 	const char *start = buf;
-	int i=256,j,temp;
+	int i = 256, j, temp;
 	int space_max = 10;
 
 	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_lcdc_device_driver * dev_drv = 
-		(struct rk_lcdc_device_driver * )fbi->par;
-	
-	for(i=0;i<256;i++)
-	{
+	struct rk_lcdc_driver *dev_drv =
+	    (struct rk_lcdc_driver *)fbi->par;
+
+	for (i = 0; i < 256; i++) {
 		temp = i;
-		dsp_lut[i] = temp + (temp<<8) + (temp<<16);  //init by default value
+		dsp_lut[i] = temp + (temp << 8) + (temp << 16);	//init by default value
 	}
 	//printk("count:%d\n>>%s\n\n",count,start);
-	for(i=0;i<256;i++)
-	{
-		space_max = 10;  //max space number 10;
-		temp = simple_strtoul(start,NULL,10);
+	for (i = 0; i < 256; i++) {
+		space_max = 10;	//max space number 10;
+		temp = simple_strtoul(start, NULL, 10);
 		dsp_lut[i] = temp;
-		do
-		{
+		do {
 			start++;
 			space_max--;
-		}while ((*start != ' ')&&space_max);
-		
-		if(!space_max)
+		} while ((*start != ' ') && space_max);
+
+		if (!space_max)
 			break;
 		else
 			start++;
 	}
 #if 0
-	for(i=0;i<16;i++)
-	{
-		for(j=0;j<16;j++)
-			printk("0x%08x ",dsp_lut[i*16+j]);
+	for (i = 0; i < 16; i++) {
+		for (j = 0; j < 16; j++)
+			printk("0x%08x ", dsp_lut[i * 16 + j]);
 		printk("\n");
 	}
 #endif
-	dev_drv->set_dsp_lut(dev_drv,dsp_lut);
+	dev_drv->ops->set_dsp_lut(dev_drv, dsp_lut);
 
 	return count;
-	
+
 }
 
 static struct device_attribute rkfb_attrs[] = {
@@ -343,29 +312,23 @@ int rkfb_create_sysfs(struct fb_info *fbi)
 {
 	int r;
 	int t;
-	for (t = 0; t < ARRAY_SIZE(rkfb_attrs); t++)
-	{
-		r = device_create_file(fbi->dev,&rkfb_attrs[t]);
-		if (r)
-		{
-			dev_err(fbi->dev, "failed to create sysfs "
-					"file\n");
+	for (t = 0; t < ARRAY_SIZE(rkfb_attrs); t++) {
+		r = device_create_file(fbi->dev, &rkfb_attrs[t]);
+		if (r) {
+			dev_err(fbi->dev, "failed to create sysfs " "file\n");
 			return r;
 		}
 	}
-	
 
 	return 0;
 }
 
-void rkfb_remove_sysfs(struct rk_fb_inf *inf)
+void rkfb_remove_sysfs(struct rk_fb *rk_fb)
 {
 	int i, t;
 
-	for (i = 0; i < inf->num_fb; i++) {
+	for (i = 0; i < rk_fb->num_fb; i++) {
 		for (t = 0; t < ARRAY_SIZE(rkfb_attrs); t++)
-			device_remove_file(inf->fb[i]->dev,
-					&rkfb_attrs[t]);
+			device_remove_file(rk_fb->fb[i]->dev, &rkfb_attrs[t]);
 	}
 }
-
diff --git a/include/dt-bindings/rkfb/rk_fb.h b/include/dt-bindings/rkfb/rk_fb.h
new file mode 100644
index 000000000000..8a50ee68f81c
--- /dev/null
+++ b/include/dt-bindings/rkfb/rk_fb.h
@@ -0,0 +1,13 @@
+#ifndef _DT_BINDINGS_RKFB_H_
+#define _DT_BINDINGS_RKFB_H_
+#define GPIO 		0
+#define REGULATOR	1
+
+#define PRMRY		1		/*primary display device*/
+#define EXTEND		2		/*extend display device*/
+
+#define NO_DUAL		0
+#define ONE_DUAL	1
+#define DUAL		2
+
+#endif
diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.h
index c0dd4ace333b..9d703da59af4 100755
--- a/include/linux/rk_fb.h
+++ b/include/linux/rk_fb.h
@@ -18,18 +18,18 @@
 
 #include <linux/fb.h>
 #include <linux/platform_device.h>
-#include<linux/completion.h>
-#include<linux/spinlock.h>
-#include<asm/atomic.h>
-#include<mach/board.h>
-#include<linux/rk_screen.h>
+#include <linux/completion.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+#include <linux/rk_screen.h>
+#if defined(CONFIG_OF)
+#include <dt-bindings/rkfb/rk_fb.h>
+#endif
 
 #define RK30_MAX_LCDC_SUPPORT	4
 #define RK30_MAX_LAYER_SUPPORT	4
 #define RK_MAX_FB_SUPPORT       8
 
-
-
 #define FB0_IOCTL_STOP_TIMER_FLUSH		0x6001
 #define FB0_IOCTL_SET_PANEL				0x6002
 
@@ -54,20 +54,18 @@
 #define RK_FB_IOCTL_SET_I2P_EVEN_ADDR      0x5006
 #define RK_FBIOSET_OVERLAY_STATE     	0x5018
 #define RK_FBIOGET_OVERLAY_STATE   	0X4619
-#define RK_FBIOSET_ENABLE		0x5019	
+#define RK_FBIOSET_ENABLE		0x5019
 #define RK_FBIOGET_ENABLE		0x5020
 #define RK_FBIOSET_CONFIG_DONE		0x4628
 #define RK_FBIOSET_VSYNC_ENABLE		0x4629
 #define RK_FBIOPUT_NUM_BUFFERS 		0x4625
 #define RK_FBIOPUT_COLOR_KEY_CFG	0x4626
 
-
 /**rk fb events**/
 #define RK_LF_STATUS_FC                  0xef
 #define RK_LF_STATUS_FR                  0xee
 #define RK_LF_STATUS_NC                  0xfe
-#define RK_LF_MAX_TIMEOUT 			 (1600000UL << 6) //>0.64s
-
+#define RK_LF_MAX_TIMEOUT 			 (1600000UL << 6)	//>0.64s
 
 extern int rk_fb_poll_prmry_screen_vblank(void);
 extern int rk_fb_get_prmry_screen_ft(void);
@@ -77,15 +75,15 @@ extern bool rk_fb_poll_wait_frame_complete(void);
 **          display output interface supported by rockchip lcdc                       *
 ********************************************************************/
 /* */
-#define OUT_P888            0   //24bit screen,connect to lcdc D0~D23
-#define OUT_P666            1   //18bit screen,connect to lcdc D0~D17
-#define OUT_P565            2 
+#define OUT_P888            0	//24bit screen,connect to lcdc D0~D23
+#define OUT_P666            1	//18bit screen,connect to lcdc D0~D17
+#define OUT_P565            2
 #define OUT_S888x           4
 #define OUT_CCIR656         6
 #define OUT_S888            8
 #define OUT_S888DUMY        12
 #define OUT_P16BPP4         24
-#define OUT_D888_P666       0x21 //18bit screen,connect to lcdc D2~D7, D10~D15, D18~D23
+#define OUT_D888_P666       0x21	//18bit screen,connect to lcdc D2~D7, D10~D15, D18~D23
 #define OUT_D888_P565       0x22
 
 /**
@@ -93,68 +91,64 @@ extern bool rk_fb_poll_wait_frame_complete(void);
  */
 
 enum {
-    HAL_PIXEL_FORMAT_RGBA_8888          = 1,
-    HAL_PIXEL_FORMAT_RGBX_8888          = 2,
-    HAL_PIXEL_FORMAT_RGB_888            = 3,
-    HAL_PIXEL_FORMAT_RGB_565            = 4,
-    HAL_PIXEL_FORMAT_BGRA_8888          = 5,
-    HAL_PIXEL_FORMAT_RGBA_5551          = 6,
-    HAL_PIXEL_FORMAT_RGBA_4444          = 7,
-
-    /* 0x8 - 0xFF range unavailable */
-
-    /*
-     * 0x100 - 0x1FF
-     *
-     * This range is reserved for pixel formats that are specific to the HAL
-     * implementation.  Implementations can use any value in this range to
-     * communicate video pixel formats between their HAL modules.  These formats
-     * must not have an alpha channel.  Additionally, an EGLimage created from a
-     * gralloc buffer of one of these formats must be supported for use with the
-     * GL_OES_EGL_image_external OpenGL ES extension.
-     */
-
-    /*
-     * Android YUV format:
-     *
-     * This format is exposed outside of the HAL to software decoders and
-     * applications.  EGLImageKHR must support it in conjunction with the
-     * OES_EGL_image_external extension.
-     *
-     * YV12 is a 4:2:0 YCrCb planar format comprised of a WxH Y plane followed
-     * by (W/2) x (H/2) Cr and Cb planes.
-     *
-     * This format assumes
-     * - an even width
-     * - an even height
-     * - a horizontal stride multiple of 16 pixels
-     * - a vertical stride equal to the height
-     *
-     *   y_size = stride * height
-     *   c_size = ALIGN(stride/2, 16) * height/2
-     *   size = y_size + c_size * 2
-     *   cr_offset = y_size
-     *   cb_offset = y_size + c_size
-     *
-     */
-    HAL_PIXEL_FORMAT_YV12   = 0x32315659, // YCrCb 4:2:0 Planar
-
-
-
-    /* Legacy formats (deprecated), used by ImageFormat.java */
-    HAL_PIXEL_FORMAT_YCbCr_422_SP       = 0x10, // NV16
-    HAL_PIXEL_FORMAT_YCrCb_420_SP       = 0x11, // NV21
-    HAL_PIXEL_FORMAT_YCbCr_422_I        = 0x14, // YUY2
-    HAL_PIXEL_FORMAT_YCrCb_NV12         = 0x20, // YUY2
-    HAL_PIXEL_FORMAT_YCrCb_NV12_VIDEO   = 0x21, // YUY2
-    HAL_PIXEL_FORMAT_YCrCb_444          = 0x22, //yuv444
-
+	HAL_PIXEL_FORMAT_RGBA_8888 = 1,
+	HAL_PIXEL_FORMAT_RGBX_8888 = 2,
+	HAL_PIXEL_FORMAT_RGB_888 = 3,
+	HAL_PIXEL_FORMAT_RGB_565 = 4,
+	HAL_PIXEL_FORMAT_BGRA_8888 = 5,
+	HAL_PIXEL_FORMAT_RGBA_5551 = 6,
+	HAL_PIXEL_FORMAT_RGBA_4444 = 7,
+
+	/* 0x8 - 0xFF range unavailable */
+
+	/*
+	 * 0x100 - 0x1FF
+	 *
+	 * This range is reserved for pixel formats that are specific to the HAL
+	 * implementation.  Implementations can use any value in this range to
+	 * communicate video pixel formats between their HAL modules.  These formats
+	 * must not have an alpha channel.  Additionally, an EGLimage created from a
+	 * gralloc buffer of one of these formats must be supported for use with the
+	 * GL_OES_EGL_image_external OpenGL ES extension.
+	 */
+
+	/*
+	 * Android YUV format:
+	 *
+	 * This format is exposed outside of the HAL to software decoders and
+	 * applications.  EGLImageKHR must support it in conjunction with the
+	 * OES_EGL_image_external extension.
+	 *
+	 * YV12 is a 4:2:0 YCrCb planar format comprised of a WxH Y plane followed
+	 * by (W/2) x (H/2) Cr and Cb planes.
+	 *
+	 * This format assumes
+	 * - an even width
+	 * - an even height
+	 * - a horizontal stride multiple of 16 pixels
+	 * - a vertical stride equal to the height
+	 *
+	 *   y_size = stride * height
+	 *   c_size = ALIGN(stride/2, 16) * height/2
+	 *   size = y_size + c_size * 2
+	 *   cr_offset = y_size
+	 *   cb_offset = y_size + c_size
+	 *
+	 */
+	HAL_PIXEL_FORMAT_YV12 = 0x32315659,	// YCrCb 4:2:0 Planar
+
+	/* Legacy formats (deprecated), used by ImageFormat.java */
+	HAL_PIXEL_FORMAT_YCbCr_422_SP = 0x10,	// NV16
+	HAL_PIXEL_FORMAT_YCrCb_420_SP = 0x11,	// NV21
+	HAL_PIXEL_FORMAT_YCbCr_422_I = 0x14,	// YUY2
+	HAL_PIXEL_FORMAT_YCrCb_NV12 = 0x20,	// YUY2
+	HAL_PIXEL_FORMAT_YCrCb_NV12_VIDEO = 0x21,	// YUY2
+	HAL_PIXEL_FORMAT_YCrCb_444 = 0x22,	//yuv444
 
 };
 
-
 //display data format
-enum data_format{
+enum data_format {
 	ARGB888 = 0,
 	RGB888,
 	RGB565,
@@ -166,31 +160,31 @@ enum data_format{
 	ABGR888,
 };
 
-enum fb_win_map_order{
-	FB_DEFAULT_ORDER	   = 0,
+enum fb_win_map_order {
+	FB_DEFAULT_ORDER = 0,
 	FB0_WIN2_FB1_WIN1_FB2_WIN0 = 12,
-	FB0_WIN1_FB1_WIN2_FB2_WIN0 = 21, 
+	FB0_WIN1_FB1_WIN2_FB2_WIN0 = 21,
 	FB0_WIN2_FB1_WIN0_FB2_WIN1 = 102,
 	FB0_WIN0_FB1_WIN2_FB2_WIN1 = 120,
 	FB0_WIN0_FB1_WIN1_FB2_WIN2 = 210,
-	FB0_WIN1_FB1_WIN0_FB2_WIN2 = 201,       
+	FB0_WIN1_FB1_WIN0_FB2_WIN2 = 201,
 };
 
 struct rk_fb_rgb {
-	struct fb_bitfield	red;
-	struct fb_bitfield	green;
-	struct fb_bitfield	blue;
-	struct fb_bitfield	transp;
+	struct fb_bitfield red;
+	struct fb_bitfield green;
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;
 };
 
 struct rk_fb_vsync {
-	wait_queue_head_t	wait;
-	ktime_t			timestamp;
-	bool			active;
-	bool                    irq_stop;
-	int			irq_refcount;
-	struct mutex		irq_lock;
-	struct task_struct	*thread;
+	wait_queue_head_t wait;
+	ktime_t timestamp;
+	bool active;
+	bool irq_stop;
+	int irq_refcount;
+	struct mutex irq_lock;
+	struct task_struct *thread;
 };
 
 struct color_key_cfg {
@@ -199,38 +193,52 @@ struct color_key_cfg {
 	u32 win2_color_key_cfg;
 };
 
-typedef enum _TRSP_MODE
-{
-    TRSP_CLOSE = 0,
-    TRSP_FMREG,
-    TRSP_FMREGEX,
-    TRSP_FMRAM,
-    TRSP_FMRAMEX,
-    TRSP_MASK,
-    TRSP_INVAL
+struct pwr_ctr {
+	char name[32];
+	int type;
+	int gpio;
+	int atv_val;
+	char rgl_name[32];
+	int volt;
+	int delay;
+};
+
+struct rk_disp_pwr_ctr_list {
+	struct list_head list;
+	struct pwr_ctr pwr_ctr;
+};
+
+typedef enum _TRSP_MODE {
+	TRSP_CLOSE = 0,
+	TRSP_FMREG,
+	TRSP_FMREGEX,
+	TRSP_FMRAM,
+	TRSP_FMRAMEX,
+	TRSP_MASK,
+	TRSP_INVAL
 } TRSP_MODE;
 
 struct layer_par {
 	char name[5];
 	int id;
-	bool state; 	//on or off
-	u32	pseudo_pal[16];
-	u32 y_offset;       //yuv/rgb offset  -->LCDC_WINx_YRGB_MSTx
-	u32 c_offset;     //cb cr offset--->LCDC_WINx_CBR_MSTx
-	u32 xpos;         //start point in panel  --->LCDC_WINx_DSP_ST
+	bool state;		//on or off
+	u32 pseudo_pal[16];
+	u32 y_offset;		//yuv/rgb offset  -->LCDC_WINx_YRGB_MSTx
+	u32 c_offset;		//cb cr offset--->LCDC_WINx_CBR_MSTx
+	u32 xpos;		//start point in panel  --->LCDC_WINx_DSP_ST
 	u32 ypos;
-	u16 xsize;        // display window width/height  -->LCDC_WINx_DSP_INFO
-	u16 ysize;          
-	u16 xact;        //origin display window size -->LCDC_WINx_ACT_INFO
+	u16 xsize;		// display window width/height  -->LCDC_WINx_DSP_INFO
+	u16 ysize;
+	u16 xact;		//origin display window size -->LCDC_WINx_ACT_INFO
 	u16 yact;
-	u16 xvir;       //virtual width/height     -->LCDC_WINx_VIR
+	u16 xvir;		//virtual width/height     -->LCDC_WINx_VIR
 	u16 yvir;
 	unsigned long smem_start;
-	unsigned long cbr_start;  // Cbr memory start address
+	unsigned long cbr_start;	// Cbr memory start address
 	enum data_format format;
 
 	bool support_3d;
-    	u32 scale_yrgb_x;
+	u32 scale_yrgb_x;
 	u32 scale_yrgb_y;
 	u32 scale_cbcr_x;
 	u32 scale_cbcr_y;
@@ -244,189 +252,156 @@ struct layer_par {
 	u32 reserved;
 };
 
+struct rk_lcdc_driver;
+
+struct rk_lcdc_drv_ops {
+	int (*open) (struct rk_lcdc_driver * dev_drv, int layer_id, bool open);
+	int (*init_lcdc) (struct rk_lcdc_driver * dev_drv);
+	int (*ioctl) (struct rk_lcdc_driver * dev_drv, unsigned int cmd,
+		      unsigned long arg, int layer_id);
+	int (*suspend) (struct rk_lcdc_driver * dev_drv);
+	int (*resume) (struct rk_lcdc_driver * dev_drv);
+	int (*blank) (struct rk_lcdc_driver * dev_drv, int layer_id,
+		      int blank_mode);
+	int (*set_par) (struct rk_lcdc_driver * dev_drv, int layer_id);
+	int (*pan_display) (struct rk_lcdc_driver * dev_drv, int layer_id);
+	int (*lcdc_reg_update) (struct rk_lcdc_driver * dev_drv);
+	 ssize_t(*get_disp_info) (struct rk_lcdc_driver * dev_drv, char *buf,
+				  int layer_id);
+	int (*load_screen) (struct rk_lcdc_driver * dev_drv, bool initscreen);
+	int (*get_layer_state) (struct rk_lcdc_driver * dev_drv, int layer_id);
+	int (*ovl_mgr) (struct rk_lcdc_driver * dev_drv, int swap, bool set);	//overlay manager
+	int (*fps_mgr) (struct rk_lcdc_driver * dev_drv, int fps, bool set);
+	int (*fb_get_layer) (struct rk_lcdc_driver * dev_drv, const char *id);	//find layer for fb
+	int (*fb_layer_remap) (struct rk_lcdc_driver * dev_drv,
+			       enum fb_win_map_order order);
+	int (*set_dsp_lut) (struct rk_lcdc_driver * dev_drv, int *lut);
+	int (*read_dsp_lut) (struct rk_lcdc_driver * dev_drv, int *lut);
+	int (*lcdc_hdmi_process) (struct rk_lcdc_driver * dev_drv, int mode);	//some lcdc need to some process in hdmi mode
+	int (*poll_vblank) (struct rk_lcdc_driver * dev_drv);
+	int (*lcdc_rst) (struct rk_lcdc_driver * dev_drv);
+	int (*dpi_open) (struct rk_lcdc_driver * dev_drv, bool open);
+	int (*dpi_layer_sel) (struct rk_lcdc_driver * dev_drv, int layer_id);
+	int (*dpi_status) (struct rk_lcdc_driver * dev_drv);
 
-struct rk_lcdc_device_driver{
+};
+
+struct rk_lcdc_driver {
 	char name[6];
 	int id;
-	struct device  *dev;
-	
+	int prop;
+	struct device *dev;
+
 	struct layer_par *layer_par[RK_MAX_FB_SUPPORT];
 	struct layer_par *def_layer_par;
 	int num_layer;
-	int num_buf;				//the num_of buffer
-	int fb_index_base;                     //the first fb index of the lcdc device
-	rk_screen *screen0;		      //some platform have only one lcdc,but extend
-	rk_screen *screen1;		      //two display devices for dual display,such as rk2918,rk2928
-	rk_screen *cur_screen;		     //screen0 is primary screen ,like lcd panel,screen1 is  extend screen,like hdmi
+	int num_buf;		//the num_of buffer
+	int fb_index_base;	//the first fb index of the lcdc device
+	rk_screen *screen0;	//some platform have only one lcdc,but extend
+	rk_screen *screen1;	//two display devices for dual display,such as rk2918,rk2928
+	rk_screen *cur_screen;	//screen0 is primary screen ,like lcd panel,screen1 is  extend screen,like hdmi
 	u32 pixclock;
 
-	
-        char fb0_win_id;
-        char fb1_win_id;
-        char fb2_win_id;
-        struct mutex fb_win_id_mutex;
-	
-	struct completion  frame_done;		  //sync for pan_display,whe we set a new frame address to lcdc register,we must make sure the frame begain to display
-	spinlock_t  cpl_lock; 			 //lock for completion  frame done
-	int first_frame ;
-	struct rk_fb_vsync	 vsync_info;
-	int wait_fs;				//wait for new frame start in kernel
-	
+	char fb0_win_id;
+	char fb1_win_id;
+	char fb2_win_id;
+	struct mutex fb_win_id_mutex;
+
+	struct completion frame_done;	//sync for pan_display,whe we set a new frame address to lcdc register,we must make sure the frame begain to display
+	spinlock_t cpl_lock;	//lock for completion  frame done
+	int first_frame;
+	struct rk_fb_vsync vsync_info;
+	int wait_fs;		//wait for new frame start in kernel
+
 	struct rk29fb_info *screen_ctr_info;
-	int (*open)(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open);
-	int (*init_lcdc)(struct rk_lcdc_device_driver *dev_drv);
-	int (*ioctl)(struct rk_lcdc_device_driver *dev_drv, unsigned int cmd,unsigned long arg,int layer_id);
-	int (*suspend)(struct rk_lcdc_device_driver *dev_drv);
-	int (*resume)(struct rk_lcdc_device_driver *dev_drv);
-	int (*blank)(struct rk_lcdc_device_driver *dev_drv,int layer_id,int blank_mode);
-	int (*set_par)(struct rk_lcdc_device_driver *dev_drv,int layer_id);
-	int (*pan_display)(struct rk_lcdc_device_driver *dev_drv,int layer_id);
-	int (*lcdc_reg_update)(struct rk_lcdc_device_driver *dev_drv);
-	ssize_t (*get_disp_info)(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id);
-	int (*load_screen)(struct rk_lcdc_device_driver *dev_drv, bool initscreen);
-	int (*get_layer_state)(struct rk_lcdc_device_driver *dev_drv,int layer_id);
-	int (*ovl_mgr)(struct rk_lcdc_device_driver *dev_drv,int swap,bool set);  //overlay manager
-	int (*fps_mgr)(struct rk_lcdc_device_driver *dev_drv,int fps,bool set);
-	int (*fb_get_layer)(struct rk_lcdc_device_driver *dev_drv,const char *id);                                      //find layer for fb
-	int (*fb_layer_remap)(struct rk_lcdc_device_driver *dev_drv,enum fb_win_map_order order);
-	int (*set_dsp_lut)(struct rk_lcdc_device_driver *dev_drv,int *lut);
-	int (*read_dsp_lut)(struct rk_lcdc_device_driver *dev_drv,int *lut);
-	int (*lcdc_hdmi_process)(struct rk_lcdc_device_driver *dev_drv,int mode); //some lcdc need to some process in hdmi mode
-	int (*poll_vblank)(struct rk_lcdc_device_driver *dev_drv);
-	int (*lcdc_rst)(struct rk_lcdc_device_driver *dev_drv);
-	int (*dpi_open)(struct rk_lcdc_device_driver *dev_drv,bool open);
-	int (*dpi_layer_sel)(struct rk_lcdc_device_driver *dev_drv,int layer_id);
-	int (*dpi_status)(struct rk_lcdc_device_driver *dev_drv);
-	
+	struct list_head pwrlist_head;
+	struct rk_lcdc_drv_ops *ops;
+
 };
 
-struct rk_fb_inf {
-	struct rk29fb_info * mach_info;     //lcd io control info
+/*disp_mode: dual display mode
+*	        NO_DUAL,no dual display,
+	        ONE_DUAL,use one lcdc + rk61x for dual display
+	        DUAL,use 2 lcdcs for dual display
+  num_fb:       the total number of fb
+  num_lcdc:    the total number of lcdc
+*/
+
+struct rk_fb {
+	int disp_mode;
+	struct rk29fb_info *mach_info;
 	struct fb_info *fb[RK_MAX_FB_SUPPORT];
 	int num_fb;
 
-	struct rk_lcdc_device_driver *lcdc_dev_drv[RK30_MAX_LCDC_SUPPORT];
+	struct rk_lcdc_driver *lcdc_dev_drv[RK30_MAX_LCDC_SUPPORT];
 	int num_lcdc;
 
-	int video_mode;  //when play video set it to 1
-	struct workqueue_struct *workqueue;
-	struct delayed_work delay_work;
 };
-extern int rk_fb_register(struct rk_lcdc_device_driver *dev_drv,
-	struct rk_lcdc_device_driver *def_drv,int id);
-extern int rk_fb_unregister(struct rk_lcdc_device_driver *dev_drv);
+extern int rk_fb_register(struct rk_lcdc_driver *dev_drv,
+				struct layer_par *layer_par, int id);
+extern int rk_fb_unregister(struct rk_lcdc_driver *dev_drv);
 extern int get_fb_layer_id(struct fb_fix_screeninfo *fix);
-extern struct rk_lcdc_device_driver * rk_get_lcdc_drv(char *name);
-extern rk_screen * rk_fb_get_prmry_screen(void);
-u32 rk_fb_get_prmry_screen_pixclock(void);
+extern struct rk_lcdc_driver *rk_get_lcdc_drv(char *name);
+extern rk_screen *rk_fb_get_prmry_screen(void);
+extern u32 rk_fb_get_prmry_screen_pixclock(void);
+extern int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv);
+extern int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv);
+extern int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv);
+extern bool is_prmry_rk_lcdc_registered(void);
+
+static int inline support_uboot_display(void)
+{
+	return 0;
+}
+
+extern int rk_disp_prase_timing_dt(struct rk_lcdc_driver *dev_drv);
 
 extern int rk_fb_dpi_open(bool open);
 extern int rk_fb_dpi_layer_sel(int layer_id);
 extern int rk_fb_dpi_status(void);
 
-extern int rk_fb_switch_screen(rk_screen *screen ,int enable ,int lcdc_id);
-extern int rk_fb_disp_scale(u8 scale_x, u8 scale_y,u8 lcdc_id);
+extern int rk_fb_switch_screen(rk_screen * screen, int enable, int lcdc_id);
+extern int rk_fb_disp_scale(u8 scale_x, u8 scale_y, u8 lcdc_id);
 extern int rkfb_create_sysfs(struct fb_info *fbi);
-extern char * get_format_string(enum data_format,char *fmt);
+extern char *get_format_string(enum data_format, char *fmt);
 extern int support_uboot_display(void);
-static int inline rk_fb_calc_fps(rk_screen *screen,u32 pixclock)
+static int inline rk_fb_calc_fps(rk_screen * screen, u32 pixclock)
 {
 	int x, y;
 	unsigned long long hz;
-	if(!screen)
-	{
-		printk(KERN_ERR "%s:null screen!\n",__func__);
+	if (!screen) {
+		printk(KERN_ERR "%s:null screen!\n", __func__);
 		return 0;
 	}
-	x = screen->x_res + screen->left_margin + screen->right_margin + screen->hsync_len;
-	y = screen->y_res + screen->upper_margin + screen->lower_margin + screen->vsync_len;
+	x = screen->x_res + screen->left_margin + screen->right_margin +
+	    screen->hsync_len;
+	y = screen->y_res + screen->upper_margin + screen->lower_margin +
+	    screen->vsync_len;
 
-	hz = 1000000000000ULL;		/* 1e12 picoseconds per second */
+	hz = 1000000000000ULL;	/* 1e12 picoseconds per second */
 
 	hz += (x * y) / 2;
-	do_div(hz, x * y);		/* divide by x * y with rounding */
+	do_div(hz, x * y);	/* divide by x * y with rounding */
 
 	hz += pixclock / 2;
-	do_div(hz,pixclock);		/* divide by pixclock with rounding */
+	do_div(hz, pixclock);	/* divide by pixclock with rounding */
 
-	return  hz;
+	return hz;
 }
 
-static int inline __rk_platform_add_display_devices(struct platform_device *fb,
-	struct platform_device *lcdc0,struct platform_device *lcdc1,
-	struct platform_device *bl)
+#if defined(CONFIG_BACKLIGHT_RK29_BL)
+void rk29_backlight_set(bool on);
+bool rk29_get_backlight_status(void);
+#else
+static void rk29_backlight_set(bool on)
 {
-	struct rk29fb_info *lcdc0_screen_info = NULL;
-	struct rk29fb_info *lcdc1_screen_info = NULL;
-	struct platform_device *prmry_lcdc = NULL;
-	struct platform_device *extend_lcdc = NULL;
-	
-	if(!fb)
-	{
-		printk(KERN_ERR "warning:no rockchip fb device!\n");
-	}
-	else
-	{
-		platform_device_register(fb);
-	}
-
-	if((!lcdc0)&&(!lcdc1))
-	{
-		printk(KERN_ERR "warning:no lcdc device!\n");
-	}
-	else
-	{
-		if(lcdc0)
-		{
-			lcdc0_screen_info = lcdc0->dev.platform_data;
-			if(lcdc0_screen_info->prop == PRMRY)
-			{
-				prmry_lcdc = lcdc0;
-				printk(KERN_INFO "lcdc0 is used as primary display device contoller!\n");
-			}
-			else
-			{
-				extend_lcdc = lcdc0;
-				printk(KERN_INFO "lcdc0 is used as external display device contoller!\n");
-			}
-				
-			
-		}
-		else
-		{
-			printk(KERN_INFO "warning:lcdc0 not add to system!\n");
-		}
-		
-		if(lcdc1)
-		{
-			lcdc1_screen_info = lcdc1->dev.platform_data;
-			if(lcdc1_screen_info->prop == PRMRY)
-			{
-				prmry_lcdc = lcdc1;
-				printk(KERN_INFO "lcdc1 is used as primary display device controller!\n");
-			}
-			else
-			{
-				extend_lcdc = lcdc1;
-				printk(KERN_INFO "lcdc1 is used as external display device controller!\n");
-			}
-				
-			
-		}
-		else
-		{
-			printk(KERN_INFO "warning:lcdc1 not add to system!\n");
-		}
-	}
-
-	if(prmry_lcdc)
-		platform_device_register(prmry_lcdc);
-	if(extend_lcdc)
-		platform_device_register(extend_lcdc);
-	if(bl)
-		platform_device_register(bl);
+	while (0) ;
+}
 
-	return 0;
+static bool rk29_get_backlight_status(void)
+{
+	return false;
 }
+#endif
 
 #endif
diff --git a/include/linux/rk_screen.h b/include/linux/rk_screen.h
index 54320f249960..1e68c911441a 100755
--- a/include/linux/rk_screen.h
+++ b/include/linux/rk_screen.h
@@ -78,11 +78,6 @@ typedef enum _MCU_STATUS {
 
 } MCU_STATUS;
 
-enum rk_disp_prop{       //display device property
-    PRMRY = 1,                     //primary display device ,like LCD screen
-    EXTEND,                        //extend display device ,like hdmi ,tv out
-};
-
 struct rk29_fb_setting_info {
 	u8 data_num;
 	u8 vsync_en;
@@ -201,7 +196,7 @@ typedef struct rk29fb_screen {
 
 struct rk29fb_info {
 	u32 fb_id;
-	enum rk_disp_prop prop;		//display device property,like PRMRY,EXTEND
+	int prop;		//display device property,like PRMRY,EXTEND
 	u32 mcu_fmk_pin;
 	struct rk29lcd_info *lcd_info;
 	int (*io_init)(struct rk29_fb_setting_info *fb_setting);
-- 
2.35.3

