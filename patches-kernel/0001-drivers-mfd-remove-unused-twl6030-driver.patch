From e77e72667412015ffe7394b13a51568127a61280 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Sat, 3 Nov 2018 14:48:02 +0800
Subject: [PATCH] drivers/mfd: remove unused twl6030 driver

Change-Id: I1edeb3c4cce065bce8efa578b6b118cdd1d286a3
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/input/misc/twl6030-pwrbutton.c |  210 --
 drivers/mfd/twl6030-gpadc.c            | 1455 -----------
 drivers/mfd/twl6030-madc.c             |  354 ---
 drivers/mfd/twl6030-power.c            |  362 ---
 drivers/mfd/twl6030-poweroff.c         |   74 -
 drivers/power/twl6030_bci_battery.c    | 3331 ------------------------
 include/linux/i2c/twl6030-gpadc.h      |  152 --
 include/linux/i2c/twl6030-madc.h       |   86 -
 8 files changed, 6024 deletions(-)
 delete mode 100755 drivers/input/misc/twl6030-pwrbutton.c
 delete mode 100755 drivers/mfd/twl6030-gpadc.c
 delete mode 100644 drivers/mfd/twl6030-madc.c
 delete mode 100644 drivers/mfd/twl6030-power.c
 delete mode 100644 drivers/mfd/twl6030-poweroff.c
 delete mode 100644 drivers/power/twl6030_bci_battery.c
 delete mode 100644 include/linux/i2c/twl6030-gpadc.h
 delete mode 100644 include/linux/i2c/twl6030-madc.h

diff --git a/drivers/input/misc/twl6030-pwrbutton.c b/drivers/input/misc/twl6030-pwrbutton.c
deleted file mode 100755
index 0ff9a1128f40..000000000000
--- a/drivers/input/misc/twl6030-pwrbutton.c
+++ /dev/null
@@ -1,210 +0,0 @@
-/**
- * twl6030-pwrbutton.c - TWL6030 Power Button Input Driver
- *
- * Copyright (C) 2011
- *
- * Written by Dan Murphy <DMurphy@ti.com>
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License. See the file "COPYING" in the main directory of this
- * archive for more details.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Derived Work from: twl4030-pwrbutton.c from
- * Peter De Schrijver <peter.de-schrijver@nokia.com>
- * Felipe Balbi <felipe.balbi@nokia.com>
- *
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/i2c/twl.h>
-#include <linux/delay.h>
-
-#define PWR_PWRON_IRQ (1 << 0)
-#define STS_HW_CONDITIONS 0x21
-
-struct twl6030_pwr_button {
-	struct input_dev *input_dev;
-	struct device		*dev;
-	struct mutex		irq_lock;
-	int report_key;
-};
-
-static inline int twl6030_readb(struct twl6030_pwr_button *twl,
-		u8 module, u8 address)
-{
-	u8 data = 0;
-	int ret = 0;
-
-	ret = twl_i2c_read_u8(module, &data, address);
-	if (ret >= 0)
-		ret = data;
-	else
-		dev_dbg(twl->dev,
-			"TWL6030:readb[0x%x,0x%x] Error %d\n",
-					module, address, ret);
-
-	return ret;
-}
-
-static inline int twl6030_writeb(struct twl6030_pwr_button *twl, u8 module,
-						u8 data, u8 address)
-{
-	int ret = 0;
-
-	ret = twl_i2c_write_u8(module, data, address);
-	if (ret < 0)
-		dev_dbg(twl->dev,
-			"TWL6030:Write[0x%x] Error %d\n", address, ret);
-	return ret;
-}
-
-static irqreturn_t powerbutton_irq(int irq, void *_pwr)
-{
-	struct twl6030_pwr_button *pwr = _pwr;
-	int hw_state;
-	int pwr_val;
-	static int prev_hw_state = 0xFFFF;
-	static int push_release_flag = 0 ;
-	
-	mutex_lock(& pwr ->irq_lock);
-	hw_state = twl6030_readb(pwr, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);
-	pwr_val = !(hw_state & PWR_PWRON_IRQ);
-
-	if ((prev_hw_state != pwr_val) && (prev_hw_state != 0xFFFF)) {
-		push_release_flag = 0;
-		input_report_key(pwr->input_dev, pwr->report_key, pwr_val);
-		input_sync(pwr->input_dev);
-	} else if (!push_release_flag) {
-		push_release_flag = 1;
-		if(prev_hw_state != 0xFFFF){
-			input_report_key(pwr->input_dev, pwr->report_key, !pwr_val);
-			input_sync(pwr->input_dev);
-
-			msleep(20);
-			input_report_key(pwr->input_dev, pwr->report_key, pwr_val);
-			input_sync(pwr->input_dev);
-		}
-		else	{
-			input_report_key(pwr->input_dev, pwr->report_key, pwr_val);
-			input_sync(pwr->input_dev);
-		}
-	} else
-		push_release_flag = 0;
-
-	prev_hw_state = pwr_val;
-	mutex_unlock(& pwr ->irq_lock);
-
-	return IRQ_HANDLED;
-}
-
-static int __devinit twl6030_pwrbutton_probe(struct platform_device *pdev)
-{
-	struct twl6030_pwr_button *pwr_button;
-	int irq = platform_get_irq(pdev, 0);
-	int err = -ENODEV;
-
-	pr_info("%s: Enter\n", __func__);
-	pwr_button = kzalloc(sizeof(struct twl6030_pwr_button), GFP_KERNEL);
-	if (!pwr_button)
-		return -ENOMEM;
-
-	pwr_button->input_dev = input_allocate_device();
-	if (!pwr_button->input_dev) {
-		dev_dbg(&pdev->dev, "Can't allocate power button\n");
-		goto input_error;
-	}
-
-	__set_bit(EV_KEY, pwr_button->input_dev->evbit);
-
-	pwr_button->report_key = KEY_POWER;
-	pwr_button->dev = &pdev->dev;
-	pwr_button->input_dev->evbit[0] = BIT_MASK(EV_KEY);
-	pwr_button->input_dev->keybit[BIT_WORD(pwr_button->report_key)] =
-			BIT_MASK(pwr_button->report_key);
-	pwr_button->input_dev->name = "twl6030_pwrbutton";
-	pwr_button->input_dev->phys = "twl6030_pwrbutton/input0";
-	pwr_button->input_dev->dev.parent = &pdev->dev;
-
-	err = request_threaded_irq(irq, NULL, powerbutton_irq,
-			IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
-			"twl6030_pwrbutton", pwr_button);
-	if (err < 0) {
-		dev_dbg(&pdev->dev, "Can't get IRQ for pwrbutton: %d\n", err);
-		goto free_input_dev;
-	}
-
-	err = input_register_device(pwr_button->input_dev);
-	if (err) {
-		dev_dbg(&pdev->dev, "Can't register power button: %d\n", err);
-		goto free_irq;
-	}
-	mutex_init(&pwr_button->irq_lock);
-
-	twl6030_interrupt_unmask(0x01, REG_INT_MSK_LINE_A);
-	twl6030_interrupt_unmask(0x01, REG_INT_MSK_STS_A);
-
-	platform_set_drvdata(pdev, pwr_button);
-
-	return 0;
-
-free_irq:
-	free_irq(irq, NULL);
-free_input_dev:
-	input_free_device(pwr_button->input_dev);
-input_error:
-	kfree(pwr_button);
-	return err;
-}
-
-static int __devexit twl6030_pwrbutton_remove(struct platform_device *pdev)
-{
-	struct input_dev *pwr = platform_get_drvdata(pdev);
-	int irq = platform_get_irq(pdev, 0);
-
-	free_irq(irq, pwr);
-	input_unregister_device(pwr);
-
-	return 0;
-}
-
-struct platform_driver twl6030_pwrbutton_driver = {
-	.probe		= twl6030_pwrbutton_probe,
-	.remove		= __devexit_p(twl6030_pwrbutton_remove),
-	.driver		= {
-		.name	= "twl6030_pwrbutton",
-		.owner	= THIS_MODULE,
-	},
-};
-
-static int __init twl6030_pwrbutton_init(void)
-{
-	return platform_driver_register(&twl6030_pwrbutton_driver);
-}
-module_init(twl6030_pwrbutton_init);
-
-static void __exit twl6030_pwrbutton_exit(void)
-{
-	platform_driver_unregister(&twl6030_pwrbutton_driver);
-}
-module_exit(twl6030_pwrbutton_exit);
-
-MODULE_ALIAS("platform:twl6030_pwrbutton");
-MODULE_DESCRIPTION("Triton2 Power Button");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Dan Murphy <DMurphy@ti.com>");
diff --git a/drivers/mfd/twl6030-gpadc.c b/drivers/mfd/twl6030-gpadc.c
deleted file mode 100755
index 5265763ae0db..000000000000
--- a/drivers/mfd/twl6030-gpadc.c
+++ /dev/null
@@ -1,1455 +0,0 @@
-/*
- * drivers/i2c/chips/twl6030-gpadc.c
- *
- * TWL6030 GPADC module driver
- *
- * Copyright (C) 2009 Texas Instruments Inc.
- * Nishant Kamat <nskamat@ti.com>
- *
- * Based on twl4030-madc.c
- * Copyright (C) 2008 Nokia Corporation
- * Mikko Ylinen <mikko.k.ylinen@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/platform_device.h>
-#include <linux/miscdevice.h>
-#include <linux/slab.h>
-#include <linux/hwmon-sysfs.h>
-#include <linux/i2c/twl.h>
-#include <linux/i2c/twl6030-gpadc.h>
-
-#include <linux/uaccess.h>
-
-#define TWL6030_GPADC_PFX	"twl6030-gpadc: "
-#define ENABLE_GPADC	0x02
-#define REG_TOGGLE1	0x90
-#define GPADCS		(1 << 1)
-#define GPADCR		(1 << 0)
-
-#define SCALE				(1 << 15)
-
-struct twl6030_chnl_calib {
-	s32 gain_error;
-	s32 offset_error;
-};
-
-struct twl6030_ideal_code {
-	s16 code1;
-	s16 code2;
-};
-
-struct twl6032_chnl_calib {
-	s32 gain;
-	s32 gain_error;
-	s32 offset_error;
-};
-
-struct twl6032_ideal_code {
-	s16 code1;
-	s16 code2;
-	s16 v1;
-	s16 v2;
-};
-
-static struct twl6030_chnl_calib
-	twl6030_calib_tbl[GPADC_MAX_CHANNELS];
-static const u32 calibration_bit_map = 0x47FF;
-
-/* Trim address where measured offset from ideal code is stored */
-static const u8 twl6030_trim_addr[GPADC_MAX_CHANNELS] = {
-	0xCD, /* CHANNEL 0 */
-	0xD1, /* CHANNEL 1 */
-	0xD9, /* CHANNEL 2 */
-	0xD1, /* CHANNEL 3 */
-	0xD1, /* CHANNEL 4 */
-	0xD1, /* CHANNEL 5 */
-	0xD1, /* CHANNEL 6 */
-	0xD3, /* CHANNEL 7 */
-	0xCF, /* CHANNEL 8 */
-	0xD5, /* CHANNEL 9 */
-	0xD7, /* CHANNEL 10 */
-	0x00, /* CHANNEL 11 */
-	0x00, /* CHANNEL 12 */
-	0x00, /* CHANNEL 13 */
-	0xDB, /* CHANNEL 14 */
-	0x00, /* CHANNEL 15 */
-	0x00, /* CHANNEL 16 */
-};
-
-#define TWL6032_GPADC_TRIM1	0xCD
-#define TWL6032_GPADC_TRIM2	0xCE
-#define TWL6032_GPADC_TRIM3	0xCF
-#define TWL6032_GPADC_TRIM4	0xD0
-#define TWL6032_GPADC_TRIM5	0xD1
-#define TWL6032_GPADC_TRIM6	0xD2
-#define TWL6032_GPADC_TRIM7	0xD3
-#define TWL6032_GPADC_TRIM8	0xD4
-#define TWL6032_GPADC_TRIM9	0xD5
-#define TWL6032_GPADC_TRIM10	0xD6
-#define TWL6032_GPADC_TRIM11	0xD7
-#define TWL6032_GPADC_TRIM12	0xD8
-#define TWL6032_GPADC_TRIM13	0xD9
-#define TWL6032_GPADC_TRIM14	0xDA
-#define TWL6032_GPADC_TRIM15	0xDB
-#define TWL6032_GPADC_TRIM16	0xDC
-#define TWL6032_GPADC_TRIM19	0xFD
-
-/*
- * actual scaler gain is multiplied by 8 for fixed point operation
- * 1.875 * 8 = 15
- * For channels 0, 1, 3, 4, 5, 6, 12, 13
- * 1.25 * 8 = 10
- * is used, as scaler is Vref * divider
- * Vref = 1.25
- */
-static const u16 twl6030_gain[TWL6030_GPADC_MAX_CHANNELS] = {
-	10,	/* CHANNEL 0 */
-	10,	/* CHANNEL 1 */
-
-	/* 1.875 */
-	15,	/* CHANNEL 2 */
-
-	10,	/* CHANNEL 3 */
-	10,	/* CHANNEL 4 */
-	10,	/* CHANNEL 5 */
-	10,	/* CHANNEL 6 */
-
-	/* 5 */
-	40,	/* CHANNEL 7 */
-
-	/* 6.25 */
-	50,	/* CHANNEL 8 */
-
-	/* 11.25 */
-	90,	/* CHANNEL 9 */
-
-	/* 6.875 */
-	55,	/* CHANNEL 10 */
-
-	/* 1.875 */
-	15,	/* CHANNEL 11 */
-
-	10,	/* CHANNEL 12 */
-	10,	/* CHANNEL 13 */
-
-	/* 6.875 */
-	55,	/* CHANNEL 14 */
-
-	/* 6.25 */
-	50,	/* CHANNEL 15 */
-
-	/* 4.75 */
-	38,	/* CHANNEL 16 */
-};
-
-/*
- * calibration not needed for channel 11, 12, 13, 15 and 16
- * calibration offset is same for channel 1, 3, 4, 5
- */
-static const struct twl6030_ideal_code
-	twl6030_ideal[GPADC_MAX_CHANNELS] = {
-	{116,	745},	/* CHANNEL 0 */
-	{82,	900},	/* CHANNEL 1 */
-	{55,	818},	/* CHANNEL 2 */
-	{82,	900},	/* CHANNEL 3 */
-	{82,	900},	/* CHANNEL 4 */
-	{82,	900},	/* CHANNEL 5 */
-	{82,	900},	/* CHANNEL 6 */
-	{614,	941},	/* CHANNEL 7 */
-	{82,	688},	/* CHANNEL 8 */
-	{182,	818},	/* CHANNEL 9 */
-	{149,	818},	/* CHANNEL 10 */
-	{0,	0},	/* CHANNEL 11 */
-	{0,	0},	/* CHANNEL 12 */
-	{0,	0},	/* CHANNEL 13 */
-	{48,	714},	/* CHANNEL 14 */
-	{0,	0},	/* CHANNEL 15 */
-	{0,	0},	/* CHANNEL 16 */
-};
-
-/* PhoenixLite has a different calibration sysem to the Phoenix */
-static const struct twl6032_ideal_code
-			twl6032_ideal[GPADC_MAX_CHANNELS] = {
-	{	/* CHANNEL 0 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 440,
-		.v2 = 1000,
-	},
-	{	/* CHANNEL 1 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 440,
-		.v2 = 1000,
-	},
-	{	/* CHANNEL 2 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 660,
-		.v2 = 1500,
-	},
-	{	/* CHANNEL 3 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 440,
-		.v2 = 1000,
-	},
-	{	/* CHANNEL 4 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 440,
-		.v2 = 1000,
-	},
-	{	/* CHANNEL 5 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 440,
-		.v2 = 1000,
-	},
-	{	/* CHANNEL 6 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 440,
-		.v2 = 1000,
-	},
-	{	/* CHANNEL 7 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 2200,
-		.v2 = 5000,
-	},
-	{	/* CHANNEL 8 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 2200,
-		.v2 = 5000,
-	},
-	{	/* CHANNEL 9 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 3960,
-		.v2 = 9000,
-	},
-	{	/* CHANNEL 10 */
-		.code1 = 150,
-		.code2 = 751,
-		.v1 = 1000,
-		.v2 = 5000,
-	},
-	{	/* CHANNEL 11 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 660,
-		.v2 = 1500,
-	},
-	{	/* CHANNEL 12 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 440,
-		.v2 = 1000,
-	},
-	{	/* CHANNEL 13 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 440,
-		.v2 = 1000,
-	},
-	{	/* CHANNEL 14 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 2420,
-		.v2 = 5500,
-	},
-	{},	/* CHANNEL 15 - UNUSED */
-	{},	/* CHANNEL 16 - UNUSED */
-	{},	/* CHANNEL 17 - UNUSED */
-	{	/* CHANNEL 18 */
-		.code1 = 1441,
-		.code2 = 3276,
-		.v1 = 2200,
-		.v2 = 5000,
-	},
-};
-
-
-struct twl6030_gpadc_data {
-	struct device		*dev;
-	struct mutex		lock;
-	struct work_struct	ws;
-	struct twl6030_gpadc_request	requests[TWL6030_GPADC_NUM_METHODS];
-	int irq_n;
-	struct twl6032_chnl_calib *twl6032_cal_tbl;
-	unsigned long features;
-};
-
-static struct twl6030_gpadc_data *the_gpadc;
-
-static const
-struct twl6030_gpadc_conversion_method twl6030_conversion_methods_table[] = {
-	[TWL6030_GPADC_RT] = {
-		.sel	= TWL6030_GPADC_RTSELECT_LSB,
-		.rbase	= TWL6030_GPADC_RTCH0_LSB,
-		.mask	= TWL6030_GPADC_RT_SW1_EOC_MASK,
-	},
-	/*
-	 * TWL6030_GPADC_SW1 is not supported as
-	 * interrupt from RT and SW1 cannot be differentiated
-	 */
-	[TWL6030_GPADC_SW2] = {
-		.rbase	= TWL6030_GPADC_GPCH0_LSB,
-		.ctrl	= TWL6030_GPADC_CTRL_P2,
-		.enable = TWL6030_GPADC_CTRL_P2_SP2,
-		.mask	= TWL6030_GPADC_SW2_EOC_MASK,
-	},
-};
-
-static const
-struct twl6030_gpadc_conversion_method twl6032_conversion_methods_table[] = {
-	[TWL6030_GPADC_RT] = {
-		.sel	= TWL6032_GPADC_RTSELECT_LSB,
-		.rbase	= TWL6032_RTCH0_LSB,
-		.mask	= TWL6032_GPADC_RT_EOC_MASK,
-	},
-	[TWL6030_GPADC_SW2] = {
-		.sel	= TWL6032_GPADC_GPSELECT_ISB,
-		.rbase	= TWL6032_GPCH0_LSB,
-		.ctrl	= TWL6032_GPADC_CTRL_P1,
-		.enable = TWL6030_GPADC_CTRL_P1_SP1,
-		.mask	= TWL6032_GPADC_SW_EOC_MASK,
-	},
-};
-
-static const
-struct twl6030_gpadc_conversion_method *twl6030_conversion_methods;
-
-static ssize_t show_gain(struct device *dev,
-		struct device_attribute *devattr, char *buf)
-{
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-	int value;
-	int status;
-
-	value = twl6030_calib_tbl[attr->index].gain_error;
-
-	status = sprintf(buf, "%d\n", value);
-	return status;
-}
-
-static ssize_t set_gain(struct device *dev,
-	struct device_attribute *devattr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 15000)
-							|| (val > 60000))
-		return -EINVAL;
-
-	twl6030_calib_tbl[attr->index].gain_error = val;
-
-	return status;
-}
-
-static ssize_t show_offset(struct device *dev,
-		struct device_attribute *devattr, char *buf)
-{
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-	int value;
-	int status;
-
-	value = twl6030_calib_tbl[attr->index].offset_error;
-
-	status = sprintf(buf, "%d\n", value);
-	return status;
-}
-
-static ssize_t set_offset(struct device *dev,
-	struct device_attribute *devattr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 15000)
-							|| (val > 60000))
-		return -EINVAL;
-
-	twl6030_calib_tbl[attr->index].offset_error = val;
-
-	return status;
-}
-
-static int twl6030_gpadc_read(struct twl6030_gpadc_data *gpadc, u8 reg)
-{
-	int ret;
-	u8 val = 0;
-
-	ret = twl_i2c_read_u8(TWL_MODULE_MADC, &val, reg);
-	if (ret) {
-		dev_dbg(gpadc->dev, "unable to read register 0x%X\n", reg);
-		return ret;
-	}
-
-	return val;
-}
-
-static void twl6030_gpadc_write(struct twl6030_gpadc_data *gpadc,
-				u8 reg, u8 val)
-{
-	int ret;
-
-	ret = twl_i2c_write_u8(TWL_MODULE_MADC, val, reg);
-	if (ret)
-		dev_err(gpadc->dev, "unable to write register 0x%X\n", reg);
-}
-
-static int twl6030_gpadc_channel_raw_read(struct twl6030_gpadc_data *gpadc,
-					  u8 reg)
-{
-	u8 msb, lsb;
-
-	/* For each ADC channel, we have MSB and LSB register pair.
-	 * MSB address is always LSB address+1. reg parameter is the
-	 * addr of LSB register
-	 */
-	msb = twl6030_gpadc_read(gpadc, reg + 1);
-	lsb = twl6030_gpadc_read(gpadc, reg);
-	return (int)((msb << 8) | lsb);
-}
-
-static int twl6030_gpadc_read_channels(struct twl6030_gpadc_data *gpadc,
-		u8 reg_base, u32 channels, struct twl6030_gpadc_request *req)
-{
-	int count = 0;
-	u8 reg, i;
-	s32 gain_error;
-	s32 offset_error;
-	s32 raw_code;
-	s32 corrected_code;
-	s32 raw_channel_value;
-
-	channels = ~channels;
-	if (gpadc->features & TWL6032_SUBCLASS) {
-		for (i = 0; i < TWL6032_GPADC_MAX_CHANNELS; i++) {
-			if (channels & BIT(i))
-				continue;
-
-			reg = reg_base + 2 * count;
-
-			dev_dbg(gpadc->dev, "GPADC chn: %d\n", i);
-			raw_code = twl6030_gpadc_channel_raw_read(gpadc, reg);
-			dev_dbg(gpadc->dev, "GPADC raw: %d\n", raw_code);
-			count++;
-			req->buf[i].raw_code = raw_code;
-
-			/* No correction for channels 15-17 */
-			if (unlikely((i >= 15) && (i <= 17))) {
-				raw_channel_value = raw_code;
-				req->buf[i].code = raw_code;
-				req->rbuf[i] = raw_code;
-			} else {
-				raw_channel_value = (raw_code *
-					gpadc->twl6032_cal_tbl[i].gain);
-
-				/* Shift back into mV range */
-				raw_channel_value /= 1000;
-
-				req->buf[i].code = corrected_code =
-				((raw_code * 1000) -
-				gpadc->twl6032_cal_tbl[i].offset_error) /
-				gpadc->twl6032_cal_tbl[i].gain_error;
-
-				dev_dbg(gpadc->dev, "GPADC cor: %d\n",
-					corrected_code);
-
-				req->rbuf[i] = corrected_code *
-					gpadc->twl6032_cal_tbl[i].gain;
-
-				/* Shift back into mV range */
-				req->rbuf[i] /= 1000;
-			}
-			req->buf[i].raw_channel_value = raw_channel_value;
-			dev_dbg(gpadc->dev, "GPADC val: %d\n", req->rbuf[i]);
-		}
-	} else {
-		for (i = 0; i < TWL6030_GPADC_MAX_CHANNELS; i++) {
-			if (channels & BIT(i))
-				continue;
-			reg = reg_base + 2 * i;
-			raw_code = twl6030_gpadc_channel_raw_read(gpadc, reg);
-			req->buf[i].raw_code = raw_code;
-			count++;
-			/*
-			 * multiply by 1000 to convert the unit to milli
-			 * division by 1024 (>> 10) for 10 bit ADC
-			 * division by 8 (>> 3) for actual scaler gain
-			 */
-			raw_channel_value = (raw_code * twl6030_gain[i]
-								* 1000) >> 13;
-			req->buf[i].raw_channel_value = raw_channel_value;
-
-			if (~calibration_bit_map & BIT(i)) {
-				req->buf[i].code = raw_code;
-				req->rbuf[i] = raw_channel_value;
-			} else {
-				gain_error = twl6030_calib_tbl[i].gain_error;
-				offset_error = twl6030_calib_tbl[i].offset_error;
-				req->buf[i].code = corrected_code =
-					(raw_code * SCALE - offset_error) /
-						gain_error;
-				req->rbuf[i] = (corrected_code * twl6030_gain[i]
-								* 1000) >> 13;
-			}
-			dev_dbg(gpadc->dev, "GPADC val: %d", req->rbuf[i]);
-		}
-	}
-	return count;
-}
-
-static void twl6030_gpadc_enable_irq(u16 method)
-{
-	twl6030_interrupt_unmask(twl6030_conversion_methods[method].mask,
-						REG_INT_MSK_LINE_B);
-	twl6030_interrupt_unmask(twl6030_conversion_methods[method].mask,
-						REG_INT_MSK_STS_B);
-}
-
-static void twl6030_gpadc_disable_irq(u16 method)
-{
-	twl6030_interrupt_mask(twl6030_conversion_methods[method].mask,
-						REG_INT_MSK_LINE_B);
-	twl6030_interrupt_mask(twl6030_conversion_methods[method].mask,
-						REG_INT_MSK_STS_B);
-}
-
-static irqreturn_t twl6030_gpadc_irq_handler(int irq, void *_req)
-{
-	struct twl6030_gpadc_request *req = _req;
-
-#ifdef CONFIG_LOCKDEP
-	/* WORKAROUND for lockdep forcing IRQF_DISABLED on us, which
-	 * we don't want and can't tolerate.  Although it might be
-	 * friendlier not to borrow this thread context...
-	 */
-	local_irq_enable();
-#endif
-
-	/* Find the cause of the interrupt and enable the pending
-	   bit for the corresponding method */
-	twl6030_gpadc_disable_irq(req->method);
-	req->result_pending = 1;
-
-	schedule_work(&the_gpadc->ws);
-
-	return IRQ_HANDLED;
-}
-
-static void twl6030_gpadc_work(struct work_struct *ws)
-{
-	const struct twl6030_gpadc_conversion_method *method;
-	struct twl6030_gpadc_data *gpadc;
-	struct twl6030_gpadc_request *r;
-	int len, i;
-
-	gpadc = container_of(ws, struct twl6030_gpadc_data, ws);
-	mutex_lock(&gpadc->lock);
-
-	for (i = 0; i < TWL6030_GPADC_NUM_METHODS; i++) {
-
-		r = &gpadc->requests[i];
-
-		/* No pending results for this method, move to next one */
-		if (!r->result_pending)
-			continue;
-
-		method = &twl6030_conversion_methods[r->method];
-
-		/* Read results */
-		len = twl6030_gpadc_read_channels(gpadc, method->rbase,
-						 r->channels, r);
-
-		/* Return results to caller */
-		if (r->func_cb != NULL) {
-			r->func_cb(r);
-			r->func_cb = NULL;
-		}
-
-		/* Free request */
-		r->result_pending = 0;
-		r->active	  = 0;
-	}
-
-	mutex_unlock(&gpadc->lock);
-}
-
-static int twl6030_gpadc_set_irq(struct twl6030_gpadc_data *gpadc,
-		struct twl6030_gpadc_request *req)
-{
-	struct twl6030_gpadc_request *p;
-
-	p = &gpadc->requests[req->method];
-	p->channels = req->channels;
-	p->method = req->method;
-	p->func_cb = req->func_cb;
-	p->type = req->type;
-
-	twl6030_gpadc_enable_irq(req->method);
-
-	return 0;
-}
-
-static inline void
-twl6030_gpadc_start_conversion(struct twl6030_gpadc_data *gpadc,
-			       int conv_method)
-{
-	const struct twl6030_gpadc_conversion_method *method;
-
-	method = &twl6030_conversion_methods[conv_method];
-	twl_i2c_write_u8(TWL6030_MODULE_ID1, GPADCS, REG_TOGGLE1);
-
-	switch (conv_method) {
-	case TWL6030_GPADC_SW2:
-		twl6030_gpadc_write(gpadc, method->ctrl, method->enable);
-		break;
-	case TWL6030_GPADC_RT:
-	default:
-		break;
-	}
-}
-
-static int twl6030_gpadc_is_conversion_ready(
-		struct twl6030_gpadc_data *gpadc, u8 status_reg)
-{
-	u8 reg = twl6030_gpadc_read(gpadc, status_reg);
-	return !(reg & TWL6030_GPADC_BUSY) && (reg & TWL6030_GPADC_EOC_SW);
-}
-
-static int twl6030_gpadc_wait_conversion_ready(
-		struct twl6030_gpadc_data *gpadc,
-		unsigned int timeout_ms, u8 status_reg)
-{
-	unsigned long timeout;
-
-	timeout = jiffies + msecs_to_jiffies(timeout_ms);
-	do {
-		if (twl6030_gpadc_is_conversion_ready(gpadc, status_reg))
-			return 0;
-		msleep_interruptible(1);
-	} while (!time_after(jiffies, timeout));
-
-	/* one more checking against scheduler-caused timeout */
-	if (twl6030_gpadc_is_conversion_ready(gpadc, status_reg))
-		return 0;
-	else
-		return -EAGAIN;
-}
-
-/* locks held by caller */
-static int _twl6030_gpadc_conversion(struct twl6030_gpadc_request *req,
-	const struct twl6030_gpadc_conversion_method *method)
-{
-	u8 ch_msb, ch_lsb, ch_isb;
-	int ret = 0;
-
-	if (req->method == TWL6030_GPADC_RT) {
-		ch_msb = (req->channels >> 16) & 0x01;
-		ch_isb = (req->channels >> 8) & 0xff;
-		ch_lsb = req->channels & 0xff;
-		twl6030_gpadc_write(the_gpadc, method->sel + 2, ch_msb);
-		twl6030_gpadc_write(the_gpadc, method->sel + 1, ch_isb);
-		twl6030_gpadc_write(the_gpadc, method->sel, ch_lsb);
-	}
-
-	if ((req->type == TWL6030_GPADC_IRQ_ONESHOT) &&
-		 (req->func_cb != NULL)) {
-		twl6030_gpadc_set_irq(the_gpadc, req);
-		twl6030_gpadc_start_conversion(the_gpadc, req->method);
-		the_gpadc->requests[req->method].active = 1;
-		ret = 0;
-		goto out;
-	}
-
-	/* With RT method we should not be here anymore */
-	if (req->method == TWL6030_GPADC_RT) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	twl6030_gpadc_start_conversion(the_gpadc, req->method);
-	the_gpadc->requests[req->method].active = 1;
-
-	/* Wait until conversion is ready (ctrl register returns EOC) */
-	ret = twl6030_gpadc_wait_conversion_ready(the_gpadc, 5, method->ctrl);
-	if (ret) {
-		dev_dbg(the_gpadc->dev, "conversion timeout!\n");
-		the_gpadc->requests[req->method].active = 0;
-		goto out;
-	}
-
-	ret = twl6030_gpadc_read_channels(the_gpadc, method->rbase,
-					  req->channels, req);
-	the_gpadc->requests[req->method].active = 0;
-out:
-	return ret;
-}
-
-/* locks held by caller */
-static int _twl6032_gpadc_conversion(struct twl6030_gpadc_request *req,
-	const struct twl6030_gpadc_conversion_method *method)
-{
-	int i, ret, count = 0, channelcnt = 0;
-	u8 ch_msb, ch_lsb, ch_isb;
-
-	if ((req->type == TWL6030_GPADC_IRQ_ONESHOT) &&
-		(req->func_cb == NULL)) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	for (i = 0; i < TWL6032_GPADC_MAX_CHANNELS; i++)
-		if (req->channels & BIT(i))
-			channelcnt++;
-
-	if (req->method == TWL6030_GPADC_RT) {
-		/*
-		 * For the TWL6032 real time conversion
-		 * maximum channels count is 2
-		 */
-		if ((req->type != TWL6030_GPADC_IRQ_ONESHOT) ||
-			 (channelcnt > 2)) {
-			ret = -EINVAL;
-			goto out;
-		}
-
-		ch_msb = (req->channels >> 16) & 0x07;
-		ch_isb = (req->channels >> 8) & 0xff;
-		ch_lsb = req->channels & 0xff;
-		twl6030_gpadc_write(the_gpadc, method->sel + 2, ch_msb);
-		twl6030_gpadc_write(the_gpadc, method->sel + 1, ch_isb);
-		twl6030_gpadc_write(the_gpadc, method->sel, ch_lsb);
-	}
-
-	/*
-	 * For the TWL6032 Asynchronous Conversion
-	 * maximum channels count is 1
-	 */
-	if ((req->method == TWL6030_GPADC_SW2) &&
-		 (req->type == TWL6030_GPADC_IRQ_ONESHOT)) {
-		if (channelcnt > 1) {
-			ret = -EINVAL;
-			goto out;
-		}
-
-		for (i = 0; i < TWL6032_GPADC_MAX_CHANNELS; i++) {
-			if (!(req->channels & BIT(i)))
-				continue;
-
-			/* select the ADC channel to be read */
-			twl6030_gpadc_write(the_gpadc, method->sel, i);
-		}
-	}
-
-	if (req->type == TWL6030_GPADC_IRQ_ONESHOT) {
-		twl6030_gpadc_set_irq(the_gpadc, req);
-		twl6030_gpadc_start_conversion(the_gpadc, req->method);
-		the_gpadc->requests[req->method].active = 1;
-		ret = 0;
-		goto out;
-	}
-
-	for (i = 0; i < TWL6032_GPADC_MAX_CHANNELS; i++) {
-		if (!(req->channels & BIT(i)))
-			continue;
-
-		/* select the ADC channel to be read */
-		twl6030_gpadc_write(the_gpadc, method->sel, i);
-
-		twl6030_gpadc_start_conversion(the_gpadc, req->method);
-		the_gpadc->requests[req->method].active = 1;
-
-		/* Wait until conversion is ready (ctrl register is EOC) */
-		ret = twl6030_gpadc_wait_conversion_ready(the_gpadc, 5,
-				method->ctrl);
-		if (ret) {
-			dev_dbg(the_gpadc->dev, "conversion timeout!\n");
-			the_gpadc->requests[req->method].active = 0;
-			goto out;
-		}
-
-		ret = twl6030_gpadc_read_channels(the_gpadc, method->rbase,
-					1 << i, req);
-		if (!ret)
-			dev_err(the_gpadc->dev, "%s: channel error %d\n",
-					__func__, i);
-
-		count += ret;
-		the_gpadc->requests[req->method].active = 0;
-	}
-	ret = count;
-out:
-	return ret;
-}
-
-int twl6030_gpadc_conversion(struct twl6030_gpadc_request *req)
-{
-	const struct twl6030_gpadc_conversion_method *method;
-	int ret = 0;
-
-	if (unlikely(!req))
-		return -EINVAL;
-
-	if (!the_gpadc)
-		return -EAGAIN;
-
-	mutex_lock(&the_gpadc->lock);
-
-	if (req->method >= TWL6030_GPADC_NUM_METHODS) {
-		dev_err(the_gpadc->dev, "unsupported conversion method\n");
-		ret = -EINVAL;
-		goto out;
-	}
-
-	/* Do we have a conversion request ongoing */
-	if (the_gpadc->requests[req->method].active) {
-		ret = -EBUSY;
-		goto out;
-	}
-
-	method = &twl6030_conversion_methods[req->method];
-
-	if (the_gpadc->features & TWL6032_SUBCLASS)
-		ret = _twl6032_gpadc_conversion(req, method);
-	else
-		ret = _twl6030_gpadc_conversion(req, method);
-
-out:
-	mutex_unlock(&the_gpadc->lock);
-
-	return ret;
-}
-EXPORT_SYMBOL(twl6030_gpadc_conversion);
-
-static ssize_t show_channel(struct device *dev,
-		struct device_attribute *devattr, char *buf)
-{
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-	struct twl6030_gpadc_request req;
-	int temp = 0;
-	int ret;
-
-	req.channels = (1 << attr->index);
-	req.method = TWL6030_GPADC_SW2;
-	req.active = 0;
-	req.func_cb = NULL;
-	ret = twl6030_gpadc_conversion(&req);
-	if (ret < 0)
-		return ret;
-
-	if (req.rbuf[attr->index] > 0)
-		temp = req.rbuf[attr->index];
-
-	ret = sprintf(buf, "%d\n", temp);
-
-	return ret;
-}
-
-static ssize_t show_raw_code(struct device *dev,
-		struct device_attribute *devattr, char *buf)
-{
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
-	struct twl6030_gpadc_request req;
-	int temp = 0;
-	int ret;
-
-	req.channels = (1 << attr->index);
-	req.method = TWL6030_GPADC_SW2;
-	req.active = 0;
-	req.func_cb = NULL;
-	ret = twl6030_gpadc_conversion(&req);
-	if (ret < 0)
-		return ret;
-
-	if (req.buf[attr->index].raw_channel_value > 0)
-		temp = req.buf[attr->index].raw_code;
-
-	ret = sprintf(buf, "%d\n", temp);
-
-	return ret;
-}
-
-#define in_gain(index) \
-static SENSOR_DEVICE_ATTR(in##index##_gain, S_IRUGO|S_IWUSR, show_gain, \
-	set_gain, index); \
-static SENSOR_DEVICE_ATTR(in##index##_offset, S_IRUGO|S_IWUSR, show_offset, \
-	set_offset, index)
-
-in_gain(0);
-in_gain(1);
-in_gain(2);
-in_gain(3);
-in_gain(4);
-in_gain(5);
-in_gain(6);
-in_gain(7);
-in_gain(8);
-in_gain(9);
-in_gain(10);
-in_gain(11);
-in_gain(12);
-in_gain(13);
-in_gain(14);
-in_gain(15);
-in_gain(16);
-
-#define in_channel(index) \
-static SENSOR_DEVICE_ATTR(in##index##_channel, S_IRUGO, show_channel, \
-	NULL, index); \
-static SENSOR_DEVICE_ATTR(in##index##_raw_code, S_IRUGO, show_raw_code, \
-	NULL, index)
-
-in_channel(0);
-in_channel(1);
-in_channel(2);
-in_channel(3);
-in_channel(4);
-in_channel(5);
-in_channel(6);
-in_channel(7);
-in_channel(8);
-in_channel(9);
-in_channel(10);
-in_channel(11);
-in_channel(12);
-in_channel(13);
-in_channel(14);
-in_channel(15);
-in_channel(16);
-in_channel(17);
-in_channel(18);
-
-#define IN_ATTRS(X)\
-	&sensor_dev_attr_in##X##_gain.dev_attr.attr,	\
-	&sensor_dev_attr_in##X##_offset.dev_attr.attr	\
-
-#define IN_ATTRS_CHANNEL(X)\
-	&sensor_dev_attr_in##X##_channel.dev_attr.attr,		\
-	&sensor_dev_attr_in##X##_raw_code.dev_attr.attr	\
-
-static struct attribute *twl6030_gpadc_attributes[] = {
-	IN_ATTRS(0),
-	IN_ATTRS(1),
-	IN_ATTRS(2),
-	IN_ATTRS(3),
-	IN_ATTRS(4),
-	IN_ATTRS(5),
-	IN_ATTRS(6),
-	IN_ATTRS(7),
-	IN_ATTRS(8),
-	IN_ATTRS(9),
-	IN_ATTRS(10),
-	IN_ATTRS(11),
-	IN_ATTRS(12),
-	IN_ATTRS(13),
-	IN_ATTRS(14),
-	IN_ATTRS(15),
-	IN_ATTRS(16),
-	IN_ATTRS_CHANNEL(0),
-	IN_ATTRS_CHANNEL(1),
-	IN_ATTRS_CHANNEL(2),
-	IN_ATTRS_CHANNEL(3),
-	IN_ATTRS_CHANNEL(4),
-	IN_ATTRS_CHANNEL(5),
-	IN_ATTRS_CHANNEL(6),
-	IN_ATTRS_CHANNEL(7),
-	IN_ATTRS_CHANNEL(8),
-	IN_ATTRS_CHANNEL(9),
-	IN_ATTRS_CHANNEL(10),
-	IN_ATTRS_CHANNEL(11),
-	IN_ATTRS_CHANNEL(12),
-	IN_ATTRS_CHANNEL(13),
-	IN_ATTRS_CHANNEL(14),
-	IN_ATTRS_CHANNEL(15),
-	IN_ATTRS_CHANNEL(16),
-	IN_ATTRS_CHANNEL(17),
-	IN_ATTRS_CHANNEL(18),
-	NULL
-};
-
-static const struct attribute_group twl6030_gpadc_group = {
-	.attrs = twl6030_gpadc_attributes,
-};
-
-static long twl6030_gpadc_ioctl(struct file *filp, unsigned int cmd,
-			       unsigned long arg)
-{
-	struct twl6030_gpadc_user_parms par;
-	int val, ret;
-
-	ret = copy_from_user(&par, (void __user *) arg, sizeof(par));
-	if (ret) {
-		dev_dbg(the_gpadc->dev, "copy_from_user: %d\n", ret);
-		return -EACCES;
-	}
-
-	switch (cmd) {
-	case TWL6030_GPADC_IOCX_ADC_READ:
-	case TWL6030_GPADC_IOCX_ADC_RAW_READ: {
-		struct twl6030_gpadc_request req;
-		if (the_gpadc->features & TWL6032_SUBCLASS) {
-			if (par.channel >= TWL6032_GPADC_MAX_CHANNELS)
-				return -EINVAL;
-		} else {
-			if (par.channel >= TWL6030_GPADC_MAX_CHANNELS)
-				return -EINVAL;
-		}
-
-		req.channels = (1 << par.channel);
-		req.method	= TWL6030_GPADC_SW2;
-		req.func_cb	= NULL;
-
-		val = twl6030_gpadc_conversion(&req);
-		if (likely(val > 0)) {
-			par.status = 0;
-			if (cmd == TWL6030_GPADC_IOCX_ADC_READ)
-				par.result = (u16)req.rbuf[par.channel];
-			else
-				par.result = (u16)req.buf[par.channel].raw_code;
-
-		} else if (val == 0) {
-			par.status = -ENODATA;
-		} else {
-			par.status = val;
-		}
-		break;
-					     }
-	default:
-		return -EINVAL;
-	}
-
-	ret = copy_to_user((void __user *) arg, &par, sizeof(par));
-	if (ret) {
-		dev_dbg(the_gpadc->dev, "copy_to_user: %d\n", ret);
-		return -EACCES;
-	}
-
-	return 0;
-}
-
-static const struct file_operations twl6030_gpadc_fileops = {
-	.owner = THIS_MODULE,
-	.unlocked_ioctl = twl6030_gpadc_ioctl
-};
-
-static struct miscdevice twl6030_gpadc_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "twl6030-gpadc",
-	.fops = &twl6030_gpadc_fileops
-};
-
-static int twl6030_calibration(void)
-{
-	s8 delta_error1 = 0, delta_error2 = 0;
-	s16 ideal_code1, ideal_code2;
-	s32 gain_error_1;
-	s32 offset_error;
-	u8 index;
-	int ret;
-
-	for (index = 0; index < TWL6030_GPADC_MAX_CHANNELS; index++) {
-		if (~calibration_bit_map & (1 << index))
-			continue;
-
-		ret = twl_i2c_read_u8(TWL6030_MODULE_ID2, &delta_error1,
-					twl6030_trim_addr[index]);
-		if (ret < 0)
-			return ret;
-
-		twl_i2c_read_u8(TWL6030_MODULE_ID2, &delta_error2,
-					(twl6030_trim_addr[index] + 1));
-		if (ret < 0)
-			return ret;
-
-		/* convert 7 bit to 8 bit signed number */
-		delta_error1 = ((s8)(delta_error1 << 1) >> 1);
-		delta_error2 = ((s8)(delta_error2 << 1) >> 1);
-		ideal_code1 = twl6030_ideal[index].code1;
-		ideal_code2 = twl6030_ideal[index].code2;
-
-		gain_error_1 = (delta_error2 - delta_error1) * SCALE
-						/ (ideal_code2 - ideal_code1);
-		offset_error = delta_error1 * SCALE - gain_error_1
-							*  ideal_code1;
-		twl6030_calib_tbl[index].gain_error = gain_error_1 + SCALE;
-		twl6030_calib_tbl[index].offset_error = offset_error;
-	}
-
-	return 0;
-}
-
-static int twl6032_calibration(struct twl6030_gpadc_data *gpadc)
-{
-	int chn, d1 = 0, d2 = 0, b, k, gain, x1, x2, temp;
-	u8 trim_regs[17];
-	int ret;
-
-	ret = twl_i2c_read(TWL6030_MODULE_ID2, trim_regs + 1,
-			TWL6032_GPADC_TRIM1, 16);
-	if (ret < 0)
-		return ret;
-
-	/* Loop to calculate the value needed for returning voltages from
-	 * GPADC not values.
-	 *
-	 * gain is calculated to 3 decimal places fixed point.
-	 */
-	for (chn = 0; chn < TWL6032_GPADC_MAX_CHANNELS; chn++) {
-
-		switch (chn) {
-		case 0:
-		case 1:
-		case 2:
-		case 3:
-		case 4:
-		case 5:
-		case 6:
-		case 11:
-		case 12:
-		case 13:
-		case 14:
-			/* D1 */
-			d1 = (trim_regs[3] & 0x1F) << 2;
-			d1 |= (trim_regs[1] & 0x06) >> 1;
-			if (trim_regs[1] & 0x01)
-				d1 = -d1;
-
-			/* D2 */
-			d2 = (trim_regs[4] & 0x3F) << 2;
-			d2 |= (trim_regs[2] & 0x06) >> 1;
-			if (trim_regs[2] & 0x01)
-				d2 = -d2;
-			break;
-		case 8:
-			/* D1 */
-			temp = (trim_regs[3] & 0x1F) << 2;
-			temp |= (trim_regs[1] & 0x06) >> 1;
-			if (trim_regs[1] & 0x01)
-				temp = -temp;
-
-			d1 = (trim_regs[8] & 0x18) << 1;
-			d1 |= (trim_regs[7] & 0x1E) >> 1;
-			if (trim_regs[7] & 0x01)
-				d1 = -d1;
-
-			d1 += temp;
-
-			/* D2 */
-			temp = (trim_regs[4] & 0x3F) << 2;
-			temp |= (trim_regs[2] & 0x06) >> 1;
-			if (trim_regs[2] & 0x01)
-				temp = -temp;
-
-			d2 = (trim_regs[10] & 0x1F) << 2;
-			d2 |= (trim_regs[8] & 0x06) >> 1;
-			if (trim_regs[8] & 0x01)
-				d2 = -d2;
-
-			d2 += temp;
-			break;
-		case 9:
-			/* D1 */
-			temp = (trim_regs[3] & 0x1F) << 2;
-			temp |= (trim_regs[1] & 0x06) >> 1;
-			if (trim_regs[1] & 0x01)
-				temp = -temp;
-
-			d1 = (trim_regs[14] & 0x18) << 1;
-			d1 |= (trim_regs[12] & 0x1E) >> 1;
-			if (trim_regs[12] & 0x01)
-				d1 = -d1;
-
-			d1 += temp;
-
-			/* D2 */
-			temp = (trim_regs[4] & 0x3F) << 2;
-			temp |= (trim_regs[2] & 0x06) >> 1;
-			if (trim_regs[2] & 0x01)
-				temp = -temp;
-
-			d2 = (trim_regs[16] & 0x1F) << 2;
-			d2 |= (trim_regs[14] & 0x06) >> 1;
-			if (trim_regs[14] & 0x01)
-				d2 = -d2;
-
-			d2 += temp;
-		case 10:
-			/* D1 */
-			d1 = (trim_regs[11] & 0x0F) << 3;
-			d1 |= (trim_regs[9] & 0x0E) >> 1;
-			if (trim_regs[9] & 0x01)
-				d1 = -d1;
-
-			/* D2 */
-			d2 = (trim_regs[15] & 0x0F) << 3;
-			d2 |= (trim_regs[13] & 0x0E) >> 1;
-			if (trim_regs[13] & 0x01)
-				d2 = -d2;
-			break;
-		case 7:
-		case 18:
-			/* D1 */
-			temp = (trim_regs[3] & 0x1F) << 2;
-			temp |= (trim_regs[1] & 0x06) >> 1;
-			if (trim_regs[1] & 0x01)
-				temp = -temp;
-
-			d1 = (trim_regs[5] & 0x7E) >> 1;
-			if (trim_regs[5] & 0x01)
-				d1 = -d1;
-
-			d1 += temp;
-
-			/* D2 */
-			temp = (trim_regs[4] & 0x3F) << 2;
-			temp |= (trim_regs[2] & 0x06) >> 1;
-			if (trim_regs[2] & 0x01)
-				temp = -temp;
-
-			d2 = (trim_regs[6] & 0xFF) >> 1;
-			if (trim_regs[6] & 0x01)
-				d2 = -d2;
-
-			d2 += temp;
-			break;
-		default:
-			/* No data for other channels */
-			continue;
-		}
-
-		dev_dbg(gpadc->dev, "GPADC d1   for Chn: %d = %d\n", chn, d1);
-		dev_dbg(gpadc->dev, "GPADC d2   for Chn: %d = %d\n", chn, d2);
-
-		/* Gain */
-		gain = ((twl6032_ideal[chn].v2 -
-			twl6032_ideal[chn].v1) * 1000) /
-			((twl6032_ideal[chn].code2 -
-			twl6032_ideal[chn].code1));
-
-		x1 = twl6032_ideal[chn].code1;
-		x2 = twl6032_ideal[chn].code2;
-
-		/* k */
-		k = 1000 + (((d2 - d1) * 1000) / (x2 - x1));
-
-		/* b */
-		b = (d1 * 1000) - (k - 1000) * x1;
-
-		gpadc->twl6032_cal_tbl[chn].gain = gain;
-		gpadc->twl6032_cal_tbl[chn].gain_error = k;
-		gpadc->twl6032_cal_tbl[chn].offset_error = b;
-
-		dev_dbg(gpadc->dev, "GPADC x1   for Chn: %d = %d\n", chn, x1);
-		dev_dbg(gpadc->dev, "GPADC x2   for Chn: %d = %d\n", chn, x2);
-		dev_dbg(gpadc->dev, "GPADC Gain for Chn: %d = %d\n", chn, gain);
-		dev_dbg(gpadc->dev, "GPADC k    for Chn: %d = %d\n", chn, k);
-		dev_dbg(gpadc->dev, "GPADC b    for Chn: %d = %d\n", chn, b);
-
-	}
-
-	return 0;
-}
-
-static int __devinit twl6030_gpadc_probe(struct platform_device *pdev)
-{
-	struct twl6030_gpadc_data *gpadc;
-	struct twl4030_madc_platform_data *pdata = pdev->dev.platform_data;
-	int irq;
-	int irq_rt;
-	int ret = 0;
-
-	gpadc = kzalloc(sizeof *gpadc, GFP_KERNEL);
-	if (!gpadc)
-		return -ENOMEM;
-
-	if (!pdata) {
-		dev_dbg(&pdev->dev, "platform_data not available\n");
-		ret = -EINVAL;
-		goto err_pdata;
-	}
-
-	if (pdata->features & TWL6032_SUBCLASS) {
-		gpadc->twl6032_cal_tbl = kzalloc(
-				sizeof(struct twl6032_chnl_calib) *
-				TWL6032_GPADC_MAX_CHANNELS,
-				GFP_KERNEL);
-		if (!gpadc->twl6032_cal_tbl) {
-			ret = -ENOMEM;
-			goto err_pdata;
-		}
-	}
-
-	gpadc->dev = &pdev->dev;
-
-	gpadc->features = pdata->features;
-
-	twl6030_conversion_methods = twl6030_conversion_methods_table;
-
-	if (gpadc->features & TWL6032_SUBCLASS)
-		twl6030_conversion_methods = twl6032_conversion_methods_table;
-
-	ret = misc_register(&twl6030_gpadc_device);
-	if (ret) {
-		dev_dbg(&pdev->dev, "could not register misc_device\n");
-		goto err_misc;
-	}
-
-	irq_rt = platform_get_irq(pdev, 0);
-	if (irq_rt < 0) {
-		dev_err(&pdev->dev, "failed to get irq\n");
-		goto err_irq;
-	}
-
-	ret = request_threaded_irq(irq_rt, NULL, twl6030_gpadc_irq_handler,
-		0, "twl6030_gpadc", &gpadc->requests[TWL6030_GPADC_RT]);
-	if (ret) {
-		dev_dbg(&pdev->dev, "could not request irq\n");
-		goto err_irq;
-	}
-
-	irq = platform_get_irq(pdev, 1);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "failed to get irq\n");
-		goto err_irq_rt;
-	}
-
-	ret = request_threaded_irq(irq, NULL, twl6030_gpadc_irq_handler,
-		0, "twl6030_gpadc", &gpadc->requests[TWL6030_GPADC_SW2]);
-	if (ret) {
-		dev_dbg(&pdev->dev, "could not request irq\n");
-		goto err_irq_rt;
-	}
-
-	platform_set_drvdata(pdev, gpadc);
-	mutex_init(&gpadc->lock);
-	INIT_WORK(&gpadc->ws, twl6030_gpadc_work);
-
-	if (gpadc->features & TWL6032_SUBCLASS)
-		ret = twl6032_calibration(gpadc);
-	else
-		ret = twl6030_calibration();
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to read calibration registers\n");
-		goto err_calib;
-	}
-	the_gpadc = gpadc;
-
-	ret = sysfs_create_group(&pdev->dev.kobj, &twl6030_gpadc_group);
-	if (ret)
-		dev_err(&pdev->dev, "could not create sysfs files\n");
-
-	return 0;
-
-err_calib:
-	free_irq(irq, &gpadc->requests[TWL6030_GPADC_SW2]);
-err_irq_rt:
-	free_irq(irq_rt, &gpadc->requests[TWL6030_GPADC_RT]);
-err_irq:
-	misc_deregister(&twl6030_gpadc_device);
-
-err_misc:
-	if (pdata->features & TWL6032_SUBCLASS)
-		kfree(gpadc->twl6032_cal_tbl);
-err_pdata:
-	kfree(gpadc);
-
-	return ret;
-}
-
-static int __devexit twl6030_gpadc_remove(struct platform_device *pdev)
-{
-	struct twl6030_gpadc_data *gpadc = platform_get_drvdata(pdev);
-
-	twl6030_gpadc_disable_irq(TWL6030_GPADC_RT);
-	twl6030_gpadc_disable_irq(TWL6030_GPADC_SW2);
-	free_irq(platform_get_irq(pdev, 0), gpadc);
-	sysfs_remove_group(&pdev->dev.kobj, &twl6030_gpadc_group);
-	cancel_work_sync(&gpadc->ws);
-	misc_deregister(&twl6030_gpadc_device);
-
-	return 0;
-}
-
-static int twl6030_gpadc_suspend(struct device *pdev)
-{
-	int ret;
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_ID1, GPADCR, REG_TOGGLE1);
-	if (ret)
-		pr_err("%s: Error reseting GPADC (%d)!\n", __func__, ret);
-
-	return 0;
-};
-
-static int twl6030_gpadc_resume(struct device *pdev)
-{
-	int ret;
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_ID1, GPADCS, REG_TOGGLE1);
-	if (ret)
-		pr_err("%s: Error setting GPADC (%d)!\n", __func__, ret);
-
-	return 0;
-};
-static const struct dev_pm_ops twl6030_gpadc_pm_ops = {
-	.suspend = twl6030_gpadc_suspend,
-	.resume = twl6030_gpadc_resume,
-};
-
-static struct platform_driver twl6030_gpadc_driver = {
-	.probe		= twl6030_gpadc_probe,
-	.remove		= __devexit_p(twl6030_gpadc_remove),
-	.driver		= {
-		.name	= "twl6030_gpadc",
-		.owner	= THIS_MODULE,
-		.pm = &twl6030_gpadc_pm_ops,
-	},
-};
-
-static int __init twl6030_gpadc_init(void)
-{
-	return platform_driver_register(&twl6030_gpadc_driver);
-}
-module_init(twl6030_gpadc_init);
-
-static void __exit twl6030_gpadc_exit(void)
-{
-	platform_driver_unregister(&twl6030_gpadc_driver);
-}
-module_exit(twl6030_gpadc_exit);
-
-MODULE_ALIAS("platform:twl6030-gpadc");
-MODULE_AUTHOR("Texas Instruments Inc.");
-MODULE_DESCRIPTION("twl6030 ADC driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/twl6030-madc.c b/drivers/mfd/twl6030-madc.c
deleted file mode 100644
index f537ba5cbc87..000000000000
--- a/drivers/mfd/twl6030-madc.c
+++ /dev/null
@@ -1,354 +0,0 @@
-/*
- *
- * TWL6030 MADC module driver-This driver only implements the ADC read
- * functions
- *
- * Copyright (C) 2011 Samsung Telecommunications of America
- *
- * Based on twl4030-madc.c
- * Copyright (C) 2008 Nokia Corporation
- * Mikko Ylinen <mikko.k.ylinen@nokia.com>
- *
- * Amit Kucheria <amit.kucheria@canonical.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/i2c/twl.h>
-#include <linux/i2c/twl6030-madc.h>
-#include <linux/module.h>
-#include <linux/stddef.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/mutex.h>
-#include <linux/bitops.h>
-#include <linux/jiffies.h>
-#include <linux/types.h>
-#include <linux/gfp.h>
-#include <linux/err.h>
-#include <linux/wakelock.h>
-
-#define GPADCS		(1 << 1)
-#define GPADCR		(1 << 0)
-#define REG_TOGGLE1	0x90
-
-#define DRIVER_NAME	(twl6030_madc_driver.driver.name)
-static struct platform_driver twl6030_madc_driver;
-
-/*
- * struct twl6030_madc_data - a container for madc info
- * @dev - pointer to device structure for madc
- * @lock - mutex protecting this data structure
- */
-struct twl6030_madc_data {
-	struct device *dev;
-	struct mutex lock;
-	struct dentry		*file;
-	struct wake_lock wakelock;
-};
-
-static struct twl6030_madc_data *twl6030_madc;
-static u8 gpadc_ctrl_reg;
-
-static inline int twl6030_madc_start_conversion(struct twl6030_madc_data *madc)
-{
-	int ret;
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_ID1, GPADCS, REG_TOGGLE1);
-	if (ret) {
-		dev_err(madc->dev, "unable to write register 0x%X\n",
-			REG_TOGGLE1);
-		return ret;
-	}
-
-	udelay(100);
-	ret = twl_i2c_write_u8(TWL_MODULE_MADC, TWL6030_MADC_SP1,
-				TWL6030_MADC_CTRL_P1);
-	if (ret) {
-		dev_err(madc->dev, "unable to write register 0x%X\n",
-			TWL6030_MADC_CTRL_P1);
-		return ret;
-	}
-	return 0;
-}
-
-/*
- * Function that waits for conversion to be ready
- * @madc - pointer to twl4030_madc_data struct
- * @timeout_ms - timeout value in milliseconds
- * @status_reg - ctrl register
- * returns 0 if succeeds else a negative error value
- */
-static int twl6030_madc_wait_conversion_ready(struct twl6030_madc_data *madc,
-					      unsigned int timeout_ms,
-					      u8 status_reg)
-{
-	unsigned long timeout;
-	unsigned long delta;
-	u8 reg;
-	int ret;
-
-	delta = msecs_to_jiffies(timeout_ms);
-
-	if (delta < 2)
-		delta = 2;
-
-	wake_lock(&madc->wakelock);
-	timeout = jiffies + delta;
-	do {
-		ret = twl_i2c_read_u8(TWL6030_MODULE_MADC, &reg, status_reg);
-		if (ret) {
-			dev_err(madc->dev,
-				"unable to read status register 0x%X\n",
-				status_reg);
-			goto unlock;
-		}
-		if (!(reg & TWL6030_MADC_BUSY) && (reg & TWL6030_MADC_EOCP1)) {
-			ret = 0;
-			goto unlock;
-		}
-
-		if (time_after(jiffies, timeout))
-			break;
-
-		usleep_range(500, 2000);
-	} while (1);
-
-	dev_err(madc->dev, "conversion timeout, ctrl_px=0x%08x\n", reg);
-	ret = -EAGAIN;
-
-unlock:
-	wake_unlock(&madc->wakelock);
-	return ret;
-}
-
-/*
- * Function to read a particular channel value.
- * @madc - pointer to struct twl6030_madc_data
- * @reg - lsb of ADC Channel
- * If the i2c read fails it returns an error else returns 0.
- */
-static int twl6030_madc_channel_raw_read(struct twl6030_madc_data *madc,
-					u8 reg)
-{
-	u8 msb, lsb;
-	int ret;
-
-	mutex_lock(&madc->lock);
-	ret = twl6030_madc_start_conversion(twl6030_madc);
-	if (ret)
-		goto unlock;
-
-	ret = twl6030_madc_wait_conversion_ready(twl6030_madc, 5,
-						TWL6030_MADC_CTRL_P1);
-	if (ret)
-		goto unlock;
-
-	/*
-	 * For each ADC channel, we have MSB and LSB register
-	 * pair. MSB address is always LSB address+1. reg parameter is
-	 * the address of LSB register
-	 */
-	ret = twl_i2c_read_u8(TWL6030_MODULE_MADC, &msb, reg + 1);
-	if (ret) {
-		dev_err(madc->dev, "unable to read MSB register 0x%X\n",
-			reg + 1);
-		goto unlock;
-	}
-	ret = twl_i2c_read_u8(TWL6030_MODULE_MADC, &lsb, reg);
-	if (ret) {
-		dev_err(madc->dev, "unable to read LSB register 0x%X\n", reg);
-		goto unlock;
-	}
-	ret = (int)((msb << 8) | lsb);
-unlock:
-	/* Disable GPADC for power savings. */
-	twl_i2c_write_u8(TWL6030_MODULE_ID1, GPADCR, REG_TOGGLE1);
-	mutex_unlock(&madc->lock);
-	return ret;
-}
-
-/*
- * Return channel value
- * Or < 0 on failure.
- */
-int twl6030_get_madc_conversion(int channel_no)
-{
-	u8 reg = TWL6030_MADC_GPCH0_LSB + (2 * channel_no);
-	if (!twl6030_madc) {
-		pr_err("%s: No ADC device\n", __func__);
-		return -EINVAL;
-	}
-	if (channel_no >= TWL6030_MADC_MAX_CHANNELS) {
-		dev_err(twl6030_madc->dev,
-			"%s: Channel number (%d) exceeds max (%d)\n",
-			__func__, channel_no, TWL6030_MADC_MAX_CHANNELS);
-		return -EINVAL;
-	}
-
-	return twl6030_madc_channel_raw_read(twl6030_madc, reg);
-}
-EXPORT_SYMBOL_GPL(twl6030_get_madc_conversion);
-
-#ifdef CONFIG_DEBUG_FS
-
-static int debug_twl6030_madc_show(struct seq_file *s, void *_)
-{
-	int i, result;
-	for (i = 0; i < TWL6030_MADC_MAX_CHANNELS; i++) {
-		result = twl6030_get_madc_conversion(i);
-		seq_printf(s, "channel %3d returns result %d\n",
-			i, result);
-	}
-	return 0;
-}
-
-static int debug_twl6030_madc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, debug_twl6030_madc_show, inode->i_private);
-}
-
-static const struct file_operations debug_fops = {
-	.open		= debug_twl6030_madc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-#define DEBUG_FOPS	(&debug_fops)
-
-#else
-#define DEBUG_FOPS	NULL
-#endif
-
-/*
- * Initialize MADC
- */
-static int __devinit twl6030_madc_probe(struct platform_device *pdev)
-{
-	struct twl6030_madc_data *madc;
-	struct twl4030_madc_platform_data *pdata = pdev->dev.platform_data;
-
-	if (!pdata) {
-		dev_err(&pdev->dev, "platform_data not available\n");
-		return -EINVAL;
-	}
-	madc = kzalloc(sizeof(*madc), GFP_KERNEL);
-	if (!madc)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, madc);
-	madc->dev = &pdev->dev;
-	mutex_init(&madc->lock);
-	madc->file = debugfs_create_file(DRIVER_NAME, S_IRUGO, NULL,
-					madc, DEBUG_FOPS);
-	wake_lock_init(&madc->wakelock, WAKE_LOCK_SUSPEND, "twl6030 adc");
-	twl6030_madc = madc;
-	return 0;
-}
-
-static int __devexit twl6030_madc_remove(struct platform_device *pdev)
-{
-	struct twl6030_madc_data *madc = platform_get_drvdata(pdev);
-
-	wake_lock_destroy(&madc->wakelock);
-	mutex_destroy(&madc->lock);
-	free_irq(platform_get_irq(pdev, 0), madc);
-	platform_set_drvdata(pdev, NULL);
-	twl6030_madc = NULL;
-	debugfs_remove(madc->file);
-	kfree(madc);
-
-	return 0;
-}
-
-static int twl6030_madc_suspend(struct device *pdev)
-{
-	int ret;
-	u8 reg_val;
-
-	ret = twl_i2c_read_u8(TWL_MODULE_MADC, &reg_val, TWL6030_MADC_CTRL);
-	if (!ret) {
-		reg_val &= ~(TWL6030_MADC_TEMP1_EN);
-		ret = twl_i2c_write_u8(TWL_MODULE_MADC, reg_val,
-					TWL6030_MADC_CTRL);
-	}
-
-	if (ret) {
-		dev_err(twl6030_madc->dev, "unable to disable madc temp1!\n");
-		gpadc_ctrl_reg = TWL6030_MADC_TEMP1_EN;
-	} else
-		gpadc_ctrl_reg = reg_val;
-
-	return 0;
-};
-
-static int twl6030_madc_resume(struct device *pdev)
-{
-	int ret;
-
-	if (!(gpadc_ctrl_reg & TWL6030_MADC_TEMP1_EN)) {
-		gpadc_ctrl_reg |= TWL6030_MADC_TEMP1_EN;
-		ret = twl_i2c_write_u8(TWL_MODULE_MADC, gpadc_ctrl_reg,
-					TWL6030_MADC_CTRL);
-		if (ret)
-			dev_err(twl6030_madc->dev,
-				"unable to enable madc temp1!\n");
-	}
-
-	return 0;
-};
-
-static const struct dev_pm_ops twl6030_madc_pm_ops = {
-	.suspend = twl6030_madc_suspend,
-	.resume = twl6030_madc_resume,
-};
-
-static struct platform_driver twl6030_madc_driver = {
-	.probe = twl6030_madc_probe,
-	.remove = __exit_p(twl6030_madc_remove),
-	.driver = {
-		   .name = "twl6030_madc",
-		   .owner = THIS_MODULE,
-		   .pm = &twl6030_madc_pm_ops,
-		   },
-};
-
-static int __init twl6030_madc_init(void)
-{
-	return platform_driver_register(&twl6030_madc_driver);
-}
-
-module_init(twl6030_madc_init);
-
-static void __exit twl6030_madc_exit(void)
-{
-	platform_driver_unregister(&twl6030_madc_driver);
-}
-
-module_exit(twl6030_madc_exit);
-
-MODULE_DESCRIPTION("TWL6030 ADC driver");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("J Keerthy");
-MODULE_ALIAS("platform:twl6030_madc");
diff --git a/drivers/mfd/twl6030-power.c b/drivers/mfd/twl6030-power.c
deleted file mode 100644
index 918b3c26b9a0..000000000000
--- a/drivers/mfd/twl6030-power.c
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- * Handling for Resource Mapping for TWL6030 Family of chips
- *
- * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
- *	Nishanth Menon
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/pm.h>
-#include <linux/i2c/twl.h>
-#include <linux/platform_device.h>
-#include <linux/suspend.h>
-#include <linux/string.h>
-
-#include <asm/mach-types.h>
-
-#define VREG_GRP		0
-#define MSK_TRANSITION_APP_SHIFT	0x5
-
-static u8 dev_on_group;
-
-/**
- * struct twl6030_resource_map - describe the resource mapping for TWL6030
- * @name:	name of the resource
- * @res_id:	resource ID
- * @base_addr: base address for TWL6030
- * @base_addr: type of the Resources Assignment register for TWL6032
- * base_addr = 0 for PREQx_RES_ASS_A register
- * base_addr = 1 for PREQx_RES_ASS_B register
- * base_addr = 2 for PREQx_RES_ASS_C register
- * @group: which device group can control this resource?
- * @mask: unused for TWL6030
- * @mask: bit mask of the resource in PREQx_RES_ASS_x registers for TWL6032
- */
-struct twl6030_resource_map {
-	char *name;
-	u8 res_id;
-	u8 base_addr;
-	u8 group;
-	u8 mask;
-};
-
-#define TWL6030_RES_DATA(ID, NAME, BASE_ADDR, GROUP) \
-	{.res_id = ID, .name = NAME, .base_addr = BASE_ADDR,\
-	.group = GROUP, .mask = 0,}
-
-#define TWL6032_RES_DATA(ID, NAME, BASE_ADDR, GROUP, MASK) \
-	{.res_id = ID, .name = NAME, .base_addr = BASE_ADDR,\
-	.group = GROUP, .mask = MASK,}
-
-/* list of all s/w modifiable resources in TWL6030 */
-static __initdata struct twl6030_resource_map twl6030_res_map[] = {
-	TWL6030_RES_DATA(RES_V1V29, "V1V29", 0x40, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_V1V8, "V1V8", 0x46, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_V2V1, "V2V1", 0x4c, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VDD1, "CORE1", 0x52, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VDD2, "CORE2", 0x58, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VDD3, "CORE3", 0x5e, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VMEM, "VMEM", 0x64, DEV_GRP_P1),
-	/* VANA cannot be modified */
-	TWL6030_RES_DATA(RES_VUAX1, "VUAX1", 0x84, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VAUX2, "VAUX2", 0x88, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VAUX3, "VAUX3", 0x8c, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VCXIO, "VCXIO", 0x90, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VDAC, "VDAC", 0x94, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VMMC1, "VMMC", 0x98, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VPP, "VPP", 0x9c, DEV_GRP_P1),
-	/* VRTC cannot be modified */
-	TWL6030_RES_DATA(RES_VUSBCP, "VUSB", 0xa0, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_VSIM, "VSIM", 0xa4, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_REGEN, "REGEN1", 0xad, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_REGEN2, "REGEN2", 0xb0, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_SYSEN, "SYSEN", 0xb3, DEV_GRP_P1),
-	/* NRES_PWRON cannot be modified */
-	/* 32KCLKAO cannot be modified */
-	TWL6030_RES_DATA(RES_32KCLKG, "32KCLKG", 0xbc, DEV_GRP_P1),
-	TWL6030_RES_DATA(RES_32KCLKAUDIO, "32KCLKAUDIO", 0xbf, DEV_GRP_P1),
-	/* BIAS cannot be modified */
-	/* VBATMIN_HI cannot be modified */
-	/* RC6MHZ cannot be modified */
-	/* TEMP cannot be modified */
-};
-
-/* list of all s/w modifiable resources in TWL6032 */
-static __initdata struct twl6030_resource_map twl6032_res_map[] = {
-	/* PREQx_RES_ASS_A register resources */
-	TWL6032_RES_DATA(RES_LDOUSB, "VUSB", 0, DEV_GRP_P1, BIT(5)),
-	TWL6032_RES_DATA(RES_SMPS5, "SMPS5", 0, DEV_GRP_P1, BIT(4)),
-	TWL6032_RES_DATA(RES_SMPS5, "SMPS4", 0, DEV_GRP_P1, BIT(3)),
-	TWL6032_RES_DATA(RES_SMPS5, "SMPS3", 0, DEV_GRP_P1, BIT(2)),
-	TWL6032_RES_DATA(RES_SMPS5, "SMPS2", 0, DEV_GRP_P1, BIT(1)),
-	TWL6032_RES_DATA(RES_SMPS5, "SMPS1", 0, DEV_GRP_P1, BIT(0)),
-	/* PREQx_RES_ASS_B register resources */
-	TWL6032_RES_DATA(RES_LDOLN, "LDOLN", 1, DEV_GRP_P1, BIT(7)),
-	TWL6032_RES_DATA(RES_LDO7, "LDO7", 1, DEV_GRP_P1, BIT(6)),
-	TWL6032_RES_DATA(RES_LDO6, "LDO6", 1, DEV_GRP_P1, BIT(5)),
-	TWL6032_RES_DATA(RES_LDO5, "LDO5", 1, DEV_GRP_P1, BIT(4)),
-	TWL6032_RES_DATA(RES_LDO4, "LDO4", 1, DEV_GRP_P1, BIT(3)),
-	TWL6032_RES_DATA(RES_LDO3, "LDO3", 1, DEV_GRP_P1, BIT(2)),
-	TWL6032_RES_DATA(RES_LDO2, "LDO2", 1, DEV_GRP_P1, BIT(1)),
-	TWL6032_RES_DATA(RES_LDO1, "LDO1", 1, DEV_GRP_P1, BIT(0)),
-	/* PREQx_RES_ASS_C register resources */
-	TWL6032_RES_DATA(RES_VSYSMIN_HI, "VSYSMIN_HI", 2, DEV_GRP_P1, BIT(5)),
-	TWL6032_RES_DATA(RES_32KCLKG, "32KCLKG", 2, DEV_GRP_P1, BIT(4)),
-	TWL6032_RES_DATA(RES_32KCLKAUDIO, "32KCLKAUDIO", 2, DEV_GRP_P1, BIT(3)),
-	TWL6032_RES_DATA(RES_SYSEN, "SYSEN", 2, DEV_GRP_P1, BIT(2)),
-	TWL6032_RES_DATA(RES_REGEN2, "REGEN2", 2, DEV_GRP_P1, BIT(1)),
-	TWL6032_RES_DATA(RES_REGEN, "REGEN1", 2, DEV_GRP_P1, BIT(0)),
-};
-
-static struct twl4030_system_config twl6030_sys_config[] = {
-	{.name = "DEV_ON", .group =  DEV_GRP_P1,},
-};
-
-/* Actual power groups that TWL understands */
-#define P3_GRP_6030	BIT(2)		/* secondary processor, modem, etc */
-#define P2_GRP_6030	BIT(1)		/* "peripherals" */
-#define P1_GRP_6030	BIT(0)		/* CPU/Linux */
-
-static __init void twl6030_process_system_config(void)
-{
-	u8 grp;
-	int r;
-	bool i = false;
-
-	struct twl4030_system_config *sys_config;
-	sys_config = twl6030_sys_config;
-
-	while (sys_config && sys_config->name) {
-		if (!strcmp(sys_config->name, "DEV_ON")) {
-			dev_on_group = sys_config->group;
-			i = true;
-			break;
-		}
-		sys_config++;
-	}
-	if (!i)
-		pr_err("%s: Couldn't find DEV_ON resource configuration!"
-			" MOD & CON group would be kept active.\n", __func__);
-
-	if (dev_on_group) {
-		r = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &grp,
-				TWL6030_PHOENIX_DEV_ON);
-		if (r) {
-			pr_err("%s: Error(%d) reading  {addr=0x%02x}",
-				__func__, r, TWL6030_PHOENIX_DEV_ON);
-			/*
-			 * On error resetting to 0, so that all the process
-			 * groups are kept active.
-			 */
-			dev_on_group = 0;
-		} else {
-			/*
-			 * Unmapped processor groups are disabled by writing
-			 * 1 to corresponding group in DEV_ON.
-			 */
-			grp |= (dev_on_group & DEV_GRP_P1) ? 0 : P1_GRP_6030;
-			grp |= (dev_on_group & DEV_GRP_P2) ? 0 : P2_GRP_6030;
-			grp |= (dev_on_group & DEV_GRP_P3) ? 0 : P3_GRP_6030;
-			dev_on_group = grp;
-		}
-
-		/*
-		 *  unmask PREQ transition Executes ACT2SLP and SLP2ACT sleep
-		 *   sequence
-		 */
-		r = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &grp,
-				TWL6030_PM_MASTER_MSK_TRANSITION);
-		if (r) {
-			pr_err("%s: Error (%d) reading"
-				" TWL6030_MSK_TRANSITION\n", __func__, r);
-			return;
-		}
-
-		grp &= (dev_on_group << MSK_TRANSITION_APP_SHIFT);
-
-		r = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, grp,
-					TWL6030_PM_MASTER_MSK_TRANSITION);
-		if (r)
-			pr_err("%s: Error (%d) writing to"
-				" TWL6030_MSK_TRANSITION\n", __func__, r);
-	}
-}
-
-#define DEV_GRP_P1_OFFSET	1
-#define DEV_GRP_P2_OFFSET	4
-#define DEV_GRP_P3_OFFSET	7
-
-static __init void twl6030_program_map(unsigned long features)
-{
-	struct twl6030_resource_map *res;
-	int r, i;
-
-	if (features & TWL6032_SUBCLASS) {
-		/**
-		 * mask[0] = 0 for twl_i2c_write
-		 * mask[1]-mask[3]: PREQ1_RES_ASS_A - PREQ1_RES_ASS_C
-		 * mask[4]-mask[6]: PREQ2_RES_ASS_A - PREQ2_RES_ASS_C
-		 * mask[7]-mask[9]: PREQ3_RES_ASS_A - PREQ3_RES_ASS_C
-		 */
-		u8 mask[10];
-
-		res = twl6032_res_map;
-		memset(&mask[0], 0, 10);
-
-		for (i = 0; i < ARRAY_SIZE(twl6032_res_map); i++) {
-			/* map back from generic device id to TWL6032 mask */
-			mask[DEV_GRP_P1_OFFSET + res->base_addr] |= \
-				(res->group & DEV_GRP_P1) ? res->mask : 0;
-			mask[DEV_GRP_P2_OFFSET + res->base_addr] |= \
-				(res->group & DEV_GRP_P2) ? res->mask : 0;
-			mask[DEV_GRP_P3_OFFSET + res->base_addr] |= \
-				(res->group & DEV_GRP_P3) ? res->mask : 0;
-			res++;
-		}
-
-		r = twl_i2c_write(TWL6030_MODULE_ID0, &mask[0],
-			TWL6032_PREQ1_RES_ASS_A, 9);
-
-		if (r)
-			pr_err("%s: Error(%d) programming TWL6032 PREQ "
-				"Assignment Registers {start addr=0xd7}\n",
-				__func__, r);
-	} else {
-		res = twl6030_res_map;
-		for (i = 0; i < ARRAY_SIZE(twl6030_res_map); i++) {
-			u8 grp = 0;
-
-			/* map back from generic device id to TWL6030 ID */
-			grp |= (res->group & DEV_GRP_P1) ? P1_GRP_6030 : 0;
-			grp |= (res->group & DEV_GRP_P2) ? P2_GRP_6030 : 0;
-			grp |= (res->group & DEV_GRP_P3) ? P3_GRP_6030 : 0;
-
-			r = twl_i2c_write_u8(TWL6030_MODULE_ID0, res->group,
-					     res->base_addr);
-			if (r)
-				pr_err("%s: Error(%d) programming map %s {"
-					"addr=0x%02x},grp=0x%02X\n", __func__,
-					r, res->name, res->base_addr,
-					res->group);
-			res++;
-		}
-	}
-}
-
-static __init void twl6030_update_system_map
-			(struct twl4030_system_config *sys_list)
-{
-	int i;
-	struct twl4030_system_config *sys_res;
-
-	while (sys_list && sys_list->name)  {
-		sys_res = twl6030_sys_config;
-		for (i = 0; i < ARRAY_SIZE(twl6030_sys_config); i++) {
-			if (!strcmp(sys_res->name, sys_list->name))
-				sys_res->group = sys_list->group &
-					(DEV_GRP_P1 | DEV_GRP_P2 | DEV_GRP_P3);
-			sys_res++;
-		}
-		sys_list++;
-	}
-}
-
-static __init void twl6030_update_map(struct twl4030_resconfig *res_list, \
-					unsigned long features)
-{
-	int i, res_idx = 0;
-	struct twl6030_resource_map *res;
-	struct twl6030_resource_map *cur_twl6030_res = twl6030_res_map;
-	int twl6030_res_cnt = ARRAY_SIZE(twl6030_res_map);
-
-	if (features & TWL6032_SUBCLASS) {
-		cur_twl6030_res = twl6032_res_map;
-		twl6030_res_cnt = ARRAY_SIZE(twl6032_res_map);
-	}
-
-	while (res_list->resource != TWL4030_RESCONFIG_UNDEF) {
-		res = cur_twl6030_res;
-		for (i = 0; i < twl6030_res_cnt; i++) {
-			if (res->res_id == res_list->resource) {
-				res->group = res_list->devgroup &
-				    (DEV_GRP_P1 | DEV_GRP_P2 | DEV_GRP_P3);
-				break;
-			}
-			res++;
-		}
-
-		if (i == twl6030_res_cnt) {
-			pr_err("%s: in platform_data resource index %d, cannot"
-			       " find match for resource 0x%02x. NO Update!\n",
-			       __func__, res_idx, res_list->resource);
-		}
-		res_list++;
-		res_idx++;
-	}
-}
-
-
-static int twl6030_power_notifier_cb(struct notifier_block *notifier,
-					unsigned long pm_event,  void *unused)
-{
-	int r = 0;
-
-	switch (pm_event) {
-	case PM_SUSPEND_PREPARE:
-		r = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, dev_on_group,
-				TWL6030_PHOENIX_DEV_ON);
-		if (r)
-			pr_err("%s: Error(%d) programming {addr=0x%02x}",
-				__func__, r, TWL6030_PHOENIX_DEV_ON);
-		break;
-	}
-
-	return notifier_from_errno(r);
-}
-
-static struct notifier_block twl6030_power_pm_notifier = {
-	.notifier_call = twl6030_power_notifier_cb,
-};
-
-/**
- * twl6030_power_init() - Update the power map to reflect connectivity of board
- * @power_data:	power resource map to update (OPTIONAL) - use this if a resource
- *		is used by other devices other than APP (DEV_GRP_P1)
- */
-void __init twl6030_power_init(struct twl4030_power_data *power_data, \
-					unsigned long features)
-{
-	int r;
-
-	if (power_data && (!power_data->resource_config &&
-					!power_data->sys_config)) {
-		pr_err("%s: power data from platform without configuration!\n",
-		       __func__);
-		return;
-	}
-
-	if (power_data && power_data->resource_config)
-		twl6030_update_map(power_data->resource_config, features);
-
-	if (power_data && power_data->sys_config)
-		twl6030_update_system_map(power_data->sys_config);
-
-	twl6030_process_system_config();
-
-	twl6030_program_map(features);
-
-	r = register_pm_notifier(&twl6030_power_pm_notifier);
-	if (r)
-		pr_err("%s: twl6030 power registration failed!\n", __func__);
-
-	return;
-}
diff --git a/drivers/mfd/twl6030-poweroff.c b/drivers/mfd/twl6030-poweroff.c
deleted file mode 100644
index 3187806fceed..000000000000
--- a/drivers/mfd/twl6030-poweroff.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * /drivers/mfd/twl6030-poweroff.c
- *
- * Power off device
- *
- * Copyright (C) 2011 Texas Instruments Corporation
- *
- * Written by Rajeev Kulkarni <rajeevk@ti.com>
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License. See the file "COPYING" in the main directory of this
- * archive for more details.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <linux/module.h>
-#include <linux/pm.h>
-#include <linux/i2c/twl.h>
-
-#define APP_DEVOFF	(1<<0)
-#define CON_DEVOFF	(1<<1)
-#define MOD_DEVOFF	(1<<2)
-
-void twl6030_poweroff(void)
-{
-	u8 val = 0;
-	int err = 0;
-
-	err = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &val,
-				  TWL6030_PHOENIX_DEV_ON);
-	if (err) {
-		pr_warning("I2C error %d reading PHOENIX_DEV_ON\n", err);
-		return;
-	}
-
-	val |= APP_DEVOFF | CON_DEVOFF | MOD_DEVOFF;
-
-	err = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, val,
-				   TWL6030_PHOENIX_DEV_ON);
-
-	if (err) {
-		pr_warning("I2C error %d writing PHOENIX_DEV_ON\n", err);
-		return;
-	}
-
-	return;
-}
-
-static int __init twl6030_poweroff_init(void)
-{
-	pm_power_off = twl6030_poweroff;
-
-	return 0;
-}
-
-static void __exit twl6030_poweroff_exit(void)
-{
-	pm_power_off = NULL;
-}
-
-module_init(twl6030_poweroff_init);
-module_exit(twl6030_poweroff_exit);
-
-MODULE_DESCRIPTION("TLW6030 device power off");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Rajeev Kulkarni");
diff --git a/drivers/power/twl6030_bci_battery.c b/drivers/power/twl6030_bci_battery.c
deleted file mode 100644
index 4441fe252dbc..000000000000
--- a/drivers/power/twl6030_bci_battery.c
+++ /dev/null
@@ -1,3331 +0,0 @@
-/*
- * linux/drivers/power/twl6030_bci_battery.c
- *
- * OMAP4:TWL6030 battery driver for Linux
- *
- * Copyright (C) 2008-2009 Texas Instruments, Inc.
- * Author: Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/i2c/twl.h>
-#include <linux/power_supply.h>
-#include <linux/i2c/twl6030-gpadc.h>
-#include <linux/i2c/bq2415x.h>
-#include <linux/wakelock.h>
-#include <linux/usb/otg.h>
-
-#include <mach/gpio.h>
-
-#define CONTROLLER_INT_MASK	0x00
-#define CONTROLLER_CTRL1	0x01
-#define CONTROLLER_WDG		0x02
-#define CONTROLLER_STAT1	0x03
-#define CHARGERUSB_INT_STATUS	0x04
-#define CHARGERUSB_INT_MASK	0x05
-#define CHARGERUSB_STATUS_INT1	0x06
-#define CHARGERUSB_STATUS_INT2	0x07
-#define CHARGERUSB_CTRL1	0x08
-#define CHARGERUSB_CTRL2	0x09
-#define CHARGERUSB_CTRL3	0x0A
-#define CHARGERUSB_STAT1	0x0B
-#define CHARGERUSB_VOREG	0x0C
-#define CHARGERUSB_VICHRG	0x0D
-#define CHARGERUSB_CINLIMIT	0x0E
-#define CHARGERUSB_CTRLLIMIT1	0x0F
-#define CHARGERUSB_CTRLLIMIT2	0x10
-#define ANTICOLLAPSE_CTRL1	0x11
-#define ANTICOLLAPSE_CTRL2	0x12
-
-/* TWL6032 registers 0xDA to 0xDE - TWL6032_MODULE_CHARGER */
-#define CONTROLLER_CTRL2	0x00
-#define CONTROLLER_VSEL_COMP	0x01
-#define CHARGERUSB_VSYSREG	0x02
-#define CHARGERUSB_VICHRG_PC	0x03
-#define LINEAR_CHRG_STS		0x04
-
-/* TWL6032 Charger Mode Register */
-#define CHARGER_MODE_REG	0xD4
-#define CHARGER_MODE_POWERPATH	BIT(3)
-#define CHARGER_MODE_AUTOCHARGE	BIT(6)
-
-#define LINEAR_CHRG_STS_CRYSTL_OSC_OK	0x40
-#define LINEAR_CHRG_STS_END_OF_CHARGE	0x20
-#define LINEAR_CHRG_STS_VBATOV		0x10
-#define LINEAR_CHRG_STS_VSYSOV		0x08
-#define LINEAR_CHRG_STS_DPPM_STS	0x04
-#define LINEAR_CHRG_STS_CV_STS		0x02
-#define LINEAR_CHRG_STS_CC_STS		0x01
-
-#define FG_REG_00	0x00
-#define FG_REG_01	0x01
-#define FG_REG_02	0x02
-#define FG_REG_03	0x03
-#define FG_REG_04	0x04
-#define FG_REG_05	0x05
-#define FG_REG_06	0x06
-#define FG_REG_07	0x07
-#define FG_REG_08	0x08
-#define FG_REG_09	0x09
-#define FG_REG_10	0x0A
-#define FG_REG_11	0x0B
-
-/* CONTROLLER_INT_MASK */
-#define MVAC_FAULT		(1 << 7)
-#define MAC_EOC			(1 << 6)
-#define LINCH_GATED		(1 << 5)
-#define MBAT_REMOVED		(1 << 4)
-#define MFAULT_WDG		(1 << 3)
-#define MBAT_TEMP		(1 << 2)
-#define MVBUS_DET		(1 << 1)
-#define MVAC_DET		(1 << 0)
-
-/* CONTROLLER_CTRL1 */
-#define CONTROLLER_CTRL1_EN_LINCH	(1 << 5)
-#define CONTROLLER_CTRL1_EN_CHARGER	(1 << 4)
-#define CONTROLLER_CTRL1_SEL_CHARGER	(1 << 3)
-
-/* CONTROLLER_STAT1 */
-#define CONTROLLER_STAT1_EXTCHRG_STATZ	(1 << 7)
-#define CONTROLLER_STAT1_LINCH_GATED	(1 << 6)
-#define CONTROLLER_STAT1_CHRG_DET_N	(1 << 5)
-#define CONTROLLER_STAT1_FAULT_WDG	(1 << 4)
-#define CONTROLLER_STAT1_VAC_DET	(1 << 3)
-#define VAC_DET	(1 << 3)
-#define CONTROLLER_STAT1_VBUS_DET	(1 << 2)
-#define VBUS_DET	(1 << 2)
-#define CONTROLLER_STAT1_BAT_REMOVED	(1 << 1)
-#define CONTROLLER_STAT1_BAT_TEMP_OVRANGE (1 << 0)
-
-/* CHARGERUSB_INT_STATUS */
-#define EN_LINCH		(1 << 4)
-#define CURRENT_TERM_INT	(1 << 3)
-#define CHARGERUSB_STAT		(1 << 2)
-#define CHARGERUSB_THMREG	(1 << 1)
-#define CHARGERUSB_FAULT	(1 << 0)
-
-/* CHARGERUSB_INT_MASK */
-#define MASK_MCURRENT_TERM		(1 << 3)
-#define MASK_MCHARGERUSB_STAT		(1 << 2)
-#define MASK_MCHARGERUSB_THMREG		(1 << 1)
-#define MASK_MCHARGERUSB_FAULT		(1 << 0)
-
-/* CHARGERUSB_STATUS_INT1 */
-#define CHARGERUSB_STATUS_INT1_TMREG	(1 << 7)
-#define CHARGERUSB_STATUS_INT1_NO_BAT	(1 << 6)
-#define CHARGERUSB_STATUS_INT1_BST_OCP	(1 << 5)
-#define CHARGERUSB_STATUS_INT1_TH_SHUTD	(1 << 4)
-#define CHARGERUSB_STATUS_INT1_BAT_OVP	(1 << 3)
-#define CHARGERUSB_STATUS_INT1_POOR_SRC	(1 << 2)
-#define CHARGERUSB_STATUS_INT1_SLP_MODE	(1 << 1)
-#define CHARGERUSB_STATUS_INT1_VBUS_OVP	(1 << 0)
-
-/* CHARGERUSB_STATUS_INT2 */
-#define ICCLOOP		(1 << 3)
-#define CURRENT_TERM	(1 << 2)
-#define CHARGE_DONE	(1 << 1)
-#define ANTICOLLAPSE	(1 << 0)
-
-/* CHARGERUSB_CTRL1 */
-#define SUSPEND_BOOT	(1 << 7)
-#define OPA_MODE	(1 << 6)
-#define HZ_MODE		(1 << 5)
-#define TERM		(1 << 4)
-
-/* CHARGERUSB_CTRL2 */
-#define CHARGERUSB_CTRL2_VITERM_50	(0 << 5)
-#define CHARGERUSB_CTRL2_VITERM_100	(1 << 5)
-#define CHARGERUSB_CTRL2_VITERM_150	(2 << 5)
-#define CHARGERUSB_CTRL2_VITERM_400	(7 << 5)
-
-/* CHARGERUSB_CTRL3 */
-#define VBUSCHRG_LDO_OVRD	(1 << 7)
-#define CHARGE_ONCE		(1 << 6)
-#define BST_HW_PR_DIS		(1 << 5)
-#define AUTOSUPPLY		(1 << 3)
-#define BUCK_HSILIM		(1 << 0)
-
-/* CHARGERUSB_VOREG */
-#define CHARGERUSB_VOREG_3P52		0x01
-#define CHARGERUSB_VOREG_4P0		0x19
-#define CHARGERUSB_VOREG_4P2		0x23
-#define CHARGERUSB_VOREG_4P76		0x3F
-
-/* CHARGERUSB_VICHRG */
-#define CHARGERUSB_VICHRG_300		0x0
-#define CHARGERUSB_VICHRG_500		0x4
-#define CHARGERUSB_VICHRG_1500		0xE
-
-/* CHARGERUSB_CINLIMIT */
-#define CHARGERUSB_CIN_LIMIT_100	0x1
-#define CHARGERUSB_CIN_LIMIT_300	0x5
-#define CHARGERUSB_CIN_LIMIT_500	0x9
-#define CHARGERUSB_CIN_LIMIT_NONE	0xF
-
-/* CHARGERUSB_CTRLLIMIT1 */
-#define VOREGL_4P16			0x21
-#define VOREGL_4P56			0x35
-
-/* CHARGERUSB_CTRLLIMIT2 */
-#define CHARGERUSB_CTRLLIMIT2_1500	0x0E
-#define		LOCK_LIMIT		(1 << 4)
-
-/* ANTICOLLAPSE_CTRL2 */
-#define BUCK_VTH_SHIFT			5
-
-/* FG_REG_00 */
-#define CC_ACTIVE_MODE_SHIFT	6
-#define CC_AUTOCLEAR		(1 << 2)
-#define CC_CAL_EN		(1 << 1)
-#define CC_PAUSE		(1 << 0)
-
-#define REG_TOGGLE1		0x90
-#define FGDITHS			(1 << 7)
-#define FGDITHR			(1 << 6)
-#define FGS			(1 << 5)
-#define FGR			(1 << 4)
-
-/* TWL6030_GPADC_CTRL */
-#define GPADC_CTRL_TEMP1_EN	(1 << 0)    /* input ch 1 */
-#define GPADC_CTRL_TEMP2_EN	(1 << 1)    /* input ch 4 */
-#define GPADC_CTRL_SCALER_EN	(1 << 2)    /* input ch 2 */
-#define GPADC_CTRL_SCALER_DIV4	(1 << 3)
-#define GPADC_CTRL_SCALER_EN_CH11	(1 << 4)    /* input ch 11 */
-#define GPADC_CTRL_TEMP1_EN_MONITOR	(1 << 5)
-#define GPADC_CTRL_TEMP2_EN_MONITOR	(1 << 6)
-#define GPADC_CTRL_ISOURCE_EN		(1 << 7)
-
-#define GPADC_ISOURCE_22uA		22
-#define GPADC_ISOURCE_7uA		7
-
-/* TWL6030/6032 BATTERY VOLTAGE GPADC CHANNELS */
-
-#define TWL6030_GPADC_VBAT_CHNL	0x07
-#define TWL6032_GPADC_VBAT_CHNL	0x12
-
-/* TWL6030_GPADC_CTRL2 */
-#define GPADC_CTRL2_CH18_SCALER_EN	BIT(2)
-
-#define ENABLE_ISOURCE		0x80
-
-#define REG_MISC1		0xE4
-#define VAC_MEAS		0x04
-#define VBAT_MEAS		0x02
-#define BB_MEAS			0x01
-
-#define REG_USB_VBUS_CTRL_SET	0x04
-#define VBUS_MEAS		0x01
-#define REG_USB_ID_CTRL_SET	0x06
-#define ID_MEAS			0x01
-
-#define BBSPOR_CFG		0xE6
-#define	BB_CHG_EN		(1 << 3)
-
-#define STS_HW_CONDITIONS	0x21
-#define STS_USB_ID		(1 << 2)	/* Level status of USB ID */
-
-#define BATTERY_RESISTOR	10000
-#define SIMULATOR_RESISTOR	5000
-#define BATTERY_DETECT_THRESHOLD	((BATTERY_RESISTOR + SIMULATOR_RESISTOR) / 2)   //battery voltage threshold divided by 22uA
-#define CHARGING_CAPACITY_UPDATE_PERIOD	(1000 * 60 * 1)
-
-
-
-/************************************************************/
-#define TIMER_MS_COUNTS     1000
-#define  NUM_DISCHARGE_MIN_SAMPLE   30
-#define NUM_CHARGE_MIN_SAMPLE   30
-/**************************************************************/
-
-/* To get VBUS input limit from twl6030_usb */
-#if CONFIG_TWL6030_USB
-extern unsigned int twl6030_get_usb_max_power(struct otg_transceiver *x);
-#else
-static inline unsigned int twl6030_get_usb_max_power(struct otg_transceiver *x)
-{
-	return 0;
-};
-#endif
-
-/* Ptr to thermistor table */
-static const unsigned int fuelgauge_rate[4] = {1, 4, 16, 64};
-static struct wake_lock chrg_lock;
-
-
-struct twl6030_bci_device_info {
-	struct device		*dev;
-
-	int			voltage_mV;
-	int			bk_voltage_mV;
-	int			current_uA;
-	int			current_avg_uA;
-	int			temp_C;
-	int			charge_status;
-	int			vac_priority;
-	int			bat_health;
-	int			charger_source;
-
-	int			fuelgauge_mode;
-	int			timer_n2;
-	int			timer_n1;
-	s32			charge_n1;
-	s32			charge_n2;
-	s16			cc_offset;
-	u8			usb_online;
-	u8			ac_online;
-	u8			stat1;
-	u8			linear_stat;
-	u8			status_int1;
-	u8			status_int2;
-
-	u8			gpadc_vbat_chnl;
-	u8			watchdog_duration;
-	u16			current_avg_interval;
-	u16			monitoring_interval;
-	unsigned int		min_vbus;
-
-	struct			twl4030_bci_platform_data *platform_data;
-
-	unsigned int		charger_incurrentmA;
-	unsigned int		charger_outcurrentmA;
-	unsigned long		usb_max_power;
-	unsigned long		event;
-
-	unsigned int		capacity;
-	unsigned int		capacity_debounce_count;
-	unsigned long		ac_next_refresh;
-	unsigned int		prev_capacity;
-	unsigned int		wakelock_enabled;
-
-	struct power_supply	bat;
-	struct power_supply	usb;
-	struct power_supply	ac;
-	struct power_supply	bk_bat;
-
-	struct otg_transceiver	*otg;
-	struct notifier_block	nb;
-	struct work_struct	usb_work;
-
-	struct workqueue_struct	*freezable_work;
-
-	struct delayed_work	twl6030_bci_monitor_work;
-	struct delayed_work	twl6030_current_avg_work;
-
-	unsigned long		features;
-
-	int			use_hw_charger;
-	int			use_power_path;
-
-	/* max scale current based on sense resitor */
-	int			current_max_scale;
-	struct delayed_work work;
-	unsigned int interval;
-
-	int 	gBatCapacityDisChargeCnt;
-	int           capacitytmp;
-	int           usb_status;
-	int           usb_old_satus;
-	int 	 gBatCapacityChargeCnt;
-	int            suspend_capacity;
-	int            resume_status;
-};
-
-static BLOCKING_NOTIFIER_HEAD(notifier_list);
-extern u32 wakeup_timer_seconds;
-
-static void twl6030_config_min_vbus_reg(struct twl6030_bci_device_info *di,
-						unsigned int value)
-{
-	u8 rd_reg = 0;
-	int ret;
-
-	/* not required on TWL6032 */
-	if (di->features & TWL6032_SUBCLASS)
-		return;
-
-	if (value > 4760 || value < 4200) {
-		dev_err(di->dev, "invalid min vbus\n");
-		return;
-	}
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &rd_reg,
-					ANTICOLLAPSE_CTRL2);
-	if (ret)
-		goto err;
-	rd_reg = rd_reg & 0x1F;
-	rd_reg = rd_reg | (((value - 4200)/80) << BUCK_VTH_SHIFT);
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, rd_reg,
-					ANTICOLLAPSE_CTRL2);
-
-	if (!ret)
-		return;
-err:
-	pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static void twl6030_config_iterm_reg(struct twl6030_bci_device_info *di,
-						unsigned int term_currentmA)
-{
-	int ret;
-
-	if ((term_currentmA > 400) || (term_currentmA < 50)) {
-		dev_err(di->dev, "invalid termination current\n");
-		return;
-	}
-
-	term_currentmA = ((term_currentmA - 50)/50) << 5;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, term_currentmA,
-						CHARGERUSB_CTRL2);
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static unsigned int twl6030_get_iterm_reg(struct twl6030_bci_device_info *di)
-{
-	int ret;
-	unsigned int currentmA;
-	u8 val = 0;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &val, CHARGERUSB_CTRL2);
-	if (ret) {
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-		currentmA = 0;
-	} else
-		currentmA = 50 + (val >> 5) * 50;
-
-	return currentmA;
-}
-
-static void twl6030_config_voreg_reg(struct twl6030_bci_device_info *di,
-							unsigned int voltagemV)
-{
-	int ret;
-
-	if ((voltagemV < 3500) || (voltagemV > 4760)) {
-		dev_err(di->dev, "invalid charger_voltagemV\n");
-		return;
-	}
-
-	voltagemV = (voltagemV - 3500) / 20;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, voltagemV,
-						CHARGERUSB_VOREG);
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static unsigned int twl6030_get_voreg_reg(struct twl6030_bci_device_info *di)
-{
-	int ret;
-	unsigned int voltagemV;
-	u8 val = 0;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &val, CHARGERUSB_VOREG);
-	if (ret) {
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-		voltagemV = 0;
-	} else
-		voltagemV = 3500 + (val * 20);
-
-	return voltagemV;
-}
-
-static void twl6030_config_vichrg_reg(struct twl6030_bci_device_info *di,
-							unsigned int currentmA)
-{
-	int ret;
-
-	if ((currentmA >= 300) && (currentmA <= 450))
-		currentmA = (currentmA - 300) / 50;
-	else if ((currentmA >= 500) && (currentmA <= 1500))
-		currentmA = (currentmA - 500) / 100 + 4;
-	else {
-		dev_err(di->dev, "invalid charger_currentmA\n");
-		return;
-	}
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, currentmA,
-						CHARGERUSB_VICHRG);
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static void twl6030_config_cinlimit_reg(struct twl6030_bci_device_info *di,
-							unsigned int currentmA)
-{
-	int ret;
-
-	if ((currentmA >= 50) && (currentmA <= 750))
-		currentmA = (currentmA - 50) / 50;
-	else if ((currentmA > 750) && (currentmA <= 1500) &&
-			(di->features & TWL6032_SUBCLASS)) {
-			currentmA = ((currentmA % 100) ? 0x30 : 0x20) +
-						((currentmA - 100) / 100);
-	} else if (currentmA < 50) {
-		dev_err(di->dev, "invalid input current limit\n");
-		return;
-	} else {
-		/* This is no current limit */
-		currentmA = 0x0F;
-	}
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, currentmA,
-					CHARGERUSB_CINLIMIT);
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static void twl6030_config_limit1_reg(struct twl6030_bci_device_info *di,
-							unsigned int voltagemV)
-{
-	int ret;
-
-	if ((voltagemV < 3500) || (voltagemV > 4760)) {
-		dev_err(di->dev, "invalid max_charger_voltagemV\n");
-		return;
-	}
-
-	voltagemV = (voltagemV - 3500) / 20;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, voltagemV,
-						CHARGERUSB_CTRLLIMIT1);
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static unsigned int twl6030_get_limit1_reg(struct twl6030_bci_device_info *di)
-{
-	int ret;
-	unsigned int voltagemV;
-	u8 val = 0;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &val,
-				CHARGERUSB_CTRLLIMIT1);
-	if (ret) {
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-		voltagemV = 0;
-	} else
-		voltagemV = 3500 + (val * 20);
-
-	return voltagemV;
-}
-
-static void twl6030_config_limit2_reg(struct twl6030_bci_device_info *di,
-							unsigned int currentmA)
-{
-	int ret;
-
-	if ((currentmA >= 300) && (currentmA <= 450))
-		currentmA = (currentmA - 300) / 50;
-	else if ((currentmA >= 500) && (currentmA <= 1500))
-		currentmA = (currentmA - 500) / 100 + 4;
-	else {
-		dev_err(di->dev, "invalid max_charger_currentmA\n");
-		return;
-	}
-
-	currentmA |= LOCK_LIMIT;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, currentmA,
-						CHARGERUSB_CTRLLIMIT2);
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static const int vichrg[] = {
-	300, 350, 400, 450, 500, 600, 700, 800,
-	900, 1000, 1100, 1200, 1300, 1400, 1500, 300
-};
-
-static unsigned int twl6030_get_limit2_reg(struct twl6030_bci_device_info *di)
-{
-	int ret;
-	unsigned int currentmA;
-	u8 val = 0;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &val,
-					CHARGERUSB_CTRLLIMIT2);
-	if (ret) {
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-		currentmA = 0;
-	} else
-		currentmA = vichrg[val & 0xF];
-
-	return currentmA;
-}
-
-/*
- * Return channel value
- * Or < 0 on failure.
- */
-static int twl6030_get_gpadc_conversion(struct twl6030_bci_device_info *di,
-					int channel_no)
-{
-	struct twl6030_gpadc_request req;
-	int temp = 0;
-	int ret;
-
-	req.channels = (1 << channel_no);
-	req.method = TWL6030_GPADC_SW2;
-	req.active = 0;
-	req.func_cb = NULL;
-	ret = twl6030_gpadc_conversion(&req);
-	if (ret < 0)
-		return ret;
-
-	if (req.rbuf[channel_no] > 0)
-		temp = req.rbuf[channel_no];
-
-	return temp;
-}
-
-static int is_battery_present(struct twl6030_bci_device_info *di)
-{
-	int val;
-	static unsigned int current_src_val;
-
-	/*
-	 * Prevent charging on batteries were id resistor is
-	 * less than 5K.
-	 */
-	val = twl6030_get_gpadc_conversion(di,di->gpadc_vbat_chnl);
-
-	/*
-	 * twl6030_get_gpadc_conversion for
-	 * 6030 return resistance, for 6032 - voltage and
-	 * it should be converted to resistance before
-	 * using.
-	 */
-	if (!current_src_val) {
-		u8 reg = 0;
-
-		if (twl_i2c_read_u8(TWL_MODULE_MADC, &reg,
-					TWL6030_GPADC_CTRL))
-			pr_err("%s: Error reading TWL6030_GPADC_CTRL\n",
-				__func__);
-
-		current_src_val = (reg & GPADC_CTRL_ISOURCE_EN) ?
-					GPADC_ISOURCE_22uA :
-					GPADC_ISOURCE_7uA;
-	}
-
-	val = (val * 1000) / current_src_val;
-
-	if (val < BATTERY_DETECT_THRESHOLD)
-		return 0;
-
-	return 1;
-}
-
-static void twl6030_stop_usb_charger(struct twl6030_bci_device_info *di)
-{
-	int ret;
-	u8 reg;
-	//printk("*************twl6030_stop_usb_charger***************\n");
-	if (di->use_hw_charger) {
-		ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &reg,
-				CHARGERUSB_CTRL1);
-		if (ret)
-			goto err;
-		reg |= HZ_MODE;
-		ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, reg,
-				CHARGERUSB_CTRL1);
-		if (ret)
-			goto err;
-
-		return;
-	}
-
-	di->charger_source = 0;
-	di->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, 0, CONTROLLER_CTRL1);
-
-err:
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static void twl6030_start_usb_charger(struct twl6030_bci_device_info *di)
-{
-	int ret;
-	u8 reg;
-
-
-//printk("***************twl6030_start_usb_charger*****************************************\n");
-
-	if (di->use_hw_charger) {
-		ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &reg,
-				CHARGERUSB_CTRL1);
-		if (ret)
-			goto err;
-
-		reg &= ~HZ_MODE;
-		ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, reg,
-				CHARGERUSB_CTRL1);
-		if (ret)
-			goto err;
-
-		return;
-	}
-
-	if (!is_battery_present(di)) {
-		dev_info(di->dev, "BATTERY NOT DETECTED!\n");
-		return;
-	}
-
-	if (di->charger_source == POWER_SUPPLY_TYPE_MAINS)
-		return;
-
-	dev_dbg(di->dev, "USB input current limit %dmA\n",
-					di->charger_incurrentmA);
-	if (di->charger_incurrentmA < 50) {
-		ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER,
-					0, CONTROLLER_CTRL1);
-		if (ret)
-			goto err;
-
-		return;
-	}
-
-	twl6030_config_vichrg_reg(di, di->charger_outcurrentmA);
-	twl6030_config_cinlimit_reg(di, di->charger_incurrentmA);
-	twl6030_config_voreg_reg(di, di->platform_data->max_bat_voltagemV);
-	twl6030_config_iterm_reg(di, di->platform_data->termination_currentmA);
-
-	if (di->charger_incurrentmA >= 50) {
-		reg = CONTROLLER_CTRL1_EN_CHARGER;
-
-		if (di->use_power_path)
-			reg |= CONTROLLER_CTRL1_EN_LINCH;
-
-		ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, reg,
-				CONTROLLER_CTRL1);
-		if (ret)
-			goto err;
-
-		di->charge_status = POWER_SUPPLY_STATUS_CHARGING;
-	}
-	return;
-err:
-	pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static void twl6030_stop_ac_charger(struct twl6030_bci_device_info *di)
-{
-	long int events;
-	int ret;
-
-	di->charger_source = 0;
-	di->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;
-	events = BQ2415x_STOP_CHARGING;
-
-	if (di->use_hw_charger)
-		return;
-
-	blocking_notifier_call_chain(&notifier_list, events, NULL);
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, 0, CONTROLLER_CTRL1);
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-
-	if (di->wakelock_enabled)
-		wake_unlock(&chrg_lock);
-}
-
-static void twl6030_start_ac_charger(struct twl6030_bci_device_info *di)
-{
-	long int events;
-	int ret;
-
-	if (!is_battery_present(di)) {
-		dev_info(di->dev, "BATTERY NOT DETECTED!\n");
-		return;
-	}
-	dev_dbg(di->dev, "AC charger detected\n");
-	di->charger_source = POWER_SUPPLY_TYPE_MAINS;
-	di->charge_status = POWER_SUPPLY_STATUS_CHARGING;
-	events = BQ2415x_START_CHARGING;
-
-	if (di->use_hw_charger)
-		return;
-
-	blocking_notifier_call_chain(&notifier_list, events, NULL);
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER,
-			CONTROLLER_CTRL1_EN_CHARGER |
-			CONTROLLER_CTRL1_SEL_CHARGER,
-			CONTROLLER_CTRL1);
-	if (ret)
-		pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-
-	if (di->wakelock_enabled)
-		wake_lock(&chrg_lock);
-}
-
-static void twl6030_stop_charger(struct twl6030_bci_device_info *di)
-{
-	//printk("$$$$$$$$$$$$twl6030_stop_charger$$$$$$$$$$$$\n");
-	if (di->charger_source == POWER_SUPPLY_TYPE_MAINS)
-		twl6030_stop_ac_charger(di);
-	else if (di->charger_source == POWER_SUPPLY_TYPE_USB)
-		twl6030_stop_usb_charger(di);
-}
-
-static void twl6032_charger_ctrl_interrupt(struct twl6030_bci_device_info *di)
-{
-	u8 stat_toggle, stat_reset, stat_set = 0;
-	u8 present_state = 0, linear_state;
-	u8 present_status = 0;
-	int err;
-
-	err = twl_i2c_read_u8(TWL6032_MODULE_CHARGER, &present_state,
-			LINEAR_CHRG_STS);
-	if (err < 0) {
-		dev_err(di->dev, "%s: Error access to TWL6030 (%d)\n",
-								__func__, err);
-		return;
-	}
-
-	err = twl_i2c_read_u8(TWL6032_MODULE_CHARGER, &present_status,
-			CHARGERUSB_INT_STATUS);
-	if (err < 0) {
-		dev_err(di->dev, "%s: Error access to TWL6030 (%d)\n",
-								__func__, err);
-		return;
-	}
-
-	linear_state = di->linear_stat;
-
-	stat_toggle = linear_state ^ present_state;
-	stat_set = stat_toggle & present_state;
-	stat_reset = stat_toggle & linear_state;
-	di->linear_stat = present_state;
-
-	if (stat_set & LINEAR_CHRG_STS_CRYSTL_OSC_OK)
-		dev_dbg(di->dev, "Linear status: CRYSTAL OSC OK\n");
-	if (present_state & LINEAR_CHRG_STS_END_OF_CHARGE) {
-		dev_dbg(di->dev, "Linear status: END OF CHARGE\n");
-		di->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
-	}
-	if (present_status & EN_LINCH) {
-		dev_dbg(di->dev, "Linear status: START OF CHARGE\n");
-		di->charge_status = POWER_SUPPLY_STATUS_CHARGING;
-	}
-
-	if (stat_set & LINEAR_CHRG_STS_VBATOV) {
-		dev_dbg(di->dev, "Linear Status: VBATOV\n");
-		di->bat_health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
-	}
-	if (stat_reset & LINEAR_CHRG_STS_VBATOV) {
-		dev_dbg(di->dev, "Linear Status: VBATOV\n");
-		di->bat_health = POWER_SUPPLY_HEALTH_GOOD;
-	}
-
-	if (stat_set & LINEAR_CHRG_STS_VSYSOV)
-		dev_dbg(di->dev, "Linear Status: VSYSOV\n");
-	if (stat_set & LINEAR_CHRG_STS_DPPM_STS)
-		dev_dbg(di->dev, "Linear Status: DPPM STS\n");
-	if (stat_set & LINEAR_CHRG_STS_CV_STS)
-		dev_dbg(di->dev, "Linear Status: CV STS\n");
-	if (stat_set & LINEAR_CHRG_STS_CC_STS)
-		dev_dbg(di->dev, "Linear Status: CC STS\n");
-}
-
-/*
- * Interrupt service routine
- *
- * Attends to TWL 6030 power module interruptions events, specifically
- * USB_PRES (USB charger presence) CHG_PRES (AC charger presence) events
- *
- */
-static irqreturn_t twl6030charger_ctrl_interrupt(int irq, void *_di)
-{
-//	printk("%s\n", __func__);
-
-	struct twl6030_bci_device_info *di = _di;
-	int ret;
-	int charger_fault = 0;
-	long int events;
-	u8 stat_toggle, stat_reset, stat_set = 0;
-	u8 charge_state = 0;
-	u8 present_charge_state = 0;
-	u8 ac_or_vbus, no_ac_and_vbus = 0;
-	u8 hw_state = 0, temp = 0;
-
-	/* read charger controller_stat1 */
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &present_charge_state,
-		CONTROLLER_STAT1);
-	if (ret) {
-		/*
-		 * Since present state read failed, charger_state is no
-		 * longer valid, reset to zero inorder to detect next events
-		 */
-		charge_state = 0;
-		return IRQ_NONE;
-	}
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &hw_state, STS_HW_CONDITIONS);
-	if (ret)
-		goto err;
-
-	charge_state = di->stat1;
-
-	stat_toggle = charge_state ^ present_charge_state;
-	stat_set = stat_toggle & present_charge_state;
-	stat_reset = stat_toggle & charge_state;
-
-	no_ac_and_vbus = !((present_charge_state) & (VBUS_DET | VAC_DET));
-	ac_or_vbus = charge_state & (VBUS_DET | VAC_DET);
-	if (no_ac_and_vbus && ac_or_vbus) {
-		di->charger_source = 0;
-		dev_dbg(di->dev, "No Charging source\n");
-		/* disable charging when no source present */
-	}
-
-	charge_state = present_charge_state;
-	di->stat1 = present_charge_state;
-	if ((charge_state & VAC_DET) &&
-		(charge_state & CONTROLLER_STAT1_EXTCHRG_STATZ)) {
-		events = BQ2415x_CHARGER_FAULT;
-		blocking_notifier_call_chain(&notifier_list, events, NULL);
-	}
-
-	if (stat_reset & VBUS_DET) {
-		/* On a USB detach, UNMASK VBUS OVP if masked*/
-		ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &temp,
-				CHARGERUSB_INT_MASK);
-		if (ret)
-			goto err;
-
-		if (temp & MASK_MCHARGERUSB_FAULT) {
-			ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER,
-					(temp & ~MASK_MCHARGERUSB_FAULT),
-					CHARGERUSB_INT_MASK);
-			if (ret)
-				goto err;
-		}
-		di->usb_online = 0;
-		dev_info(di->dev, "usb removed\n");
-		twl6030_stop_usb_charger(di);
-		if (present_charge_state & VAC_DET)
-			twl6030_start_ac_charger(di);
-
-	}
-
-	if (stat_set & VBUS_DET) {
-		/* In HOST mode (ID GROUND) when a device is connected,
-		 * Mask VBUS OVP interrupt and do no enable usb
-		 * charging
-		 */
-		if (hw_state & STS_USB_ID) {
-			ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER,
-					&temp,
-					CHARGERUSB_INT_MASK);
-			if (ret)
-				goto err;
-
-			if (!(temp & MASK_MCHARGERUSB_FAULT)) {
-				ret = twl_i2c_write_u8(
-						TWL6030_MODULE_CHARGER,
-						(temp | MASK_MCHARGERUSB_FAULT),
-						CHARGERUSB_INT_MASK);
-				if (ret)
-					goto err;
-			}
-		} else {
-			di->usb_online = POWER_SUPPLY_TYPE_USB;
-			if ((present_charge_state & VAC_DET) &&
-					(di->vac_priority == 2))
-				dev_info(di->dev, "USB charger detected"
-						", continue with VAC\n");
-			else {
-				di->charger_source =
-						POWER_SUPPLY_TYPE_USB;
-				di->charge_status =
-						POWER_SUPPLY_STATUS_CHARGING;
-			}
-			dev_info(di->dev, "vbus detect\n");
-		}
-	}
-
-	if (stat_reset & VAC_DET) {
-		di->ac_online = 0;
-		dev_info(di->dev, "vac removed\n");
-		twl6030_stop_ac_charger(di);
-		if (present_charge_state & VBUS_DET) {
-			di->charger_source = POWER_SUPPLY_TYPE_USB;
-			di->charge_status =
-					POWER_SUPPLY_STATUS_CHARGING;
-			twl6030_start_usb_charger(di);
-		}
-	}
-	if (stat_set & VAC_DET) {
-		di->ac_online = POWER_SUPPLY_TYPE_MAINS;
-		if ((present_charge_state & VBUS_DET) &&
-				(di->vac_priority == 3))
-			dev_info(di->dev,
-					"AC charger detected"
-					", continue with VBUS\n");
-		else
-			twl6030_start_ac_charger(di);
-	}
-
-	if (stat_set & CONTROLLER_STAT1_FAULT_WDG) {
-		charger_fault = 1;
-		dev_info(di->dev, "Fault watchdog fired\n");
-	}
-	if (stat_reset & CONTROLLER_STAT1_FAULT_WDG)
-		dev_err(di->dev, "Fault watchdog recovered\n");
-	if (stat_set & CONTROLLER_STAT1_BAT_REMOVED)
-		dev_err(di->dev, "Battery removed\n");
-	if (stat_reset & CONTROLLER_STAT1_BAT_REMOVED)
-		dev_err(di->dev, "Battery inserted\n");
-	if (stat_set & CONTROLLER_STAT1_BAT_TEMP_OVRANGE) {
-		dev_err(di->dev, "Battery temperature overrange\n");
-		di->bat_health = POWER_SUPPLY_HEALTH_OVERHEAT;
-	}
-	if (stat_reset & CONTROLLER_STAT1_BAT_TEMP_OVRANGE) {
-		dev_dbg(di->dev, "Battery temperature within range\n");
-		di->bat_health = POWER_SUPPLY_HEALTH_GOOD;
-	}
-	if (di->features & TWL6032_SUBCLASS)
-		twl6032_charger_ctrl_interrupt(di);
-
-	if (charger_fault) {
-		twl6030_stop_usb_charger(di);
-		di->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
-		dev_dbg(di->dev, "Charger Fault stop charging\n");
-	}
-
-	if (di->capacity != -1)
-		power_supply_changed(&di->bat);
-	else {
-		cancel_delayed_work(&di->twl6030_bci_monitor_work);
-		queue_delayed_work(di->freezable_work, &di->twl6030_bci_monitor_work, 0);
-	}
-err:
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t twl6030charger_fault_interrupt(int irq, void *_di)
-{
-	struct twl6030_bci_device_info *di = _di;
-	int charger_fault = 0;
-	int ret;
-
-	u8 usb_charge_sts = 0, usb_charge_sts1 = 0, usb_charge_sts2 = 0;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &usb_charge_sts,
-						CHARGERUSB_INT_STATUS);
-	if (ret)
-		goto err;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &usb_charge_sts1,
-						CHARGERUSB_STATUS_INT1);
-	if (ret)
-		goto err;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &usb_charge_sts2,
-						CHARGERUSB_STATUS_INT2);
-	if (ret)
-		goto err;
-
-	di->status_int1 = usb_charge_sts1;
-	di->status_int2 = usb_charge_sts2;
-	if (usb_charge_sts & CURRENT_TERM_INT)
-		dev_dbg(di->dev, "USB CURRENT_TERM_INT\n");
-	if (usb_charge_sts & CHARGERUSB_THMREG)
-		dev_dbg(di->dev, "USB CHARGERUSB_THMREG\n");
-	if (usb_charge_sts & CHARGERUSB_FAULT)
-		dev_dbg(di->dev, "USB CHARGERUSB_FAULT\n");
-
-	if (usb_charge_sts1 & CHARGERUSB_STATUS_INT1_TMREG)
-		dev_dbg(di->dev, "USB CHARGER Thermal regulation activated\n");
-	if (usb_charge_sts1 & CHARGERUSB_STATUS_INT1_NO_BAT)
-		dev_dbg(di->dev, "No Battery Present\n");
-	if (usb_charge_sts1 & CHARGERUSB_STATUS_INT1_BST_OCP)
-		dev_dbg(di->dev, "USB CHARGER Boost Over current protection\n");
-	if (usb_charge_sts1 & CHARGERUSB_STATUS_INT1_TH_SHUTD) {
-		charger_fault = 1;
-		dev_dbg(di->dev, "USB CHARGER Thermal Shutdown\n");
-	}
-	if (usb_charge_sts1 & CHARGERUSB_STATUS_INT1_BAT_OVP)
-		dev_dbg(di->dev, "USB CHARGER Bat Over Voltage Protection\n");
-	if (usb_charge_sts1 & CHARGERUSB_STATUS_INT1_POOR_SRC)
-		dev_dbg(di->dev, "USB CHARGER Poor input source\n");
-	if (usb_charge_sts1 & CHARGERUSB_STATUS_INT1_SLP_MODE)
-		dev_dbg(di->dev, "USB CHARGER Sleep mode\n");
-	if (usb_charge_sts1 & CHARGERUSB_STATUS_INT1_VBUS_OVP)
-		dev_dbg(di->dev, "USB CHARGER VBUS over voltage\n");
-
-	if (usb_charge_sts2 & CHARGE_DONE) {
-		di->charge_status = POWER_SUPPLY_STATUS_FULL;
-		dev_dbg(di->dev, "USB charge done\n");
-	}
-	if (usb_charge_sts2 & CURRENT_TERM)
-		dev_dbg(di->dev, "USB CURRENT_TERM\n");
-	if (usb_charge_sts2 & ICCLOOP)
-		dev_dbg(di->dev, "USB ICCLOOP\n");
-	if (usb_charge_sts2 & ANTICOLLAPSE)
-		dev_dbg(di->dev, "USB ANTICOLLAPSE\n");
-
-	if (charger_fault) {
-		twl6030_stop_usb_charger(di);
-		di->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
-		dev_dbg(di->dev, "Charger Fault stop charging\n");
-	}
-	dev_info(di->dev, "Charger fault detected STS, INT1, INT2 %x %x %x\n",
-	    usb_charge_sts, usb_charge_sts1, usb_charge_sts2);
-
-	power_supply_changed(&di->bat);
-err:
-	return IRQ_HANDLED;
-}
-
-/*
- * In HW charger mode on 6032 irq routines must only deal with updating
- * state of charger. The hardware deals with start/stop conditions
- * automatically.
- */
-static irqreturn_t twl6032charger_ctrl_interrupt_hw(int irq, void *_di)
-{
-	struct twl6030_bci_device_info *di = _di;
-	u8 stat1, linear;
-	int charger_stop = 0, end_of_charge = 0;
-	int ret;
-
-	//printk("xxxxxxxxxxxxxxxxxxxxxxxx twl6032charger_ctrl_interrupt_hw   xxxxxxxxxxxxxx\n");
-	/* read charger controller_stat1 */
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &stat1,
-			CONTROLLER_STAT1);
-	if (ret)
-		goto out;
-
-	ret = twl_i2c_read_u8(TWL6032_MODULE_CHARGER, &linear,
-			LINEAR_CHRG_STS);
-	if (ret < 0)
-		goto out;
-
-	if (!(stat1 & (VBUS_DET | VAC_DET))) {
-		charger_stop = 1;
-		di->ac_online = di->usb_online = 0;
-		//printk("%%%%%%%%%%%%%%charger_stop = 1%%%%%%%%%%%%%\n");
-	}
-
-	if (!(di->usb_online || di->ac_online)) {
-		if (stat1 & VBUS_DET) {
-			di->usb_online = 1;
-			di->bat_health = POWER_SUPPLY_HEALTH_GOOD;
-//			printk("%%%%%%%%%%%%%%di->usb_online = 1%%%%%%%%%%%%%\n");
-
-			//schedule_work(&di->usb_work);
-		} else if (stat1 & VAC_DET) {
-			di->ac_online = 1;
-			di->bat_health = POWER_SUPPLY_HEALTH_GOOD;
-//			printk("%%%%%%%%%%%%%%di->ac_online = 1%%%%%%%%%%%%%\n");
-		}
-	}
-
-	if (stat1 & CONTROLLER_STAT1_FAULT_WDG) {
-		charger_stop = 1;
-		di->bat_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-		 dev_err(di->dev, "Charger error : Fault watchdog\n");
-	}
-	if (stat1 & CONTROLLER_STAT1_BAT_REMOVED) {
-		charger_stop = 1;
-		di->bat_health = POWER_SUPPLY_HEALTH_DEAD;
-		dev_info(di->dev, "Battery removed\n");
-	}
-	if (stat1 & CONTROLLER_STAT1_BAT_TEMP_OVRANGE) {
-		charger_stop = 1;
-		 dev_dbg(di->dev,
-			"Charger error : Battery temperature overrange\n");
-		di->bat_health = POWER_SUPPLY_HEALTH_OVERHEAT;
-	}
-
-	if ((stat1 & CONTROLLER_STAT1_LINCH_GATED) &&
-			di->use_power_path) {
-
-		charger_stop = 1;
-
-		if (linear & LINEAR_CHRG_STS_CRYSTL_OSC_OK) {
-			di->bat_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-			 dev_dbg(di->dev, "Charger error: CRYSTAL OSC OK\n");
-		}
-
-		if (linear & LINEAR_CHRG_STS_END_OF_CHARGE) {
-			end_of_charge = 1;
-			di->bat_health = POWER_SUPPLY_HEALTH_GOOD;
-			dev_dbg(di->dev, "Charger: Full charge\n");
-		}
-
-		if (linear & LINEAR_CHRG_STS_VBATOV) {
-			di->bat_health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
-			 dev_dbg(di->dev,
-				"Charger error : Linear Status: VBATOV\n");
-		}
-
-		if (linear & LINEAR_CHRG_STS_VSYSOV) {
-			di->bat_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-			 dev_dbg(di->dev,
-				"Charger error : Linear Status: VSYSOV\n");
-		}
-	}
-
-	if (charger_stop) {
-		if (!(stat1 & (VBUS_DET | VAC_DET))) {
-			di->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;
-		} else {
-			if (end_of_charge)
-				di->charge_status =
-					POWER_SUPPLY_STATUS_FULL;
-			else
-				di->charge_status =
-					POWER_SUPPLY_STATUS_NOT_CHARGING;
-		}
-	}
-	//printk("%%%%%%%%%%%%%%%%%%twl6032charger_ctrl_interrupt_hw  end  xxxxxxxxxxxxxx\n");
-
-	power_supply_changed(&di->bat);
-
-out:
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t twl6032charger_fault_interrupt_hw(int irq, void *_di)
-{
-	struct twl6030_bci_device_info *di = _di;
-	int charger_stop = 0, charger_start = 0;
-	int ret;
-	u8 sts, sts_int1, sts_int2, stat1;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &sts,
-						CHARGERUSB_INT_STATUS);
-	if (ret)
-		goto out;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &sts_int1,
-						CHARGERUSB_STATUS_INT1);
-	if (ret)
-		goto out;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &sts_int2,
-						CHARGERUSB_STATUS_INT2);
-	if (ret)
-		goto out;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &stat1,
-						CONTROLLER_STAT1);
-	if (ret)
-		goto out;
-
-	if (sts & EN_LINCH) {
-		charger_start = 1;
-		dev_dbg(di->dev, "Charger: EN_LINCH\n");
-		goto out;
-	}
-
-	if ((sts & CURRENT_TERM_INT) && !di->use_power_path) {
-		dev_dbg(di->dev, "Charger: CURRENT_TERM_INT\n");
-
-		if (sts_int2 & CURRENT_TERM) {
-			charger_stop = 1;
-			 dev_dbg(di->dev, "Charger error: CURRENT_TERM\n");
-		}
-	}
-
-	if (sts & CHARGERUSB_STAT) {
-		dev_dbg(di->dev, "Charger: CHARGEUSB_STAT\n");
-
-		if (sts_int2 & ANTICOLLAPSE)
-			 dev_dbg(di->dev, "Charger error: ANTICOLLAPSE\n");
-	}
-
-	if (sts & CHARGERUSB_THMREG) {
-		dev_dbg(di->dev, "Charger: CHARGERUSB_THMREG\n");
-
-		if (sts_int1 & CHARGERUSB_STATUS_INT1_TMREG)
-			dev_dbg(di->dev, "Charger error: TMREG\n");
-	}
-
-	if (sts & CHARGERUSB_FAULT) {
-		dev_dbg(di->dev, "Charger: CHARGERUSB_FAULT\n");
-
-		charger_stop = 1;
-
-		if (!di->use_power_path) {
-			if (sts_int1 & CHARGERUSB_STATUS_INT1_NO_BAT) {
-				di->bat_health = POWER_SUPPLY_HEALTH_DEAD;
-				dev_err(di->dev,
-					"Charger error : NO_BAT\n");
-			}
-			if (sts_int1 & CHARGERUSB_STATUS_INT1_BAT_OVP) {
-				di->bat_health =
-					POWER_SUPPLY_HEALTH_OVERVOLTAGE;
-				dev_dbg(di->dev, "Charger error : BAT_OVP\n");
-			}
-		}
-
-		if (sts_int1 & CHARGERUSB_STATUS_INT1_BST_OCP) {
-			di->bat_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-			printk(KERN_ERR "Charger error : BST_OCP\n");
-		}
-		if (sts_int1 & CHARGERUSB_STATUS_INT1_TH_SHUTD) {
-			di->bat_health = POWER_SUPPLY_HEALTH_OVERHEAT;
-			printk(KERN_ERR "Charger error : TH_SHUTD\n");
-		}
-		if (sts_int1 & CHARGERUSB_STATUS_INT1_POOR_SRC) {
-			di->bat_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-			printk(KERN_ERR "Charger error : POOR_SRC\n");
-		}
-		if (sts_int1 & CHARGERUSB_STATUS_INT1_SLP_MODE)
-			dev_dbg(di->dev, "Charger error: SLP_MODE\n");
-
-		if (sts_int1 & CHARGERUSB_STATUS_INT1_VBUS_OVP) {
-			di->bat_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-			printk(KERN_ERR "Charger error : VBUS_OVP\n");
-		}
-	}
-
-	if (charger_stop) {
-		if (!(stat1 & (VBUS_DET | VAC_DET)))
-			di->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;
-		else
-			di->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
-	}
-
-out:
-	if (charger_start) {
-		di->charge_status = POWER_SUPPLY_STATUS_CHARGING;
-		di->bat_health = POWER_SUPPLY_HEALTH_GOOD;
-	}
-
-	power_supply_changed(&di->bat);
-
-	return IRQ_HANDLED;
-}
-
-static void twl6030battery_current(struct twl6030_bci_device_info *di)
-{
-	int ret = 0;
-	u16 read_value = 0;
-	s16 temp = 0;
-	int current_now = 0;
-
-	/* FG_REG_10, 11 is 14 bit signed instantaneous current sample value */
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *)&read_value,
-								FG_REG_10, 2);
-	if (ret < 0) {
-		dev_info(di->dev, "failed to read FG_REG_10: current_now\n");
-		return;
-	}
-
-	temp = ((s16)(read_value << 2) >> 2);
-	current_now = temp - di->cc_offset;
-
-	/* current drawn per sec */
-	current_now = current_now * fuelgauge_rate[di->fuelgauge_mode];
-	/* current in mAmperes */
-	current_now = (current_now * di->current_max_scale) >> 13;
-	/* current in uAmperes */
-	current_now = current_now * 1000;
-	di->current_uA = current_now;
-
-	return;
-}
-
-/*
- * Setup the twl6030 BCI module to enable backup
- * battery charging.
- */
-static int twl6030backupbatt_setup(void)
-{
-	int ret;
-	u8 rd_reg = 0;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &rd_reg, BBSPOR_CFG);
-	if (ret)
-		return ret;
-
-	rd_reg |= BB_CHG_EN;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_ID0, rd_reg, BBSPOR_CFG);
-
-	return ret;
-}
-
-/*
- * Setup the twl6030 BCI module to measure battery
- * temperature
- */
-static int twl6030battery_temp_setup(bool enable)
-{
-	int ret;
-	u8 rd_reg = 0;
-
-	ret = twl_i2c_read_u8(TWL_MODULE_MADC, &rd_reg, TWL6030_GPADC_CTRL);
-	if (ret)
-		return ret;
-
-	if (enable)
-		rd_reg |= (GPADC_CTRL_TEMP1_EN | GPADC_CTRL_TEMP2_EN |
-			GPADC_CTRL_TEMP1_EN_MONITOR |
-			GPADC_CTRL_TEMP2_EN_MONITOR | GPADC_CTRL_SCALER_DIV4);
-	else
-		rd_reg ^= (GPADC_CTRL_TEMP1_EN | GPADC_CTRL_TEMP2_EN |
-			GPADC_CTRL_TEMP1_EN_MONITOR |
-			GPADC_CTRL_TEMP2_EN_MONITOR | GPADC_CTRL_SCALER_DIV4);
-
-	ret = twl_i2c_write_u8(TWL_MODULE_MADC, rd_reg, TWL6030_GPADC_CTRL);
-
-	return ret;
-}
-
-static int twl6030battery_voltage_setup(struct twl6030_bci_device_info *di)
-{
-	int ret;
-	u8 rd_reg = 0;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &rd_reg, REG_MISC1);
-	if (ret)
-		return ret;
-
-	rd_reg = rd_reg | VAC_MEAS | VBAT_MEAS | BB_MEAS;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_ID0, rd_reg, REG_MISC1);
-	if (ret)
-		return ret;
-
-	ret = twl_i2c_read_u8(TWL_MODULE_USB, &rd_reg, REG_USB_VBUS_CTRL_SET);
-	if (ret)
-		return ret;
-
-	rd_reg = rd_reg | VBUS_MEAS;
-	ret = twl_i2c_write_u8(TWL_MODULE_USB, rd_reg, REG_USB_VBUS_CTRL_SET);
-	if (ret)
-		return ret;
-
-	ret = twl_i2c_read_u8(TWL_MODULE_USB, &rd_reg, REG_USB_ID_CTRL_SET);
-	if (ret)
-		return ret;
-
-	rd_reg = rd_reg | ID_MEAS;
-	ret = twl_i2c_write_u8(TWL_MODULE_USB, rd_reg, REG_USB_ID_CTRL_SET);
-	if (ret)
-		return ret;
-
-	if (di->features & TWL6032_SUBCLASS)
-		ret = twl_i2c_write_u8(TWL_MODULE_MADC,
-					GPADC_CTRL2_CH18_SCALER_EN,
-					TWL6030_GPADC_CTRL2);
-
-	return ret;
-}
-
-static int twl6030battery_current_setup(bool enable)
-{
-	int ret = 0;
-	u8  reg = 0;
-
-	/*
-	 * Writing 0 to REG_TOGGLE1 has no effect, so
-	 * can directly set/reset FG.
-	 */
-	if (enable)
-		reg = FGDITHS | FGS;
-	else
-		reg = FGDITHR | FGR;
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_ID1, reg, REG_TOGGLE1);
-	if (ret)
-		return ret;
-
-	 ret = twl_i2c_write_u8(TWL6030_MODULE_GASGAUGE, CC_CAL_EN, FG_REG_00);
-
-	return ret;
-}
-
-static enum power_supply_property twl6030_bci_battery_props[] = {
-	POWER_SUPPLY_PROP_STATUS,
-	POWER_SUPPLY_PROP_HEALTH,
-	POWER_SUPPLY_PROP_ONLINE,
-	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-	POWER_SUPPLY_PROP_CURRENT_NOW,
-	POWER_SUPPLY_PROP_CURRENT_AVG,
-	POWER_SUPPLY_PROP_CAPACITY,
-	POWER_SUPPLY_PROP_TEMP,
-};
-
-static enum power_supply_property twl6030_usb_props[] = {
-	POWER_SUPPLY_PROP_ONLINE,
-	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-};
-
-static enum power_supply_property twl6030_ac_props[] = {
-	POWER_SUPPLY_PROP_ONLINE,
-	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-};
-
-static enum power_supply_property twl6030_bk_bci_battery_props[] = {
-	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-};
-
-static void twl6030_current_avg(struct work_struct *work)
-{
-//	printk("%s\n", __func__);
-
-	s32 samples = 0;
-	s16 cc_offset = 0;
-	int current_avg_uA = 0;
-	int ret;
-	struct twl6030_bci_device_info *di = container_of(work,
-		struct twl6030_bci_device_info,
-		twl6030_current_avg_work.work);
-
-	di->charge_n2 = di->charge_n1;
-	di->timer_n2 = di->timer_n1;
-
-	/* FG_REG_01, 02, 03 is 24 bit unsigned sample counter value */
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *) &di->timer_n1,
-							FG_REG_01, 3);
-	if (ret < 0)
-		goto err;
-	/*
-	 * FG_REG_04, 5, 6, 7 is 32 bit signed accumulator value
-	 * accumulates instantaneous current value
-	 */
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *) &di->charge_n1,
-							FG_REG_04, 4);
-	if (ret < 0)
-		goto err;
-	/* FG_REG_08, 09 is 10 bit signed calibration offset value */
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *) &cc_offset,
-							FG_REG_08, 2);
-	if (ret < 0)
-		goto err;
-	cc_offset = ((s16)(cc_offset << 6) >> 6);
-	di->cc_offset = cc_offset;
-
-	samples = di->timer_n1 - di->timer_n2;
-	/* check for timer overflow */
-	if (di->timer_n1 < di->timer_n2)
-		samples = samples + (1 << 24);
-
-	/* offset is accumulative over number of samples */
-	cc_offset = cc_offset * samples;
-
-	current_avg_uA = ((di->charge_n1 - di->charge_n2 - cc_offset)
-					* di->current_max_scale) /
-					fuelgauge_rate[di->fuelgauge_mode];
-	/* clock is a fixed 32Khz */
-	current_avg_uA >>= 15;
-
-	/* Correct for the fuelguage sampling rate */
-	samples /= fuelgauge_rate[di->fuelgauge_mode] * 4;
-
-	/*
-	 * Only update the current average if we have had a valid number
-	 * of samples in the accumulation.
-	 */
-	if (samples) {
-		current_avg_uA = current_avg_uA / samples;
-		di->current_avg_uA = current_avg_uA * 1000;
-	}
-
-	queue_delayed_work(di->freezable_work, &di->twl6030_current_avg_work,
-		msecs_to_jiffies(1000 * di->current_avg_interval));
-	return;
-err:
-	pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-#define BATT_NUM  11
-struct batt_vol_cal{
-	u32 disp_cal;
-	u32 dis_charge_vol;
-	u32 charge_vol;
-};
-static struct batt_vol_cal  batt_table[BATT_NUM] = {
-	{0,3571,3730},//{1,3420,3525},{2,3420,3575},{3,3475,3600},{5,3505,3620},{7,3525,3644},
-	{9,3628,3770},//{11,3557,3670},{13,3570,3684},{15,3580,3700},{17,3610,3715},
-	{19,3670,3878},//{21,3640,3748},{23,3652,3756},{25,3662,3775},{27,3672,3790},
-	{29,3719,3895},//{31,3687,3814},{33,3693,3818},{35,3699,3822},{37,3705,3825},
-	{39,3770,3941},//{41,3714,3832},{43,3718,3834},{45,3722,3836},{47,3726,3837},
-	{49,3801,3980},//{51,3734,3841},{53,3738,3842},{55,3742,3844},{57,3746,3844},
-	{59,3849,4010},//{61,3756,3860},{63,3764,3864},{65,3774,3871},{67,3786,3890},
-	{69,3864,4024},//{71,3808,3930},{73,3817,3977},{75,3827,3977},{77,3845,3997},
-	{79,3884,4040},//{81,3964,4047},{83,3982,4064},{85,4002,4080},{87,4026,4096},
-	{89,4001,4050},//{91,4034,4144},{93,4055,4150},{95,4085,4195},{97,4085,4195},
-	{100,4070,4090},
-};
-#if 0
-static int capacity_changed(struct twl6030_bci_device_info *di)
-{
-	int curr_capacity = di->capacity;
-	int charger_source = di->charger_source;
-	int charging_disabled = 0;
-	struct batt_vol_cal *p;
-	int i=0;
-
-	p = batt_table;
-	/* Because system load is always greater than
-	 * termination current, we will never get a CHARGE DONE
-	 * int from BQ. And charging will alwys be in progress.
-	 * We consider Vbat>3900 to be a full battery.
-	 * Since Voltage measured during charging is Voreg ~4.2v,
-	 * we dont update capacity if we are charging.
-	 */
-
-	/* if it has been more than 10 minutes since our last update
-	 * and we are charging we force a update.
-	 */
-	if (time_after(jiffies, di->ac_next_refresh)
-		&& (di->charger_source != POWER_SUPPLY_TYPE_BATTERY)) {
-		charging_disabled = 1;
-		di->ac_next_refresh = jiffies +
-			msecs_to_jiffies(CHARGING_CAPACITY_UPDATE_PERIOD);
-		di->capacity = -1;
-
-		/* We have to disable charging to read correct
-		 * voltages.
-		 */
-		twl6030_stop_charger(di);
-		/*voltage setteling time*/
-		msleep(200);
-		di->voltage_mV = twl6030_get_gpadc_conversion(di,
-						di->gpadc_vbat_chnl);
-		
-	}
-
-	/* Setting the capacity level only makes sense when on
-	 * the battery is powering the board.
-	 */
-	 if (di->charge_status == POWER_SUPPLY_STATUS_CHARGING){  //charge
-		if(di->voltage_mV >= p[BATT_NUM - 1].charge_vol){
-			curr_capacity = 100;
-		}	
-		else{
-			if(di->voltage_mV <= p[0].charge_vol){
-				curr_capacity = 0;
-			}
-			else{
-				for(i = 0; i < BATT_NUM - 1; i++){
-
-					if((p[i].charge_vol <= di->voltage_mV) && (di->voltage_mV < (p[i+1].charge_vol))){
-						curr_capacity = p[i].disp_cal ;
-						break;
-					}
-				}
-			}  
-		}
-
-	}
-	else if (di->charge_status == POWER_SUPPLY_STATUS_DISCHARGING){  //discharge
-		if(di->voltage_mV >= p[BATT_NUM - 1].dis_charge_vol){
-			curr_capacity = 100;
-		}	
-		else{
-			if(di->voltage_mV <= p[0].dis_charge_vol){
-				curr_capacity = 0;
-			}
-			else{
-				for(i = 0; i < BATT_NUM - 1; i++){
-					if(((p[i].dis_charge_vol) <= di->voltage_mV) && (di->voltage_mV < (p[i+1].dis_charge_vol))){
-						curr_capacity = p[i].disp_cal ;
-						break;
-					}
-				}
-			}  
-
-		}
-
-
-	}
-	
-	/*	
-	if (di->charge_status == POWER_SUPPLY_STATUS_CHARGING) {
-		if (di->voltage_mV < 3520)
-			curr_capacity = 0;
-		else if (di->voltage_mV < 3600 && di->voltage_mV >= 3500)
-			curr_capacity = 20;
-		else if (di->voltage_mV < 3700 && di->voltage_mV >= 3600)
-			curr_capacity = 50;
-		else if (di->voltage_mV < 3800 && di->voltage_mV >= 3700)
-			curr_capacity = 75;
-		else if (di->voltage_mV < 3900 && di->voltage_mV >= 3800)
-			curr_capacity = 90;
-		else if (di->voltage_mV >= 3900)
-				curr_capacity = 100;
-	}
-	
-*/
-
-
-	/* if we disabled charging to check capacity,
-	 * enable it again after we read the
-	 * correct voltage.
-	 */
-	if (charging_disabled) {
-		if (charger_source == POWER_SUPPLY_TYPE_MAINS)
-			twl6030_start_ac_charger(di);
-		else if (charger_source == POWER_SUPPLY_TYPE_USB)
-			twl6030_start_usb_charger(di);
-	}
-
-	/* if battery is not present we assume it is on battery simulator and
-	 * current capacity is set to 100%
-	 */
-	if (!is_battery_present(di))
-		curr_capacity = 100;
-	 
-
-       /* Debouncing of voltage change. */
-	if (di->capacity == -1) {
-		di->capacity = curr_capacity;
-		di->capacity_debounce_count = 0;
-		return 1;
-	}
-/*
-	if (curr_capacity != di->prev_capacity) {
-		di->prev_capacity = curr_capacity;
-		di->capacity_debounce_count = 0;
-	} else if (++di->capacity_debounce_count >= 4) {
-		di->capacity = curr_capacity;
-		di->capacity_debounce_count = 0;
-		return 1;
-	}
-*/
-	return 1;
-}
-#endif
-static int  twl6030_batt_vol_to_capacity (struct twl6030_bci_device_info *di)
-
-{
-
-	int i = 0;
-	int capacity = 0;
-	int BatVoltage;
-
-	struct batt_vol_cal *p;
-	p = batt_table;
-
-	BatVoltage = di ->voltage_mV;
-
-	if (di->charge_status == POWER_SUPPLY_STATUS_CHARGING){  //charge
-	        if(BatVoltage >=  (p[BATT_NUM - 1].charge_vol)){
-	                capacity = 100;
-	        }
-	        else{
-	                if(BatVoltage <= (p[0].charge_vol)){
-	                        capacity = 0;
-	                }
-	                else{
-	                        for(i = 0; i < BATT_NUM - 1; i++){
-
-	                                if(((p[i].charge_vol) <= BatVoltage) && (BatVoltage < (p[i+1].charge_vol))){
-	                                     //   capacity = p[i].disp_cal ;
-			capacity = i * 10 + ((BatVoltage - p[i].charge_vol) * 10) / (p[i+1] .charge_vol- p[i].charge_vol);
-
-					     
-	                                        break;
-	                                }
-	                        }
-	                }
-	        }
-
-	}
-	else{  //discharge
-	        if(BatVoltage >= (p[BATT_NUM - 1].dis_charge_vol)){
-	                capacity = 100;
-	        }
-	        else{
-	                if(BatVoltage <= (p[0].dis_charge_vol)){
-	                        capacity = 0;
-	                }
-	                else{
-	                        for(i = 0; i < BATT_NUM - 1; i++){
-	                                if(((p[i].dis_charge_vol) <= BatVoltage) && (BatVoltage < (p[i+1].dis_charge_vol))){
-	                                //        capacity = p[i].disp_cal ;
-			capacity = i * 10 + ((BatVoltage - p[i].dis_charge_vol) * 10) / (p[i+1] .dis_charge_vol- p[i].dis_charge_vol);
-	                                        break;
-	                                }
-	                        }
-	                }
-
-	        }
-
-
-	}
-
-	return capacity;
-
-}
-
-
-                                       
-static void twl6030_batt_capacity_samples(struct twl6030_bci_device_info *di)
-{
-	int capacity = 0;
-	capacity = twl6030_batt_vol_to_capacity (di);
-	twl6030battery_current(di);
-
-	if( 1 == di->resume_status ){
-		di->resume_status = 0;
-		if  (di->charge_status == POWER_SUPPLY_STATUS_CHARGING){\
-			if (di->suspend_capacity > capacity){
-
-				di->capacity =  di->suspend_capacity;
-			}else{
-				di->capacity = capacity;
-			}	
-		}else{
-			if (di->suspend_capacity > capacity){
-				di->capacity = capacity;
-			}else{
-				di->capacity =  di->suspend_capacity;
-			}	
-		
-		}
-		return;
-		
-	}
-
-	if (di->charge_status == POWER_SUPPLY_STATUS_FULL){
-		if (capacity < di->capacity){
-			if (di ->gBatCapacityChargeCnt >= NUM_CHARGE_MIN_SAMPLE){
-				di ->gBatCapacityChargeCnt = 0;
-				if (di -> capacity < 99){
-					di -> capacity++;
-				}
-			}
-			
-		}
-		
-	}
-		
-	  
-	if (di->charge_status == POWER_SUPPLY_STATUS_CHARGING){
-		if (capacity > di->capacity){
-			//
-			if (++(di->gBatCapacityChargeCnt) >= NUM_CHARGE_MIN_SAMPLE){
-				di ->gBatCapacityChargeCnt  = 0;
-				if (di ->  capacity < 99){
-					di -> capacity++;
-					
-				}
-			}
-			di->gBatCapacityDisChargeCnt = 0;  //0
-		}
-
-	}
-//////////////////////////////////////////////////////////////////////////////////////////////////////////////
-	if ((di->charge_status == POWER_SUPPLY_STATUS_DISCHARGING)||(di->charge_status == POWER_SUPPLY_STATUS_NOT_CHARGING)){
-
-	//,
-		if (capacity < di -> capacity){
-			if (++(di->gBatCapacityDisChargeCnt) >= NUM_DISCHARGE_MIN_SAMPLE){
-				di ->gBatCapacityDisChargeCnt = 0;
-				if (di -> capacity > 0){
-					di -> capacity-- ;
-					//bat->bat_change  = 1;
-				}
-			}
-		}
-		else{
-			di ->gBatCapacityDisChargeCnt = 0;
-		}
-		//di ->gBatCapacityChargeCnt = 0;
-	}
-		di ->capacitytmp = capacity;
-}
-
-static int twl6030_set_watchdog(struct twl6030_bci_device_info *di, int val)
-{
-	di->watchdog_duration = val;
-
-	dev_dbg(di->dev, "Watchdog reset %d", val);
-
-	return twl_i2c_write_u8(TWL6030_MODULE_CHARGER, val, CONTROLLER_WDG);
-
-}
-#if 0
-static void twl6030_bci_adc_set(struct twl6030_bci_device_info *di)
-{
-	struct twl6030_gpadc_request req;
-	int adc_code;
-	int temp;
-	int ret;
-	//int level;
-
-	/* Kick the charger watchdog */
-	if (di->charge_status == POWER_SUPPLY_STATUS_CHARGING)
-		twl6030_set_watchdog(di, di->watchdog_duration);
-	
-	req.method = TWL6030_GPADC_SW2;
-	req.channels = (1 << 1) | (1 << di->gpadc_vbat_chnl) | (1 << 8);
-	req.active = 0;
-	req.func_cb = NULL;
-	ret = twl6030_gpadc_conversion(&req);
-
-	
-	if (ret < 0) {
-		dev_dbg(di->dev, "gpadc conversion failed: %d\n", ret);
-		return;
-	}
-	
-	if (req.rbuf[di->gpadc_vbat_chnl] > 0)
-		di->voltage_mV = req.rbuf[di->gpadc_vbat_chnl];
-
-	if (req.rbuf[8] > 0)
-		di->bk_voltage_mV = req.rbuf[8];
-
-	if (di->platform_data->battery_tmp_tbl == NULL)
-		return;
-
-	adc_code = req.rbuf[1];
-	for (temp = 0; temp < di->platform_data->tblsize; temp++) {
-		if (adc_code >= di->platform_data->
-				battery_tmp_tbl[temp])
-			break;
-	}
-	//printk("twl6030_bci_adc_set---di->voltage_mV-=-%d,di->capacity = %d \n",di->voltage_mV,di->capacity);
-	/* first 2 values are for negative temperature */
-
-}
-#endif
-static void twl6030_bci_battery_work(struct work_struct *work)
-{
-
-	struct twl6030_bci_device_info *di = container_of(work,
-		struct twl6030_bci_device_info, twl6030_bci_monitor_work.work);
-	struct twl6030_gpadc_request req;
-	int adc_code;
-	int temp;
-	int ret;
-//	int level;
-
-	/* Kick the charger watchdog */
-	if (di->charge_status == POWER_SUPPLY_STATUS_CHARGING)
-		twl6030_set_watchdog(di, di->watchdog_duration);
-	
-	req.method = TWL6030_GPADC_SW2;
-	req.channels = (1 << 1) | (1 << di->gpadc_vbat_chnl) | (1 << 8);
-	req.active = 0;
-	req.func_cb = NULL;
-	ret = twl6030_gpadc_conversion(&req);
-
-	queue_delayed_work(di->freezable_work, &di->twl6030_bci_monitor_work,
-			msecs_to_jiffies(TIMER_MS_COUNTS)); //* di->monitoring_interval
-	
-	if (ret < 0) {
-		dev_dbg(di->dev, "gpadc conversion failed: %d\n", ret);
-		return;
-	}
-	
-	if (req.rbuf[di->gpadc_vbat_chnl] > 0)
-		di->voltage_mV = req.rbuf[di->gpadc_vbat_chnl];
-
-	if (req.rbuf[8] > 0)
-		di->bk_voltage_mV = req.rbuf[8];
-
-	if (di->platform_data->battery_tmp_tbl == NULL)
-		return;
-
-	adc_code = req.rbuf[1];
-	for (temp = 0; temp < di->platform_data->tblsize; temp++) {
-		if (adc_code >= di->platform_data->
-				battery_tmp_tbl[temp])
-			break;
-	}
-	//printk("workxxxxx---di->voltage_mV-=-%d,di->capacity = %d \n",di->voltage_mV,di->capacity);
-	/* first 2 values are for negative temperature */
-	di->temp_C = (temp - 2); /* in degrees Celsius */
-//	if (capacity_changed(di))  //xsf
-	{
-		twl6030_batt_capacity_samples(di);
-		// di->capacity = level;
-		power_supply_changed(&di->bat);
-	}
-}
-
-static void twl6030_current_mode_changed(struct twl6030_bci_device_info *di)
-{
-	int ret;
-	//printk("%s\n", __func__);
-
-	/* FG_REG_01, 02, 03 is 24 bit unsigned sample counter value */
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *) &di->timer_n1,
-							FG_REG_01, 3);
-	if (ret < 0)
-		goto err;
-	/*
-	 * FG_REG_04, 5, 6, 7 is 32 bit signed accumulator value
-	 * accumulates instantaneous current value
-	 */
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *) &di->charge_n1,
-							FG_REG_04, 4);
-	if (ret < 0)
-		goto err;
-
-	cancel_delayed_work(&di->twl6030_current_avg_work);
-	queue_delayed_work(di->freezable_work, &di->twl6030_current_avg_work,
-		msecs_to_jiffies(1000 * di->current_avg_interval));
-	return;
-err:
-	pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-}
-
-static void twl6030_work_interval_changed(struct twl6030_bci_device_info *di)
-{
-	//printk("%s\n", __func__);
-
-	cancel_delayed_work(&di->twl6030_bci_monitor_work);
-	queue_delayed_work(di->freezable_work, &di->twl6030_bci_monitor_work,
-		msecs_to_jiffies(1000 * di->monitoring_interval));
-}
-
-#define to_twl6030_bci_device_info(x) container_of((x), \
-			struct twl6030_bci_device_info, bat);
-#if 0
-static void twl6030_bci_battery_external_power_changed(struct power_supply *psy)
-{//	printk("%s\n", __func__);
-
-	struct twl6030_bci_device_info *di = to_twl6030_bci_device_info(psy);
-
-	cancel_delayed_work(&di->twl6030_bci_monitor_work);
-	queue_delayed_work(di->freezable_work, &di->twl6030_bci_monitor_work, 0);
-}
-#endif
-
-#define to_twl6030_ac_device_info(x) container_of((x), \
-		struct twl6030_bci_device_info, ac);
-
-static int twl6030_ac_get_property(struct power_supply *psy,
-					enum power_supply_property psp,
-					union power_supply_propval *val)
-{
-	u8 stat1;
-	struct twl6030_bci_device_info *di = to_twl6030_ac_device_info(psy);
-	switch (psp) {
-	case POWER_SUPPLY_PROP_ONLINE:
-		twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &stat1,
-					CONTROLLER_STAT1);
-		
-		if (stat1 & VAC_DET) {
-			val->intval =  1;
-		}
-		else
-			val->intval =  0;
-
-		///printk("&&&&&&&&&&&&ac---charge  ac->intval = %d &&&&&&&&&&&&&&&\n" ,val->intval);
-
-		break;
-	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-		val->intval = twl6030_get_gpadc_conversion(di, 9) * 1000;
-
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-#define to_twl6030_usb_device_info(x) container_of((x), \
-		struct twl6030_bci_device_info, usb);
-
-static int twl6030_usb_get_property(struct power_supply *psy,
-					enum power_supply_property psp,
-					union power_supply_propval *val)
-{
-	u8 stat1;
-	struct twl6030_bci_device_info *di = to_twl6030_usb_device_info(psy);
-	switch (psp) {
-	case POWER_SUPPLY_PROP_ONLINE:
-
-		twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &stat1,
-					CONTROLLER_STAT1);
-		
-		if (stat1 & VBUS_DET) {
-			val->intval =  1;
-		}
-		else
-			val->intval =  0;
-
-		//val->intval = di->usb_online; //xsf
-		
-		//printk("&&&&&&&&&&&&usb---charge  val->intval = %d &&&&&&&&&&&&&&&\n" ,val->intval);
-		break;
-	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-		val->intval = twl6030_get_gpadc_conversion(di, 10) * 1000;
-		//printk("&&&&&&&&&&&&usb-voltage = &&&&&&&&&&&&&&&%d\n", val->intval);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-#define to_twl6030_bk_bci_device_info(x) container_of((x), \
-		struct twl6030_bci_device_info, bk_bat);
-
-static int twl6030_bk_bci_battery_get_property(struct power_supply *psy,
-					enum power_supply_property psp,
-					union power_supply_propval *val)
-{
-	struct twl6030_bci_device_info *di = to_twl6030_bk_bci_device_info(psy);
-	val->intval = 0;	
-	switch (psp) {
-	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-		val->intval = di->bk_voltage_mV * 1000;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int twl6030_bci_battery_get_property(struct power_supply *psy,
-					enum power_supply_property psp,
-					union power_supply_propval *val)
-{
-	struct twl6030_bci_device_info *di;
-
-	di = to_twl6030_bci_device_info(psy);
-
-	switch (psp) {
-	case POWER_SUPPLY_PROP_STATUS:
-		val->intval = di->charge_status;
-		break;
-	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-		di->voltage_mV = twl6030_get_gpadc_conversion(di,
-						di->gpadc_vbat_chnl);
-		val->intval = di->voltage_mV * 1000;
-		break;
-	case POWER_SUPPLY_PROP_CURRENT_NOW:
-		twl6030battery_current(di);
-		val->intval = di->current_uA;
-		break;
-	case POWER_SUPPLY_PROP_TEMP:
-		val->intval = di->temp_C;
-		break;
-	case POWER_SUPPLY_PROP_ONLINE:
-		val->intval = di->charger_source;
-		break;
-	case POWER_SUPPLY_PROP_CURRENT_AVG:
-		val->intval = di->current_avg_uA;
-		break;
-	case POWER_SUPPLY_PROP_HEALTH:
-		val->intval = di->bat_health;
-		break;
-	case POWER_SUPPLY_PROP_CAPACITY:
-		val->intval = di->capacity;
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-int twl6030_register_notifier(struct notifier_block *nb,
-				unsigned int events)
-{
-	return blocking_notifier_chain_register(&notifier_list, nb);
-}
-EXPORT_SYMBOL_GPL(twl6030_register_notifier);
-
-int twl6030_unregister_notifier(struct notifier_block *nb,
-				unsigned int events)
-{
-	return blocking_notifier_chain_unregister(&notifier_list, nb);
-}
-EXPORT_SYMBOL_GPL(twl6030_unregister_notifier);
-
-static void twl6030_usb_charger_work(struct work_struct *work)
-{
-	struct twl6030_bci_device_info	*di =
-		container_of(work, struct twl6030_bci_device_info, usb_work);
-	switch (di->event) {
-	case USB_EVENT_CHARGER:
-		/* POWER_SUPPLY_TYPE_USB_DCP */
-		di->usb_online = POWER_SUPPLY_TYPE_USB_DCP;
-		di->charger_incurrentmA = 1800;
-		break;
-	case USB_EVENT_VBUS:
-		switch (di->usb_online) {
-		case POWER_SUPPLY_TYPE_USB_CDP:
-			/*
-			 * Only 500mA here or high speed chirp
-			 * handshaking may break
-			 */
-			di->charger_incurrentmA = 500;
-		case POWER_SUPPLY_TYPE_USB:
-			break;
-		}
-		break;
-	case USB_EVENT_NONE:
-		di->usb_online = 0;
-		di->charger_incurrentmA = 0;
-		break;
-	case USB_EVENT_ENUMERATED:
-		if (di->usb_online == POWER_SUPPLY_TYPE_USB_CDP)
-			di->charger_incurrentmA = 560;
-		else
-			di->charger_incurrentmA = di->usb_max_power;
-		break;
-	default:
-		return;
-	}
-	twl6030_start_usb_charger(di);
-
-	power_supply_changed(&di->usb);
-}
-
-static int twl6030_usb_notifier_call(struct notifier_block *nb,
-		unsigned long event, void *data)
-{
-	struct twl6030_bci_device_info *di =
-		container_of(nb, struct twl6030_bci_device_info, nb);
-	di->event = event;
-	switch (event) {
-	case USB_EVENT_VBUS:
-		di->usb_online = *((unsigned int *) data);
-		break;
-	case USB_EVENT_ENUMERATED:
-		di->usb_max_power = *((unsigned int *) data);
-		break;
-	case USB_EVENT_CHARGER:
-	case USB_EVENT_NONE:
-		break;
-	case USB_EVENT_ID:
-	default:
-		return NOTIFY_OK;
-	}
-
-	schedule_work(&di->usb_work);
-
-	return NOTIFY_OK;
-}
-
-static ssize_t set_fg_mode(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	int ret;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val > 3))
-		return -EINVAL;
-	di->fuelgauge_mode = val;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_GASGAUGE, (val << 6) | CC_CAL_EN,
-							FG_REG_00);
-	if (ret)
-		return -EIO;
-	twl6030_current_mode_changed(di);
-	return status;
-}
-
-static ssize_t show_fg_mode(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->fuelgauge_mode;
-	return sprintf(buf, "%d\n", val);
-}
-
-static ssize_t set_charge_src(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 2) || (val > 3))
-		return -EINVAL;
-	di->vac_priority = val;
-	return status;
-}
-
-static ssize_t show_charge_src(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->vac_priority;
-	return sprintf(buf, "%d\n", val);
-}
-
-static ssize_t show_vbus_voltage(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = twl6030_get_gpadc_conversion(di, 10);
-
-	return sprintf(buf, "%d\n", val);
-}
-
-static ssize_t show_id_level(struct device *dev, struct device_attribute *attr,
-							char *buf)
-{
-	int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = twl6030_get_gpadc_conversion(di, 14);
-
-	return sprintf(buf, "%d\n", val);
-}
-
-static ssize_t set_watchdog(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	int ret;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 1) || (val > 127))
-		return -EINVAL;
-	ret = twl6030_set_watchdog(di, val);
-	if (ret)
-		return -EIO;
-
-	return status;
-}
-
-static ssize_t show_watchdog(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->watchdog_duration;
-	return sprintf(buf, "%d\n", val);
-}
-
-static ssize_t show_fg_counter(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	int fg_counter = 0;
-	int ret;
-
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *) &fg_counter,
-							FG_REG_01, 3);
-	if (ret < 0)
-		return -EIO;
-	return sprintf(buf, "%d\n", fg_counter);
-}
-
-static ssize_t show_fg_accumulator(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	long fg_accum = 0;
-	int ret;
-
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *) &fg_accum,
-							FG_REG_04, 4);
-	if (ret > 0)
-		return -EIO;
-
-	return sprintf(buf, "%ld\n", fg_accum);
-}
-
-static ssize_t show_fg_offset(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	s16 fg_offset = 0;
-	int ret;
-
-	ret = twl_i2c_read(TWL6030_MODULE_GASGAUGE, (u8 *) &fg_offset,
-							FG_REG_08, 2);
-	if (ret < 0)
-		return -EIO;
-	fg_offset = ((s16)(fg_offset << 6) >> 6);
-
-	return sprintf(buf, "%d\n", fg_offset);
-}
-
-static ssize_t set_fg_clear(struct device *dev, struct device_attribute *attr,
-						const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	int ret;
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val != 1))
-		return -EINVAL;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_GASGAUGE, CC_AUTOCLEAR,
-							FG_REG_00);
-	if (ret)
-		return -EIO;
-
-	return status;
-}
-
-static ssize_t set_fg_cal(struct device *dev, struct device_attribute *attr,
-						const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	int ret;
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val != 1))
-		return -EINVAL;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_GASGAUGE, CC_CAL_EN, FG_REG_00);
-	if (ret)
-		return -EIO;
-
-	return status;
-}
-
-static ssize_t set_charging(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t count)
-{
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if (strncmp(buf, "startac", 7) == 0) {
-		if (di->charger_source == POWER_SUPPLY_TYPE_USB)
-			twl6030_stop_usb_charger(di);
-		twl6030_start_ac_charger(di);
-	} else if (strncmp(buf, "startusb", 8) == 0) {
-		if (di->charger_source == POWER_SUPPLY_TYPE_MAINS)
-			twl6030_stop_ac_charger(di);
-		di->charger_source = POWER_SUPPLY_TYPE_USB;
-		di->charge_status = POWER_SUPPLY_STATUS_CHARGING;
-		twl6030_start_usb_charger(di);
-	} else if (strncmp(buf, "stop" , 4) == 0)
-		twl6030_stop_charger(di);
-	else
-		return -EINVAL;
-
-	return status;
-}
-
-static ssize_t set_regulation_voltage(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 3500)
-			|| (val > di->platform_data->max_charger_voltagemV))
-		return -EINVAL;
-	di->platform_data->max_bat_voltagemV = val;
-	twl6030_config_voreg_reg(di, val);
-
-	return status;
-}
-
-static ssize_t show_regulation_voltage(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	unsigned int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->platform_data->max_bat_voltagemV;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t set_termination_current(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 50) || (val > 400))
-		return -EINVAL;
-	di->platform_data->termination_currentmA = val;
-	twl6030_config_iterm_reg(di, val);
-
-	return status;
-}
-
-static ssize_t show_termination_current(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	unsigned int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->platform_data->termination_currentmA;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t set_cin_limit(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 50) || (val > 1500))
-		return -EINVAL;
-	di->charger_incurrentmA = val;
-	twl6030_config_cinlimit_reg(di, val);
-
-	return status;
-}
-
-static ssize_t show_cin_limit(struct device *dev, struct device_attribute *attr,
-								  char *buf)
-{
-	unsigned int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->charger_incurrentmA;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t set_charge_current(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 300)
-			|| (val > di->platform_data->max_charger_currentmA))
-		return -EINVAL;
-	di->charger_outcurrentmA = val;
-	twl6030_config_vichrg_reg(di, val);
-
-	return status;
-}
-
-static ssize_t show_charge_current(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	unsigned int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->charger_outcurrentmA;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t set_min_vbus(struct device *dev, struct device_attribute *attr,
-				  const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 4200) || (val > 4760))
-		return -EINVAL;
-	di->min_vbus = val;
-	twl6030_config_min_vbus_reg(di, val);
-
-	return status;
-}
-
-static ssize_t show_min_vbus(struct device *dev, struct device_attribute *attr,
-				  char *buf)
-{
-	unsigned int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->min_vbus;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t set_current_avg_interval(struct device *dev,
-	  struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 10) || (val > 3600))
-		return -EINVAL;
-	di->current_avg_interval = val;
-	twl6030_current_mode_changed(di);
-
-	return status;
-}
-
-static ssize_t show_current_avg_interval(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	unsigned int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->current_avg_interval;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t set_wakelock_enable(struct device *dev,
-	  struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 0) || (val > 1))
-		return -EINVAL;
-
-	if ((val) && (di->charger_source == POWER_SUPPLY_TYPE_MAINS))
-		wake_lock(&chrg_lock);
-	else
-		wake_unlock(&chrg_lock);
-
-	di->wakelock_enabled = val;
-	return status;
-}
-
-static ssize_t show_wakelock_enable(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	unsigned int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->wakelock_enabled;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t set_monitoring_interval(struct device *dev,
-	  struct device_attribute *attr, const char *buf, size_t count)
-{
-	long val;
-	int status = count;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	if ((strict_strtol(buf, 10, &val) < 0) || (val < 10) || (val > 3600))
-		return -EINVAL;
-	di->monitoring_interval = val;
-	twl6030_work_interval_changed(di);
-
-	return status;
-}
-
-static ssize_t show_monitoring_interval(struct device *dev,
-		  struct device_attribute *attr, char *buf)
-{
-	unsigned int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->monitoring_interval;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t show_bsi(struct device *dev,
-		  struct device_attribute *attr, char *buf)
-{
-	int val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = twl6030_get_gpadc_conversion(di, 0);
-	return sprintf(buf, "%d\n", val);
-}
-
-static ssize_t show_stat1(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	unsigned val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->stat1;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t show_status_int1(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	unsigned val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->status_int1;
-	return sprintf(buf, "%u\n", val);
-}
-
-static ssize_t show_status_int2(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	unsigned val;
-	struct twl6030_bci_device_info *di = dev_get_drvdata(dev);
-
-	val = di->status_int2;
-	return sprintf(buf, "%u\n", val);
-}
-
-static DEVICE_ATTR(fg_mode, S_IWUSR | S_IRUGO, show_fg_mode, set_fg_mode);
-static DEVICE_ATTR(charge_src, S_IWUSR | S_IRUGO, show_charge_src,
-		set_charge_src);
-static DEVICE_ATTR(vbus_voltage, S_IRUGO, show_vbus_voltage, NULL);
-static DEVICE_ATTR(id_level, S_IRUGO, show_id_level, NULL);
-static DEVICE_ATTR(watchdog, S_IWUSR | S_IRUGO, show_watchdog, set_watchdog);
-static DEVICE_ATTR(fg_counter, S_IRUGO, show_fg_counter, NULL);
-static DEVICE_ATTR(fg_accumulator, S_IRUGO, show_fg_accumulator, NULL);
-static DEVICE_ATTR(fg_offset, S_IRUGO, show_fg_offset, NULL);
-static DEVICE_ATTR(fg_clear, S_IWUSR, NULL, set_fg_clear);
-static DEVICE_ATTR(fg_cal, S_IWUSR, NULL, set_fg_cal);
-static DEVICE_ATTR(charging, S_IWUSR | S_IRUGO, NULL, set_charging);
-static DEVICE_ATTR(regulation_voltage, S_IWUSR | S_IRUGO,
-		show_regulation_voltage, set_regulation_voltage);
-static DEVICE_ATTR(termination_current, S_IWUSR | S_IRUGO,
-		show_termination_current, set_termination_current);
-static DEVICE_ATTR(cin_limit, S_IWUSR | S_IRUGO, show_cin_limit,
-		set_cin_limit);
-static DEVICE_ATTR(charge_current, S_IWUSR | S_IRUGO, show_charge_current,
-		set_charge_current);
-static DEVICE_ATTR(min_vbus, S_IWUSR | S_IRUGO, show_min_vbus, set_min_vbus);
-static DEVICE_ATTR(monitoring_interval, S_IWUSR | S_IRUGO,
-		show_monitoring_interval, set_monitoring_interval);
-static DEVICE_ATTR(current_avg_interval, S_IWUSR | S_IRUGO,
-		show_current_avg_interval, set_current_avg_interval);
-static DEVICE_ATTR(wakelock_enable, S_IWUSR | S_IRUGO,
-		show_wakelock_enable, set_wakelock_enable);
-static DEVICE_ATTR(bsi, S_IRUGO, show_bsi, NULL);
-static DEVICE_ATTR(stat1, S_IRUGO, show_stat1, NULL);
-static DEVICE_ATTR(status_int1, S_IRUGO, show_status_int1, NULL);
-static DEVICE_ATTR(status_int2, S_IRUGO, show_status_int2, NULL);
-
-static struct attribute *twl6030_bci_attributes[] = {
-	&dev_attr_fg_mode.attr,
-	&dev_attr_charge_src.attr,
-	&dev_attr_vbus_voltage.attr,
-	&dev_attr_id_level.attr,
-	&dev_attr_watchdog.attr,
-	&dev_attr_fg_counter.attr,
-	&dev_attr_fg_accumulator.attr,
-	&dev_attr_fg_offset.attr,
-	&dev_attr_fg_clear.attr,
-	&dev_attr_fg_cal.attr,
-	&dev_attr_charging.attr,
-	&dev_attr_regulation_voltage.attr,
-	&dev_attr_termination_current.attr,
-	&dev_attr_cin_limit.attr,
-	&dev_attr_charge_current.attr,
-	&dev_attr_min_vbus.attr,
-	&dev_attr_monitoring_interval.attr,
-	&dev_attr_current_avg_interval.attr,
-	&dev_attr_bsi.attr,
-	&dev_attr_stat1.attr,
-	&dev_attr_status_int1.attr,
-	&dev_attr_status_int2.attr,
-	&dev_attr_wakelock_enable.attr,
-	NULL,
-};
-
-static const struct attribute_group twl6030_bci_attr_group = {
-	.attrs = twl6030_bci_attributes,
-};
-
-static char *twl6030_bci_supplied_to[] = {
-	"twl6030_battery",
-};
-
-extern int dwc_vbus_status(void);
-
-static void twl6030_battery_update_status(struct twl6030_bci_device_info *di)
-{
-	power_supply_changed(&di->bat);
-	power_supply_changed(&di->usb);
-	power_supply_changed(&di->ac);
-
-}
-static void twl6030_battery_work(struct work_struct *work)
-{	
-
-	struct twl6030_bci_device_info *di = container_of(work, struct twl6030_bci_device_info, work.work); 
-	twl6030_battery_update_status(di);
-	//set charging current
-		twl_i2c_write_u8(TWL6030_MODULE_CHARGER,0x00,CHARGERUSB_CTRL1);
-		if(2 == dwc_vbus_status()){
-			twl_i2c_write_u8(TWL6030_MODULE_CHARGER, 0x2e,CHARGERUSB_CINLIMIT);	//set vbus input current is 1.5A
-			twl_i2c_write_u8(TWL6030_MODULE_CHARGER, 0x0b,CHARGERUSB_VICHRG);	//set mos output current is 1A
-		}
-		else if(1 == dwc_vbus_status()){
-			twl_i2c_write_u8(TWL6030_MODULE_CHARGER, 0x2e,CHARGERUSB_CINLIMIT);//set vbus input current is 500ma
-			twl_i2c_write_u8(TWL6030_MODULE_CHARGER, 0x09,CHARGERUSB_VICHRG);	//set mos output current is 500ma
-		}
-	/* reschedule for the next time */
-	queue_delayed_work(di->freezable_work, &di->work, di->interval);
-}
-
-static int __devinit twl6030_bci_battery_probe(struct platform_device *pdev)
-{
-	struct twl4030_bci_platform_data *pdata = pdev->dev.platform_data;
-	struct twl6030_bci_device_info *di;
-	int irq;
-	int ret;
-	u8 controller_stat = 0;
-	u8 chargerusb_ctrl1 = 0;
-	u8 hw_state = 0;
-	u8 reg = 0;
-	//printk("%s\n", __func__);
-	if (!pdata) {
-		dev_info(&pdev->dev, "platform_data not available\n");
-		return -EINVAL;
-	}
-
-	di = kzalloc(sizeof(*di), GFP_KERNEL);
-	if (!di)
-		return -ENOMEM;
-
-	di->platform_data = kmemdup(pdata, sizeof(*pdata), GFP_KERNEL);
-	if (!di->platform_data) {
-		kfree(di);
-		return -ENOMEM;
-	}
-
-	if (pdata->monitoring_interval == 0) {
-		di->monitoring_interval = 10;
-		di->current_avg_interval = 10;
-	} else {
-		di->monitoring_interval = pdata->monitoring_interval;
-		di->current_avg_interval = pdata->monitoring_interval;
-	}
-
-	di->platform_data = pdata;
-	di->features = pdata->features;
-	di->dev = &pdev->dev;
-
-
-//	printk("di->feature = %d, TWL6032_SUBCLASS = %d\n",di->features,TWL6032_SUBCLASS);
-	if (di->features & TWL6032_SUBCLASS) {
-		ret = twl_i2c_read_u8(TWL_MODULE_RTC, &reg, CHARGER_MODE_REG);
-		if (ret)
-			goto temp_setup_fail;
-
-		if (reg & CHARGER_MODE_POWERPATH) {
-			dev_dbg(di->dev, "Charger: PowerPath\n");
-			di->use_power_path = 1;
-		} else {
-			dev_dbg(di->dev, "Charger: NON PowerPath\n");
-			di->use_power_path = 0;
-		}
-
-		if (reg & CHARGER_MODE_AUTOCHARGE) {
-			dev_dbg(di->dev, "Charger: AutoCharge\n");
-			di->use_hw_charger = 1;
-		} else {
-			dev_dbg(di->dev, "Charger: NON AutoCharge\n");
-			di->use_hw_charger = 0;
-		}
-	} else {
-		di->use_power_path = 0;
-		di->use_hw_charger = 0;
-	}
-//	printk("di->feature = %d, TWL6032_SUBCLASS = %d,di->use_hw_charger =%d \n",di->features,TWL6032_SUBCLASS,di->use_hw_charger );
-
-	
-	if (di->use_hw_charger) {
-		di->platform_data->max_charger_currentmA =
-				twl6030_get_limit2_reg(di);
-		di->platform_data->max_charger_voltagemV =
-				twl6030_get_limit1_reg(di);
-		di->platform_data->termination_currentmA =
-				twl6030_get_iterm_reg(di);
-		di->platform_data->max_bat_voltagemV =
-				twl6030_get_voreg_reg(di);
-	}
-//	printk("max_charger_currentmA = %d, max_charger_voltagemV = %d\n,termination_currentmA =%d, max_bat_voltagemV =%d \n",di->platform_data->max_charger_currentmA ,
-//		di->platform_data->max_charger_voltagemV,di->platform_data->termination_currentmA, di->platform_data->max_bat_voltagemV);
-	di->bat.name = "twl6030_battery";
-	di->bat.supplied_to = twl6030_bci_supplied_to;
-	di->bat.num_supplicants = ARRAY_SIZE(twl6030_bci_supplied_to);
-	di->bat.type = POWER_SUPPLY_TYPE_BATTERY;
-	di->bat.properties = twl6030_bci_battery_props;
-	di->bat.num_properties = ARRAY_SIZE(twl6030_bci_battery_props);
-	di->bat.get_property = twl6030_bci_battery_get_property;
-	//di->bat.external_power_changed =
-	//		twl6030_bci_battery_external_power_changed;
-	di->bat_health = POWER_SUPPLY_HEALTH_GOOD;
-
-	di->usb.name = "twl6030_usb";
-	di->usb.type = POWER_SUPPLY_TYPE_USB;
-	di->usb.properties = twl6030_usb_props;
-	di->usb.num_properties = ARRAY_SIZE(twl6030_usb_props);
-	di->usb.get_property = twl6030_usb_get_property;
-
-	di->ac.name = "twl6030_ac";
-	di->ac.type = POWER_SUPPLY_TYPE_MAINS;
-	di->ac.properties = twl6030_ac_props;
-	di->ac.num_properties = ARRAY_SIZE(twl6030_ac_props);
-	di->ac.get_property = twl6030_ac_get_property;
-
-	di->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;
-
-	di->bk_bat.name = "twl6030_bk_battery";
-	di->bk_bat.type = POWER_SUPPLY_TYPE_BATTERY;
-	di->bk_bat.properties = twl6030_bk_bci_battery_props;
-	di->bk_bat.num_properties = ARRAY_SIZE(twl6030_bk_bci_battery_props);
-	di->bk_bat.get_property = twl6030_bk_bci_battery_get_property;
-
-	di->vac_priority = 2;
-	di->capacity = -1;
-	di->capacity_debounce_count = 0;
-	di->ac_next_refresh = jiffies - 1;
-	platform_set_drvdata(pdev, di);
-
-	/* calculate current max scale from sense */
-	if (pdata->sense_resistor_mohm) {
-		di->current_max_scale = (62000) / pdata->sense_resistor_mohm;
-	} else {
-		/* Set sensible defaults if platform data is missing */
-		if (di->features & TWL6032_SUBCLASS)
-			di->current_max_scale = 3100;
-		else
-			di->current_max_scale = 6200;
-	}
-
-	wake_lock_init(&chrg_lock, WAKE_LOCK_SUSPEND, "ac_chrg_wake_lock");
-	/* settings for temperature sensing */
-	ret = twl6030battery_temp_setup(true);
-	if (ret)
-		goto temp_setup_fail;
-
-	/* request charger fault interruption choosing between sw/hw mode */
-	irq = platform_get_irq(pdev, 1);
-	if (!di->use_hw_charger)
-		ret = request_threaded_irq(irq, NULL,
-				twl6030charger_fault_interrupt,
-				0, "twl_bci_fault", di);
-	else
-		ret = request_threaded_irq(irq, NULL,
-				twl6032charger_fault_interrupt_hw,
-				0, "twl_bci_fault", di);
-
-	if (ret) {
-		dev_info(&pdev->dev, "could not request irq %d, status %d\n",
-			irq, ret);
-		goto temp_setup_fail;
-	}
-
-	/* request charger ctrl interruption choosing between sw/hw mode */
-	irq = platform_get_irq(pdev, 0);
-	if (!di->use_hw_charger)
-		ret = request_threaded_irq(irq, NULL,
-				twl6030charger_ctrl_interrupt,
-				0, "twl_bci_ctrl", di);
-	else
-		ret = request_threaded_irq(irq, NULL,
-				twl6032charger_ctrl_interrupt_hw,  
-				0, "twl_bci_ctrl", di);  // 
-
-	if (ret) {
-		dev_info(&pdev->dev, "could not request irq %d, status %d\n",
-			irq, ret);
-		goto chg_irq_fail;
-	}
-
-	ret = power_supply_register(&pdev->dev, &di->bat);
-	if (ret) {
-		dev_info(&pdev->dev, "failed to register main battery\n");
-		goto batt_failed;
-	}
-
-	ret = power_supply_register(&pdev->dev, &di->usb);
-	if (ret) {
-		dev_info(&pdev->dev, "failed to register usb power supply\n");
-		goto usb_failed;
-	}
-
-	ret = power_supply_register(&pdev->dev, &di->ac);
-	if (ret) {
-		dev_info(&pdev->dev, "failed to register ac power supply\n");
-		goto ac_failed;
-	}
-
-	ret = power_supply_register(&pdev->dev, &di->bk_bat);
-	if (ret) {
-		dev_info(&pdev->dev, "failed to register backup battery\n");
-		goto bk_batt_failed;
-	}
-	di->charge_n1 = 0;
-	di->timer_n1 = 0;
-
-	//di->freezable_work = create_freezable_workqueue("battery");
-#if 1
-	if (di->features & TWL6032_SUBCLASS) {
-		di->charger_incurrentmA = 1000;
-		di->gpadc_vbat_chnl = TWL6032_GPADC_VBAT_CHNL;
-	} else {
-		di->charger_incurrentmA = twl6030_get_usb_max_power(di->otg);
-		di->gpadc_vbat_chnl = TWL6030_GPADC_VBAT_CHNL;
-	}
-#endif
-#if 1
-
-	ret = twl6030battery_voltage_setup(di);
-	if (ret)
-		dev_info(&pdev->dev, "voltage measurement setup failed\n");
-
-	ret = twl6030battery_current_setup(true);
-	if (ret)
-		dev_info(&pdev->dev, "current measurement setup failed\n");
-
-
-	di->voltage_mV = twl6030_get_gpadc_conversion(di, di->gpadc_vbat_chnl);
-	di->voltage_mV = twl6030_get_gpadc_conversion(di, di->gpadc_vbat_chnl);
-	di->capacity = twl6030_batt_vol_to_capacity( di);
-	twl6030battery_current(di);
-#endif
-	di->freezable_work = system_freezable_wq;
-	INIT_DELAYED_WORK(&di->twl6030_bci_monitor_work,
-				twl6030_bci_battery_work);
-	queue_delayed_work(di->freezable_work, &di->twl6030_bci_monitor_work, 0);
-#if 1
-	INIT_DELAYED_WORK_DEFERRABLE(&di->twl6030_current_avg_work,
-						twl6030_current_avg);
-	queue_delayed_work(di->freezable_work, &di->twl6030_current_avg_work, 500);
-#endif
-#if 0
-	ret = twl6030battery_voltage_setup(di);
-	if (ret)
-		dev_info(&pdev->dev, "voltage measurement setup failed\n");
-
-	ret = twl6030battery_current_setup(true);
-	if (ret)
-		dev_info(&pdev->dev, "current measurement setup failed\n");
-#endif
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-	/* initialize for USB charging */
-	if (!di->use_hw_charger) {
-		twl6030_config_limit1_reg(di, pdata->max_charger_voltagemV);
-		twl6030_config_limit2_reg(di,
-				di->platform_data->max_charger_currentmA);
-	}
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, MBAT_TEMP,
-						CONTROLLER_INT_MASK);
-	if (ret)
-		goto bk_batt_failed;
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, MASK_MCHARGERUSB_THMREG,
-						CHARGERUSB_INT_MASK);
-	if (ret)
-		goto bk_batt_failed;
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &controller_stat,
-		CONTROLLER_STAT1);
-	if (ret)
-		goto bk_batt_failed;
-
-	di->stat1 = controller_stat;
-	di->charger_outcurrentmA = di->platform_data->max_charger_currentmA;
-
-	twl6030_set_watchdog(di, 32);
-
-	INIT_WORK(&di->usb_work, twl6030_usb_charger_work);
-	di->nb.notifier_call = twl6030_usb_notifier_call;
-	di->otg = otg_get_transceiver();
-	if (di->otg) {
-		ret = otg_register_notifier(di->otg, &di->nb);
-		if (ret)
-			dev_err(&pdev->dev, "otg register notifier"
-						" failed %d\n", ret);
-	} else
-		dev_err(&pdev->dev, "otg_get_transceiver failed %d\n", ret);
-
-
-	if (di->features & TWL6032_SUBCLASS) {
-		di->charger_incurrentmA = 1000;
-		di->gpadc_vbat_chnl = TWL6032_GPADC_VBAT_CHNL;
-	} else {
-		di->charger_incurrentmA = twl6030_get_usb_max_power(di->otg);
-		di->gpadc_vbat_chnl = TWL6030_GPADC_VBAT_CHNL;
-	}
-
-	di->voltage_mV = twl6030_get_gpadc_conversion(di, di->gpadc_vbat_chnl);
-	dev_info(&pdev->dev, "Battery Voltage at Bootup is %d mV\n",
-							di->voltage_mV);
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &hw_state, STS_HW_CONDITIONS);
-	if (ret)
-		goto  bk_batt_failed;
-	if (!is_battery_present(di)) {
-		if (!(hw_state & STS_USB_ID)) {
-			dev_dbg(di->dev, "Put USB in HZ mode\n");
-			ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER,
-					&chargerusb_ctrl1, CHARGERUSB_CTRL1);
-			if (ret)
-				goto  bk_batt_failed;
-
-			chargerusb_ctrl1 |= HZ_MODE;  // high-impedance
-			ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER,
-					 chargerusb_ctrl1, CHARGERUSB_CTRL1);
-			if (ret)
-				goto  bk_batt_failed;
-		}
-	} else if (!di->use_hw_charger) {
-		if (controller_stat & VAC_DET) {
-			di->ac_online = POWER_SUPPLY_TYPE_MAINS;
-			twl6030_start_ac_charger(di);
-		} else if (controller_stat & VBUS_DET) {
-			/*
-			 * In HOST mode (ID GROUND) with a device connected,
-			 * do no enable usb charging
-			 */
-			if (!(hw_state & STS_USB_ID)) {
-				di->usb_online = POWER_SUPPLY_TYPE_USB;
-				di->charger_source = POWER_SUPPLY_TYPE_USB;
-				di->charge_status =
-						POWER_SUPPLY_STATUS_CHARGING;
-				di->event = USB_EVENT_VBUS;
-				schedule_work(&di->usb_work);
-			}
-		}
-	} else {
-		int fault, charge_usb, charge_ac;
-
-		twl_i2c_read_u8(TWL6032_MODULE_CHARGER, &reg,
-				CHARGERUSB_INT_STATUS);
-
-		fault = !(di->stat1 & CONTROLLER_STAT1_LINCH_GATED) &&
-				!(di->stat1 & CONTROLLER_STAT1_FAULT_WDG);
-		charge_usb = (di->stat1 & VBUS_DET) &&
-				!(reg & CHARGERUSB_FAULT);
-		charge_ac = (di->stat1 & VAC_DET) &&
-				!(di->stat1 & CONTROLLER_STAT1_EXTCHRG_STATZ);
-
-		dev_dbg(di->dev, "boot charge state fault %d, usb %d, ac %d\n",
-				fault, charge_usb, charge_ac);
-
-		if (fault && (charge_usb || charge_ac))
-			di->charge_status = POWER_SUPPLY_STATUS_CHARGING;
-		else {
-			if (di->stat1 & (VBUS_DET | VAC_DET))
-				di->charge_status =
-					POWER_SUPPLY_STATUS_NOT_CHARGING;
-			else
-				di->charge_status =
-					POWER_SUPPLY_STATUS_DISCHARGING;
-		}
-	}
-#if 1	
-	di->interval = msecs_to_jiffies(1 * 1000);
-	INIT_DELAYED_WORK(&di->work, twl6030_battery_work);
-	queue_delayed_work(di->freezable_work, &di->work, 1*HZ);
-#endif
-	ret = twl6030backupbatt_setup();
-	if (ret)
-		dev_info(&pdev->dev, "Backup Bat charging setup failed\n");
-
-	twl6030_interrupt_unmask(TWL6030_CHARGER_CTRL_INT_MASK,
-						REG_INT_MSK_LINE_C);
-	twl6030_interrupt_unmask(TWL6030_CHARGER_CTRL_INT_MASK,
-						REG_INT_MSK_STS_C);
-	twl6030_interrupt_unmask(TWL6030_CHARGER_FAULT_INT_MASK,
-						REG_INT_MSK_LINE_C);
-	twl6030_interrupt_unmask(TWL6030_CHARGER_FAULT_INT_MASK,
-						REG_INT_MSK_STS_C);
-
-	ret = sysfs_create_group(&pdev->dev.kobj, &twl6030_bci_attr_group);
-	if (ret)
-		dev_info(&pdev->dev, "could not create sysfs files\n");
-
-	return 0;
-
-bk_batt_failed:
-	cancel_delayed_work(&di->twl6030_bci_monitor_work);
-	power_supply_unregister(&di->ac);
-ac_failed:
-	power_supply_unregister(&di->usb);
-usb_failed:
-	power_supply_unregister(&di->bat);
-batt_failed:
-	free_irq(irq, di);
-chg_irq_fail:
-	irq = platform_get_irq(pdev, 1);
-	free_irq(irq, di);
-temp_setup_fail:
-	wake_lock_destroy(&chrg_lock);
-	platform_set_drvdata(pdev, NULL);
-	kfree(di);
-
-	return ret;
-}
-
-static int __devexit twl6030_bci_battery_remove(struct platform_device *pdev)
-{
-	struct twl6030_bci_device_info *di = platform_get_drvdata(pdev);
-	int irq;
-
-	twl6030_interrupt_mask(TWL6030_CHARGER_CTRL_INT_MASK,
-						REG_INT_MSK_LINE_C);
-	twl6030_interrupt_mask(TWL6030_CHARGER_CTRL_INT_MASK,
-						REG_INT_MSK_STS_C);
-	twl6030_interrupt_mask(TWL6030_CHARGER_FAULT_INT_MASK,
-						REG_INT_MSK_LINE_C);
-	twl6030_interrupt_mask(TWL6030_CHARGER_FAULT_INT_MASK,
-						REG_INT_MSK_STS_C);
-
-	irq = platform_get_irq(pdev, 0);
-	free_irq(irq, di);
-
-	irq = platform_get_irq(pdev, 1);
-	free_irq(irq, di);
-
-	otg_unregister_notifier(di->otg, &di->nb);
-	sysfs_remove_group(&pdev->dev.kobj, &twl6030_bci_attr_group);
-	cancel_delayed_work(&di->twl6030_bci_monitor_work);
-	cancel_delayed_work(&di->twl6030_current_avg_work);
-	flush_scheduled_work();
-	power_supply_unregister(&di->bat);
-	power_supply_unregister(&di->usb);
-	power_supply_unregister(&di->ac);
-	power_supply_unregister(&di->bk_bat);
-	wake_lock_destroy(&chrg_lock);
-	platform_set_drvdata(pdev, NULL);
-	kfree(di->platform_data);
-	kfree(di);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int twl6030_bci_battery_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct twl6030_bci_device_info *di = platform_get_drvdata(pdev);
-	long int events;
-	u8 rd_reg = 0;
-	int ret;
-
-	/* mask to prevent wakeup due to 32s timeout from External charger */
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &rd_reg,
-						CONTROLLER_INT_MASK);
-	if (ret)
-		goto err;
-
-	rd_reg |= MVAC_FAULT;
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, MBAT_TEMP,
-						CONTROLLER_INT_MASK);
-	if (ret)
-		goto err;
-
-              //cancel_delayed_work(&di->work);
-	 cancel_delayed_work(&di->twl6030_bci_monitor_work);
-	//cancel_delayed_work(&di->twl6030_current_avg_work);
-
-	di->suspend_capacity = di->capacity;
-
-	/* We cannot tolarate a sleep longer than 30 seconds
-	 * while on ac charging we have to reset the BQ watchdog timer.
-	 */
-//	if ((di->charger_source == POWER_SUPPLY_TYPE_MAINS) &&
-//		((wakeup_timer_seconds > 25) || !wakeup_timer_seconds)) {
-//		wakeup_timer_seconds = 25;
-//	}
-
-	/*reset the BQ watch dog*/
-	events = BQ2415x_RESET_TIMER;
-	blocking_notifier_call_chain(&notifier_list, events, NULL);
-
-	ret = twl6030battery_temp_setup(false);
-	if (ret) {
-		pr_err("%s: Temp measurement setup failed (%d)!\n",
-				__func__, ret);
-		return ret;
-	}
-
-	ret = twl6030battery_current_setup(false);
-	if (ret) {
-		pr_err("%s: Current measurement setup failed (%d)!\n",
-				__func__, ret);
-		return ret;
-	}
-
-	return 0;
-err:
-	pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-	return ret;
-}
-
-static int twl6030_bci_battery_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct twl6030_bci_device_info *di = platform_get_drvdata(pdev);
-	long int events;
-	u8 rd_reg = 0;
-	int ret;
-
-	di->resume_status =1;
-	ret = twl6030battery_temp_setup(true);
-	if (ret) {
-		pr_err("%s: Temp measurement setup failed (%d)!\n",
-				__func__, ret);
-		return ret;
-	}
-
-	ret = twl6030battery_current_setup(true);
-	if (ret) {
-		pr_err("%s: Current measurement setup failed (%d)!\n",
-				__func__, ret);
-		return ret;
-	}
-
-	ret = twl_i2c_read_u8(TWL6030_MODULE_CHARGER, &rd_reg, CONTROLLER_INT_MASK);
-	if (ret)
-		goto err;
-
-	rd_reg &= ~(0xFF & MVAC_FAULT);
-	ret = twl_i2c_write_u8(TWL6030_MODULE_CHARGER, MBAT_TEMP,
-						CONTROLLER_INT_MASK);
-	if (ret)
-		goto err;
-
-	queue_delayed_work(di->freezable_work, &di->twl6030_bci_monitor_work, 0);
-	//queue_delayed_work(di->freezable_work, &di->twl6030_current_avg_work, 50);
-	//queue_delayed_work(di->freezable_work, &di->work, di->interval);
-
-	events = BQ2415x_RESET_TIMER;
-	blocking_notifier_call_chain(&notifier_list, events, NULL);
-
-	return 0;
-err:
-	pr_err("%s: Error access to TWL6030 (%d)\n", __func__, ret);
-	return ret;
-}
-#else
-#define twl6030_bci_battery_suspend	NULL
-#define twl6030_bci_battery_resume	NULL
-#endif /* CONFIG_PM */
-
-static const struct dev_pm_ops pm_ops = {
-	.suspend	= twl6030_bci_battery_suspend,
-	.resume		= twl6030_bci_battery_resume,
-};
-
-static struct platform_driver twl6030_bci_battery_driver = {
-	.probe		= twl6030_bci_battery_probe,
-	.remove		= __devexit_p(twl6030_bci_battery_remove),
-	.driver		= {
-		.name	= "twl6030_bci",
-		.pm	= &pm_ops,
-	},
-};
-
-static int __init twl6030_battery_init(void)
-{
-	return platform_driver_register(&twl6030_bci_battery_driver);
-}
-module_init(twl6030_battery_init);
-
-static void __exit twl6030_battery_exit(void)
-{
-	platform_driver_unregister(&twl6030_bci_battery_driver);
-}
-module_exit(twl6030_battery_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:twl6030_bci");
-MODULE_AUTHOR("Texas Instruments Inc");
diff --git a/include/linux/i2c/twl6030-gpadc.h b/include/linux/i2c/twl6030-gpadc.h
deleted file mode 100644
index 8d952a7a692a..000000000000
--- a/include/linux/i2c/twl6030-gpadc.h
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * include/linux/i2c/twl6030-gpadc.h
- *
- * TWL6030 GPADC module driver header
- *
- * Copyright (C) 2009 Texas Instruments Inc.
- * Nishant Kamat <nskamat@ti.com>
- *
- * Based on twl4030-madc.h
- * Copyright (C) 2008 Nokia Corporation
- * Mikko Ylinen <mikko.k.ylinen@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef _TWL6030_GPADC_H
-#define _TWL6030_GPADC_H
-
-struct twl6030_gpadc_conversion_method {
-	u8 sel;
-	u8 rbase;
-	u8 ctrl;
-	u8 enable;
-	u8 mask;
-};
-
-#define TWL6030_GPADC_MAX_CHANNELS 17
-#define TWL6032_GPADC_MAX_CHANNELS 19
-/* Define this as the biggest of all chips using this driver */
-#define GPADC_MAX_CHANNELS TWL6032_GPADC_MAX_CHANNELS
-
-/*
- * raw_code - raw adc value
- * raw_channel_value - adc * channel gain
- * code - calibrated adc value
- */
-struct twl6030_value {
-	int raw_code;
-	int raw_channel_value;
-	int code;
-};
-
-struct twl6030_gpadc_request {
-	u32 channels;
-	u16 do_avg;
-	u16 method;
-	u16 type;
-	int active;
-	int result_pending;
-	int rbuf[TWL6032_GPADC_MAX_CHANNELS];
-	void (*func_cb)(struct twl6030_gpadc_request *req);
-	struct twl6030_value buf[TWL6032_GPADC_MAX_CHANNELS];
-};
-
-enum conversion_methods {
-	TWL6030_GPADC_RT,
-	TWL6030_GPADC_SW2,
-	TWL6030_GPADC_NUM_METHODS
-};
-
-enum sample_type {
-	TWL6030_GPADC_WAIT,
-	TWL6030_GPADC_IRQ_ONESHOT,
-	TWL6030_GPADC_IRQ_REARM
-};
-
-#define TWL6030_GPADC_CTRL		0x00    /* 0x2e */
-#define TWL6030_GPADC_CTRL2		0x01	/* 0x2f */
-
-#define TWL6030_GPADC_RTSELECT_LSB	0x02    /* 0x30 */
-#define TWL6030_GPADC_RTSELECT_ISB	0x03
-#define TWL6030_GPADC_RTSELECT_MSB	0x04
-
-#define TWL6032_GPADC_RTSELECT_LSB	0x04    /* 0x32 */
-#define TWL6032_GPADC_RTSELECT_ISB	0x05
-#define TWL6032_GPADC_RTSELECT_MSB	0x06
-
-#define TWL6030_GPADC_CTRL_P1		0x05
-#define TWL6030_GPADC_CTRL_P2		0x06
-
-#define TWL6032_GPADC_GPSELECT_ISB	0x07
-#define TWL6032_GPADC_CTRL_P1		0x08
-
-#define TWL6032_RTCH0_LSB			0x09
-#define TWL6032_RTCH0_MSB			0x0a
-#define TWL6032_RTCH1_LSB			0x0b
-#define TWL6032_RTCH1_MSB			0x0c
-#define TWL6032_GPCH0_LSB			0x0d
-#define TWL6032_GPCH0_MSB			0x0e
-
-#define TWL6030_GPADC_CTRL_P1_SP1	(1 << 3)
-#define TWL6030_GPADC_CTRL_P1_EOCRT	(1 << 2)
-#define TWL6030_GPADC_CTRL_P1_EOCP1	(1 << 1)
-#define TWL6030_GPADC_CTRL_P1_BUSY	(1 << 0)
-
-#define TWL6030_GPADC_CTRL_P2_SP2	(1 << 2)
-#define TWL6030_GPADC_CTRL_P2_EOCP2	(1 << 1)
-#define TWL6030_GPADC_CTRL_P1_BUSY	(1 << 0)
-
-#define TWL6030_GPADC_EOC_SW		(1 << 1)
-#define TWL6030_GPADC_BUSY		(1 << 0)
-
-#define TWL6030_GPADC_RTCH0_LSB		(0x07)
-#define TWL6030_GPADC_GPCH0_LSB		(0x29)
-
-/* Fixed channels */
-#define TWL6030_GPADC_CTRL_TEMP1_EN	(1 << 0)    /* input ch 1 */
-#define TWL6030_GPADC_CTRL_TEMP2_EN	(1 << 1)    /* input ch 4 */
-#define TWL6030_GPADC_CTRL_SCALER_EN	(1 << 2)    /* input ch 2 */
-#define TWL6030_GPADC_CTRL_SCALER_DIV4	(1 << 3)
-#define TWL6030_GPADC_CTRL_SCALER_EN_CH11	(1 << 4)    /* input ch 11 */
-#define TWL6030_GPADC_CTRL_TEMP1_EN_MONITOR	(1 << 5)
-#define TWL6030_GPADC_CTRL_TEMP2_EN_MONITOR	(1 << 6)
-#define TWL6030_GPADC_CTRL_ISOURCE_EN		(1 << 7)
-
-#define TWL6030_GPADC_CTRL2_REMSENSE_0		(1 << 0)
-#define TWL6030_GPADC_CTRL2_REMSENSE_1		(1 << 1)
-#define TWL6030_GPADC_CTRL2_SCALER_EN_CH18	(1 << 2)
-#define TWL6030_GPADC_CTRL2_VBAT_SCALER_DIV4	(1 << 3)
-
-#define TWL6030_GPADC_RT_SW1_EOC_MASK		(1 << 5)
-#define TWL6030_GPADC_SW2_EOC_MASK		(1 << 6)
-
-#define TWL6032_GPADC_RT_EOC_MASK		(1 << 4)
-#define TWL6032_GPADC_SW_EOC_MASK		(1 << 5)
-
-#define TWL6030_GPADC_IOC_MAGIC '`'
-#define TWL6030_GPADC_IOCX_ADC_RAW_READ	_IO(TWL6030_GPADC_IOC_MAGIC, 0)
-#define TWL6030_GPADC_IOCX_ADC_READ	_IO(TWL6030_GPADC_IOC_MAGIC+1, 0)
-
-struct twl6030_gpadc_user_parms {
-	int channel;
-	int status;
-	u16 result;
-};
-
-int twl6030_gpadc_conversion(struct twl6030_gpadc_request *conv);
-
-#endif
diff --git a/include/linux/i2c/twl6030-madc.h b/include/linux/i2c/twl6030-madc.h
deleted file mode 100644
index 81b946478d8a..000000000000
--- a/include/linux/i2c/twl6030-madc.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * twl6030_madc.h - Header for TWL6030 MADC
- *
- * Copyright (C) 2011 Samsung Telecommunications of America
- *
- * Based on twl4030-madc.h
- * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
- * J Keerthy <j-keerthy@ti.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef _TWL6030_MADC_H
-#define _TWL6030_MADC_H
-
-#define TWL6030_MADC_MAX_CHANNELS 17
-/*
- * twl6030 madc occupies the same offset in the twl6030 map that
- * twl4030 madc does in the twl4030 map.
- * likewise the charger
- */
-#define TWL6030_MODULE_MADC          TWL4030_MODULE_MADC
-#define TWL6030_MODULE_MAIN_CHARGE   TWL4030_MODULE_MAIN_CHARGE
-
-#define TWL6030_MADC_CTRL		0x00
-#define    TWL6030_MADC_TEMP1_EN        (1 << 0)
-#define    TWL6030_MADC_TEMP2_EN        (1 << 1)
-#define    TWL6030_MADC_SCALER_EN_CH2	(1 << 2)
-#define    TWL6030_MADC_VBAT_SCALER_DIV	(1 << 3)
-#define    TWL6030_MADC_SCALER_EN_CH11	(1 << 4)
-#define    TWL6030_MADC_TMP1_EN_MONITOR	(1 << 5)
-#define    TWL6030_MADC_TMP2_EN_MONITOR	(1 << 6)
-#define    TWL6030_MADC_ISOURCE_EN	(1 << 7)
-
-#define TWL6030_MADC_RTSELECT_LSB	0x02
-#define    TWL6030_MADC_ADCIN0	(1 << 0)
-#define    TWL6030_MADC_ADCIN1	(1 << 1)
-#define    TWL6030_MADC_ADCIN2	(1 << 2)
-#define    TWL6030_MADC_ADCIN3	(1 << 3)
-#define    TWL6030_MADC_ADCIN4	(1 << 4)
-#define    TWL6030_MADC_ADCIN5	(1 << 5)
-#define    TWL6030_MADC_ADCIN6	(1 << 6)
-#define    TWL6030_MADC_ADCIN7	(1 << 7)
-
-#define TWL6030_MADC_RTSELECT_ISB	0x03
-#define    TWL6030_MADC_ADCIN8		(1 << 0)
-#define    TWL6030_MADC_ADCIN9		(1 << 1)
-#define    TWL6030_MADC_ADCIN10		(1 << 2)
-#define    TWL6030_MADC_ADCIN11		(1 << 3)
-#define    TWL6030_MADC_ADCIN12		(1 << 4)
-#define    TWL6030_MADC_ADCIN13		(1 << 5)
-#define    TWL6030_MADC_ADCIN14		(1 << 6)
-#define    TWL6030_MADC_ADCIN15		(1 << 7)
-
-#define TWL6030_MADC_RTSELECT_MSB	0x04
-#define    TWL6030_MADC_ADCIN16		(1 << 0)
-
-#define TWL6030_MADC_CTRL_P1		0x05
-#define    TWL6030_MADC_BUSY		(1 << 0)
-#define    TWL6030_MADC_EOCP1		(1 << 1)
-#define    TWL6030_MADC_EOCRT		(1 << 2)
-#define    TWL6030_MADC_SP1		(1 << 3)
-
-#define TWL6030_MADC_CTRL_P2		0x06
-#define    TWL6030_MADC_BUSYB		(1 << 0)
-#define    TWL6030_MADC_EOCP2		(1 << 1)
-#define    TWL6030_MADC_SP2		(1 << 2)
-
-#define TWL6030_MADC_RTCH0_LSB		0x07
-#define TWL6030_MADC_GPCH0_LSB		0x29
-
-int twl6030_get_madc_conversion(int channel_no);
-#endif
-- 
2.35.3

