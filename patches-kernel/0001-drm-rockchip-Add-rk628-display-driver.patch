From e285c9b20e45cc9aaf05a52f5bfbb8abb27db7e1 Mon Sep 17 00:00:00 2001
From: Wyon Bi <bivvy.bi@rock-chips.com>
Date: Wed, 23 Oct 2019 14:26:13 +0800
Subject: [PATCH] drm/rockchip: Add rk628 display driver

Change-Id: I7be65c5ed58df2be2cf2cfe819feacf8a610e880
Signed-off-by: Wyon Bi <bivvy.bi@rock-chips.com>
---
 drivers/gpu/drm/rockchip/Kconfig              |    1 +
 drivers/gpu/drm/rockchip/Makefile             |    1 +
 drivers/gpu/drm/rockchip/rk628/Kconfig        |    8 +
 drivers/gpu/drm/rockchip/rk628/Makefile       |   10 +
 .../gpu/drm/rockchip/rk628/rk628_combtxphy.c  |  465 ++++++
 drivers/gpu/drm/rockchip/rk628/rk628_dsi.c    | 1393 +++++++++++++++++
 drivers/gpu/drm/rockchip/rk628/rk628_lvds.c   |  327 ++++
 .../drm/rockchip/rk628/rk628_post_process.c   |  401 +++++
 drivers/gpu/drm/rockchip/rk628/rk628_rgb.c    |  203 +++
 9 files changed, 2809 insertions(+)
 create mode 100644 drivers/gpu/drm/rockchip/rk628/Kconfig
 create mode 100644 drivers/gpu/drm/rockchip/rk628/Makefile
 create mode 100644 drivers/gpu/drm/rockchip/rk628/rk628_combtxphy.c
 create mode 100644 drivers/gpu/drm/rockchip/rk628/rk628_dsi.c
 create mode 100644 drivers/gpu/drm/rockchip/rk628/rk628_lvds.c
 create mode 100644 drivers/gpu/drm/rockchip/rk628/rk628_post_process.c
 create mode 100644 drivers/gpu/drm/rockchip/rk628/rk628_rgb.c

diff --git a/drivers/gpu/drm/rockchip/Kconfig b/drivers/gpu/drm/rockchip/Kconfig
index e53b89122569..eb0e65785ad3 100644
--- a/drivers/gpu/drm/rockchip/Kconfig
+++ b/drivers/gpu/drm/rockchip/Kconfig
@@ -94,5 +94,6 @@ config ROCKCHIP_RGB
 	  say Y to enable its driver.
 
 source "drivers/gpu/drm/rockchip/rk618/Kconfig"
+source "drivers/gpu/drm/rockchip/rk628/Kconfig"
 
 endif
diff --git a/drivers/gpu/drm/rockchip/Makefile b/drivers/gpu/drm/rockchip/Makefile
index 65eb7b91705d..67bba02d5056 100644
--- a/drivers/gpu/drm/rockchip/Makefile
+++ b/drivers/gpu/drm/rockchip/Makefile
@@ -21,3 +21,4 @@ rockchipdrm-$(CONFIG_ROCKCHIP_RGB) += rockchip_rgb.o
 obj-$(CONFIG_DRM_ROCKCHIP) += rockchipdrm.o
 
 obj-$(CONFIG_DRM_ROCKCHIP_RK618) += rk618/
+obj-$(CONFIG_DRM_ROCKCHIP_RK628) += rk628/
diff --git a/drivers/gpu/drm/rockchip/rk628/Kconfig b/drivers/gpu/drm/rockchip/rk628/Kconfig
new file mode 100644
index 000000000000..80cdf2370b9f
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk628/Kconfig
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+
+config DRM_ROCKCHIP_RK628
+	tristate "Rockchip RK628 display bridge driver"
+	depends on DRM_ROCKCHIP
+	depends on MFD_RK628
+	---help---
+	  Rockchip RK628 display bridge chips driver.
diff --git a/drivers/gpu/drm/rockchip/rk628/Makefile b/drivers/gpu/drm/rockchip/rk628/Makefile
new file mode 100644
index 000000000000..5d6f58f473fc
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk628/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the Rockchip RK628 display bridge driver.
+#
+
+obj-$(CONFIG_DRM_ROCKCHIP_RK628) += rk628_combtxphy.o \
+				    rk628_dsi.o \
+				    rk628_lvds.o \
+				    rk628_post_process.o \
+				    rk628_rgb.o
diff --git a/drivers/gpu/drm/rockchip/rk628/rk628_combtxphy.c b/drivers/gpu/drm/rockchip/rk628/rk628_combtxphy.c
new file mode 100644
index 000000000000..3b9edaa979a6
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk628/rk628_combtxphy.c
@@ -0,0 +1,465 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
+ *
+ * Author: Wyon Bi <bivvy.bi@rock-chips.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/phy/phy.h>
+#include <linux/mfd/rk628.h>
+
+#define REG(x)			((x) + 0x90000)
+
+#define COMBTXPHY_CON0		REG(0x0000)
+#define SW_TX_IDLE_MASK		GENMASK(29, 20)
+#define SW_TX_IDLE(x)		UPDATE(x, 29, 20)
+#define SW_TX_PD_MASK		GENMASK(17, 8)
+#define SW_TX_PD(x)		UPDATE(x, 17, 8)
+#define SW_BUS_WIDTH_MASK	GENMASK(6, 5)
+#define SW_BUS_WIDTH_7BIT	UPDATE(0x3, 6, 5)
+#define SW_BUS_WIDTH_8BIT	UPDATE(0x2, 6, 5)
+#define SW_BUS_WIDTH_9BIT	UPDATE(0x1, 6, 5)
+#define SW_BUS_WIDTH_10BIT	UPDATE(0x0, 6, 5)
+#define SW_PD_PLL_MASK		BIT(4)
+#define SW_PD_PLL		BIT(4)
+#define SW_GVI_LVDS_EN_MASK	BIT(3)
+#define SW_GVI_LVDS_EN		BIT(3)
+#define SW_MIPI_DSI_EN_MASK	BIT(2)
+#define SW_MIPI_DSI_EN		BIT(2)
+#define SW_MODULEB_EN_MASK	BIT(1)
+#define SW_MODULEB_EN		BIT(1)
+#define SW_MODULEA_EN_MASK	BIT(0)
+#define SW_MODULEA_EN		BIT(0)
+#define COMBTXPHY_CON1		REG(0x0004)
+#define COMBTXPHY_CON2		REG(0x0008)
+#define COMBTXPHY_CON3		REG(0x000c)
+#define COMBTXPHY_CON4		REG(0x0010)
+#define COMBTXPHY_CON5		REG(0x0014)
+#define SW_RATE(x)		UPDATE(x, 26, 24)
+#define SW_REF_DIV(x)		UPDATE(x, 20, 16)
+#define SW_PLL_FB_DIV(x)	UPDATE(x, 14, 10)
+#define SW_PLL_FRAC_DIV(x)	UPDATE(x, 9, 0)
+#define COMBTXPHY_CON6		REG(0x0018)
+#define COMBTXPHY_CON7		REG(0x001c)
+#define SW_TX_RTERM_MASK	GENMASK(22, 20)
+#define SW_TX_RTERM(x)		UPDATE(x, 22, 20)
+#define SW_TX_MODE_MASK		GENMASK(17, 16)
+#define SW_TX_MODE(x)		UPDATE(x, 17, 16)
+#define SW_TX_CTL_CON5_MASK	BIT(10)
+#define SW_TX_CTL_CON5(x)	UPDATE(x, 10, 10)
+#define SW_TX_CTL_CON4_MASK	GENMASK(9, 8)
+#define SW_TX_CTL_CON4(x)	UPDATE(x, 9, 8)
+#define COMBTXPHY_CON8		REG(0x0020)
+#define COMBTXPHY_CON9		REG(0x0024)
+#define SW_DSI_FSET_EN_MASK	BIT(29)
+#define SW_DSI_FSET_EN		BIT(29)
+#define SW_DSI_RCAL_EN_MASK	BIT(28)
+#define SW_DSI_RCAL_EN		BIT(28)
+#define COMBTXPHY_CON10		REG(0x0028)
+#define TX9_CKDRV_EN		BIT(9)
+#define TX8_CKDRV_EN		BIT(8)
+#define TX7_CKDRV_EN		BIT(7)
+#define TX6_CKDRV_EN		BIT(6)
+#define TX5_CKDRV_EN		BIT(5)
+#define TX4_CKDRV_EN		BIT(4)
+#define TX3_CKDRV_EN		BIT(3)
+#define TX2_CKDRV_EN		BIT(2)
+#define TX1_CKDRV_EN		BIT(1)
+#define TX0_CKDRV_EN		BIT(0)
+#define COMBTXPHY_MAX_REGISTER	COMBTXPHY_CON10
+
+struct rk628_combtxphy {
+	struct device *dev;
+	struct rk628 *parent;
+	struct regmap *grf;
+	struct regmap *regmap;
+	struct clk *pclk;
+	struct reset_control *rstc;
+	enum phy_mode mode;
+	unsigned int flags;
+
+	u8 ref_div;
+	u8 fb_div;
+	u16 frac_div;
+	u8 rate_div;
+};
+
+static int rk628_combtxphy_dsi_power_on(struct rk628_combtxphy *combtxphy)
+{
+	u32 val;
+	int ret;
+
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_BUS_WIDTH_MASK | SW_GVI_LVDS_EN_MASK |
+			   SW_MIPI_DSI_EN_MASK,
+			   SW_BUS_WIDTH_8BIT | SW_MIPI_DSI_EN);
+
+	if (combtxphy->flags & COMBTXPHY_MODULEA_EN)
+		regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+				   SW_MODULEA_EN_MASK, SW_MODULEA_EN);
+	if (combtxphy->flags & COMBTXPHY_MODULEB_EN)
+		regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+				   SW_MODULEB_EN_MASK, SW_MODULEB_EN);
+
+	regmap_write(combtxphy->regmap, COMBTXPHY_CON5,
+		     SW_REF_DIV(combtxphy->ref_div - 1) |
+		     SW_PLL_FB_DIV(combtxphy->fb_div) |
+		     SW_PLL_FRAC_DIV(combtxphy->frac_div) |
+		     SW_RATE(combtxphy->rate_div / 2));
+
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_PD_PLL, 0);
+
+	ret = regmap_read_poll_timeout(combtxphy->grf, GRF_DPHY0_STATUS,
+				       val, val & DPHY_PHYLOCK, 0, 1000);
+	if (ret < 0) {
+		dev_err(combtxphy->dev, "phy is not lock\n");
+		return ret;
+	}
+
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON9,
+			   SW_DSI_FSET_EN_MASK | SW_DSI_RCAL_EN_MASK,
+			   SW_DSI_FSET_EN | SW_DSI_RCAL_EN);
+
+	usleep_range(200, 400);
+
+	return 0;
+}
+
+static int rk628_combtxphy_lvds_power_on(struct rk628_combtxphy *combtxphy)
+{
+	u32 val;
+	int ret;
+
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON7,
+			   SW_TX_MODE_MASK, SW_TX_MODE(3));
+	regmap_write(combtxphy->regmap, COMBTXPHY_CON10,
+		     TX7_CKDRV_EN | TX2_CKDRV_EN);
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_BUS_WIDTH_MASK | SW_GVI_LVDS_EN_MASK |
+			   SW_MIPI_DSI_EN_MASK,
+			   SW_BUS_WIDTH_7BIT | SW_GVI_LVDS_EN);
+
+	if (combtxphy->flags & COMBTXPHY_MODULEA_EN)
+		regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+				   SW_MODULEA_EN_MASK, SW_MODULEA_EN);
+	if (combtxphy->flags & COMBTXPHY_MODULEB_EN)
+		regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+				   SW_MODULEB_EN_MASK, SW_MODULEB_EN);
+
+	regmap_write(combtxphy->regmap, COMBTXPHY_CON5,
+		     SW_REF_DIV(combtxphy->ref_div - 1) |
+		     SW_PLL_FB_DIV(combtxphy->fb_div) |
+		     SW_PLL_FRAC_DIV(combtxphy->frac_div) |
+		     SW_RATE(combtxphy->rate_div / 2));
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_PD_PLL | SW_TX_PD_MASK, 0);
+
+	ret = regmap_read_poll_timeout(combtxphy->grf, GRF_DPHY0_STATUS,
+				       val, val & DPHY_PHYLOCK, 0, 1000);
+	if (ret < 0) {
+		dev_info(combtxphy->dev, "phy is not lock\n");
+		return ret;
+	}
+
+	usleep_range(100, 200);
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_TX_IDLE_MASK, 0);
+
+	return 0;
+}
+
+static int rk628_combtxphy_gvi_power_on(struct rk628_combtxphy *combtxphy)
+{
+	regmap_write(combtxphy->regmap, COMBTXPHY_CON5,
+		     SW_REF_DIV(combtxphy->ref_div - 1) |
+		     SW_PLL_FB_DIV(combtxphy->fb_div) |
+		     SW_PLL_FRAC_DIV(combtxphy->frac_div) |
+		     SW_RATE(combtxphy->rate_div / 2));
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_BUS_WIDTH_MASK | SW_GVI_LVDS_EN_MASK |
+			   SW_MIPI_DSI_EN_MASK |
+			   SW_MODULEB_EN_MASK | SW_MODULEA_EN_MASK,
+			   SW_BUS_WIDTH_10BIT | SW_GVI_LVDS_EN |
+			   SW_MODULEB_EN | SW_MODULEA_EN);
+
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_PD_PLL | SW_TX_PD_MASK, 0);
+	usleep_range(100, 200);
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_TX_IDLE_MASK, 0);
+
+	return 0;
+}
+
+static int rk628_combtxphy_power_on(struct phy *phy)
+{
+	struct rk628_combtxphy *combtxphy = phy_get_drvdata(phy);
+
+	clk_prepare_enable(combtxphy->pclk);
+	reset_control_assert(combtxphy->rstc);
+	udelay(10);
+	reset_control_deassert(combtxphy->rstc);
+	udelay(10);
+
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_TX_IDLE_MASK | SW_TX_PD_MASK | SW_PD_PLL_MASK,
+			   SW_TX_IDLE(0x3ff) | SW_TX_PD(0x3ff) | SW_PD_PLL);
+
+	switch (combtxphy->mode) {
+	case PHY_MODE_VIDEO_MIPI:
+		regmap_update_bits(combtxphy->grf, GRF_POST_PROC_CON,
+				   SW_TXPHY_REFCLK_SEL_MASK,
+				   SW_TXPHY_REFCLK_SEL(0));
+		return rk628_combtxphy_dsi_power_on(combtxphy);
+	case PHY_MODE_VIDEO_LVDS:
+		regmap_update_bits(combtxphy->grf, GRF_POST_PROC_CON,
+				   SW_TXPHY_REFCLK_SEL_MASK,
+				   SW_TXPHY_REFCLK_SEL(1));
+		return rk628_combtxphy_lvds_power_on(combtxphy);
+	case PHY_MODE_GVI:
+		regmap_update_bits(combtxphy->grf, GRF_POST_PROC_CON,
+				   SW_TXPHY_REFCLK_SEL_MASK,
+				   SW_TXPHY_REFCLK_SEL(0));
+		return rk628_combtxphy_gvi_power_on(combtxphy);
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk628_combtxphy_power_off(struct phy *phy)
+{
+	struct rk628_combtxphy *combtxphy = phy_get_drvdata(phy);
+
+	regmap_update_bits(combtxphy->regmap, COMBTXPHY_CON0,
+			   SW_TX_IDLE_MASK | SW_TX_PD_MASK | SW_PD_PLL_MASK |
+			   SW_MODULEB_EN_MASK | SW_MODULEA_EN_MASK,
+			   SW_TX_IDLE(0x3ff) | SW_TX_PD(0x3ff) | SW_PD_PLL);
+
+	clk_disable_unprepare(combtxphy->pclk);
+
+	return 0;
+}
+
+static int rk628_combtxphy_set_mode(struct phy *phy, enum phy_mode mode)
+{
+	struct rk628_combtxphy *combtxphy = phy_get_drvdata(phy);
+	unsigned int fvco, frac_rate, fin = 24;
+
+	switch (mode) {
+	case PHY_MODE_VIDEO_MIPI:
+	{
+		int bus_width = phy_get_bus_width(phy);
+		unsigned int fhsc = bus_width >> 8;
+		unsigned int flags = bus_width & 0xff;
+
+		fhsc = fin * (fhsc / fin);
+
+		if (fhsc < 80 || fhsc > 1500)
+			return -EINVAL;
+		else if (fhsc < 375)
+			combtxphy->rate_div = 4;
+		else if (fhsc < 750)
+			combtxphy->rate_div = 2;
+		else
+			combtxphy->rate_div = 1;
+
+		combtxphy->flags = flags;
+
+		fvco = fhsc * 2 * combtxphy->rate_div;
+		combtxphy->ref_div = 1;
+		combtxphy->fb_div = fvco / 8 / fin;
+		frac_rate = fvco - (fin * 8 * combtxphy->fb_div);
+
+		if (frac_rate) {
+			frac_rate <<= 10;
+			frac_rate /= fin * 8;
+			combtxphy->frac_div = frac_rate;
+		} else {
+			combtxphy->frac_div = 0;
+		}
+
+		fvco = fin * (1024 * combtxphy->fb_div + combtxphy->frac_div);
+		fvco *= 8;
+		fvco = DIV_ROUND_UP(fvco, 1024 * combtxphy->ref_div);
+		fhsc = fvco / 2 / combtxphy->rate_div;
+		phy_set_bus_width(phy, fhsc);
+		break;
+	}
+	case PHY_MODE_VIDEO_LVDS:
+	{
+		int bus_width = phy_get_bus_width(phy);
+		unsigned int flags = bus_width & 0xff;
+		unsigned int rate = (bus_width >> 8) * 7;
+
+		combtxphy->flags = flags;
+		combtxphy->ref_div = 1;
+		combtxphy->fb_div = 14;
+		combtxphy->frac_div = 0;
+
+		if (rate < 500)
+			combtxphy->rate_div = 4;
+		else if (rate < 1000)
+			combtxphy->rate_div = 2;
+		else
+			combtxphy->rate_div = 1;
+		break;
+	}
+	case PHY_MODE_GVI:
+	{
+		unsigned int fhsc = phy_get_bus_width(phy) & 0xfff;
+
+		if (fhsc < 500 || fhsc > 4000)
+			return -EINVAL;
+		else if (fhsc < 1000)
+			combtxphy->rate_div = 4;
+		else if (fhsc < 2000)
+			combtxphy->rate_div = 2;
+		else
+			combtxphy->rate_div = 1;
+		fvco = fhsc * combtxphy->rate_div;
+
+		combtxphy->ref_div = 1;
+		combtxphy->fb_div = fvco / 8 / fin;
+		frac_rate = fvco - (fin * 8 * combtxphy->fb_div);
+
+		if (frac_rate) {
+			frac_rate <<= 10;
+			frac_rate /= fin * 8;
+			combtxphy->frac_div = frac_rate;
+		} else {
+			combtxphy->frac_div = 0;
+		}
+
+		fvco = fin * (1024 * combtxphy->fb_div + combtxphy->frac_div);
+		fvco *= 8;
+		fvco /= 1024 * combtxphy->ref_div;
+		fhsc = fvco / combtxphy->rate_div;
+		phy_set_bus_width(phy, fhsc);
+
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	combtxphy->mode = mode;
+
+	return 0;
+}
+
+static const struct phy_ops rk628_combtxphy_ops = {
+	.set_mode = rk628_combtxphy_set_mode,
+	.power_on = rk628_combtxphy_power_on,
+	.power_off = rk628_combtxphy_power_off,
+	.owner = THIS_MODULE,
+};
+
+static const struct regmap_range rk628_combtxphy_readable_ranges[] = {
+	regmap_reg_range(COMBTXPHY_CON0, COMBTXPHY_CON10),
+};
+
+static const struct regmap_access_table rk628_combtxphy_readable_table = {
+	.yes_ranges     = rk628_combtxphy_readable_ranges,
+	.n_yes_ranges   = ARRAY_SIZE(rk628_combtxphy_readable_ranges),
+};
+
+static const struct regmap_config rk628_combtxphy_regmap_cfg = {
+	.name = "combtxphy",
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.cache_type = REGCACHE_RBTREE,
+	.max_register = COMBTXPHY_MAX_REGISTER,
+	.reg_format_endian = REGMAP_ENDIAN_LITTLE,
+	.val_format_endian = REGMAP_ENDIAN_LITTLE,
+	.rd_table = &rk628_combtxphy_readable_table,
+};
+
+static int rk628_combtxphy_probe(struct platform_device *pdev)
+{
+	struct rk628 *rk628 = dev_get_drvdata(pdev->dev.parent);
+	struct device *dev = &pdev->dev;
+	struct rk628_combtxphy *combtxphy;
+	struct phy_provider *phy_provider;
+	struct phy *phy;
+	int ret;
+
+	combtxphy = devm_kzalloc(dev, sizeof(*combtxphy), GFP_KERNEL);
+	if (!combtxphy)
+		return -ENOMEM;
+
+	combtxphy->dev = dev;
+	combtxphy->parent = rk628;
+	combtxphy->grf = rk628->grf;
+	platform_set_drvdata(pdev, combtxphy);
+
+	combtxphy->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(combtxphy->pclk))
+		return PTR_ERR(combtxphy->pclk);
+
+	combtxphy->rstc = of_reset_control_get(dev->of_node, NULL);
+	if (IS_ERR(combtxphy->rstc)) {
+		ret = PTR_ERR(combtxphy->rstc);
+		dev_err(dev, "failed to get reset control: %d\n", ret);
+		return ret;
+	}
+
+	combtxphy->regmap = devm_regmap_init_i2c(rk628->client,
+						 &rk628_combtxphy_regmap_cfg);
+	if (IS_ERR(combtxphy->regmap)) {
+		ret = PTR_ERR(combtxphy->regmap);
+		dev_err(dev, "failed to allocate register map: %d\n", ret);
+		return ret;
+	}
+
+	regmap_write(combtxphy->regmap, COMBTXPHY_CON0,
+		     SW_TX_IDLE(0x3ff) | SW_TX_PD(0x3ff) | SW_PD_PLL);
+
+	phy = devm_phy_create(dev, NULL, &rk628_combtxphy_ops);
+	if (IS_ERR(phy)) {
+		ret = PTR_ERR(phy);
+		dev_err(dev, "failed to create phy: %d\n", ret);
+		return ret;
+	}
+
+	phy_set_drvdata(phy, combtxphy);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider)) {
+		ret = PTR_ERR(phy_provider);
+		dev_err(dev, "failed to register phy provider: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id rk628_combtxphy_of_match[] = {
+	{ .compatible = "rockchip,rk628-combtxphy", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, rk628_combtxphy_of_match);
+
+static struct platform_driver rk628_combtxphy_driver = {
+	.driver = {
+		.name = "rk628-combtxphy",
+		.of_match_table	= of_match_ptr(rk628_combtxphy_of_match),
+	},
+	.probe = rk628_combtxphy_probe,
+};
+module_platform_driver(rk628_combtxphy_driver);
+
+MODULE_AUTHOR("Wyon Bi <bivvy.bi@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip RK628 GVI/LVDS/MIPI Combo TX PHY driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/rockchip/rk628/rk628_dsi.c b/drivers/gpu/drm/rockchip/rk628/rk628_dsi.c
new file mode 100644
index 000000000000..c437342a41d4
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk628/rk628_dsi.c
@@ -0,0 +1,1393 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
+ *
+ * Author: Wyon Bi <bivvy.bi@rock-chips.com>
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/mfd/rk628.h>
+#include <linux/reset.h>
+#include <linux/phy/phy.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_of.h>
+#include <drm/drm_panel.h>
+
+#include <video/of_display_timing.h>
+#include <video/mipi_display.h>
+#include <video/videomode.h>
+#include <asm/unaligned.h>
+
+#define DSI_VERSION			0x0000
+#define DSI_PWR_UP			0x0004
+#define RESET				0
+#define POWER_UP			BIT(0)
+#define DSI_CLKMGR_CFG			0x0008
+#define TO_CLK_DIVISION(x)		UPDATE(x, 15,  8)
+#define TX_ESC_CLK_DIVISION(x)		UPDATE(x,  7,  0)
+#define DSI_DPI_VCID			0x000c
+#define DPI_VID(x)			UPDATE(x,  1,  0)
+#define DSI_DPI_COLOR_CODING		0x0010
+#define LOOSELY18_EN			BIT(8)
+#define DPI_COLOR_CODING(x)		UPDATE(x,  3,  0)
+#define DSI_DPI_CFG_POL			0x0014
+#define COLORM_ACTIVE_LOW		BIT(4)
+#define SHUTD_ACTIVE_LOW		BIT(3)
+#define HSYNC_ACTIVE_LOW		BIT(2)
+#define VSYNC_ACTIVE_LOW		BIT(1)
+#define DATAEN_ACTIVE_LOW		BIT(0)
+#define DSI_DPI_LP_CMD_TIM		0x0018
+#define OUTVACT_LPCMD_TIME(x)		UPDATE(x, 23, 16)
+#define INVACT_LPCMD_TIME(x)		UPDATE(x,  7,  0)
+#define DSI_PCKHDL_CFG			0x002c
+#define CRC_RX_EN			BIT(4)
+#define ECC_RX_EN			BIT(3)
+#define BTA_EN				BIT(2)
+#define EOTP_RX_EN			BIT(1)
+#define EOTP_TX_EN			BIT(0)
+#define DSI_GEN_VCID			0x0030
+#define DSI_MODE_CFG			0x0034
+#define CMD_VIDEO_MODE(x)		UPDATE(x,  0,  0)
+#define DSI_VID_MODE_CFG		0x0038
+#define VPG_EN				BIT(16)
+#define LP_CMD_EN			BIT(15)
+#define FRAME_BTA_ACK_EN		BIT(14)
+#define LP_HFP_EN			BIT(13)
+#define LP_HBP_EN			BIT(12)
+#define LP_VACT_EN			BIT(11)
+#define LP_VFP_EN			BIT(10)
+#define LP_VBP_EN			BIT(9)
+#define LP_VSA_EN			BIT(8)
+#define VID_MODE_TYPE(x)		UPDATE(x,  1,  0)
+#define DSI_VID_PKT_SIZE		0x003c
+#define VID_PKT_SIZE(x)			UPDATE(x, 13,  0)
+#define DSI_VID_NUM_CHUNKS		0x0040
+#define DSI_VID_NULL_SIZE		0x0044
+#define DSI_VID_HSA_TIME		0x0048
+#define VID_HSA_TIME(x)			UPDATE(x, 11,  0)
+#define DSI_VID_HBP_TIME		0x004c
+#define VID_HBP_TIME(x)			UPDATE(x, 11,  0)
+#define DSI_VID_HLINE_TIME		0x0050
+#define VID_HLINE_TIME(x)		UPDATE(x, 14,  0)
+#define DSI_VID_VSA_LINES		0x0054
+#define VSA_LINES(x)			UPDATE(x,  9,  0)
+#define DSI_VID_VBP_LINES		0x0058
+#define VBP_LINES(x)			UPDATE(x,  9,  0)
+#define DSI_VID_VFP_LINES		0x005c
+#define VFP_LINES(x)			UPDATE(x,  9,  0)
+#define DSI_VID_VACTIVE_LINES		0x0060
+#define V_ACTIVE_LINES(x)		UPDATE(x, 13,  0)
+#define DSI_EDPI_CMD_SIZE		0x0064
+#define EDPI_ALLOWED_CMD_SIZE(x)	UPDATE(x, 15,  0)
+#define DSI_CMD_MODE_CFG		0x0068
+#define MAX_RD_PKT_SIZE			BIT(24)
+#define DCS_LW_TX			BIT(19)
+#define DCS_SR_0P_TX			BIT(18)
+#define DCS_SW_1P_TX			BIT(17)
+#define DCS_SW_0P_TX			BIT(16)
+#define GEN_LW_TX			BIT(14)
+#define GEN_SR_2P_TX			BIT(13)
+#define GEN_SR_1P_TX			BIT(12)
+#define GEN_SR_0P_TX			BIT(11)
+#define GEN_SW_2P_TX			BIT(10)
+#define GEN_SW_1P_TX			BIT(9)
+#define GEN_SW_0P_TX			BIT(8)
+#define ACK_RQST_EN			BIT(1)
+#define TEAR_FX_EN			BIT(0)
+#define DSI_GEN_HDR			0x006c
+#define GEN_WC_MSBYTE(x)		UPDATE(x, 23, 16)
+#define GEN_WC_LSBYTE(x)		UPDATE(x, 15,  8)
+#define GEN_VC(x)			UPDATE(x,  7,  6)
+#define GEN_DT(x)			UPDATE(x,  5,  0)
+#define DSI_GEN_PLD_DATA		0x0070
+#define DSI_CMD_PKT_STATUS		0x0074
+#define GEN_RD_CMD_BUSY			BIT(6)
+#define GEN_PLD_R_FULL			BIT(5)
+#define GEN_PLD_R_EMPTY			BIT(4)
+#define GEN_PLD_W_FULL			BIT(3)
+#define GEN_PLD_W_EMPTY			BIT(2)
+#define GEN_CMD_FULL			BIT(1)
+#define GEN_CMD_EMPTY			BIT(0)
+#define DSI_TO_CNT_CFG			0x0078
+#define HSTX_TO_CNT(x)			UPDATE(x, 31, 16)
+#define LPRX_TO_CNT(x)			UPDATE(x, 15,  0)
+#define DSI_HS_RD_TO_CNT		0x007c
+#define HS_RD_TO_CNT(x)			UPDATE(x, 15,  0)
+#define DSI_LP_RD_TO_CNT		0x0080
+#define LP_RD_TO_CNT(x)			UPDATE(x, 15,  0)
+#define DSI_HS_WR_TO_CNT		0x0084
+#define HS_WR_TO_CNT(x)			UPDATE(x, 15,  0)
+#define DSI_LP_WR_TO_CNT		0x0088
+#define LP_WR_TO_CNT(x)			UPDATE(x, 15,  0)
+#define DSI_BTA_TO_CNT			0x008c
+#define BTA_TO_CNT(x)			UPDATE(x, 15,  0)
+#define DSI_SDF_3D			0x0090
+#define DSI_LPCLK_CTRL			0x0094
+#define AUTO_CLKLANE_CTRL		BIT(1)
+#define PHY_TXREQUESTCLKHS		BIT(0)
+#define DSI_PHY_TMR_LPCLK_CFG		0x0098
+#define PHY_CLKHS2LP_TIME(x)		UPDATE(x, 25, 16)
+#define PHY_CLKLP2HS_TIME(x)		UPDATE(x,  9,  0)
+#define DSI_PHY_TMR_CFG			0x009c
+#define PHY_HS2LP_TIME(x)		UPDATE(x, 31, 24)
+#define PHY_LP2HS_TIME(x)		UPDATE(x, 23, 16)
+#define MAX_RD_TIME(x)			UPDATE(x, 14,  0)
+#define DSI_PHY_RSTZ			0x00a0
+#define PHY_FORCEPLL			BIT(3)
+#define PHY_ENABLECLK			BIT(2)
+#define PHY_RSTZ			BIT(1)
+#define PHY_SHUTDOWNZ			BIT(0)
+#define DSI_PHY_IF_CFG			0x00a4
+#define PHY_STOP_WAIT_TIME(x)		UPDATE(x, 15,  8)
+#define N_LANES(x)			UPDATE(x,  1,  0)
+#define DSI_PHY_STATUS			0x00b0
+#define PHY_STOPSTATE3LANE		BIT(11)
+#define PHY_STOPSTATE2LANE		BIT(9)
+#define PHY_STOPSTATE1LANE		BIT(7)
+#define PHY_STOPSTATE0LANE		BIT(4)
+#define PHY_STOPSTATECLKLANE		BIT(2)
+#define PHY_LOCK			BIT(0)
+#define PHY_STOPSTATELANE		(PHY_STOPSTATE0LANE | \
+					 PHY_STOPSTATECLKLANE)
+#define DSI_INT_ST0			0x00bc
+#define DSI_INT_ST1			0x00c0
+#define DSI_INT_MSK0			0x00c4
+#define DSI_INT_MSK1			0x00c8
+#define DSI_INT_FORCE0			0x00d8
+#define DSI_INT_FORCE1			0x00dc
+#define DSI_MAX_REGISTER		DSI_INT_FORCE1
+
+/* Test Code: 0x44 (HS RX Control of Lane 0) */
+#define HSFREQRANGE(x)			UPDATE(x, 6, 1)
+
+enum dpi_color_coding {
+	DPI_COLOR_CODING_16BIT_1,
+	DPI_COLOR_CODING_16BIT_2,
+	DPI_COLOR_CODING_16BIT_3,
+	DPI_COLOR_CODING_18BIT_1,
+	DPI_COLOR_CODING_18BIT_2,
+	DPI_COLOR_CODING_24BIT,
+};
+
+enum vid_mode_type {
+	VID_MODE_TYPE_NON_BURST_SYNC_PULSES,
+	VID_MODE_TYPE_NON_BURST_SYNC_EVENTS,
+	VID_MODE_TYPE_BURST,
+};
+
+enum operation_mode {
+	VIDEO_MODE,
+	COMMAND_MODE,
+};
+
+struct rk628_dsi_data {
+	u32 reg_base;
+	u8 id;
+};
+
+struct rk628_dsi {
+	struct drm_bridge base;
+	struct drm_connector connector;
+	struct drm_display_mode mode;
+	struct drm_panel *panel;
+
+	struct device *dev;
+	struct rk628 *parent;
+	struct mipi_dsi_host host;
+	struct phy *phy;
+	struct clk *pclk;
+	struct clk *cfgclk;
+	struct reset_control *rst;
+	struct regmap *grf;
+	struct regmap *regmap;
+	struct regmap *testif;
+	struct regmap_config config;
+	struct regmap_access_table rd_table;
+	struct regmap_range range;
+	int irq;
+	u32 reg_base;
+	u8 id;
+
+	struct rk628_dsi *master;
+	struct rk628_dsi *slave;
+	unsigned int lane_mbps;
+	u32 channel;
+	u32 lanes;
+	u32 format;
+	unsigned long mode_flags;
+};
+
+static inline struct rk628_dsi *bridge_to_dsi(struct drm_bridge *b)
+{
+	return container_of(b, struct rk628_dsi, base);
+}
+
+static inline struct rk628_dsi *host_to_dsi(struct mipi_dsi_host *h)
+{
+	return container_of(h, struct rk628_dsi, host);
+}
+
+static inline struct rk628_dsi *connector_to_dsi(struct drm_connector *c)
+{
+	return container_of(c, struct rk628_dsi, connector);
+}
+
+static inline void dsi_write(struct rk628_dsi *dsi, u32 reg, u32 val)
+{
+	regmap_write(dsi->regmap, dsi->reg_base + reg, val);
+}
+
+static inline u32 dsi_read(struct rk628_dsi *dsi, u32 reg)
+{
+	u32 val;
+
+	regmap_read(dsi->regmap, dsi->reg_base + reg, &val);
+
+	return val;
+}
+
+static inline void dsi_update_bits(struct rk628_dsi *dsi, u32 reg, u32 mask,
+				   u32 val)
+{
+	u32 orig, tmp;
+
+	orig = dsi_read(dsi, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	dsi_write(dsi, reg, tmp);
+}
+
+static inline void dpishutdn_assert(struct rk628_dsi *dsi)
+{
+	regmap_update_bits(dsi->grf, dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   DPISHUTDN, 1);
+}
+
+static inline void dpishutdn_deassert(struct rk628_dsi *dsi)
+{
+	regmap_update_bits(dsi->grf, dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   DPISHUTDN, 0);
+}
+
+static int genif_wait_w_pld_fifo_not_full(struct rk628_dsi *dsi)
+{
+	u32 sts;
+	int ret;
+
+	ret = regmap_read_poll_timeout(dsi->regmap,
+				       dsi->reg_base + DSI_CMD_PKT_STATUS,
+				       sts, !(sts & GEN_PLD_W_FULL),
+				       0, 1000);
+	if (ret < 0) {
+		dev_err(dsi->dev, "generic write payload fifo is full\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int genif_wait_cmd_fifo_not_full(struct rk628_dsi *dsi)
+{
+	u32 sts;
+	int ret;
+
+	ret = regmap_read_poll_timeout(dsi->regmap,
+				       dsi->reg_base + DSI_CMD_PKT_STATUS,
+				       sts, !(sts & GEN_CMD_FULL),
+				       0, 1000);
+	if (ret < 0) {
+		dev_err(dsi->dev, "generic write cmd fifo is full\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int genif_wait_write_fifo_empty(struct rk628_dsi *dsi)
+{
+	u32 sts;
+	u32 mask;
+	int ret;
+
+	mask = GEN_CMD_EMPTY | GEN_PLD_W_EMPTY;
+	ret = regmap_read_poll_timeout(dsi->regmap,
+				       dsi->reg_base + DSI_CMD_PKT_STATUS,
+				       sts, (sts & mask) == mask,
+				       0, 1000);
+	if (ret < 0) {
+		dev_err(dsi->dev, "generic write fifo is full\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline void testif_testclk_assert(struct rk628_dsi *dsi)
+{
+	regmap_update_bits(dsi->grf, dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   PHY_TESTCLK, PHY_TESTCLK);
+	udelay(1);
+}
+
+static inline void testif_testclk_deassert(struct rk628_dsi *dsi)
+{
+	regmap_update_bits(dsi->grf, dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   PHY_TESTCLK, 0);
+	udelay(1);
+}
+
+static inline void testif_testclr_assert(struct rk628_dsi *dsi)
+{
+	regmap_update_bits(dsi->grf, dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   PHY_TESTCLR, PHY_TESTCLR);
+	udelay(1);
+}
+
+static inline void testif_testclr_deassert(struct rk628_dsi *dsi)
+{
+	regmap_update_bits(dsi->grf, dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   PHY_TESTCLR, 0);
+	udelay(1);
+}
+
+static inline void testif_testen_assert(struct rk628_dsi *dsi)
+{
+	regmap_update_bits(dsi->grf, dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   PHY_TESTEN, PHY_TESTEN);
+	udelay(1);
+}
+
+static inline void testif_testen_deassert(struct rk628_dsi *dsi)
+{
+	regmap_update_bits(dsi->grf,  dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   PHY_TESTEN, 0);
+	udelay(1);
+}
+
+static inline void testif_set_data(struct rk628_dsi *dsi, u8 data)
+{
+	regmap_update_bits(dsi->grf, dsi->id ?
+			   GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+			   PHY_TESTDIN_MASK, PHY_TESTDIN(data));
+	udelay(1);
+}
+
+static inline u8 testif_get_data(struct rk628_dsi *dsi)
+{
+	u32 data = 0;
+
+	regmap_read(dsi->grf, dsi->id ?
+		    GRF_DPHY1_STATUS : GRF_DPHY0_STATUS, &data);
+
+	return data >> PHY_TESTDOUT_SHIFT;
+}
+
+static void testif_test_code_write(struct rk628_dsi *dsi, u8 test_code)
+{
+	testif_testclk_assert(dsi);
+	testif_set_data(dsi, test_code);
+	testif_testen_assert(dsi);
+	testif_testclk_deassert(dsi);
+	testif_testen_deassert(dsi);
+}
+
+static void testif_test_data_write(struct rk628_dsi *dsi, u8 test_data)
+{
+	testif_testclk_deassert(dsi);
+	testif_set_data(dsi, test_data);
+	testif_testclk_assert(dsi);
+}
+
+static int testif_write(void *context, unsigned int reg, unsigned int value)
+{
+	struct rk628_dsi *dsi = context;
+	u8 monitor_data;
+
+	testif_test_code_write(dsi, reg);
+	testif_test_data_write(dsi, value);
+	monitor_data = testif_get_data(dsi);
+
+	dev_dbg(dsi->dev,
+		"test_code=0x%02x, test_data=0x%02x, monitor_data=0x%02x\n",
+		reg, value, monitor_data);
+
+	return 0;
+}
+
+static int testif_read(void *context, unsigned int reg, unsigned int *value)
+{
+	struct rk628_dsi *dsi = context;
+
+	testif_test_code_write(dsi, reg);
+	*value = testif_get_data(dsi);
+	testif_test_data_write(dsi, *value);
+
+	return 0;
+}
+
+static inline void mipi_dphy_enableclk_assert(struct rk628_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_ENABLECLK, PHY_ENABLECLK);
+	udelay(1);
+}
+
+static inline void mipi_dphy_enableclk_deassert(struct rk628_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_ENABLECLK, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_shutdownz_assert(struct rk628_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_SHUTDOWNZ, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_shutdownz_deassert(struct rk628_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_SHUTDOWNZ, PHY_SHUTDOWNZ);
+	udelay(1);
+}
+
+static inline void mipi_dphy_rstz_assert(struct rk628_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_RSTZ, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_rstz_deassert(struct rk628_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_RSTZ, PHY_RSTZ);
+	udelay(1);
+}
+
+static void mipi_dphy_init(struct rk628_dsi *dsi)
+{
+	const struct {
+		unsigned long max_lane_mbps;
+		u8 hsfreqrange;
+	} hsfreqrange_table[] = {
+		{  90, 0x00}, { 100, 0x10}, { 110, 0x20}, { 130, 0x01},
+		{ 140, 0x11}, { 150, 0x21}, { 170, 0x02}, { 180, 0x12},
+		{ 200, 0x22}, { 220, 0x03}, { 240, 0x13}, { 250, 0x23},
+		{ 270, 0x04}, { 300, 0x14}, { 330, 0x05}, { 360, 0x15},
+		{ 400, 0x25}, { 450, 0x06}, { 500, 0x16}, { 550, 0x07},
+		{ 600, 0x17}, { 650, 0x08}, { 700, 0x18}, { 750, 0x09},
+		{ 800, 0x19}, { 850, 0x29}, { 900, 0x39}, { 950, 0x0a},
+		{1000, 0x1a}, {1050, 0x2a}, {1100, 0x3a}, {1150, 0x0b},
+		{1200, 0x1b}, {1250, 0x2b}, {1300, 0x3b}, {1350, 0x0c},
+		{1400, 0x1c}, {1450, 0x2c}, {1500, 0x3c}
+	};
+	u8 hsfreqrange;
+	unsigned int index;
+
+	for (index = 0; index < ARRAY_SIZE(hsfreqrange_table); index++)
+		if (dsi->lane_mbps <= hsfreqrange_table[index].max_lane_mbps)
+			break;
+
+	if (index == ARRAY_SIZE(hsfreqrange_table))
+		--index;
+
+	hsfreqrange = hsfreqrange_table[index].hsfreqrange;
+	regmap_write(dsi->testif, 0x44, HSFREQRANGE(hsfreqrange));
+}
+
+static int mipi_dphy_power_on(struct rk628_dsi *dsi)
+{
+	unsigned int val, mask;
+	int ret;
+
+	mipi_dphy_enableclk_deassert(dsi);
+	mipi_dphy_shutdownz_assert(dsi);
+	mipi_dphy_rstz_assert(dsi);
+	testif_testclr_assert(dsi);
+
+	/* Set all REQUEST inputs to zero */
+	regmap_write(dsi->grf, dsi->id ?
+		     GRF_MIPI_TX1_CON : GRF_MIPI_TX0_CON,
+		     FORCETXSTOPMODE(0) | FORCERXMODE(0));
+	udelay(1);
+
+	testif_testclr_deassert(dsi);
+	mipi_dphy_init(dsi);
+
+	mipi_dphy_enableclk_assert(dsi);
+	mipi_dphy_shutdownz_deassert(dsi);
+	mipi_dphy_rstz_deassert(dsi);
+	usleep_range(1500, 2000);
+
+	phy_power_on(dsi->phy);
+
+	ret = regmap_read_poll_timeout(dsi->regmap, dsi->reg_base + DSI_PHY_STATUS,
+				       val, val & PHY_LOCK, 0, 1000);
+	if (ret < 0) {
+		dev_err(dsi->dev, "PHY is not locked\n");
+		return ret;
+	}
+
+	usleep_range(100, 200);
+
+	mask = PHY_STOPSTATELANE;
+	ret = regmap_read_poll_timeout(dsi->regmap, dsi->reg_base + DSI_PHY_STATUS,
+				       val, (val & mask) == mask,
+				       0, 1000);
+	if (ret < 0) {
+		dev_err(dsi->dev, "lane module is not in stop state\n");
+		return ret;
+	}
+
+	udelay(10);
+
+	return 0;
+}
+
+static void mipi_dphy_power_off(struct rk628_dsi *dsi)
+{
+	dsi_write(dsi, DSI_PHY_RSTZ, 0);
+	phy_power_off(dsi->phy);
+}
+
+static int rk628_dsi_turn_on_peripheral(struct rk628_dsi *dsi)
+{
+	dpishutdn_assert(dsi);
+	udelay(20);
+	dpishutdn_deassert(dsi);
+
+	return 0;
+}
+
+static int rk628_dsi_shutdown_peripheral(struct rk628_dsi *dsi)
+{
+	dpishutdn_deassert(dsi);
+	udelay(20);
+	dpishutdn_assert(dsi);
+
+	return 0;
+}
+
+static int rk628_dsi_host_attach(struct mipi_dsi_host *host,
+				 struct mipi_dsi_device *device)
+{
+	struct rk628_dsi *dsi = host_to_dsi(host);
+
+	if (device->lanes < 1 || device->lanes > 8)
+		return -EINVAL;
+
+	dsi->lanes = device->lanes;
+	dsi->channel = device->channel;
+	dsi->format = device->format;
+	dsi->mode_flags = device->mode_flags;
+
+	dsi->panel = of_drm_find_panel(device->dev.of_node);
+	if (!dsi->panel)
+		return -EPROBE_DEFER;
+
+	if (dsi->lanes > 4) {
+		struct device *d = bus_find_device_by_name(&platform_bus_type,
+							   NULL, "rk628-dsi1");
+		struct rk628_dsi *slave;
+
+		if (!d)
+			return -EPROBE_DEFER;
+
+		slave = dev_get_drvdata(d);
+		if (!slave)
+			return -EPROBE_DEFER;
+
+		dsi->slave = slave;
+		dsi->lanes /= 2;
+		slave->master = dsi;
+		slave->lanes = dsi->lanes;
+		slave->channel = dsi->channel;
+		slave->format = dsi->format;
+		slave->mode_flags = dsi->mode_flags;
+	}
+
+	return 0;
+}
+
+static int rk628_dsi_host_detach(struct mipi_dsi_host *host,
+				 struct mipi_dsi_device *device)
+{
+	return 0;
+}
+
+static int rk628_dsi_read_from_fifo(struct rk628_dsi *dsi,
+				    const struct mipi_dsi_msg *msg)
+{
+	u8 *payload = msg->rx_buf;
+	unsigned int vrefresh = drm_mode_vrefresh(&dsi->mode);
+	u16 length;
+	u32 val;
+	int ret;
+
+	ret = regmap_read_poll_timeout(dsi->regmap,
+				       dsi->reg_base + DSI_CMD_PKT_STATUS,
+				       val, !(val & GEN_RD_CMD_BUSY),
+				       0, DIV_ROUND_UP(1000000, vrefresh));
+	if (ret) {
+		dev_err(dsi->dev, "entire response isn't stored in the FIFO\n");
+		return ret;
+	}
+
+	/* Receive payload */
+	for (length = msg->rx_len; length; length -= 4) {
+		ret = regmap_read_poll_timeout(dsi->regmap,
+					       dsi->reg_base + DSI_CMD_PKT_STATUS,
+					       val, !(val & GEN_PLD_R_EMPTY),
+					       0, 1000);
+		if (ret) {
+			dev_err(dsi->dev, "Read payload FIFO is empty\n");
+			return ret;
+		}
+
+		val = dsi_read(dsi, DSI_GEN_PLD_DATA);
+
+		switch (length) {
+		case 3:
+			payload[2] = (val >> 16) & 0xff;
+			/* fallthrough */
+		case 2:
+			payload[1] = (val >> 8) & 0xff;
+			/* fallthrough */
+		case 1:
+			payload[0] = val & 0xff;
+			return 0;
+		}
+
+		payload[0] = (val >>  0) & 0xff;
+		payload[1] = (val >>  8) & 0xff;
+		payload[2] = (val >> 16) & 0xff;
+		payload[3] = (val >> 24) & 0xff;
+		payload += 4;
+	}
+
+	return 0;
+}
+
+static ssize_t rk628_dsi_transfer(struct rk628_dsi *dsi,
+				  const struct mipi_dsi_msg *msg)
+{
+	struct mipi_dsi_packet packet;
+	int ret;
+	u32 val;
+
+	if (msg->flags & MIPI_DSI_MSG_REQ_ACK)
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG,
+				ACK_RQST_EN, ACK_RQST_EN);
+
+	if (msg->flags & MIPI_DSI_MSG_USE_LPM) {
+		dsi_update_bits(dsi, DSI_VID_MODE_CFG, LP_CMD_EN, LP_CMD_EN);
+	} else {
+		dsi_update_bits(dsi, DSI_VID_MODE_CFG, LP_CMD_EN, 0);
+		dsi_update_bits(dsi, DSI_LPCLK_CTRL,
+				PHY_TXREQUESTCLKHS, PHY_TXREQUESTCLKHS);
+	}
+
+	switch (msg->type) {
+	case MIPI_DSI_SHUTDOWN_PERIPHERAL:
+		return rk628_dsi_shutdown_peripheral(dsi);
+	case MIPI_DSI_TURN_ON_PERIPHERAL:
+		return rk628_dsi_turn_on_peripheral(dsi);
+	case MIPI_DSI_DCS_SHORT_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SW_0P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				DCS_SW_0P_TX : 0);
+		break;
+	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SW_1P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				DCS_SW_1P_TX : 0);
+		break;
+	case MIPI_DSI_DCS_LONG_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_LW_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				DCS_LW_TX : 0);
+		break;
+	case MIPI_DSI_DCS_READ:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SR_0P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				DCS_SR_0P_TX : 0);
+		break;
+	case MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, MAX_RD_PKT_SIZE,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				MAX_RD_PKT_SIZE : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_0P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SW_0P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_1P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SW_1P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_2P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SW_2P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_LONG_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_LW_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_LW_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_0P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SR_0P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_1P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SR_1P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_2P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SR_2P_TX : 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* create a packet to the DSI protocol */
+	ret = mipi_dsi_create_packet(&packet, msg);
+	if (ret) {
+		dev_err(dsi->dev, "failed to create packet: %d\n", ret);
+		return ret;
+	}
+
+	/* Send payload */
+	while (packet.payload_length >= 4) {
+		/*
+		 * Alternatively, you can always keep the FIFO
+		 * nearly full by monitoring the FIFO state until
+		 * it is not full, and then writea single word of data.
+		 * This solution is more resource consuming
+		 * but it simultaneously avoids FIFO starvation,
+		 * making it possible to use FIFO sizes smaller than
+		 * the amount of data of the longest packet to be written.
+		 */
+		ret = genif_wait_w_pld_fifo_not_full(dsi);
+		if (ret)
+			return ret;
+
+		val = get_unaligned_le32(packet.payload);
+		dsi_write(dsi, DSI_GEN_PLD_DATA, val);
+
+		packet.payload += 4;
+		packet.payload_length -= 4;
+	}
+
+	val = 0;
+	switch (packet.payload_length) {
+	case 3:
+		val |= packet.payload[2] << 16;
+		/* fallthrough */
+	case 2:
+		val |= packet.payload[1] << 8;
+		/* fallthrough */
+	case 1:
+		val |= packet.payload[0];
+		dsi_write(dsi, DSI_GEN_PLD_DATA, val);
+		break;
+	}
+
+	ret = genif_wait_cmd_fifo_not_full(dsi);
+	if (ret)
+		return ret;
+
+	/* Send packet header */
+	val = get_unaligned_le32(packet.header);
+	dsi_write(dsi, DSI_GEN_HDR, val);
+
+	ret = genif_wait_write_fifo_empty(dsi);
+	if (ret)
+		return ret;
+
+	if (msg->rx_len) {
+		ret = rk628_dsi_read_from_fifo(dsi, msg);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (dsi->slave)
+		rk628_dsi_transfer(dsi->slave, msg);
+
+	return msg->tx_len;
+}
+
+static ssize_t rk628_dsi_host_transfer(struct mipi_dsi_host *host,
+				       const struct mipi_dsi_msg *msg)
+{
+	struct rk628_dsi *dsi = host_to_dsi(host);
+
+	return rk628_dsi_transfer(dsi, msg);
+}
+
+static const struct mipi_dsi_host_ops rk628_dsi_host_ops = {
+	.attach = rk628_dsi_host_attach,
+	.detach = rk628_dsi_host_detach,
+	.transfer = rk628_dsi_host_transfer,
+};
+
+static struct drm_encoder *
+rk628_dsi_connector_best_encoder(struct drm_connector *connector)
+{
+	struct rk628_dsi *dsi = connector_to_dsi(connector);
+
+	return dsi->base.encoder;
+}
+
+static int rk628_dsi_connector_get_modes(struct drm_connector *connector)
+{
+	struct rk628_dsi *dsi = connector_to_dsi(connector);
+
+	return drm_panel_get_modes(dsi->panel);
+}
+
+static struct drm_connector_helper_funcs rk628_dsi_connector_helper_funcs = {
+	.get_modes = rk628_dsi_connector_get_modes,
+	.best_encoder = rk628_dsi_connector_best_encoder,
+};
+
+static void rk628_dsi_drm_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
+static const struct drm_connector_funcs rk628_dsi_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = rk628_dsi_drm_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static void rk628_dsi_set_vid_mode(struct rk628_dsi *dsi)
+{
+	struct drm_display_mode *mode = &dsi->mode;
+	unsigned int lanebyteclk = (dsi->lane_mbps * USEC_PER_MSEC) >> 3;
+	unsigned int dpipclk = mode->clock;
+	u32 hline, hsa, hbp, hline_time, hsa_time, hbp_time;
+	u32 vactive, vsa, vfp, vbp;
+	u32 val;
+
+	val = LP_HFP_EN | LP_HBP_EN | LP_VACT_EN | LP_VFP_EN | LP_VBP_EN |
+	      LP_VSA_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HFP)
+		val &= ~LP_HFP_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HBP)
+		val &= ~LP_HBP_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		val |= VID_MODE_TYPE_BURST;
+	else if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)
+		val |= VID_MODE_TYPE_NON_BURST_SYNC_PULSES;
+	else
+		val |= VID_MODE_TYPE_NON_BURST_SYNC_EVENTS;
+
+	dsi_write(dsi, DSI_VID_MODE_CFG, val);
+
+	if (dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)
+		dsi_update_bits(dsi, DSI_LPCLK_CTRL,
+				AUTO_CLKLANE_CTRL, AUTO_CLKLANE_CTRL);
+
+	dsi_write(dsi, DSI_VID_PKT_SIZE, VID_PKT_SIZE(mode->hdisplay));
+
+	vactive = mode->vdisplay;
+	vsa = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+	hsa = mode->hsync_end - mode->hsync_start;
+	hbp = mode->htotal - mode->hsync_end;
+	hline = mode->htotal;
+
+	hline_time = DIV_ROUND_CLOSEST_ULL(hline * lanebyteclk, dpipclk);
+	dsi_write(dsi, DSI_VID_HLINE_TIME, VID_HLINE_TIME(hline_time));
+	hsa_time = DIV_ROUND_CLOSEST_ULL(hsa * lanebyteclk, dpipclk);
+	dsi_write(dsi, DSI_VID_HSA_TIME, VID_HSA_TIME(hsa_time));
+	hbp_time = DIV_ROUND_CLOSEST_ULL(hbp * lanebyteclk, dpipclk);
+	dsi_write(dsi, DSI_VID_HBP_TIME, VID_HBP_TIME(hbp_time));
+
+	dsi_write(dsi, DSI_VID_VACTIVE_LINES, vactive);
+	dsi_write(dsi, DSI_VID_VSA_LINES, vsa);
+	dsi_write(dsi, DSI_VID_VFP_LINES, vfp);
+	dsi_write(dsi, DSI_VID_VBP_LINES, vbp);
+
+	dsi_write(dsi, DSI_MODE_CFG, CMD_VIDEO_MODE(VIDEO_MODE));
+}
+
+static void rk628_dsi_set_cmd_mode(struct rk628_dsi *dsi)
+{
+	struct drm_display_mode *mode = &dsi->mode;
+
+	dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_LW_TX, 0);
+	dsi_write(dsi, DSI_EDPI_CMD_SIZE,
+		  EDPI_ALLOWED_CMD_SIZE(mode->hdisplay));
+	dsi_write(dsi, DSI_MODE_CFG, CMD_VIDEO_MODE(COMMAND_MODE));
+}
+
+static void rk628_dsi_disable(struct rk628_dsi *dsi)
+{
+	dsi_write(dsi, DSI_PWR_UP, RESET);
+	dsi_write(dsi, DSI_LPCLK_CTRL, 0);
+	dsi_write(dsi, DSI_EDPI_CMD_SIZE, 0);
+	dsi_write(dsi, DSI_MODE_CFG, CMD_VIDEO_MODE(COMMAND_MODE));
+	dsi_write(dsi, DSI_PWR_UP, POWER_UP);
+
+	if (dsi->slave)
+		rk628_dsi_disable(dsi->slave);
+}
+
+static void rk628_dsi_post_disable(struct rk628_dsi *dsi)
+{
+	dsi_write(dsi, DSI_INT_MSK0, 0);
+	dsi_write(dsi, DSI_INT_MSK1, 0);
+	dsi_write(dsi, DSI_PWR_UP, RESET);
+	mipi_dphy_power_off(dsi);
+
+	clk_disable_unprepare(dsi->cfgclk);
+	clk_disable_unprepare(dsi->pclk);
+
+	if (dsi->slave)
+		rk628_dsi_post_disable(dsi->slave);
+}
+
+static unsigned int rk628_dsi_get_lane_rate(struct rk628_dsi *dsi)
+{
+	struct device *dev = dsi->dev;
+	const struct drm_display_mode *mode = &dsi->mode;
+	unsigned int max_lane_rate = 1500;
+	unsigned int lane_rate;
+	unsigned int value;
+	int bpp, lanes;
+
+	/* optional override of the desired bandwidth */
+	if (!of_property_read_u32(dev->of_node, "rockchip,lane-rate", &value))
+		return value;
+
+	bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+	if (bpp < 0)
+		bpp = 24;
+
+	lanes = dsi->slave ? dsi->lanes * 2 : dsi->lanes;
+	lane_rate = mode->clock / 1000 * bpp / lanes;
+	lane_rate = DIV_ROUND_UP(lane_rate * 5, 4);
+
+	if (lane_rate > max_lane_rate)
+		lane_rate = max_lane_rate;
+
+	return lane_rate;
+}
+
+static void rk628_dsi_pre_enable(struct rk628_dsi *dsi)
+{
+	u32 val;
+
+	clk_prepare_enable(dsi->pclk);
+	clk_prepare_enable(dsi->cfgclk);
+	reset_control_assert(dsi->rst);
+	usleep_range(20, 40);
+	reset_control_deassert(dsi->rst);
+	usleep_range(20, 40);
+
+	dsi_write(dsi, DSI_PWR_UP, RESET);
+	dsi_write(dsi, DSI_MODE_CFG, CMD_VIDEO_MODE(COMMAND_MODE));
+
+	val = DIV_ROUND_UP(dsi->lane_mbps >> 3, 20);
+	dsi_write(dsi, DSI_CLKMGR_CFG,
+		  TO_CLK_DIVISION(10) | TX_ESC_CLK_DIVISION(val));
+
+	val = CRC_RX_EN | ECC_RX_EN | BTA_EN | EOTP_TX_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_EOT_PACKET)
+		val &= ~EOTP_TX_EN;
+
+	dsi_write(dsi, DSI_PCKHDL_CFG, val);
+
+	dsi_write(dsi, DSI_TO_CNT_CFG, HSTX_TO_CNT(1000) | LPRX_TO_CNT(1000));
+	dsi_write(dsi, DSI_BTA_TO_CNT, 0xd00);
+	dsi_write(dsi, DSI_PHY_TMR_CFG,
+		  PHY_HS2LP_TIME(0x14) | PHY_LP2HS_TIME(0x10) |
+		  MAX_RD_TIME(10000));
+	dsi_write(dsi, DSI_PHY_TMR_LPCLK_CFG,
+		  PHY_CLKHS2LP_TIME(0x40) | PHY_CLKLP2HS_TIME(0x40));
+	dsi_write(dsi, DSI_PHY_IF_CFG,
+		  PHY_STOP_WAIT_TIME(0x20) | N_LANES(dsi->lanes - 1));
+
+	mipi_dphy_power_on(dsi);
+
+	dsi_write(dsi, DSI_PWR_UP, POWER_UP);
+
+	dsi_write(dsi, DSI_INT_MSK0, 0x1fffff);
+	dsi_write(dsi, DSI_INT_MSK1, 0x1f7f);
+
+	if (dsi->slave)
+		rk628_dsi_pre_enable(dsi->slave);
+}
+
+static void rk628_dsi_enable(struct rk628_dsi *dsi)
+{
+	struct drm_display_mode *mode = &dsi->mode;
+	u32 val;
+
+	dsi_write(dsi, DSI_PWR_UP, RESET);
+
+	switch (dsi->format) {
+	case MIPI_DSI_FMT_RGB666:
+		val = DPI_COLOR_CODING(DPI_COLOR_CODING_18BIT_2) | LOOSELY18_EN;
+		break;
+	case MIPI_DSI_FMT_RGB666_PACKED:
+		val = DPI_COLOR_CODING(DPI_COLOR_CODING_18BIT_1);
+		break;
+	case MIPI_DSI_FMT_RGB565:
+		val = DPI_COLOR_CODING(DPI_COLOR_CODING_16BIT_1);
+		break;
+	case MIPI_DSI_FMT_RGB888:
+	default:
+		val = DPI_COLOR_CODING(DPI_COLOR_CODING_24BIT);
+		break;
+	}
+
+	dsi_write(dsi, DSI_DPI_COLOR_CODING, val);
+
+	val = 0;
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		val |= VSYNC_ACTIVE_LOW;
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		val |= HSYNC_ACTIVE_LOW;
+	dsi_write(dsi, DSI_DPI_CFG_POL, val);
+
+	dsi_write(dsi, DSI_DPI_VCID, DPI_VID(dsi->channel));
+	dsi_write(dsi, DSI_DPI_LP_CMD_TIM,
+		  OUTVACT_LPCMD_TIME(4) | INVACT_LPCMD_TIME(4));
+
+	dsi_update_bits(dsi, DSI_LPCLK_CTRL,
+			PHY_TXREQUESTCLKHS, PHY_TXREQUESTCLKHS);
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO)
+		rk628_dsi_set_vid_mode(dsi);
+	else
+		rk628_dsi_set_cmd_mode(dsi);
+
+	dsi_write(dsi, DSI_PWR_UP, POWER_UP);
+
+	if (dsi->slave)
+		rk628_dsi_enable(dsi->slave);
+}
+
+static void rk628_dsi_bridge_enable(struct drm_bridge *bridge)
+{
+	struct rk628_dsi *dsi = bridge_to_dsi(bridge);
+	unsigned int rate = rk628_dsi_get_lane_rate(dsi);
+	int bus_width;
+	int ret;
+
+	regmap_update_bits(dsi->grf, GRF_SYSTEM_CON0, SW_OUTPUT_MODE_MASK,
+			   SW_OUTPUT_MODE(OUTPUT_MODE_DSI));
+	regmap_update_bits(dsi->grf, GRF_POST_PROC_CON, SW_SPLIT_EN,
+			   dsi->slave ? SW_SPLIT_EN : 0);
+
+	bus_width = rate << 8;
+	if (dsi->slave)
+		bus_width |= COMBTXPHY_MODULEA_EN | COMBTXPHY_MODULEB_EN;
+	else if (dsi->id)
+		bus_width |= COMBTXPHY_MODULEB_EN;
+	else
+		bus_width |= COMBTXPHY_MODULEA_EN;
+	phy_set_bus_width(dsi->phy, bus_width);
+
+	ret = phy_set_mode(dsi->phy, PHY_MODE_VIDEO_MIPI);
+	if (ret) {
+		dev_err(dsi->dev, "failed to set phy mode: %d\n", ret);
+		return;
+	}
+	dsi->lane_mbps = phy_get_bus_width(dsi->phy);
+	if (dsi->slave)
+		dsi->slave->lane_mbps = dsi->lane_mbps;
+
+	rk628_dsi_pre_enable(dsi);
+	drm_panel_prepare(dsi->panel);
+	rk628_dsi_enable(dsi);
+	drm_panel_enable(dsi->panel);
+
+	dev_info(dsi->dev, "final DSI-Link bandwidth: %u x %d Mbps\n",
+		 dsi->lane_mbps, dsi->slave ? dsi->lanes * 2 : dsi->lanes);
+}
+
+static void rk628_dsi_bridge_disable(struct drm_bridge *bridge)
+{
+	struct rk628_dsi *dsi = bridge_to_dsi(bridge);
+
+	drm_panel_disable(dsi->panel);
+	rk628_dsi_disable(dsi);
+	drm_panel_unprepare(dsi->panel);
+	rk628_dsi_post_disable(dsi);
+}
+
+static void rk628_dsi_bridge_mode_set(struct drm_bridge *bridge,
+				      struct drm_display_mode *mode,
+				      struct drm_display_mode *adj)
+{
+	struct rk628_dsi *dsi = bridge_to_dsi(bridge);
+
+	drm_mode_copy(&dsi->mode, adj);
+	if (dsi->slave) {
+		dsi->mode.hdisplay /= 2;
+		drm_mode_copy(&dsi->slave->mode, &dsi->mode);
+	}
+}
+
+static int rk628_dsi_bridge_attach(struct drm_bridge *bridge)
+{
+	struct rk628_dsi *dsi = bridge_to_dsi(bridge);
+	struct drm_connector *connector = &dsi->connector;
+	struct drm_device *drm = bridge->dev;
+	int ret;
+
+	if (!dsi->panel)
+		return -EPROBE_DEFER;
+
+	ret = drm_connector_init(drm, connector, &rk628_dsi_connector_funcs,
+				 DRM_MODE_CONNECTOR_DSI);
+	if (ret) {
+		dev_err(dsi->dev, "Failed to initialize connector with drm\n");
+		return ret;
+	}
+
+	drm_connector_helper_add(connector, &rk628_dsi_connector_helper_funcs);
+	drm_connector_attach_encoder(connector, bridge->encoder);
+
+	ret = drm_panel_attach(dsi->panel, connector);
+	if (ret) {
+		dev_err(dsi->dev, "Failed to attach panel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct drm_bridge_funcs rk628_dsi_bridge_funcs = {
+	.attach = rk628_dsi_bridge_attach,
+	.mode_set = rk628_dsi_bridge_mode_set,
+	.enable = rk628_dsi_bridge_enable,
+	.disable = rk628_dsi_bridge_disable,
+};
+
+static irqreturn_t rk628_dsi_irq_handler(int irq, void *dev_id)
+{
+	struct rk628_dsi *dsi = dev_id;
+	u32 int_st0, int_st1;
+
+	int_st0 = dsi_read(dsi, DSI_INT_ST0);
+	int_st1 = dsi_read(dsi, DSI_INT_ST1);
+
+	if (!int_st0 && !int_st1)
+		return IRQ_NONE;
+
+	dev_info(dsi->dev, "int_st0=0x%08x, int_st1=0x%08x\n",
+		 int_st0, int_st1);
+
+	return IRQ_HANDLED;
+}
+
+static const struct regmap_config testif_regmap_config = {
+	.name = "phy",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0x97,
+	.cache_type = REGCACHE_RBTREE,
+	.reg_write = testif_write,
+	.reg_read = testif_read,
+};
+
+static bool rk628_dsi_register_volatile(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case DSI_GEN_HDR:
+	case DSI_GEN_PLD_DATA:
+	case DSI_CMD_PKT_STATUS:
+	case DSI_PHY_STATUS:
+	case DSI_INT_ST0:
+	case DSI_INT_ST1:
+	case DSI_INT_FORCE0:
+	case DSI_INT_FORCE1:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int rk628_dsi_probe(struct platform_device *pdev)
+{
+	struct rk628 *rk628 = dev_get_drvdata(pdev->dev.parent);
+	struct device *dev = &pdev->dev;
+	struct rk628_dsi *dsi;
+	const struct rk628_dsi_data *data = of_device_get_match_data(dev);
+	char name[8];
+	int ret;
+
+	if (!of_device_is_available(dev->of_node))
+		return -ENODEV;
+
+	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
+	if (!dsi)
+		return -ENOMEM;
+
+	dsi->dev = dev;
+	dsi->parent = rk628;
+	dsi->grf = rk628->grf;
+	dsi->reg_base = data->reg_base;
+	dsi->id = data->id;
+	platform_set_drvdata(pdev, dsi);
+
+	dsi->irq = platform_get_irq(pdev, 0);
+	if (dsi->irq < 0)
+		return dsi->irq;
+
+	dsi->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(dsi->pclk)) {
+		ret = PTR_ERR(dsi->pclk);
+		dev_err(dev, "failed to get pclk: %d\n", ret);
+		return ret;
+	}
+
+	dsi->cfgclk = devm_clk_get(dev, "cfg");
+	if (IS_ERR(dsi->cfgclk)) {
+		ret = PTR_ERR(dsi->cfgclk);
+		dev_err(dev, "failed to get cfg clk: %d\n", ret);
+		return ret;
+	}
+
+	dsi->rst = of_reset_control_get(dev->of_node, NULL);
+	if (IS_ERR(dsi->rst)) {
+		ret = PTR_ERR(dsi->rst);
+		dev_err(dev, "failed to get reset control: %d\n", ret);
+		return ret;
+	}
+
+	dsi->phy = devm_of_phy_get(dev, dev->of_node, NULL);
+	if (IS_ERR(dsi->phy)) {
+		ret = PTR_ERR(dsi->phy);
+		dev_err(dev, "failed to get phy: %d\n", ret);
+		return ret;
+	}
+
+	sprintf(name, "dsi%d", dsi->id);
+	dsi->config.name = name;
+	dsi->config.reg_bits = 32;
+	dsi->config.val_bits = 32;
+	dsi->config.reg_stride = 4;
+	dsi->config.cache_type = REGCACHE_RBTREE;
+	dsi->config.max_register = dsi->reg_base + DSI_MAX_REGISTER;
+	dsi->config.reg_format_endian = REGMAP_ENDIAN_LITTLE;
+	dsi->config.val_format_endian = REGMAP_ENDIAN_LITTLE;
+	dsi->config.volatile_reg = rk628_dsi_register_volatile;
+	dsi->range.range_min = dsi->reg_base + DSI_VERSION;
+	dsi->range.range_max = dsi->reg_base + DSI_MAX_REGISTER;
+	dsi->rd_table.yes_ranges = &dsi->range;
+	dsi->rd_table.n_yes_ranges = 1;
+	dsi->config.rd_table = &dsi->rd_table;
+
+	dsi->regmap = devm_regmap_init_i2c(rk628->client, &dsi->config);
+	if (IS_ERR(dsi->regmap)) {
+		ret = PTR_ERR(dsi->regmap);
+		dev_err(dev, "failed to allocate register map: %d\n", ret);
+		return ret;
+	}
+
+	dsi->testif = devm_regmap_init(dev, NULL, dsi, &testif_regmap_config);
+	if (IS_ERR(dsi->testif)) {
+		ret = PTR_ERR(dsi->testif);
+		dev_err(dev, "failed to create testif regmap: %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_request_threaded_irq(dev, dsi->irq, NULL,
+					rk628_dsi_irq_handler, IRQF_ONESHOT,
+					dev_name(dev), dsi);
+	if (ret) {
+		dev_err(dev, "failed to request irq: %d\n", ret);
+		return ret;
+	}
+
+	dsi->base.funcs = &rk628_dsi_bridge_funcs;
+	dsi->base.of_node = dev->of_node;
+	drm_bridge_add(&dsi->base);
+
+	dsi->host.ops = &rk628_dsi_host_ops;
+	dsi->host.dev = dev;
+	ret = mipi_dsi_host_register(&dsi->host);
+	if (ret) {
+		drm_bridge_remove(&dsi->base);
+		dev_err(dev, "Failed to register MIPI host: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rk628_dsi_remove(struct platform_device *pdev)
+{
+	struct rk628_dsi *dsi = platform_get_drvdata(pdev);
+
+	mipi_dsi_host_unregister(&dsi->host);
+	drm_bridge_remove(&dsi->base);
+
+	return 0;
+}
+
+static const struct rk628_dsi_data rk628_dsi0_data = {
+	.reg_base = 0x50000,
+	.id = 0,
+};
+
+static const struct rk628_dsi_data rk628_dsi1_data = {
+	.reg_base = 0x60000,
+	.id = 1,
+};
+
+static const struct of_device_id rk628_dsi_of_match[] = {
+	{ .compatible = "rockchip,rk628-dsi0", .data = &rk628_dsi0_data },
+	{ .compatible = "rockchip,rk628-dsi1", .data = &rk628_dsi1_data },
+	{}
+};
+MODULE_DEVICE_TABLE(of, rk628_dsi_of_match);
+
+static struct platform_driver rk628_dsi_driver = {
+	.driver = {
+		.name = "rk628-dsi",
+		.of_match_table = of_match_ptr(rk628_dsi_of_match),
+	},
+	.probe	= rk628_dsi_probe,
+	.remove = rk628_dsi_remove,
+};
+module_platform_driver(rk628_dsi_driver);
+
+MODULE_AUTHOR("Wyon Bi <bivvy.bi@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip RK628 MIPI-DSI driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/rockchip/rk628/rk628_lvds.c b/drivers/gpu/drm/rockchip/rk628/rk628_lvds.c
new file mode 100644
index 000000000000..b0b6dcedd00b
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk628/rk628_lvds.c
@@ -0,0 +1,327 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
+ *
+ * Author: Wyon Bi <bivvy.bi@rock-chips.com>
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/mfd/rk628.h>
+#include <linux/phy/phy.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_of.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_panel.h>
+
+#include <video/of_display_timing.h>
+#include <video/videomode.h>
+
+enum lvds_format {
+	LVDS_FORMAT_VESA_24BIT,
+	LVDS_FORMAT_JEIDA_24BIT,
+	LVDS_FORMAT_JEIDA_18BIT,
+	LVDS_FORMAT_VESA_18BIT,
+};
+
+enum lvds_link_type {
+	LVDS_SINGLE_LINK,
+	LVDS_DUAL_LINK_ODD_EVEN_PIXELS,
+	LVDS_DUAL_LINK_EVEN_ODD_PIXELS,
+	LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS,
+	LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS,
+};
+
+struct rk628_lvds {
+	struct drm_bridge base;
+	struct drm_connector connector;
+	struct drm_panel *panel;
+	struct drm_display_mode mode;
+	struct device *dev;
+	struct regmap *grf;
+	struct phy *phy;
+	struct rk628 *parent;
+	enum lvds_format format;
+	enum lvds_link_type link_type;
+};
+
+static inline struct rk628_lvds *bridge_to_lvds(struct drm_bridge *b)
+{
+	return container_of(b, struct rk628_lvds, base);
+}
+
+static inline struct rk628_lvds *connector_to_lvds(struct drm_connector *c)
+{
+	return container_of(c, struct rk628_lvds, connector);
+}
+
+static enum lvds_format rk628_lvds_get_format(u32 bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB666_1X7X3_JEIDA:
+		return LVDS_FORMAT_JEIDA_18BIT;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:
+		return LVDS_FORMAT_JEIDA_24BIT;
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:
+		return LVDS_FORMAT_VESA_18BIT;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:
+	default:
+		return LVDS_FORMAT_VESA_24BIT;
+	}
+}
+
+static enum lvds_link_type rk628_lvds_get_link_type(struct rk628_lvds *lvds)
+{
+	struct device *dev = lvds->dev;
+	const char *str;
+	int ret;
+
+	ret = of_property_read_string(dev->of_node, "rockchip,link-type", &str);
+	if (ret < 0)
+		return LVDS_SINGLE_LINK;
+
+	if (!strcmp(str, "dual-link-odd-even-pixels"))
+		return LVDS_DUAL_LINK_ODD_EVEN_PIXELS;
+	else if (!strcmp(str, "dual-link-even-odd-pixels"))
+		return LVDS_DUAL_LINK_EVEN_ODD_PIXELS;
+	else if (!strcmp(str, "dual-link-left-right-pixels"))
+		return LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS;
+	else if (!strcmp(str, "dual-link-right-left-pixels"))
+		return LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS;
+	else
+		return LVDS_SINGLE_LINK;
+}
+
+static struct drm_encoder *
+rk628_lvds_connector_best_encoder(struct drm_connector *connector)
+{
+	struct rk628_lvds *lvds = connector_to_lvds(connector);
+
+	return lvds->base.encoder;
+}
+
+static int rk628_lvds_connector_get_modes(struct drm_connector *connector)
+{
+	struct rk628_lvds *lvds = connector_to_lvds(connector);
+	struct drm_display_info *info = &connector->display_info;
+	int num_modes = 0;
+
+	num_modes = drm_panel_get_modes(lvds->panel);
+
+	if (info->num_bus_formats)
+		lvds->format = rk628_lvds_get_format(info->bus_formats[0]);
+	else
+		lvds->format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG;
+
+	return num_modes;
+}
+
+static const struct drm_connector_helper_funcs
+rk628_lvds_connector_helper_funcs = {
+	.get_modes = rk628_lvds_connector_get_modes,
+	.best_encoder = rk628_lvds_connector_best_encoder,
+};
+
+static void rk628_lvds_connector_destroy(struct drm_connector *connector)
+{
+	struct rk628_lvds *lvds = connector_to_lvds(connector);
+
+	drm_panel_detach(lvds->panel);
+	drm_connector_cleanup(connector);
+}
+
+static const struct drm_connector_funcs rk628_lvds_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = rk628_lvds_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static void rk628_lvds_bridge_enable(struct drm_bridge *bridge)
+{
+	struct rk628_lvds *lvds = bridge_to_lvds(bridge);
+	const struct drm_display_mode *mode = &lvds->mode;
+	u32 val, bus_width;
+	int ret;
+
+	regmap_update_bits(lvds->grf, GRF_SYSTEM_CON0, SW_OUTPUT_MODE_MASK,
+			   SW_OUTPUT_MODE(OUTPUT_MODE_LVDS));
+
+	switch (lvds->link_type) {
+	case LVDS_DUAL_LINK_ODD_EVEN_PIXELS:
+		val = SW_LVDS_CON_CHASEL(1) | SW_LVDS_CON_STARTSEL(0) |
+		      SW_LVDS_CON_DUAL_SEL(0);
+		bus_width = COMBTXPHY_MODULEA_EN | COMBTXPHY_MODULEB_EN;
+		break;
+	case LVDS_DUAL_LINK_EVEN_ODD_PIXELS:
+		val = SW_LVDS_CON_CHASEL(1) | SW_LVDS_CON_STARTSEL(1) |
+		      SW_LVDS_CON_DUAL_SEL(0);
+		bus_width = COMBTXPHY_MODULEA_EN | COMBTXPHY_MODULEB_EN;
+		break;
+	case LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS:
+		val = SW_LVDS_CON_CHASEL(1) | SW_LVDS_CON_STARTSEL(0) |
+		      SW_LVDS_CON_DUAL_SEL(1);
+		regmap_update_bits(lvds->grf, GRF_POST_PROC_CON,
+				   SW_SPLIT_EN, SW_SPLIT_EN);
+		bus_width = COMBTXPHY_MODULEA_EN | COMBTXPHY_MODULEB_EN;
+		break;
+	case LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS:
+		val = SW_LVDS_CON_CHASEL(1) | SW_LVDS_CON_STARTSEL(1) |
+		      SW_LVDS_CON_DUAL_SEL(1);
+		regmap_update_bits(lvds->grf, GRF_POST_PROC_CON,
+				   SW_SPLIT_EN, SW_SPLIT_EN);
+		bus_width = COMBTXPHY_MODULEA_EN | COMBTXPHY_MODULEB_EN;
+		break;
+	case LVDS_SINGLE_LINK:
+	default:
+		val = SW_LVDS_CON_CHASEL(0) | SW_LVDS_CON_STARTSEL(0) |
+		      SW_LVDS_CON_DUAL_SEL(0);
+		bus_width = COMBTXPHY_MODULEA_EN;
+		break;
+	}
+
+	val |= SW_LVDS_CON_SELECT(lvds->format) |
+	       SW_LVDS_CON_MSBSEL(0) |
+	       SW_LVDS_CON_CLKINV(0);
+	regmap_write(lvds->grf, GRF_LVDS_TX_CON, val);
+
+	bus_width |= (mode->clock / 1000) << 8;
+	phy_set_bus_width(lvds->phy, bus_width);
+
+	ret = phy_set_mode(lvds->phy, PHY_MODE_VIDEO_LVDS);
+	if (ret) {
+		dev_err(lvds->dev, "failed to set phy mode: %d\n", ret);
+		return;
+	}
+
+	phy_power_on(lvds->phy);
+
+	drm_panel_prepare(lvds->panel);
+	drm_panel_enable(lvds->panel);
+}
+
+static void rk628_lvds_bridge_disable(struct drm_bridge *bridge)
+{
+	struct rk628_lvds *lvds = bridge_to_lvds(bridge);
+
+	drm_panel_disable(lvds->panel);
+	drm_panel_unprepare(lvds->panel);
+	phy_power_off(lvds->phy);
+}
+
+static int rk628_lvds_bridge_attach(struct drm_bridge *bridge)
+{
+	struct rk628_lvds *lvds = bridge_to_lvds(bridge);
+	struct drm_connector *connector = &lvds->connector;
+	struct drm_device *drm = bridge->dev;
+	int ret;
+
+	ret = drm_connector_init(drm, connector, &rk628_lvds_connector_funcs,
+				 DRM_MODE_CONNECTOR_LVDS);
+	if (ret) {
+		dev_err(lvds->dev, "Failed to initialize connector with drm\n");
+		return ret;
+	}
+
+	drm_connector_helper_add(connector, &rk628_lvds_connector_helper_funcs);
+	drm_connector_attach_encoder(connector, bridge->encoder);
+
+	ret = drm_panel_attach(lvds->panel, connector);
+	if (ret) {
+		dev_err(lvds->dev, "Failed to attach panel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void rk628_lvds_bridge_mode_set(struct drm_bridge *bridge,
+				       struct drm_display_mode *mode,
+				       struct drm_display_mode *adj)
+{
+	struct rk628_lvds *lvds = bridge_to_lvds(bridge);
+
+	drm_mode_copy(&lvds->mode, mode);
+}
+
+static const struct drm_bridge_funcs rk628_lvds_bridge_funcs = {
+	.attach = rk628_lvds_bridge_attach,
+	.enable = rk628_lvds_bridge_enable,
+	.disable = rk628_lvds_bridge_disable,
+	.mode_set = rk628_lvds_bridge_mode_set,
+};
+
+static int rk628_lvds_probe(struct platform_device *pdev)
+{
+	struct rk628 *rk628 = dev_get_drvdata(pdev->dev.parent);
+	struct device *dev = &pdev->dev;
+	struct rk628_lvds *lvds;
+	int ret;
+
+	if (!of_device_is_available(dev->of_node))
+		return -ENODEV;
+
+	lvds = devm_kzalloc(dev, sizeof(*lvds), GFP_KERNEL);
+	if (!lvds)
+		return -ENOMEM;
+
+	ret = drm_of_find_panel_or_bridge(dev->of_node, 1, -1,
+					  &lvds->panel, NULL);
+	if (ret)
+		return ret;
+
+	lvds->dev = dev;
+	lvds->parent = rk628;
+	lvds->grf = rk628->grf;
+	lvds->link_type = rk628_lvds_get_link_type(lvds);
+	platform_set_drvdata(pdev, lvds);
+
+	lvds->phy = devm_of_phy_get(dev, dev->of_node, NULL);
+	if (IS_ERR(lvds->phy)) {
+		ret = PTR_ERR(lvds->phy);
+		dev_err(dev, "failed to get phy: %d\n", ret);
+		return ret;
+	}
+
+	lvds->base.funcs = &rk628_lvds_bridge_funcs;
+	lvds->base.of_node = dev->of_node;
+	drm_bridge_add(&lvds->base);
+
+	return 0;
+}
+
+static int rk628_lvds_remove(struct platform_device *pdev)
+{
+	struct rk628_lvds *lvds = platform_get_drvdata(pdev);
+
+	drm_bridge_remove(&lvds->base);
+
+	return 0;
+}
+
+static const struct of_device_id rk628_lvds_of_match[] = {
+	{ .compatible = "rockchip,rk628-lvds", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk628_lvds_of_match);
+
+static struct platform_driver rk628_lvds_driver = {
+	.driver = {
+		.name = "rk628-lvds",
+		.of_match_table = of_match_ptr(rk628_lvds_of_match),
+	},
+	.probe = rk628_lvds_probe,
+	.remove = rk628_lvds_remove,
+};
+module_platform_driver(rk628_lvds_driver);
+
+MODULE_AUTHOR("Wyon Bi <bivvy.bi@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip RK628 LVDS driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/rockchip/rk628/rk628_post_process.c b/drivers/gpu/drm/rockchip/rk628/rk628_post_process.c
new file mode 100644
index 000000000000..1b7bad122717
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk628/rk628_post_process.c
@@ -0,0 +1,401 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
+ *
+ * Author: Wyon Bi <bivvy.bi@rock-chips.com>
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/mfd/rk628.h>
+#include <video/of_display_timing.h>
+#include <video/videomode.h>
+
+#include <drm/drm_of.h>
+#include <drm/drmP.h>
+
+struct rk628_post_process {
+	struct drm_bridge base;
+	struct drm_bridge *bridge;
+	struct drm_display_mode src_mode;
+	struct drm_display_mode dst_mode;
+	struct device *dev;
+	struct regmap *grf;
+	struct clk *sclk_vop;
+	struct clk *clk_rx_read;
+	struct reset_control *rstc_decoder;
+	struct reset_control *rstc_clk_rx;
+	struct reset_control *rstc_vop;
+};
+
+static inline struct rk628_post_process *bridge_to_pp(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct rk628_post_process, base);
+}
+
+static void calc_dsp_frm_hst_vst(const struct videomode *src,
+				 const struct videomode *dst,
+				 u32 *dsp_frame_hst, u32 *dsp_frame_vst)
+{
+	u32 bp_in, bp_out;
+	u32 v_scale_ratio;
+	u64 t_frm_st;
+	u64 t_bp_in, t_bp_out, t_delta, tin;
+	u32 src_pixclock, dst_pixclock;
+	u32 dsp_htotal, src_htotal, src_vtotal;
+
+	src_pixclock = div_u64(1000000000000llu, src->pixelclock);
+	dst_pixclock = div_u64(1000000000000llu, dst->pixelclock);
+
+	src_htotal = src->hsync_len + src->hback_porch + src->hactive +
+		     src->hfront_porch;
+	src_vtotal = src->vsync_len + src->vback_porch + src->vactive +
+		     src->vfront_porch;
+	dsp_htotal = dst->hsync_len + dst->hback_porch + dst->hactive +
+		     dst->hfront_porch;
+
+	bp_in = (src->vback_porch + src->vsync_len) * src_htotal +
+		src->hsync_len + src->hback_porch;
+	bp_out = (dst->vback_porch + dst->vsync_len) * dsp_htotal +
+		 dst->hsync_len + dst->hback_porch;
+
+	t_bp_in = bp_in * src_pixclock;
+	t_bp_out = bp_out * dst_pixclock;
+	tin = src_vtotal * src_htotal * src_pixclock;
+
+	v_scale_ratio = src->vactive / dst->vactive;
+	if (v_scale_ratio <= 2)
+		t_delta = 5 * src_htotal * src_pixclock;
+	else
+		t_delta = 12 * src_htotal * src_pixclock;
+
+	if (t_bp_in + t_delta > t_bp_out)
+		t_frm_st = (t_bp_in + t_delta - t_bp_out);
+	else
+		t_frm_st = tin - (t_bp_out - (t_bp_in + t_delta));
+
+	do_div(t_frm_st, src_pixclock);
+	*dsp_frame_hst = do_div(t_frm_st, src_htotal);
+	*dsp_frame_vst = t_frm_st;
+}
+
+static void rk628_post_process_scaler_init(struct rk628_post_process *pp,
+					   const struct drm_display_mode *s,
+					   const struct drm_display_mode *d)
+{
+	struct videomode src, dst;
+	u32 dsp_frame_hst, dsp_frame_vst;
+	u32 scl_hor_mode, scl_ver_mode;
+	u32 scl_v_factor, scl_h_factor;
+	u32 dsp_htotal, dsp_hs_end, dsp_hact_st, dsp_hact_end;
+	u32 dsp_vtotal, dsp_vs_end, dsp_vact_st, dsp_vact_end;
+	u32 dsp_hbor_end, dsp_hbor_st, dsp_vbor_end, dsp_vbor_st;
+	u16 bor_right = 0, bor_left = 0, bor_up = 0, bor_down = 0;
+	u8 hor_down_mode = 0, ver_down_mode = 0;
+
+	drm_display_mode_to_videomode(s, &src);
+	drm_display_mode_to_videomode(d, &dst);
+
+	dsp_htotal = dst.hsync_len + dst.hback_porch + dst.hactive +
+		     dst.hfront_porch;
+	dsp_vtotal = dst.vsync_len + dst.vback_porch + dst.vactive +
+		     dst.vfront_porch;
+	dsp_hs_end = dst.hsync_len;
+	dsp_vs_end = dst.vsync_len;
+	dsp_hbor_end = dst.hsync_len + dst.hback_porch + dst.hactive;
+	dsp_hbor_st = dst.hsync_len + dst.hback_porch;
+	dsp_vbor_end = dst.vsync_len + dst.vback_porch + dst.vactive;
+	dsp_vbor_st = dst.vsync_len + dst.vback_porch;
+	dsp_hact_st = dsp_hbor_st + bor_left;
+	dsp_hact_end = dsp_hbor_end - bor_right;
+	dsp_vact_st = dsp_vbor_st + bor_up;
+	dsp_vact_end = dsp_vbor_end - bor_down;
+
+	calc_dsp_frm_hst_vst(&src, &dst, &dsp_frame_hst, &dsp_frame_vst);
+	dev_dbg(pp->dev, "dsp_frame_vst=%d, dsp_frame_hst=%d\n",
+		dsp_frame_vst, dsp_frame_hst);
+
+	if (src.hactive > dst.hactive) {
+		scl_hor_mode = 2;
+
+		if (hor_down_mode == 0) {
+			if ((src.hactive - 1) / (dst.hactive - 1) > 2)
+				scl_h_factor = ((src.hactive - 1) << 14) /
+					       (dst.hactive - 1);
+			else
+				scl_h_factor = ((src.hactive - 2) << 14) /
+					       (dst.hactive - 1);
+		} else {
+			scl_h_factor = (dst.hactive << 16) /
+				       (src.hactive - 1);
+		}
+
+		dev_dbg(pp->dev, "horizontal scale down\n");
+	} else if (src.hactive == dst.hactive) {
+		scl_hor_mode = 0;
+		scl_h_factor = 0;
+
+		dev_dbg(pp->dev, "horizontal no scale\n");
+	} else {
+		scl_hor_mode = 1;
+		scl_h_factor = ((src.hactive - 1) << 16) / (dst.hactive - 1);
+
+		dev_dbg(pp->dev, "horizontal scale up\n");
+	}
+
+	if (src.vactive > dst.vactive) {
+		scl_ver_mode = 2;
+
+		if (ver_down_mode == 0) {
+			if ((src.vactive - 1) / (dst.vactive - 1) > 2)
+				scl_v_factor = ((src.vactive - 1) << 14) /
+					       (dst.vactive - 1);
+			else
+				scl_v_factor = ((src.vactive - 2) << 14) /
+					       (dst.vactive - 1);
+		} else {
+			scl_v_factor = (dst.vactive << 16) /
+				       (src.vactive - 1);
+		}
+
+		dev_dbg(pp->dev, "vertical scale down\n");
+	} else if (src.vactive == dst.vactive) {
+		scl_ver_mode = 0;
+		scl_v_factor = 0;
+
+		dev_dbg(pp->dev, "vertical no scale\n");
+	} else {
+		scl_ver_mode = 1;
+		scl_v_factor = ((src.vactive - 1) << 16) / (dst.vactive - 1);
+
+		dev_dbg(pp->dev, "vertical scale up\n");
+	}
+
+	regmap_update_bits(pp->grf, GRF_RGB_DEC_CON0,
+			   SW_HRES_MASK, SW_HRES(src.hactive));
+	regmap_write(pp->grf, GRF_SCALER_CON0,
+		     SCL_VER_DOWN_MODE(ver_down_mode) |
+		     SCL_HOR_DOWN_MODE(hor_down_mode) |
+		     SCL_VER_MODE(scl_ver_mode) | SCL_HOR_MODE(scl_hor_mode));
+	regmap_write(pp->grf, GRF_SCALER_CON1,
+		     SCL_V_FACTOR(scl_v_factor) | SCL_H_FACTOR(scl_h_factor));
+	regmap_write(pp->grf, GRF_SCALER_CON2,
+		     DSP_FRAME_VST(dsp_frame_vst) |
+		     DSP_FRAME_HST(dsp_frame_hst));
+	regmap_write(pp->grf, GRF_SCALER_CON3,
+		     DSP_HS_END(dsp_hs_end) | DSP_HTOTAL(dsp_htotal));
+	regmap_write(pp->grf, GRF_SCALER_CON4,
+		     DSP_HACT_END(dsp_hact_end) | DSP_HACT_ST(dsp_hact_st));
+	regmap_write(pp->grf, GRF_SCALER_CON5,
+		     DSP_VS_END(dsp_vs_end) | DSP_VTOTAL(dsp_vtotal));
+	regmap_write(pp->grf, GRF_SCALER_CON6,
+		     DSP_VACT_END(dsp_vact_end) | DSP_VACT_ST(dsp_vact_st));
+	regmap_write(pp->grf, GRF_SCALER_CON7,
+		     DSP_HBOR_END(dsp_hbor_end) | DSP_HBOR_ST(dsp_hbor_st));
+	regmap_write(pp->grf, GRF_SCALER_CON8,
+		     DSP_VBOR_END(dsp_vbor_end) | DSP_VBOR_ST(dsp_vbor_st));
+}
+
+static void rk628_post_process_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct rk628_post_process *pp = bridge_to_pp(bridge);
+	const struct drm_display_mode *src = &pp->src_mode;
+	const struct drm_display_mode *dst = &pp->dst_mode;
+
+	reset_control_assert(pp->rstc_decoder);
+	udelay(10);
+	reset_control_deassert(pp->rstc_decoder);
+	udelay(10);
+
+	clk_set_rate(pp->clk_rx_read, src->clock * 1000);
+	clk_prepare_enable(pp->clk_rx_read);
+	reset_control_assert(pp->rstc_clk_rx);
+	udelay(10);
+	reset_control_deassert(pp->rstc_clk_rx);
+	udelay(10);
+
+	clk_set_rate(pp->sclk_vop, dst->clock * 1000);
+	clk_prepare_enable(pp->sclk_vop);
+	reset_control_assert(pp->rstc_vop);
+	udelay(10);
+	reset_control_deassert(pp->rstc_vop);
+	udelay(10);
+
+	regmap_update_bits(pp->grf, GRF_SYSTEM_CON0, SW_VSYNC_POL_MASK,
+			   SW_VSYNC_POL(1));
+	regmap_update_bits(pp->grf, GRF_SYSTEM_CON0, SW_HSYNC_POL_MASK,
+			   SW_HSYNC_POL(1));
+
+	rk628_post_process_scaler_init(pp, src, dst);
+}
+
+static void rk628_post_process_bridge_post_disable(struct drm_bridge *bridge)
+{
+
+}
+
+static void rk628_post_process_bridge_enable(struct drm_bridge *bridge)
+{
+	struct rk628_post_process *pp = bridge_to_pp(bridge);
+
+	regmap_write(pp->grf, GRF_SCALER_CON0, SCL_EN(1));
+}
+
+static void rk628_post_process_bridge_disable(struct drm_bridge *bridge)
+{
+	struct rk628_post_process *pp = bridge_to_pp(bridge);
+
+	regmap_write(pp->grf, GRF_SCALER_CON0, SCL_EN(0));
+
+	clk_disable_unprepare(pp->sclk_vop);
+	clk_disable_unprepare(pp->clk_rx_read);
+}
+
+static void rk628_post_process_bridge_mode_set(struct drm_bridge *bridge,
+					       struct drm_display_mode *mode,
+					       struct drm_display_mode *adj)
+{
+	struct rk628_post_process *pp = bridge_to_pp(bridge);
+
+	drm_mode_copy(&pp->src_mode, adj);
+
+	if (pp->bridge->driver_private)
+		drm_mode_copy(&pp->dst_mode, pp->bridge->driver_private);
+	else
+		drm_mode_copy(&pp->dst_mode, &pp->src_mode);
+}
+
+static int rk628_post_process_bridge_attach(struct drm_bridge *bridge)
+{
+	struct rk628_post_process *pp = bridge_to_pp(bridge);
+	struct device *dev = pp->dev;
+	int ret;
+
+	ret = drm_of_find_panel_or_bridge(dev->of_node, 1, -1,
+					  NULL, &pp->bridge);
+	if (ret)
+		return ret;
+
+	ret = drm_bridge_attach(bridge->encoder, pp->bridge, bridge);
+	if (ret) {
+		dev_err(dev, "failed to attach bridge\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static bool
+rk628_post_process_bridge_mode_fixup(struct drm_bridge *bridge,
+				     const struct drm_display_mode *mode,
+				     struct drm_display_mode *adj)
+{
+	/* Fixup sync polarities, both hsync and vsync are active high */
+	adj->flags &= ~(DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC);
+	adj->flags |= (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC);
+
+	return true;
+}
+
+static const struct drm_bridge_funcs rk628_post_process_bridge_funcs = {
+	.pre_enable = rk628_post_process_bridge_pre_enable,
+	.post_disable = rk628_post_process_bridge_post_disable,
+	.enable = rk628_post_process_bridge_enable,
+	.disable = rk628_post_process_bridge_disable,
+	.mode_set = rk628_post_process_bridge_mode_set,
+	.mode_fixup = rk628_post_process_bridge_mode_fixup,
+	.attach = rk628_post_process_bridge_attach,
+};
+
+static int rk628_post_process_probe(struct platform_device *pdev)
+{
+	struct rk628 *rk628 = dev_get_drvdata(pdev->dev.parent);
+	struct device *dev = &pdev->dev;
+	struct rk628_post_process *pp;
+	int ret;
+
+	if (!of_device_is_available(dev->of_node))
+		return -ENODEV;
+
+	pp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);
+	if (!pp)
+		return -ENOMEM;
+
+	pp->dev = dev;
+	pp->grf = rk628->grf;
+	platform_set_drvdata(pdev, pp);
+
+	pp->sclk_vop = devm_clk_get(dev, "sclk_vop");
+	if (IS_ERR(pp->sclk_vop)) {
+		ret = PTR_ERR(pp->sclk_vop);
+		dev_err(dev, "failed to get sclk: %d\n", ret);
+		return ret;
+	}
+
+	pp->clk_rx_read = devm_clk_get(dev, "rx_read");
+	if (IS_ERR(pp->clk_rx_read)) {
+		ret = PTR_ERR(pp->clk_rx_read);
+		dev_err(dev, "failed to get clk_rx_read: %d\n", ret);
+		return ret;
+	}
+
+	pp->rstc_decoder = of_reset_control_get(dev->of_node, "decoder");
+	if (IS_ERR(pp->rstc_decoder)) {
+		ret = PTR_ERR(pp->rstc_decoder);
+		dev_err(dev, "failed to get decoder reset: %d\n", ret);
+		return ret;
+	}
+
+	pp->rstc_clk_rx = of_reset_control_get(dev->of_node, "clk_rx");
+	if (IS_ERR(pp->rstc_clk_rx)) {
+		ret = PTR_ERR(pp->rstc_clk_rx);
+		dev_err(dev, "failed to get clk_rx reset: %d\n", ret);
+		return ret;
+	}
+
+	pp->rstc_vop = of_reset_control_get(dev->of_node, "vop");
+	if (IS_ERR(pp->rstc_vop)) {
+		ret = PTR_ERR(pp->rstc_vop);
+		dev_err(dev, "failed to get vop reset: %d\n", ret);
+		return ret;
+	}
+
+	pp->base.funcs = &rk628_post_process_bridge_funcs;
+	pp->base.of_node = dev->of_node;
+	drm_bridge_add(&pp->base);
+
+	return 0;
+}
+
+static int rk628_post_process_remove(struct platform_device *pdev)
+{
+	struct rk628_post_process *pp = platform_get_drvdata(pdev);
+
+	drm_bridge_remove(&pp->base);
+
+	return 0;
+}
+
+static const struct of_device_id rk628_post_process_of_match[] = {
+	{ .compatible = "rockchip,rk628-post-process", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk628_post_process_of_match);
+
+static struct platform_driver rk628_post_process_driver = {
+	.driver = {
+		.name = "rk628-post-process",
+		.of_match_table = of_match_ptr(rk628_post_process_of_match),
+	},
+	.probe = rk628_post_process_probe,
+	.remove = rk628_post_process_remove,
+};
+module_platform_driver(rk628_post_process_driver);
+
+MODULE_AUTHOR("Wyon Bi <bivvy.bi@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip RK628 Post Process driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/rockchip/rk628/rk628_rgb.c b/drivers/gpu/drm/rockchip/rk628/rk628_rgb.c
new file mode 100644
index 000000000000..9c5a270beba0
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk628/rk628_rgb.c
@@ -0,0 +1,203 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
+ *
+ * Author: Wyon Bi <bivvy.bi@rock-chips.com>
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/mfd/rk628.h>
+#include <linux/phy/phy.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_of.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_panel.h>
+
+#include <video/of_display_timing.h>
+#include <video/videomode.h>
+
+struct rk628_rgb {
+	struct drm_bridge base;
+	struct drm_connector connector;
+	struct drm_display_mode mode;
+	struct drm_panel *panel;
+	struct device *dev;
+	struct regmap *grf;
+	struct rk628 *parent;
+};
+
+static inline struct rk628_rgb *bridge_to_rgb(struct drm_bridge *b)
+{
+	return container_of(b, struct rk628_rgb, base);
+}
+
+static inline struct rk628_rgb *connector_to_rgb(struct drm_connector *c)
+{
+	return container_of(c, struct rk628_rgb, connector);
+}
+
+static struct drm_encoder *
+rk628_rgb_connector_best_encoder(struct drm_connector *connector)
+{
+	struct rk628_rgb *rgb = connector_to_rgb(connector);
+
+	return rgb->base.encoder;
+}
+
+static int rk628_rgb_connector_get_modes(struct drm_connector *connector)
+{
+	struct rk628_rgb *rgb = connector_to_rgb(connector);
+
+	return drm_panel_get_modes(rgb->panel);
+}
+
+static const struct drm_connector_helper_funcs
+rk628_rgb_connector_helper_funcs = {
+	.get_modes = rk628_rgb_connector_get_modes,
+	.best_encoder = rk628_rgb_connector_best_encoder,
+};
+
+static void rk628_rgb_connector_destroy(struct drm_connector *connector)
+{
+	struct rk628_rgb *rgb = connector_to_rgb(connector);
+
+	drm_panel_detach(rgb->panel);
+	drm_connector_cleanup(connector);
+}
+
+static const struct drm_connector_funcs rk628_rgb_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = rk628_rgb_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static void rk628_rgb_bridge_enable(struct drm_bridge *bridge)
+{
+	struct rk628_rgb *rgb = bridge_to_rgb(bridge);
+
+	regmap_update_bits(rgb->grf, GRF_SYSTEM_CON0,
+			   SW_BT_DATA_OEN_MASK | SW_OUTPUT_MODE_MASK,
+			   SW_OUTPUT_MODE(OUTPUT_MODE_RGB));
+
+	drm_panel_prepare(rgb->panel);
+	drm_panel_enable(rgb->panel);
+}
+
+static void rk628_rgb_bridge_disable(struct drm_bridge *bridge)
+{
+	struct rk628_rgb *rgb = bridge_to_rgb(bridge);
+
+	drm_panel_disable(rgb->panel);
+	drm_panel_unprepare(rgb->panel);
+}
+
+static int rk628_rgb_bridge_attach(struct drm_bridge *bridge)
+{
+	struct rk628_rgb *rgb = bridge_to_rgb(bridge);
+	struct drm_connector *connector = &rgb->connector;
+	struct drm_device *drm = bridge->dev;
+	int ret;
+
+	ret = drm_connector_init(drm, connector, &rk628_rgb_connector_funcs,
+				 DRM_MODE_CONNECTOR_DPI);
+	if (ret) {
+		dev_err(rgb->dev, "Failed to initialize connector with drm\n");
+		return ret;
+	}
+
+	drm_connector_helper_add(connector, &rk628_rgb_connector_helper_funcs);
+	drm_connector_attach_encoder(connector, bridge->encoder);
+
+	ret = drm_panel_attach(rgb->panel, connector);
+	if (ret) {
+		dev_err(rgb->dev, "Failed to attach panel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void rk628_rgb_bridge_mode_set(struct drm_bridge *bridge,
+				      struct drm_display_mode *mode,
+				      struct drm_display_mode *adj)
+{
+	struct rk628_rgb *rgb = bridge_to_rgb(bridge);
+
+	drm_mode_copy(&rgb->mode, adj);
+}
+
+static const struct drm_bridge_funcs rk628_rgb_bridge_funcs = {
+	.attach = rk628_rgb_bridge_attach,
+	.enable = rk628_rgb_bridge_enable,
+	.disable = rk628_rgb_bridge_disable,
+	.mode_set = rk628_rgb_bridge_mode_set,
+};
+
+static int rk628_rgb_probe(struct platform_device *pdev)
+{
+	struct rk628 *rk628 = dev_get_drvdata(pdev->dev.parent);
+	struct device *dev = &pdev->dev;
+	struct rk628_rgb *rgb;
+	int ret;
+
+	if (!of_device_is_available(dev->of_node))
+		return -ENODEV;
+
+	rgb = devm_kzalloc(dev, sizeof(*rgb), GFP_KERNEL);
+	if (!rgb)
+		return -ENOMEM;
+
+	rgb->dev = dev;
+	rgb->parent = rk628;
+	rgb->grf = rk628->grf;
+	platform_set_drvdata(pdev, rgb);
+
+	ret = drm_of_find_panel_or_bridge(dev->of_node, 1, -1,
+					  &rgb->panel, NULL);
+	if (ret)
+		return ret;
+
+	rgb->base.funcs = &rk628_rgb_bridge_funcs;
+	rgb->base.of_node = dev->of_node;
+	drm_bridge_add(&rgb->base);
+
+	return 0;
+}
+
+static int rk628_rgb_remove(struct platform_device *pdev)
+{
+	struct rk628_rgb *rgb = platform_get_drvdata(pdev);
+
+	drm_bridge_remove(&rgb->base);
+
+	return 0;
+}
+
+static const struct of_device_id rk628_rgb_of_match[] = {
+	{ .compatible = "rockchip,rk628-rgb", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk628_rgb_of_match);
+
+static struct platform_driver rk628_rgb_driver = {
+	.driver = {
+		.name = "rk628-rgb",
+		.of_match_table = of_match_ptr(rk628_rgb_of_match),
+	},
+	.probe = rk628_rgb_probe,
+	.remove = rk628_rgb_remove,
+};
+module_platform_driver(rk628_rgb_driver);
+
+MODULE_AUTHOR("Wyon Bi <bivvy.bi@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip RK628 RGB driver");
+MODULE_LICENSE("GPL v2");
-- 
2.35.3

