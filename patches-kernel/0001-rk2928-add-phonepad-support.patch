From 72d981d8fde265a5b3768be98f4ee1ed1778b19d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E8=B5=B5=E5=AD=90=E5=88=9D?= <zzc@rock-chips.com>
Date: Wed, 27 Mar 2013 10:14:44 +0800
Subject: [PATCH] rk2928 add phonepad support

---
 .../arm/configs/rk2928_phonepad_760_defconfig |  421 ++++
 .../configs/rk2928_phonepad_760_hd_defconfig  |  421 ++++
 arch/arm/mach-rk2928/Kconfig                  |    2 +
 arch/arm/mach-rk2928/Makefile                 |    9 +-
 .../board-rk2928-phonepad-760-camera.c        |  448 ++++
 .../mach-rk2928/board-rk2928-phonepad-760.c   | 1773 ++++++++++++++++
 .../board-rk2928-phonepad-camera.c            |   20 +-
 .../mach-rk2928/board-rk2928-phonepad-key.c   |   23 +-
 .../mach-rk2928/board-rk2928-phonepad-sdmmc.c | 1827 +++++++++++++++--
 .../board-rk2928-phonepad-tps65910.c          |  638 ++++++
 arch/arm/mach-rk2928/include/mach/board.h     |   11 +
 drivers/input/touchscreen/Kconfig             |    9 +-
 drivers/input/touchscreen/Makefile            |    3 +-
 .../input/touchscreen/goodix_touch_82x_760.c  |  882 ++++++++
 drivers/input/touchscreen/tp_760_ts.c         |  922 +++++++++
 drivers/misc/bp/chips/c66a.c                  |   64 +
 drivers/misc/bp/chips/m51.c                   |   63 +
 drivers/misc/bp/chips/mi700.c                 |   60 +
 drivers/misc/bp/chips/mt6229.c                |   58 +
 drivers/misc/bp/chips/mtk6250.c               |   62 +
 drivers/misc/bp/chips/mu509.c                 |   60 +
 drivers/misc/bp/chips/mw100.c                 |   60 +
 drivers/misc/bp/chips/sc6610.c                |   62 +
 drivers/misc/modem_sound.c                    |   15 +-
 drivers/video/display/screen/Kconfig          |    4 +
 drivers/video/display/screen/Makefile         |    2 +
 .../video/display/screen/lcd_hh070d_lvds.c    |   77 +
 drivers/video/display/screen/lcd_wy_800x480.c |  109 +
 sound/soc/codecs/rk2928_codec.c               |  277 ++-
 sound/soc/codecs/rk2928_codec.h               |    7 +-
 30 files changed, 8127 insertions(+), 262 deletions(-)
 create mode 100755 arch/arm/configs/rk2928_phonepad_760_defconfig
 create mode 100644 arch/arm/configs/rk2928_phonepad_760_hd_defconfig
 create mode 100755 arch/arm/mach-rk2928/board-rk2928-phonepad-760-camera.c
 create mode 100755 arch/arm/mach-rk2928/board-rk2928-phonepad-760.c
 create mode 100755 arch/arm/mach-rk2928/board-rk2928-phonepad-tps65910.c
 create mode 100755 drivers/input/touchscreen/goodix_touch_82x_760.c
 create mode 100755 drivers/input/touchscreen/tp_760_ts.c
 create mode 100755 drivers/video/display/screen/lcd_hh070d_lvds.c
 create mode 100755 drivers/video/display/screen/lcd_wy_800x480.c

diff --git a/arch/arm/configs/rk2928_phonepad_760_defconfig b/arch/arm/configs/rk2928_phonepad_760_defconfig
new file mode 100755
index 000000000000..9e80ccb64a8c
--- /dev/null
+++ b/arch/arm/configs/rk2928_phonepad_760_defconfig
@@ -0,0 +1,421 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=1
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_ELF_CORE is not set
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_ARCH_RK2928=y
+CONFIG_DDR_FREQ=y
+CONFIG_RK_USB_UART=y
+CONFIG_MACH_RK2928_PHONEPAD_760=y
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyFIQ0 androidboot.console=ttyFIQ0 init=/init"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_WAKELOCK=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+# CONFIG_BRIDGE_NETFILTER is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+CONFIG_PHONET=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_AUTOSLEEP=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_RK=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_NAND_IDS=y
+CONFIG_MTD_RKNAND=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_MISC_DEVICES=y
+CONFIG_UID_STAT=y
+CONFIG_APANIC=y
+CONFIG_MODEM_SOUND=y
+CONFIG_BP_AUTO=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+CONFIG_PHYLIB=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN_80211=y
+CONFIG_RTL8192CU=y
+CONFIG_USB_USBNET=y
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TP_760_TS=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_GS_MMA7660=y
+CONFIG_SENSOR_DEVICE=y
+CONFIG_GSENSOR_DEVICE=y
+# CONFIG_SERIO is not set
+# CONFIG_CONSOLE_TRANSLATIONS is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_RK29=y
+CONFIG_UART0_RK29=y
+CONFIG_UART0_DMA_RK29=2
+CONFIG_UART1_RK29=y
+CONFIG_UART1_CTS_RTS_RK29=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C0_CONTROLLER_RK30=y
+CONFIG_I2C1_CONTROLLER_RK30=y
+CONFIG_I2C2_CONTROLLER_RK30=y
+CONFIG_RK_HEADSET_DET=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_EXPANDED_GPIO_NUM=0
+CONFIG_EXPANDED_GPIO_IRQ_NUM=0
+CONFIG_SPI_FPGA_GPIO_NUM=0
+CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
+CONFIG_POWER_SUPPLY=y
+CONFIG_BATTERY_RK30_ADC_FAC=y
+CONFIG_BATTERY_RK30_AC_CHARGE=y
+CONFIG_BATTERY_RK30_VOL3V8=y
+# CONFIG_HWMON is not set
+CONFIG_MFD_TPS65910=y
+CONFIG_MFD_TPS65090=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_GC0308=y
+CONFIG_GC0308_USER_DEFINED_SERIES=y
+CONFIG_VIDEO_RK29=y
+CONFIG_VIDEO_RK29_CAMMEM_ION=y
+CONFIG_ION=y
+CONFIG_ION_ROCKCHIP=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_LCD_WY_800X480=y
+CONFIG_FB_ROCKCHIP=y
+CONFIG_LCDC_RK2928=y
+CONFIG_RK_HDMI=y
+CONFIG_HDMI_RK2928=y
+CONFIG_RGA_RK30=y
+CONFIG_RK_LVDS=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+CONFIG_LOGO_LINUX_800x480_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_RK29_SOC=y
+CONFIG_SND_I2SO_USE_DOUBLE_CHANNELS=y
+CONFIG_SND_I2S_DMA_EVENT_STATIC=y
+CONFIG_SND_RK_SOC_RK2928=y
+CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB20_HOST=y
+CONFIG_USB20_OTG=y
+CONFIG_DWC_OTG_BOTH_HOST_SLAVE=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_SDMMC_RK29=y
+# CONFIG_SDMMC1_RK29 is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_TPS65910_RTC=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_CMMB is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/arm/configs/rk2928_phonepad_760_hd_defconfig b/arch/arm/configs/rk2928_phonepad_760_hd_defconfig
new file mode 100644
index 000000000000..b1bbafbaeda2
--- /dev/null
+++ b/arch/arm/configs/rk2928_phonepad_760_hd_defconfig
@@ -0,0 +1,421 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=1
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_ELF_CORE is not set
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_ARCH_RK2928=y
+CONFIG_DDR_FREQ=y
+CONFIG_RK_USB_UART=y
+CONFIG_MACH_RK2928_PHONEPAD_760=y
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyFIQ0 androidboot.console=ttyFIQ0 init=/init"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_WAKELOCK=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+# CONFIG_BRIDGE_NETFILTER is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+CONFIG_PHONET=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_AUTOSLEEP=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_RK=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_NAND_IDS=y
+CONFIG_MTD_RKNAND=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_MISC_DEVICES=y
+CONFIG_UID_STAT=y
+CONFIG_APANIC=y
+CONFIG_MODEM_SOUND=y
+CONFIG_BP_AUTO=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+CONFIG_PHYLIB=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN_80211=y
+CONFIG_RTL8192CU=y
+CONFIG_USB_USBNET=y
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GT82X_IIC_760=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_GS_MMA7660=y
+CONFIG_SENSOR_DEVICE=y
+CONFIG_GSENSOR_DEVICE=y
+# CONFIG_SERIO is not set
+# CONFIG_CONSOLE_TRANSLATIONS is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_RK29=y
+CONFIG_UART0_RK29=y
+CONFIG_UART0_DMA_RK29=2
+CONFIG_UART1_RK29=y
+CONFIG_UART1_CTS_RTS_RK29=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C0_CONTROLLER_RK30=y
+CONFIG_I2C1_CONTROLLER_RK30=y
+CONFIG_I2C2_CONTROLLER_RK30=y
+CONFIG_RK_HEADSET_DET=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_EXPANDED_GPIO_NUM=0
+CONFIG_EXPANDED_GPIO_IRQ_NUM=0
+CONFIG_SPI_FPGA_GPIO_NUM=0
+CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
+CONFIG_POWER_SUPPLY=y
+CONFIG_BATTERY_RK30_ADC_FAC=y
+CONFIG_BATTERY_RK30_AC_CHARGE=y
+CONFIG_BATTERY_RK30_VOL3V8=y
+# CONFIG_HWMON is not set
+CONFIG_MFD_TPS65910=y
+CONFIG_MFD_TPS65090=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_GC0308=y
+CONFIG_GC0308_USER_DEFINED_SERIES=y
+CONFIG_VIDEO_RK29=y
+CONFIG_VIDEO_RK29_CAMMEM_ION=y
+CONFIG_ION=y
+CONFIG_ION_ROCKCHIP=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_LCD_HH070D_LVDS=y
+CONFIG_FB_ROCKCHIP=y
+CONFIG_LCDC_RK2928=y
+CONFIG_RK_HDMI=y
+CONFIG_HDMI_RK2928=y
+CONFIG_RGA_RK30=y
+CONFIG_RK_LVDS=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+CONFIG_LOGO_LINUX_800x480_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_RK29_SOC=y
+CONFIG_SND_I2SO_USE_DOUBLE_CHANNELS=y
+CONFIG_SND_I2S_DMA_EVENT_STATIC=y
+CONFIG_SND_RK_SOC_RK2928=y
+CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB20_HOST=y
+CONFIG_USB20_OTG=y
+CONFIG_DWC_OTG_BOTH_HOST_SLAVE=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_SDMMC_RK29=y
+# CONFIG_SDMMC1_RK29 is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_TPS65910_RTC=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_CMMB is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/arm/mach-rk2928/Kconfig b/arch/arm/mach-rk2928/Kconfig
index 05631679eb83..93f5cd1758bb 100644
--- a/arch/arm/mach-rk2928/Kconfig
+++ b/arch/arm/mach-rk2928/Kconfig
@@ -22,6 +22,8 @@ config MACH_RK2926_SDK
 
 config MACH_RK2928_PHONEPAD
 	bool "RK2928_PhonePad board"
+config MACH_RK2928_PHONEPAD_760
+	bool "RK2928_PhonePad board 760"
 
 config MACH_RK2928_A720
 	bool "RK2928 A720 board"
diff --git a/arch/arm/mach-rk2928/Makefile b/arch/arm/mach-rk2928/Makefile
index 6be4f090ad10..a16912f8dc3a 100755
--- a/arch/arm/mach-rk2928/Makefile
+++ b/arch/arm/mach-rk2928/Makefile
@@ -13,13 +13,14 @@ obj-$(CONFIG_DVFS) += dvfs.o
 obj-$(CONFIG_PM) += pm.o
 obj-$(CONFIG_RK30_I2C_INSRAM) += i2c_sram.o
 
-board-y := board-rk2928.o
-obj-$(CONFIG_MACH_RK2928) += board.o
+obj-y += board.o
+
+board-$(CONFIG_MACH_RK2928) := board-rk2928.o
 
 obj-$(CONFIG_MACH_RK2928_SDK) += board-rk2928-sdk.o
 obj-$(CONFIG_MACH_RK2926_SDK) += board-rk2926-sdk.o
-obj-$(CONFIG_MACH_RK2928_PHONEPAD) += board-rk2928-phonepad.o
-
+board-$(CONFIG_MACH_RK2928_PHONEPAD) := board-rk2928-phonepad.o
+board-$(CONFIG_MACH_RK2928_PHONEPAD_760) := board-rk2928-phonepad-760.o
 obj-$(CONFIG_MACH_RK2928_A720) += board-rk2928-a720.o
 obj-$(CONFIG_MACH_RK2928_TB) += board-rk2928-tb.o
 obj-$(CONFIG_MACH_RK2926_TB) += board-rk2928-tb.o
diff --git a/arch/arm/mach-rk2928/board-rk2928-phonepad-760-camera.c b/arch/arm/mach-rk2928/board-rk2928-phonepad-760-camera.c
new file mode 100755
index 000000000000..997ae2426ba7
--- /dev/null
+++ b/arch/arm/mach-rk2928/board-rk2928-phonepad-760-camera.c
@@ -0,0 +1,448 @@
+#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Macro Define Begin  ------------------------*/
+/*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_GC2035						/* back camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_0		0x78
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  1
+#define CONFIG_SENSOR_CIF_INDEX_0                    0
+#define CONFIG_SENSOR_ORIENTATION_0 	  90
+#define CONFIG_SENSOR_POWER_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_0 	        RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_0   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_0		30000
+
+#define CONFIG_SENSOR_01  RK29_CAM_SENSOR_OV5642                   /* back camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_01 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_01                    0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_01    4
+#define CONFIG_SENSOR_ORIENTATION_01       90
+#define CONFIG_SENSOR_POWER_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_01       INVALID_GPIO//RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_01 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_01 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_01   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_01     30000
+
+#define CONFIG_SENSOR_02 RK29_CAM_SENSOR_OV5640                      /* back camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_02 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_02                    0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_02    4
+#define CONFIG_SENSOR_ORIENTATION_02       90
+#define CONFIG_SENSOR_POWER_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_02       INVALID_GPIO//RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_02   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_02      30000
+
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_GC0308                      /* front camera sensor 0 */
+#define CONFIG_SENSOR_IIC_ADDR_1 	   0x42
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  1
+#define CONFIG_SENSOR_CIF_INDEX_1				  0
+#define CONFIG_SENSOR_ORIENTATION_1       270
+#define CONFIG_SENSOR_POWER_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_1 	  RK2928_PIN3_PD7
+#define CONFIG_SENSOR_FALSH_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_1   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_1		30000
+
+#define CONFIG_SENSOR_11 RK29_CAM_SENSOR_GC0329                      /* front camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_11 	    0x62
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_11    1
+#define CONFIG_SENSOR_CIF_INDEX_11				  0
+#define CONFIG_SENSOR_ORIENTATION_11       90
+#define CONFIG_SENSOR_POWER_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_11       RK2928_PIN3_PD7
+#define CONFIG_SENSOR_FALSH_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_11 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_11 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_11 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_11 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_11   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_11      30000
+
+#define CONFIG_SENSOR_12 RK29_CAM_SENSOR_OV2659//RK29_CAM_SENSOR_OV2655                      /* front camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_12 	   0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_12    3
+#define CONFIG_SENSOR_CIF_INDEX_12				  0
+#define CONFIG_SENSOR_ORIENTATION_12       270
+#define CONFIG_SENSOR_POWER_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_12       INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_12 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_12 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_12 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_12 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_12   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_12      30000
+
+
+#endif  //#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Configuration Macro End------------------------*/
+#include "../../../drivers/media/video/rk2928_camera.c"
+/*---------------- Camera Sensor Macro Define End  ---------*/
+
+#define PMEM_CAM_SIZE PMEM_CAM_NECESSARY
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29
+#define CONFIG_SENSOR_POWER_IOCTL_USR	   1 //define this refer to your board layout
+#define CONFIG_SENSOR_RESET_IOCTL_USR	   0
+#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR	   0
+
+static void rk_cif_power(int on)
+{
+    struct regulator *ldo_18,*ldo_28;
+	ldo_28 = regulator_get(NULL, "vaux1");	// vcc28_cif
+	ldo_18 = regulator_get(NULL, "vdig1");	// vcc18_cif
+	if (ldo_28 == NULL || IS_ERR(ldo_28) || ldo_18 == NULL || IS_ERR(ldo_18)){
+        printk("get cif ldo failed!\n");
+		return;
+	    }
+    if(on == 0){
+    	regulator_force_disable(ldo_28);
+    	regulator_put(ldo_28);
+    	regulator_force_disable(ldo_18);
+    	regulator_put(ldo_18);
+    	mdelay(500);
+        }
+    else{
+    	regulator_set_voltage(ldo_28, 2800000, 2800000);
+    	regulator_enable(ldo_28);
+   // 	printk("%s set ldo7 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_28));
+    	regulator_put(ldo_28);
+
+    	regulator_set_voltage(ldo_18, 1800000, 1800000);
+    //	regulator_set_suspend_voltage(ldo, 1800000);
+    	regulator_enable(ldo_18);
+    //	printk("%s set ldo1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_18));
+    	regulator_put(ldo_18);
+        }
+}
+
+#if CONFIG_SENSOR_POWER_IOCTL_USR
+static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	//#error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
+    rk_cif_power(on);
+}
+#endif
+
+#if CONFIG_SENSOR_RESET_IOCTL_USR
+static int sensor_reset_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_FLASH_IOCTL_USR
+static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
+}
+#endif
+
+static struct rk29camera_platform_ioctl_cb	sensor_ioctl_cb = {
+	#if CONFIG_SENSOR_POWER_IOCTL_USR
+	.sensor_power_cb = sensor_power_usr_cb,
+	#else
+	.sensor_power_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_RESET_IOCTL_USR
+	.sensor_reset_cb = sensor_reset_usr_cb,
+	#else
+	.sensor_reset_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+	.sensor_powerdown_cb = sensor_powerdown_usr_cb,
+	#else
+	.sensor_powerdown_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_FLASH_IOCTL_USR
+	.sensor_flash_cb = sensor_flash_usr_cb,
+	#else
+	.sensor_flash_cb = NULL,
+	#endif
+};
+
+#if CONFIG_SENSOR_IIC_ADDR_0
+static struct reginfo_t rk_init_data_sensor_reg_0[] =
+{
+		{0x0000, 0x00,0,0}
+	};
+static struct reginfo_t rk_init_data_sensor_winseqreg_0[] ={
+	{0x0000, 0x00,0,0}
+	};
+#endif
+
+#if CONFIG_SENSOR_IIC_ADDR_1
+static struct reginfo_t rk_init_data_sensor_reg_1[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_1[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_01
+static struct reginfo_t rk_init_data_sensor_reg_01[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_01[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_02
+static struct reginfo_t rk_init_data_sensor_reg_02[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_02[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_11
+static struct reginfo_t rk_init_data_sensor_reg_11[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_11[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_12
+static struct reginfo_t rk_init_data_sensor_reg_12[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_12[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+static rk_sensor_user_init_data_s rk_init_data_sensor[RK_CAM_NUM] = 
+{
+    #if CONFIG_SENSOR_IIC_ADDR_0
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_0,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_0,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_0) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_1
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_1,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_1,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_1) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_1) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_01
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_01,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_01,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_01) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_01) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_02
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_02,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_02,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_02) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_02) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_11
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_11,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_11,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_11) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_11) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_12
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_12,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_12,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_12) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_12) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+
+ };
+#include "../../../drivers/media/video/rk2928_camera.c"
+
+#endif /* CONFIG_VIDEO_RK29 */
diff --git a/arch/arm/mach-rk2928/board-rk2928-phonepad-760.c b/arch/arm/mach-rk2928/board-rk2928-phonepad-760.c
new file mode 100755
index 000000000000..8a5a5dd1a27f
--- /dev/null
+++ b/arch/arm/mach-rk2928/board-rk2928-phonepad-760.c
@@ -0,0 +1,1773 @@
+/* arch/arm/mach-rk2928/board-rk2928-fpga.c
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/skbuff.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+#include <linux/ion.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+#include <mach/dvfs.h>
+
+#include <mach/board.h>
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/config.h>
+#include <linux/fb.h>
+#include <linux/regulator/machine.h>
+#include <linux/rfkill-rk.h>
+#include <linux/sensor-dev.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/regulator/act8931.h>
+#include <linux/regulator/rk29-pwm-regulator.h>
+#if defined(CONFIG_MODEM_SOUND)
+#include "../../../drivers/misc/modem_sound.h"
+#endif
+#if defined(CONFIG_HDMI_RK30)
+	#include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
+#endif
+#include "../../../drivers/headset_observe/rk_headset.h"
+
+#if defined(CONFIG_SPIM_RK29)
+#include "../../../drivers/spi/rk29_spim.h"
+#endif
+#ifdef CONFIG_SND_SOC_RK2928
+#include "../../../sound/soc/codecs/rk2928_codec.h"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_GT82X_IIC_760
+#include <linux/goodix_touch_82x.h>
+#endif
+
+#if defined(CONFIG_SC6610)
+#include <linux/sc6610.h>
+#endif
+
+#if defined(CONFIG_ANDROID_TIMED_GPIO)
+#include "../../../drivers/staging/android/timed_gpio.h"
+#endif
+#if defined (CONFIG_BP_AUTO)
+#include <linux/bp-auto.h>
+#endif
+#include "board-rk2928-phonepad-760-camera.c" 
+#include "board-rk2928-phonepad-key.c"
+int __sramdata g_pmic_type =  0;
+
+#ifdef  CONFIG_THREE_FB_BUFFER
+#define RK30_FB0_MEM_SIZE 12*SZ_1M
+#else
+#define RK30_FB0_MEM_SIZE 8*SZ_1M
+#endif
+
+/* Android Parameter */
+static int ap_mdm = BP_ID_M50;
+module_param(ap_mdm, int, 0644);
+static int ap_has_alsa = 0;
+module_param(ap_has_alsa, int, 0644);
+static int ap_multi_card = 0;
+module_param(ap_multi_card, int, 0644);
+static int ap_data_only = 1;
+module_param(ap_data_only, int, 0644);
+
+static int ap_has_earphone = 1;
+module_param(ap_has_earphone, int, 0644);
+
+static struct spi_board_info board_spi_devices[] = {
+};
+
+/***********************************************************
+*	rk30  backlight
+************************************************************/
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+#define PWM_ID            0
+#define PWM_MUX_NAME      GPIO0D2_PWM_0_NAME
+#define PWM_MUX_MODE      GPIO0D_PWM_0
+#define PWM_MUX_MODE_GPIO GPIO0D_GPIO0D2
+#define PWM_GPIO 	  RK2928_PIN0_PD2
+#define PWM_EFFECT_VALUE  0
+
+#define LCD_DISP_ON_PIN
+
+#ifdef  LCD_DISP_ON_PIN
+#define BL_EN_MUX_NAME     GPIO1A5_I2S_SDI_GPS_SIGN_NAME
+#define BL_EN_MUX_MODE    GPIO1A_GPIO1A5 
+#define BL_EN_PIN         RK2928_PIN1_PA5
+#define BL_EN_VALUE       GPIO_HIGH
+#endif
+static int rk29_backlight_io_init(void)
+{
+	int ret = 0;
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+#ifdef  LCD_DISP_ON_PIN
+	rk30_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
+
+	ret = gpio_request(BL_EN_PIN, NULL);
+	//if (ret != 0) {
+	//	gpio_free(BL_EN_PIN);
+	//}
+
+	gpio_direction_output(BL_EN_PIN, 0);
+	mdelay(100);
+	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#endif
+	return ret;
+}
+
+static int rk29_backlight_io_deinit(void)
+{
+	int ret = 0;
+#ifdef  LCD_DISP_ON_PIN
+	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
+	gpio_free(BL_EN_PIN);
+#endif
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+	return ret;
+}
+
+static int rk29_backlight_pwm_suspend(void)
+{
+	int ret = 0;
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+	if (gpio_request(PWM_GPIO, NULL)) {
+		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+	#if defined(CONFIG_MFD_TPS65910)	
+	if(pmic_is_tps65910())
+	{
+		gpio_direction_output(PWM_GPIO, GPIO_LOW);
+	}
+	#endif
+	#if defined(CONFIG_REGULATOR_ACT8931)
+	if(pmic_is_act8931())
+	{
+		gpio_direction_output(PWM_GPIO, GPIO_HIGH);
+	}
+	#endif
+#ifdef  LCD_DISP_ON_PIN
+	gpio_direction_output(BL_EN_PIN, 0);
+	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
+#endif
+
+	return ret;
+}
+
+static int rk29_backlight_pwm_resume(void)
+{
+	gpio_free(PWM_GPIO);
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+#ifdef  LCD_DISP_ON_PIN
+	msleep(30);
+	gpio_direction_output(BL_EN_PIN, 1);
+	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#endif
+	return 0;
+}
+
+static struct rk29_bl_info rk29_bl_info = {
+	.pwm_id = PWM_ID,
+        .min_brightness = 15,
+	.bl_ref = PWM_EFFECT_VALUE,
+	.io_init = rk29_backlight_io_init,
+	.io_deinit = rk29_backlight_io_deinit,
+	.pwm_suspend = rk29_backlight_pwm_suspend,
+	.pwm_resume = rk29_backlight_pwm_resume,
+	.pre_div = 20000,
+};
+
+static struct platform_device rk29_device_backlight = {
+	.name	= "rk29_backlight",
+	.id 	= -1,
+	.dev	= {
+		.platform_data  = &rk29_bl_info,
+	}
+};
+
+#endif
+#ifdef  CONFIG_TOUCHSCREEN_GT82X_IIC_760
+#define TOUCH_ENABLE_PIN        INVALID_GPIO
+#define TOUCH_RESET_PIN  RK2928_PIN3_PD5
+#define TOUCH_INT_PIN    RK2928_PIN3_PC7
+int goodix_init_platform_hw(void)
+{
+        int ret;
+
+
+    
+  
+        if (TOUCH_ENABLE_PIN != INVALID_GPIO) {
+                ret = gpio_request(TOUCH_ENABLE_PIN, "goodix power pin");
+                if (ret != 0) {
+                        gpio_free(TOUCH_ENABLE_PIN);
+                        printk("goodix power error\n");
+                        return -EIO;
+                }
+                gpio_direction_output(TOUCH_ENABLE_PIN, 0);
+                gpio_set_value(TOUCH_ENABLE_PIN, GPIO_LOW);
+                msleep(100);
+        }
+
+        if (TOUCH_RESET_PIN != INVALID_GPIO) {
+                ret = gpio_request(TOUCH_RESET_PIN, "goodix reset pin");
+                if (ret != 0) {
+                        gpio_free(TOUCH_RESET_PIN);
+                        printk("goodix gpio_request error\n");
+                        return -EIO;
+                }
+                gpio_direction_output(TOUCH_RESET_PIN, 0);
+                gpio_set_value(TOUCH_RESET_PIN, GPIO_LOW);
+                msleep(10);
+                gpio_set_value(TOUCH_RESET_PIN, GPIO_HIGH);
+                msleep(500);
+        }
+        return 0;
+}
+u8 ts82x_config_data[] = {
+        0x65,0x00,0x04,0x00,0x03,0x00,0x0A,0x0D,0x1E,0xE7,
+        0x32,0x03,0x08,0x10,0x48,0x42,0x42,0x20,0x00,0x01,
+        0x60,0x60,0x4B,0x6E,0x0E,0x0D,0x0C,0x0B,0x0A,0x09,
+        0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x1D,
+        0x1C,0x1B,0x1A,0x19,0x18,0x17,0x16,0x15,0x14,0x13,
+        0x12,0x11,0x10,0x0F,0x50,0x00,0x00,0x00,0x00,0x00,
+        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2B,0x00,0x00,
+        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+        0x00,0x00,0x00,0x00
+};
+static struct goodix_i2c_rmi_platform_data ts82x_pdata = {
+    .gpio_shutdown = TOUCH_ENABLE_PIN,
+    .gpio_irq = TOUCH_INT_PIN,
+    .gpio_reset = TOUCH_RESET_PIN,
+    .irq_edge = 1, /* 0:rising edge, 1:falling edge */
+
+    .ypol = 1,
+        .swap_xy = 1,
+        .xpol = 0,
+        .xmax = 1024,
+    .ymax = 600,
+    .config_info_len =ARRAY_SIZE(ts82x_config_data),
+    .config_info = ts82x_config_data,
+        .init_platform_hw= goodix_init_platform_hw,
+};
+#endif
+#ifdef CONFIG_FB_ROCKCHIP
+#define LCD_STB
+#ifdef LCD_STB
+#define LCD_STB_MUX_NAME  GPIO1A3_I2S_LRCKTX_NAME
+#define LCD_STB_GPIO_MODE GPIO1A_GPIO1A3
+
+#define LCD_STB_EN        RK2928_PIN1_PA3
+#define LCD_STB_EN_VALUE  GPIO_HIGH
+#endif
+#define LCD_MUX_NAME  GPIO0D4_PWM_2_NAME
+#define LCD_GPIO_MODE GPIO0D_GPIO0D4
+
+#define LCD_EN        RK2928_PIN0_PD4
+#define LCD_EN_VALUE  GPIO_LOW
+static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
+{
+	int ret = 0;
+
+   	 rk30_mux_api_set(LCD_MUX_NAME, LCD_GPIO_MODE);
+	ret = gpio_request(LCD_EN, NULL);
+	if (ret != 0)
+	{
+		gpio_free(LCD_EN);
+		printk(KERN_ERR "request lcd en pin fail!\n");
+		return -1;
+	}
+	else
+	{
+		gpio_direction_output(LCD_EN, LCD_EN_VALUE); //disable
+	}
+	         rk30_mux_api_set(LCD_STB_MUX_NAME, LCD_STB_GPIO_MODE);
+        ret = gpio_request(LCD_STB_EN, NULL);
+        if (ret != 0)
+        {
+                gpio_free(LCD_STB_EN);
+                printk(KERN_ERR "request lcd en pin fail!\n");
+                return -1;
+        }
+        else
+        {
+                gpio_direction_output(LCD_STB_EN, LCD_STB_EN_VALUE); //disable
+        }
+
+	return 0;
+}
+static int rk_fb_io_disable(void)
+{
+    	gpio_set_value(LCD_EN, !LCD_EN_VALUE);
+	mdelay(50);
+#ifdef LCD_STB
+	gpio_set_value(LCD_STB_EN,GPIO_LOW);
+#endif
+	return 0;
+}
+static int rk_fb_io_enable(void)
+{
+#ifdef LCD_STB
+	gpio_set_value(LCD_STB_EN,GPIO_HIGH);
+#endif
+	gpio_set_value(LCD_EN, LCD_EN_VALUE);
+	mdelay(200);
+	return 0;
+}
+
+#if defined(CONFIG_LCDC_RK2928)
+struct rk29fb_info lcdc_screen_info = {
+	.prop	   = PRMRY,		//primary display device
+	.io_init   = rk_fb_io_init,
+	.io_disable = rk_fb_io_disable,
+	.io_enable = rk_fb_io_enable,
+	.set_screen_info = set_lcd_info,
+};
+#endif
+
+static struct resource resource_fb[] = {
+	[0] = {
+		.name  = "fb0 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name  = "ipp buf",  //for rotate
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.name  = "fb2 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device device_fb = {
+	.name		= "rk-fb",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resource_fb),
+	.resource	= resource_fb,
+};
+#endif
+
+//LCDC
+#ifdef CONFIG_LCDC_RK2928
+static struct resource resource_lcdc[] = {
+	[0] = {
+		.name  = "lcdc reg",
+		.start = RK2928_LCDC_PHYS,
+		.end   = RK2928_LCDC_PHYS + RK2928_LCDC_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	
+	[1] = {
+		.name  = "lcdc irq",
+		.start = IRQ_LCDC,
+		.end   = IRQ_LCDC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device device_lcdc = {
+	.name		  = "rk2928-lcdc",
+	.id		  = 0,
+	.num_resources	  = ARRAY_SIZE(resource_lcdc),
+	.resource	  = resource_lcdc,
+	.dev 		= {
+		.platform_data = &lcdc_screen_info,
+	},
+};
+#endif
+
+#ifdef CONFIG_ION
+#define ION_RESERVE_SIZE        (80 * SZ_1M)
+static struct ion_platform_data rk30_ion_pdata = {
+	.nr = 1,
+	.heaps = {
+		{
+			.type = ION_HEAP_TYPE_CARVEOUT,
+			.id = ION_NOR_HEAP_ID,
+			.name = "norheap",
+			.size = ION_RESERVE_SIZE,
+		}
+	},
+};
+
+static struct platform_device device_ion = {
+	.name = "ion-rockchip",
+	.id = 0,
+	.dev = {
+		.platform_data = &rk30_ion_pdata,
+	},
+};
+#endif
+#if CONFIG_ANDROID_TIMED_GPIO
+static struct timed_gpio timed_gpios[] = {
+        {
+                .name = "vibrator",
+                .gpio = RK2928_PIN3_PD6,
+                .max_timeout = 1000,
+                .active_low = 0,
+                .adjust_time =20,      //adjust for diff product
+        },
+};
+
+struct timed_gpio_platform_data rk29_vibrator_info = {
+        .num_gpios = 1,
+        .gpios = timed_gpios,
+};
+
+struct platform_device rk29_device_vibrator ={
+        .name = "timed-gpio",
+        .id = -1,
+        .dev = {
+                .platform_data = &rk29_vibrator_info,
+                },
+
+};
+#endif
+
+
+#if defined (CONFIG_TP_760_TS)
+
+#define TOUCH_RESET_PIN RK2928_PIN3_PD5
+#define TOUCH_INT_PIN   RK2928_PIN3_PC7
+int ft5306_init_platform_hw(void)
+{
+	
+	if(gpio_request(TOUCH_RESET_PIN,NULL) != 0)
+	{
+		gpio_free(TOUCH_RESET_PIN);
+		printk("ft5306_init_platform_hw TOUCH_RESET_PIN error\n");
+		return -EIO;
+	}
+
+	if(gpio_request(TOUCH_INT_PIN,NULL) != 0)
+	{
+		gpio_free(TOUCH_INT_PIN);
+		printk("ift5306_init_platform_hw TOUCH_INT_PIN error\n");
+		return -EIO;
+	}
+	gpio_direction_input(TOUCH_INT_PIN);
+	gpio_direction_output(TOUCH_RESET_PIN, 1);
+	gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+	msleep(50);
+	msleep(300);
+	return 0;
+	
+}
+
+void ft5306_exit_platform_hw(void)
+{
+	gpio_free(TOUCH_RESET_PIN);
+	gpio_free(TOUCH_INT_PIN);
+}
+
+int ft5306_platform_sleep(void)
+{
+	gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+	return 0;
+}
+
+int ft5306_platform_wakeup(void)
+{
+	//gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+	//msleep(10);
+	gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+	msleep(300);
+	return 0;
+}
+
+struct ft5306_platform_data ft5306_info = {
+  .irq_pin = TOUCH_INT_PIN,
+  .rest_pin = TOUCH_RESET_PIN,
+  .init_platform_hw= ft5306_init_platform_hw,
+  .exit_platform_hw= ft5306_exit_platform_hw,
+  .platform_sleep  = ft5306_platform_sleep,
+  .platform_wakeup = ft5306_platform_wakeup,
+
+};
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_BYD693X)
+
+#define TOUCH_RESET_PIN RK2928_PIN3_PD5
+#define TOUCH_INT_PIN   RK2928_PIN3_PC7
+struct byd_platform_data byd693x_info = {
+	.int_pin = TOUCH_INT_PIN,
+	.rst_pin = TOUCH_RESET_PIN,
+	.screen_max_x = 800,
+	.screen_max_y = 480,
+	.xpol = -1,
+};
+#endif
+
+/*MMA7660 gsensor*/
+#if defined (CONFIG_GS_MMA7660)
+#define MMA7660_INT_PIN   RK2928_PIN3_PD1
+static int mma7660_init_platform_hw(void)
+{
+	//rk30_mux_api_set(GPIO1B1_SPI_TXD_UART1_SOUT_NAME, GPIO1B_GPIO1B1);
+
+	return 0;
+}
+
+static struct sensor_platform_data mma7660_info = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+        .init_platform_hw = mma7660_init_platform_hw,
+        .orientation = {1, 0, 0, 0, -1,0, 0, 0, -1},
+};
+#endif
+
+
+#if defined (CONFIG_GS_KXTIK)
+#define KXTIK_INT_PIN         RK2928_PIN3_PD1
+
+static struct sensor_platform_data kxtik_pdata = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 60,
+	.orientation = {-1, 0, 0, 0, 0, -1, 0, 1, 0},
+};
+
+#endif /* CONFIG_GS_KXTIK*/
+
+#if defined (CONFIG_GS_MM3A310)
+#define MM3A310_INT_PIN         RK2928_PIN3_PD1
+
+static struct sensor_platform_data mm3a310_pdata = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+	.orientation = {-1, 0, 0, 0, 0, -1, 0, 1, 0},
+};
+
+#endif /* CONFIG_GS_MM3A310*/
+
+
+#ifdef CONFIG_LS_AP321XX
+#define LS_AP321XX_INT_PIN         RK2928_PIN0_PC6
+
+static struct sensor_platform_data ls_ap321xx_info = {
+	.type = SENSOR_TYPE_LIGHT,
+	.irq_enable = 1,
+	.poll_delay_ms = 500,
+};
+#endif
+#ifdef CONFIG_PS_AP321XX
+#define PS_AP321XX_INT_PIN         RK2928_PIN0_PC6
+
+static struct sensor_platform_data ps_ap321xx_info = {
+	.type = SENSOR_TYPE_PROXIMITY,
+	.irq_enable = 1,
+	.poll_delay_ms = 500,
+};
+#endif
+
+#if defined(CONFIG_BATTERY_RK30_ADC)||defined(CONFIG_BATTERY_RK30_ADC_FAC)
+#define   CHARGE_OK_PIN  RK2928_PIN3_PD2
+#define   DC_DET_PIN     RK2928_PIN3_PD3
+#define   DC_CUR_SET_PIN RK2928_PIN1_PA0
+static int ac_current = -1;
+#define CHARING_CURRENT_500MA 0
+#define CHARING_CURRENT_1000MA 1
+int rk30_battery_adc_io_init(void){
+	int ret = 0;
+		
+	//dc charge detect pin
+	ret = gpio_request(DC_DET_PIN, NULL);
+	if (ret) {
+		printk("failed to request dc_det gpio\n");
+		return ret ;
+	}
+
+	gpio_pull_updown(DC_DET_PIN, 1);//important
+	ret = gpio_direction_input(DC_DET_PIN);
+	if (ret) {
+		printk("failed to set gpio dc_det input\n");
+		return ret ;
+	}
+	
+	//charge ok pin
+	ret = gpio_request(CHARGE_OK_PIN, NULL);
+	if (ret) {
+		printk("failed to request charge_ok gpio\n");
+		return ret ;
+	}
+
+	gpio_pull_updown(CHARGE_OK_PIN, 1);//important
+	ret = gpio_direction_input(CHARGE_OK_PIN);
+	if (ret) {
+		printk("failed to set gpio charge_ok input\n");
+		return ret ;
+	}
+
+	//charge current set pin
+	ret = gpio_request(DC_CUR_SET_PIN, NULL);
+	if (ret) {
+		printk("failed to request DC_CUR_SET_PIN gpio\n");
+		return ret ;
+	}
+
+	ret = gpio_direction_output(DC_CUR_SET_PIN, GPIO_LOW);//500ma
+	if (ret) {
+		printk("failed to set gpio DC_CUR_SET_PIN output\n");
+		return ret ;
+	}
+	printk("charging: set charging current 500ma\n");
+	ac_current = CHARING_CURRENT_500MA;
+
+	gpio_request(BL_EN_PIN, NULL);
+	
+	return 0;
+
+}
+
+static int set_ac_charging_current(void)
+{
+	if (gpio_get_value(BL_EN_PIN) && (ac_current==CHARING_CURRENT_1000MA)) {
+		printk("charging: set charging current 500ma\n");
+		gpio_set_value(DC_CUR_SET_PIN, GPIO_LOW);
+		ac_current = CHARING_CURRENT_500MA;
+	}
+	else if (!gpio_get_value(BL_EN_PIN) && (ac_current==CHARING_CURRENT_500MA)) {
+		printk("charging: set charging current 1000ma\n");
+		gpio_set_value(DC_CUR_SET_PIN, GPIO_HIGH);
+		ac_current = CHARING_CURRENT_1000MA;
+	}
+}
+
+static struct rk30_adc_battery_platform_data rk30_adc_battery_platdata = {
+        .dc_det_pin      = DC_DET_PIN,
+        .batt_low_pin    = INVALID_GPIO,
+        .charge_set_pin  = INVALID_GPIO,
+        .charge_ok_pin   = CHARGE_OK_PIN,
+        .dc_det_level    = GPIO_LOW,  //
+        .charge_ok_level = GPIO_HIGH,
+		//.control_ac_charging_current = set_ac_charging_current,
+		.save_capacity = 1,
+	    .is_reboot_charging = 1,
+        .io_init = rk30_battery_adc_io_init,
+};
+
+static struct platform_device rk30_device_adc_battery = {
+        .name   = "rk30-battery",
+        .id     = -1,
+        .dev = {
+                .platform_data = &rk30_adc_battery_platdata,
+        },
+};
+#endif
+
+
+#if CONFIG_RK30_PWM_REGULATOR
+const static int pwm_voltage_map[] = {
+	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000, 1400000
+};
+
+static struct regulator_consumer_supply pwm_dcdc1_consumers[] = {
+	{
+		.supply = "vdd_core",
+	}
+};
+
+struct regulator_init_data pwm_regulator_init_dcdc[1] =
+{
+	{
+		.constraints = {
+			.name = "PWM_DCDC1",
+			.min_uV = 600000,
+			.max_uV = 1800000,	//0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc1_consumers),
+		.consumer_supplies = pwm_dcdc1_consumers,
+	},
+};
+
+static struct pwm_platform_data pwm_regulator_info[1] = {
+	{
+		.pwm_id = 2,
+		.pwm_gpio = RK2928_PIN0_PD4,
+		.pwm_iomux_name = GPIO0D4_PWM_2_NAME,
+		.pwm_iomux_pwm = GPIO0D_PWM_2, 
+		.pwm_iomux_gpio = GPIO0D_GPIO0D4,
+		.pwm_voltage = 1200000,
+		.suspend_voltage = 1050000,
+		.min_uV = 1000000,
+		.max_uV	= 1400000,
+		.coefficient = 504,	//50.4%
+		.pwm_voltage_map = pwm_voltage_map,
+		.init_data	= &pwm_regulator_init_dcdc[0],
+	},
+};
+
+struct platform_device pwm_regulator_device[1] = {
+	{
+		.name = "pwm-voltage-regulator",
+		.id = 0,
+		.dev		= {
+			.platform_data = &pwm_regulator_info[0],
+		}
+	},
+};
+#endif
+
+/***********************************************************
+*	usb wifi
+************************************************************/
+#if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) || defined(CONFIG_RT5370)
+#define WIFI_POWER_EN_MUX_NAME     GPIO0B0_MMC1_CMD_NAME
+#define WIFI_POWER_EN_MUX_MODE    GPIO0B_GPIO0B0
+#define WIFI_POWER_EN_PIN         RK2928_PIN0_PB0
+#define WIFI_POWER_EN_VALUE       GPIO_LOW
+static int rkusb_wifi_init = 0;
+static void rkusb_wifi_power_io_init(void)
+{
+	int ret = 0;
+	
+	if(rkusb_wifi_init)
+		return;
+        rk30_mux_api_set(WIFI_POWER_EN_MUX_NAME, WIFI_POWER_EN_MUX_MODE);
+
+        ret = gpio_request(WIFI_POWER_EN_PIN, NULL);
+        if (ret != 0) {
+		printk("rkusb_wifi_power_io_init fail!!!!!\n");
+                gpio_free(WIFI_POWER_EN_PIN);
+        }
+
+        gpio_direction_output(WIFI_POWER_EN_PIN, 0);
+        gpio_set_value(WIFI_POWER_EN_PIN, GPIO_HIGH);
+	rkusb_wifi_init = 1;
+}
+static void rkusb_wifi_power(int on) {
+#if 0
+	struct regulator *ldo = NULL;
+	
+#if defined(CONFIG_MFD_TPS65910)	
+	if(pmic_is_tps65910()) {
+		ldo = regulator_get(NULL, "vmmc");  //vccio_wl
+	}
+#endif
+#if defined(CONFIG_REGULATOR_ACT8931)
+	if(pmic_is_act8931()) {
+		ldo = regulator_get(NULL, "act_ldo4");  //vccio_wl
+	}
+#endif	
+	
+	if(on) {
+		regulator_enable(ldo);
+		printk("%s: vccio_wl enable\n", __func__);
+	} else {
+		printk("%s: vccio_wl disable\n", __func__);
+		regulator_disable(ldo);
+	}
+	
+	regulator_put(ldo);
+	udelay(100);
+#else
+	rkusb_wifi_power_io_init();
+     	if(on)
+      	{
+		 printk("usb wifi power on!!\n");
+        	 gpio_set_value(WIFI_POWER_EN_PIN,GPIO_LOW);
+      	}
+      	else
+	{	
+		printk("usb wifi power down!!\n");
+		gpio_set_value(WIFI_POWER_EN_PIN,GPIO_HIGH);
+	}
+#endif
+}
+
+#endif
+#if defined(CONFIG_MODEM_SOUND)
+struct modem_sound_data modem_sound_info = {
+	.spkctl_io = RK2928_PIN3_PD4,
+	.spkctl_active = GPIO_HIGH,
+};
+
+struct platform_device modem_sound_device = {
+	.name = "modem_sound",
+	.id = -1,
+	.dev		= {
+	.platform_data = &modem_sound_info,
+		}
+	};
+#endif
+
+int rk2928_sd_vcc_reset(){
+      struct regulator *vcc;
+
+      vcc = regulator_get(NULL,"act_ldo4");
+      if (vcc == NULL || IS_ERR(vcc) ){
+            printk("%s get cif vaux33 ldo failed!\n",__func__);
+            return -1 ;
+      }
+
+       printk("hj---->rk29_sdmmc_hw_init get vmmc regulator successfully \n\n\n");
+       regulator_disable(vcc);
+       mdelay(2000);
+       regulator_enable(vcc);
+
+}
+/**************************************************************************************************
+ * SDMMC devices,  include the module of SD,MMC,and SDIO.noted by xbw at 2012-03-05
+**************************************************************************************************/
+
+#ifdef CONFIG_RFKILL_RK
+// bluetooth rfkill device, its driver in net/rfkill/rfkill-rk.c
+static struct rfkill_rk_platform_data rfkill_rk_platdata = {
+    .type           = RFKILL_TYPE_BLUETOOTH,
+    .poweron_gpio   = { // BT_REG_ON
+        .io             = RK2928_PIN1_PA3,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = NULL,
+            },
+        },
+
+    .reset_gpio     = { // BT_RST
+        .io             = RK2928_PIN3_PD5, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_LOW,
+        .iomux          = {
+            .name           = NULL,
+            },
+        },
+
+    .wake_gpio      = { // BT_WAKE, use to control bt's sleep and wakeup
+        .io             = RK2928_PIN0_PC6, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name           = NULL,
+            },
+        },
+
+    .wake_host_irq  = { // BT_HOST_WAKE, for bt wakeup host when it is in deep sleep
+        .gpio           = {
+            .io         = RK2928_PIN0_PC5, // set io to INVALID_GPIO for disable it
+            .enable     = GPIO_LOW,      // set GPIO_LOW for falling, set 0 for rising
+            .iomux      = {
+                .name       = NULL,
+            },
+        },
+    },
+
+    .rts_gpio       = { // UART_RTS, enable or disable BT's data coming
+        .io         = RK2928_PIN0_PC3, // set io to INVALID_GPIO for disable it
+        .enable      = GPIO_LOW,
+        .iomux      = {
+           .name        = GPIO0C3_UART0_CTSN_NAME,
+           .fgpio       = GPIO0C_GPIO0C3,
+           .fmux        = GPIO0C_UART0_RTSN,//GPIO0C_UART0_CTSN,
+            },
+        },
+};
+
+static struct platform_device device_rfkill_rk = {
+    .name   = "rfkill_rk",
+    .id     = -1,
+    .dev    = {
+        .platform_data = &rfkill_rk_platdata,
+        },
+};
+#endif
+#ifdef CONFIG_SDMMC_RK29
+#include "board-rk2928-phonepad-sdmmc.c"
+#endif
+
+#ifdef CONFIG_SDMMC0_RK29
+static int rk29_sdmmc0_cfg_gpio(void)
+{
+#ifdef CONFIG_SDMMC_RK29_OLD
+	rk30_mux_api_set(GPIO3B1_SDMMC0CMD_NAME, GPIO3B_SDMMC0_CMD);
+	rk30_mux_api_set(GPIO3B0_SDMMC0CLKOUT_NAME, GPIO3B_SDMMC0_CLKOUT);
+	rk30_mux_api_set(GPIO3B2_SDMMC0DATA0_NAME, GPIO3B_SDMMC0_DATA0);
+	rk30_mux_api_set(GPIO3B3_SDMMC0DATA1_NAME, GPIO3B_SDMMC0_DATA1);
+	rk30_mux_api_set(GPIO3B4_SDMMC0DATA2_NAME, GPIO3B_SDMMC0_DATA2);
+	rk30_mux_api_set(GPIO3B5_SDMMC0DATA3_NAME, GPIO3B_SDMMC0_DATA3);
+
+	rk30_mux_api_set(GPIO3B6_SDMMC0DETECTN_NAME, GPIO3B_GPIO3B6);
+
+	rk30_mux_api_set(GPIO3A7_SDMMC0PWREN_NAME, GPIO3A_GPIO3A7);
+	gpio_request(RK30_PIN3_PA7, "sdmmc-power");
+	gpio_direction_output(RK30_PIN3_PA7, GPIO_LOW);
+
+#else
+	    rk29_sdmmc_set_iomux(0, 0xFFFF);
+
+    #if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO)
+        rk30_mux_api_set(RK29SDK_SD_CARD_DETECT_PIN_NAME, RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO);
+    #else
+	    rk30_mux_api_set(RK29SDK_SD_CARD_DETECT_PIN_NAME, RK29SDK_SD_CARD_DETECT_IOMUX_FMUX);
+    #endif	
+
+    #if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	    gpio_request(SDMMC0_WRITE_PROTECT_PIN, "sdmmc-wp");
+	    gpio_direction_input(SDMMC0_WRITE_PROTECT_PIN);
+    #endif
+
+#endif
+
+	return 0;
+}
+
+#define CONFIG_SDMMC0_USE_DMA
+struct rk29_sdmmc_platform_data default_sdmmc0_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36),
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc0_cfg_gpio,
+
+#if !defined(CONFIG_SDMMC_RK29_OLD)
+	.set_iomux = rk29_sdmmc_set_iomux,
+#endif
+
+	.dma_name = "sd_mmc",
+#ifdef CONFIG_SDMMC0_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC) && defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+    .status = rk29sdk_wifi_mmc0_status,
+    .register_status_notify = rk29sdk_wifi_mmc0_status_register,
+#endif
+
+#if defined(RK29SDK_SD_CARD_PWR_EN) || (INVALID_GPIO != RK29SDK_SD_CARD_PWR_EN)
+    .power_en = RK29SDK_SD_CARD_PWR_EN,
+    .power_en_level = RK29SDK_SD_CARD_PWR_EN_LEVEL,
+#else
+    .power_en = INVALID_GPIO,
+    .power_en_level = GPIO_LOW,
+#endif    
+	.enable_sd_wakeup = 0,
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC0_WRITE_PROTECT_PIN,
+	.write_prt_enalbe_level = SDMMC0_WRITE_PROTECT_ENABLE_VALUE;
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+
+    .det_pin_info = {
+    #if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+        .io             = RK29SDK_SD_CARD_DETECT_N, //INVALID_GPIO,
+        .enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+        #ifdef RK29SDK_SD_CARD_DETECT_PIN_NAME
+        .iomux          = {
+            .name       = RK29SDK_SD_CARD_DETECT_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO
+            .fgpio      = RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FMUX
+            .fmux       = RK29SDK_SD_CARD_DETECT_IOMUX_FMUX,
+            #endif
+        },
+        #endif
+    #else
+        .io             = INVALID_GPIO,
+        .enable         = GPIO_LOW,
+    #endif    
+    }, 
+
+    //.setpower = rk29_sdmmc_board_setpower,
+};
+#endif // CONFIG_SDMMC0_RK29
+
+#ifdef CONFIG_SDMMC1_RK29
+#define CONFIG_SDMMC1_USE_DMA
+static int rk29_sdmmc1_cfg_gpio(void)
+{
+#if defined(CONFIG_SDMMC_RK29_OLD)
+	rk30_mux_api_set(GPIO3C0_SMMC1CMD_NAME, GPIO3C_SMMC1_CMD);
+	rk30_mux_api_set(GPIO3C5_SDMMC1CLKOUT_NAME, GPIO3C_SDMMC1_CLKOUT);
+	rk30_mux_api_set(GPIO3C1_SDMMC1DATA0_NAME, GPIO3C_SDMMC1_DATA0);
+	rk30_mux_api_set(GPIO3C2_SDMMC1DATA1_NAME, GPIO3C_SDMMC1_DATA1);
+	rk30_mux_api_set(GPIO3C3_SDMMC1DATA2_NAME, GPIO3C_SDMMC1_DATA2);
+	rk30_mux_api_set(GPIO3C4_SDMMC1DATA3_NAME, GPIO3C_SDMMC1_DATA3);
+#else
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC1_WRITE_PROTECT_PIN, "sdio-wp");
+	gpio_direction_input(SDMMC1_WRITE_PROTECT_PIN);
+#endif
+
+#endif
+
+	return 0;
+}
+
+struct rk29_sdmmc_platform_data default_sdmmc1_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34),
+
+#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+	.host_caps = (MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
+		      MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#else
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#endif
+
+	.io_init = rk29_sdmmc1_cfg_gpio,
+
+#if !defined(CONFIG_SDMMC_RK29_OLD)
+	.set_iomux = rk29_sdmmc_set_iomux,
+#endif
+
+	.dma_name = "sdio",
+#ifdef CONFIG_SDMMC1_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if defined(CONFIG_WIFI_CONTROL_FUNC) || defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC)
+    .status = rk29sdk_wifi_status,
+    .register_status_notify = rk29sdk_wifi_status_register,
+#endif
+
+    #if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+    	.write_prt = SDMMC1_WRITE_PROTECT_PIN,    	
+	    .write_prt_enalbe_level = SDMMC1_WRITE_PROTECT_ENABLE_VALUE;
+    #else
+    	.write_prt = INVALID_GPIO,
+    #endif
+
+    #if defined(CONFIG_RK29_SDIO_IRQ_FROM_GPIO)
+        .sdio_INT_gpio = RK29SDK_WIFI_SDIO_CARD_INT,
+    #endif
+
+    .det_pin_info = {    
+#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)    
+     #if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+        .io             = RK29SDK_SD_CARD_DETECT_N,
+     #else
+         .io             = INVALID_GPIO,
+     #endif   
+#else
+        .io             = INVALID_GPIO,
+#endif
+        .enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+        #ifdef RK29SDK_SD_CARD_DETECT_PIN_NAME
+        .iomux          = {
+            .name       = RK29SDK_SD_CARD_DETECT_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO
+            .fgpio      = RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FMUX
+            .fmux       = RK29SDK_SD_CARD_DETECT_IOMUX_FMUX,
+            #endif
+        },
+        #endif
+    }, 
+    
+	.enable_sd_wakeup = 0,
+};
+#endif //endif--#ifdef CONFIG_SDMMC1_RK29
+
+/**************************************************************************************************
+ * the end of setting for SDMMC devices
+**************************************************************************************************/
+#if defined(CONFIG_MT5931_MT6622)
+static struct mt6622_platform_data mt6622_platdata = {
+    .power_gpio         = { // BT_REG_ON
+        .io             = RK2928_PIN3_PC2, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = NULL,
+        },
+    },
+
+    .reset_gpio         = { // BT_RST
+        .io             = RK2928_PIN0_PC6,
+        .enable         = GPIO_LOW,
+        .iomux          = {
+            .name       = NULL,
+        },
+    },
+
+    .irq_gpio           = {
+        .io             = RK2928_PIN3_PD3,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = NULL,
+        },
+    }
+};
+
+static struct platform_device device_mt6622 = {
+    .name   = "mt6622",
+    .id     = -1,
+    .dev    = {
+        .platform_data = &mt6622_platdata,
+    },
+};
+#endif
+
+#if defined(CONFIG_SC6610)
+static int sc6610_io_init(void)
+{
+        
+        return 0;
+}
+
+static int sc6610_io_deinit(void)
+{
+        
+
+        return 0;
+}
+
+struct rk29_sc6610_data rk29_sc6610_info = {
+        .io_init = sc6610_io_init,
+        .io_deinit = sc6610_io_deinit,
+        .bp_power = RK2928_PIN3_PC2,//RK29_PIN0_PB4,
+        .bp_reset = INVALID_GPIO,//RK29_PIN0_PB3,
+        .bp_wakeup_ap = RK2928_PIN3_PC3,//RK29_PIN0_PC2,
+        .ap_wakeup_bp = RK2928_PIN3_PC4,//RK29_PIN0_PB0, 
+        .modem_assert = RK2928_PIN3_PC5,
+};
+struct platform_device rk29_device_sc6610 = {
+        .name = "SC6610",
+        .id = -1,
+        .dev            = {
+                .platform_data = &rk29_sc6610_info,
+        }
+    };
+#endif
+
+#if defined(CONFIG_BP_AUTO)
+
+static int bp_io_deinit(void)
+{
+	
+	return 0;
+}
+ 
+static int bp_io_init(void)
+{
+	rk30_mux_api_set(GPIO0D6_MMC1_PWREN_NAME, GPIO0D_GPIO0D6);//AP_STATUS
+	rk30_mux_api_set(GPIO0B6_MMC1_D3_NAME, GPIO0B_GPIO0B6);//mdm_rst
+	rk30_mux_api_set(GPIO0D0_UART2_RTSN_NAME, GPIO0D_GPIO0D0);//mdm_ready
+         return 0;
+}
+
+static int bp_id_get(void)
+{
+	return ap_mdm;   //internally 3G modem ID, defined in  include\linux\Bp-auto.h
+}
+struct bp_platform_data bp_auto_info = {	
+	.init_platform_hw 	= bp_io_init,	
+	.exit_platform_hw 	= bp_io_deinit,	
+	.get_bp_id              = bp_id_get,
+	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp	= RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.bp_assert		= RK2928_PIN3_PC5,	
+	.gpio_valid 		= 0,		//if 1:gpio is define in bp_auto_info,if 0:is not use gpio in bp_auto_info
+
+};
+
+struct platform_device device_bp_auto = {	
+        .name = "bp-auto",	
+    	.id = -1,	
+	.dev		= {
+		.platform_data = &bp_auto_info,
+	}    	
+    };
+#endif
+#if defined (CONFIG_RK_HEADSET_DET) || defined (CONFIG_RK_HEADSET_IRQ_HOOK_ADC_DET)
+static int rk_headset_io_init(int gpio, char *iomux_name, int iomux_mode)
+{
+	int ret;
+	ret = gpio_request(gpio, "headset_io");
+	if(ret) 
+		return ret;
+
+	rk30_mux_api_set(iomux_name, iomux_mode);
+	gpio_pull_updown(gpio, PullDisable);
+	gpio_direction_input(gpio);
+	mdelay(50);
+	return 0;
+};
+
+static int rk_hook_io_init(int gpio, char *iomux_name, int iomux_mode)
+{
+	int ret;
+	ret = gpio_request(gpio, "hook_io");
+	if(ret) 
+		return ret;
+
+	rk30_mux_api_set(iomux_name, iomux_mode);
+	gpio_pull_updown(gpio, PullDisable);
+	gpio_direction_input(gpio);
+	mdelay(50);
+	return 0;
+};
+
+struct rk_headset_pdata rk_headset_info = {
+		.Headset_gpio		= RK2928_PIN1_PB4,
+		.Hook_gpio  = RK2928_PIN0_PD1,
+		.Hook_down_type = HOOK_DOWN_HIGH,
+		.headset_in_type = HEADSET_IN_HIGH,
+		.hook_key_code = KEY_MEDIA,
+		.headset_gpio_info = {GPIO1B4_SPI_CSN1_NAME, GPIO1B_GPIO1B4},
+		.headset_io_init = rk_headset_io_init,
+		.hook_gpio_info = {GPIO0D1_UART2_CTSN_NAME, GPIO0D_GPIO0D1},
+		.hook_io_init = rk_hook_io_init,
+};
+struct platform_device rk_device_headset = {
+		.name	= "rk_headsetdet",
+		.id 	= 0,
+		.dev    = {
+			    .platform_data = &rk_headset_info,
+		}
+};
+#endif
+#ifdef CONFIG_SND_SOC_RK2928
+#define HP_CTL_MUX_NAME  GPIO1B6_MMC0_PWREN_NAME
+#define HP_CTL_MUX_MODE  GPIO1B_GPIO1B6
+#define HP_CTL_IO_NAME   RK2928_PIN1_PB6
+static int hpctl_io_init(void)
+{
+	int ret=0;
+
+	rk30_mux_api_set(HP_CTL_MUX_NAME, HP_CTL_MUX_MODE);
+	ret = gpio_request(HP_CTL_IO_NAME, NULL);
+        if (ret != 0) {
+        	gpio_free(HP_CTL_IO_NAME);
+		printk("HP_CTL_IO requeset fail\n");
+        }
+        else
+        {
+		gpio_direction_output(HP_CTL_IO_NAME, GPIO_LOW);
+	}
+	return ret;
+}
+struct rk2928_codec_pdata rk2928_codec_pdata_info={
+	.hpctl = HP_CTL_IO_NAME,
+	.hpctl_io_init = hpctl_io_init, 
+};
+static struct resource resources_acodec[] = {
+	{
+		.start 	= RK2928_ACODEC_PHYS,
+		.end 	= RK2928_ACODEC_PHYS + RK2928_ACODEC_SIZE - 1,
+		.flags 	= IORESOURCE_MEM,
+	},
+	{
+		.start	= RK2928_PIN3_PD4,
+		.end	= RK2928_PIN3_PD4,
+		.flags	= IORESOURCE_IO,
+	},
+};
+
+static struct platform_device device_acodec = {
+	.name	= "rk2928-codec",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resources_acodec),
+	.resource	= resources_acodec,
+	.dev    = {
+		    .platform_data = &rk2928_codec_pdata_info,
+	}	
+};
+#endif
+
+static struct platform_device *devices[] __initdata = {
+#ifdef CONFIG_FB_ROCKCHIP
+	&device_fb,
+#endif
+#ifdef CONFIG_LCDC_RK2928
+	&device_lcdc,
+#endif
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+	&rk29_device_backlight,
+#endif
+#ifdef CONFIG_ION
+	&device_ion,
+#endif
+#ifdef CONFIG_SND_SOC_RK2928
+	&device_acodec,
+#endif
+
+#if defined(CONFIG_BATTERY_RK30_ADC)||defined(CONFIG_BATTERY_RK30_ADC_FAC)
+ 	&rk30_device_adc_battery,
+#endif
+#if defined(CONFIG_SC6610)
+        &rk29_device_sc6610,
+
+#endif
+#if defined(CONFIG_BP_AUTO)
+	&device_bp_auto,
+#endif
+#if defined (CONFIG_RK_HEADSET_DET) ||  defined (CONFIG_RK_HEADSET_IRQ_HOOK_ADC_DET)
+	&rk_device_headset,
+#endif
+#if defined (CONFIG_MODEM_SOUND)
+ &modem_sound_device,
+#endif
+#ifdef CONFIG_ANDROID_TIMED_GPIO
+        &rk29_device_vibrator,
+#endif
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	&rk29sdk_wifi_device,
+#endif
+#ifdef CONFIG_MT5931_MT6622
+	&device_mt6622,
+#endif
+#ifdef CONFIG_RFKILL_RK
+	&device_rfkill_rk,
+#endif
+
+};
+//i2c
+#ifdef CONFIG_I2C0_RK30
+#ifdef CONFIG_MFD_TPS65910
+#define TPS65910_HOST_IRQ        RK2928_PIN3_PC6
+#include "board-rk2928-phonepad-tps65910.c"
+#endif
+#ifdef CONFIG_REGULATOR_ACT8931
+#define ACT8931_HOST_IRQ		RK2928_PIN1_PB2
+#include "board-rk2928-sdk-act8931.c"
+#endif
+
+static struct i2c_board_info __initdata i2c0_info[] = {
+#if defined (CONFIG_MFD_TPS65910)
+	{
+        .type           = "tps65910",
+        .addr           = TPS65910_I2C_ID0,
+        .flags          = 0,
+        .irq            = TPS65910_HOST_IRQ,
+    	.platform_data = &tps65910_data,
+	},
+#endif
+#if defined (CONFIG_REGULATOR_ACT8931)
+	{
+		.type    		= "act8931",
+		.addr           = 0x5b, 
+		.flags			= 0,
+		.irq            = ACT8931_HOST_IRQ,
+		.platform_data=&act8931_data,
+	},
+#endif
+};
+#endif
+#ifdef CONFIG_MACH_RK2926_M713
+int __sramdata gpio0d3_iomux,gpio0d3_do,gpio0d3_dir;
+#else
+int __sramdata gpio0d4_iomux,gpio0d4_do,gpio0d4_dir;
+#endif
+
+#define gpio0_readl(offset)	readl_relaxed(RK2928_GPIO0_BASE + offset)
+#define gpio0_writel(v, offset)	do { writel_relaxed(v, RK2928_GPIO0_BASE + offset); dsb(); } while (0)
+
+void __sramfunc rk30_pwm_logic_suspend_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+
+#ifdef CONFIG_MACH_RK2926_M713
+	sram_udelay(10000);
+	gpio0d3_iomux = readl_relaxed(GRF_GPIO0D_IOMUX);
+	gpio0d3_do = gpio0_readl(GPIO_SWPORTA_DR);
+	gpio0d3_dir = gpio0_readl(GPIO_SWPORTA_DDR);
+
+	writel_relaxed((gpio0d3_iomux |(1<<22)) & (~(1<<6)), GRF_GPIO0D_IOMUX);
+	gpio0_writel(gpio0d3_dir |(1<<27), GPIO_SWPORTA_DDR);
+	gpio0_writel(gpio0d3_do |(1<<27), GPIO_SWPORTA_DR);
+#else
+//	int gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
+	sram_udelay(10000);
+	gpio0d4_iomux = readl_relaxed(GRF_GPIO0D_IOMUX);
+	gpio0d4_do = gpio0_readl(GPIO_SWPORTA_DR);
+	gpio0d4_dir = gpio0_readl(GPIO_SWPORTA_DDR);
+
+	writel_relaxed((gpio0d4_iomux |(1<<24)) & (~(1<<8)), GRF_GPIO0D_IOMUX);
+	gpio0_writel(gpio0d4_dir |(1<<28), GPIO_SWPORTA_DDR);
+	gpio0_writel(gpio0d4_do |(1<<28), GPIO_SWPORTA_DR);
+#endif
+	
+#endif 
+}
+void __sramfunc rk30_pwm_logic_resume_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+#ifdef CONFIG_MACH_RK2926_M713
+	writel_relaxed((1<<22)|gpio0d3_iomux, GRF_GPIO0D_IOMUX);
+	gpio0_writel(gpio0d3_dir, GPIO_SWPORTA_DDR);
+	gpio0_writel(gpio0d3_do, GPIO_SWPORTA_DR);
+	sram_udelay(10000);
+#else
+	writel_relaxed((1<<24)|gpio0d4_iomux, GRF_GPIO0D_IOMUX);
+	gpio0_writel(gpio0d4_dir, GPIO_SWPORTA_DDR);
+	gpio0_writel(gpio0d4_do, GPIO_SWPORTA_DR);
+	sram_udelay(10000);
+        sram_udelay(10000);
+	sram_udelay(10000);
+
+#endif
+
+#endif
+
+}
+extern void pwm_suspend_voltage(void);
+extern void pwm_resume_voltage(void);
+void  rk30_pwm_suspend_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_suspend_voltage();
+#endif
+}
+void  rk30_pwm_resume_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_resume_voltage();
+#endif
+}
+
+void __sramfunc board_pmu_suspend(void)
+{      
+	#if defined (CONFIG_MFD_TPS65910)
+       if(pmic_is_tps65910())
+       board_pmu_tps65910_suspend(); 
+   	#endif   
+}
+void __sramfunc board_pmu_resume(void)
+{      
+	#if defined (CONFIG_MFD_TPS65910)
+       if(pmic_is_tps65910())
+       board_pmu_tps65910_resume(); 
+	#endif
+}
+
+#ifdef CONFIG_I2C1_RK30
+static struct i2c_board_info __initdata i2c1_info[] = {
+#if defined (CONFIG_GS_MMA7660)
+		{
+			.type		= "gs_mma7660",
+			.addr		= 0x4c,
+			.flags		= 0,
+			.irq		= MMA7660_INT_PIN,
+			.platform_data = &mma7660_info,
+		},
+#endif
+
+#if defined (CONFIG_GS_KXTIK)
+		{
+				.type		= "gs_kxtik",
+				.addr		= 0x0F,
+				.flags		= 0,
+				.platform_data = &kxtik_pdata,
+				.irq = KXTIK_INT_PIN, // Replace with appropriate GPIO setup
+		},
+#endif
+
+#if defined (CONFIG_GS_MM3A310)
+		{
+				.type		= "gs_mm3a310",
+				.addr		= 0x27,
+				.flags		= 0,
+				.platform_data = &mm3a310_pdata,
+				.irq = MM3A310_INT_PIN, // Replace with appropriate GPIO setup
+		},
+#endif
+
+#ifdef CONFIG_LS_AP321XX
+        {
+                .type                   = "ls_ap321xx",
+                .addr                   = 0x1E,
+                .flags                  = 0,
+                .irq                     = LS_AP321XX_INT_PIN,
+                .platform_data = &ls_ap321xx_info
+        },
+#endif
+
+#ifdef CONFIG_PS_AP321XX
+        {
+                .type                   = "ps_ap321xx",
+                .addr                   = 0x1E,
+                .flags                  = 0,
+                .irq                     = PS_AP321XX_INT_PIN,
+                .platform_data = &ps_ap321xx_info
+        },
+#endif
+
+#ifdef CONFIG_RDA5990
+#define RDA_WIFI_CORE_ADDR (0x13)
+#define RDA_WIFI_RF_ADDR (0x14) //correct add is 0x14
+#define RDA_BT_CORE_ADDR (0x15)
+#define RDA_BT_RF_ADDR (0x16)
+
+#define RDA_WIFI_RF_I2C_DEVNAME "rda_wifi_rf_i2c"
+#define RDA_WIFI_CORE_I2C_DEVNAME "rda_wifi_core_i2c"
+#define RDA_BT_RF_I2C_DEVNAME "rda_bt_rf_i2c"
+#define RDA_BT_CORE_I2C_DEVNAME "rda_bt_core_i2c"
+		{
+			.type          = RDA_WIFI_CORE_I2C_DEVNAME,
+			.addr          = RDA_WIFI_CORE_ADDR,
+                	.flags         = 0,
+
+		},
+
+		{
+			.type          = RDA_WIFI_RF_I2C_DEVNAME,
+			.addr          = RDA_WIFI_RF_ADDR,
+                	.flags         = 0,
+
+		},
+		{
+			.type          = RDA_BT_CORE_I2C_DEVNAME,
+			.addr          = RDA_BT_CORE_ADDR,
+                	.flags         = 0,
+
+		},
+		{
+			.type          = RDA_BT_RF_I2C_DEVNAME,
+			.addr          = RDA_BT_RF_ADDR,
+                	.flags         = 0,
+
+		},
+#endif
+
+};
+#endif
+#ifdef CONFIG_I2C2_RK30
+static struct i2c_board_info __initdata i2c2_info[] = {
+#if defined (CONFIG_TP_760_TS)
+	{
+		.type          = "ft5x0x_ts",
+		.addr          = 0x38,
+		.flags         = 0,
+		.irq           = TOUCH_INT_PIN,
+		.platform_data = &ft5306_info,
+	},
+#endif
+#if defined(CONFIG_TOUCHSCREEN_BYD693X)
+	{
+		.type          = "byd693x-ts",
+		.addr          = 0x52,
+		.flags         = 0,
+		.irq           = TOUCH_INT_PIN,
+		.platform_data = &byd693x_info,
+	},
+#endif
+#if defined(CONFIG_TOUCHSCREEN_GT82X_IIC_760)
+        {
+                .type          = "Goodix-TS-82X",
+                .addr          = 0x5D,
+                .flags         = 0,
+                .irq           = RK2928_PIN3_PC7,
+                .platform_data = &ts82x_pdata,
+        },
+#endif
+
+};
+#endif
+#ifdef CONFIG_I2C3_RK30
+static struct i2c_board_info __initdata i2c3_info[] = {
+};
+#endif
+#ifdef CONFIG_I2C_GPIO_RK30
+#define I2C_SDA_PIN     INVALID_GPIO   //set sda_pin here
+#define I2C_SCL_PIN     INVALID_GPIO   //set scl_pin here
+static int rk30_i2c_io_init(void)
+{
+        //set iomux (gpio) here
+
+        return 0;
+}
+struct i2c_gpio_platform_data default_i2c_gpio_data = {
+       .sda_pin = I2C_SDA_PIN,
+       .scl_pin = I2C_SCL_PIN,
+       .udelay = 5, // clk = 500/udelay = 100Khz
+       .timeout = 100,//msecs_to_jiffies(100),
+       .bus_num    = 5,
+       .io_init = rk30_i2c_io_init,
+};
+static struct i2c_board_info __initdata i2c_gpio_info[] = {
+};
+#endif
+static void __init rk30_i2c_register_board_info(void)
+{
+#ifdef CONFIG_I2C0_RK30
+	i2c_register_board_info(0, i2c0_info, ARRAY_SIZE(i2c0_info));
+#endif
+#ifdef CONFIG_I2C1_RK30
+	i2c_register_board_info(1, i2c1_info, ARRAY_SIZE(i2c1_info));
+#endif
+#ifdef CONFIG_I2C2_RK30
+	i2c_register_board_info(2, i2c2_info, ARRAY_SIZE(i2c2_info));
+#endif
+#ifdef CONFIG_I2C3_RK30
+	i2c_register_board_info(3, i2c3_info, ARRAY_SIZE(i2c3_info));
+#endif
+#ifdef CONFIG_I2C_GPIO_RK30
+	i2c_register_board_info(4, i2c_gpio_info, ARRAY_SIZE(i2c_gpio_info));
+#endif
+}
+//end of i2c
+
+#define POWER_ON_PIN RK2928_PIN1_PA2   //power_hold
+#if defined(CONFIG_REGULATOR_ACT8931)
+extern  int act8931_charge_det ;
+#endif
+static void rk2928_pm_power_off(void)
+{
+	printk(KERN_ERR "rk2928_pm_power_off start...\n");
+        #if defined(CONFIG_REGULATOR_ACT8931)
+        if(pmic_is_act8931())
+        {
+                 #ifdef CONFIG_BATTERY_RK30_ADC_FAC
+              if (gpio_get_value (rk30_adc_battery_platdata.dc_det_pin) == rk30_adc_battery_platdata.dc_det_level)//if(act8931_charge_det)
+		arm_pm_restart(0, NULL);
+				 #endif
+               act8931_device_shutdown();
+        }
+        #endif
+	
+	#if defined(CONFIG_MFD_TPS65910)
+	if(pmic_is_tps65910())
+	{
+		tps65910_device_shutdown();//tps65910 shutdown
+	}
+	#endif
+	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
+	
+};
+
+static void __init rk2928_board_init(void)
+{
+	gpio_request(POWER_ON_PIN, "poweronpin");
+	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
+	
+	pm_power_off = rk2928_pm_power_off;
+	
+	rk30_i2c_register_board_info();
+	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	rk29sdk_wifi_bt_gpio_control_init();
+#endif
+}
+
+static void __init rk2928_reserve(void)
+{
+#ifdef CONFIG_ION
+	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
+#endif
+#ifdef CONFIG_FB_ROCKCHIP
+	resource_fb[0].start = board_mem_reserve_add("fb0", RK30_FB0_MEM_SIZE);
+	resource_fb[0].end = resource_fb[0].start + RK30_FB0_MEM_SIZE - 1;
+#endif
+#ifdef CONFIG_VIDEO_RK29
+	rk30_camera_request_reserve_mem();
+#endif
+	board_mem_reserved();
+}
+/**
+ * dvfs_cpu_logic_table: table for arm and logic dvfs 
+ * @frequency	: arm frequency
+ * @cpu_volt	: arm voltage depend on frequency
+ * @logic_volt	: logic voltage arm requests depend on frequency
+ * comments	: min arm/logic voltage
+ */
+static struct dvfs_arm_table dvfs_cpu_logic_table[] = {
+	{.frequency = 216 * 1000,	.cpu_volt =  1200 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 312 * 1000,	.cpu_volt =  1200 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 408 * 1000,	.cpu_volt =  1200 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 504 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 600 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 696 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 816 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 912 * 1000,	.cpu_volt = 1450 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 1008 * 1000,	.cpu_volt = 1500 * 1000,	.logic_volt = 1200 * 1000},
+#if 0
+        {.frequency = 1104 * 1000,      .cpu_volt = 1400 * 1000,        .logic_volt = 1200 * 1000},
+        {.frequency = 1200 * 1000,      .cpu_volt = 1400 * 1000,        .logic_volt = 1200 * 1000},
+        {.frequency = 1104 * 1000,      .cpu_volt = 1400 * 1000,        .logic_volt = 1200 * 1000},
+        {.frequency = 1248 * 1000,      .cpu_volt = 1400 * 1000,        .logic_volt = 1200 * 1000},
+#endif
+        {.frequency = CPUFREQ_TABLE_END},
+
+};
+
+static struct cpufreq_frequency_table dvfs_gpu_table[] = {
+	{.frequency = 266 * 1000,	.index = 1200 * 1000},
+	{.frequency = 400 * 1000,	.index = 1275 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+static struct cpufreq_frequency_table dvfs_ddr_table[] = {
+	{.frequency = 300 * 1000,	.index = 1200 * 1000},
+	{.frequency = 400 * 1000,	.index = 1200 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+#define DVFS_CPU_TABLE_SIZE	(ARRAY_SIZE(dvfs_cpu_logic_table))
+static struct cpufreq_frequency_table cpu_dvfs_table[DVFS_CPU_TABLE_SIZE];
+static struct cpufreq_frequency_table dep_cpu2core_table[DVFS_CPU_TABLE_SIZE];
+
+void __init board_clock_init(void)
+{
+	rk2928_clock_data_init(periph_pll_default, codec_pll_default, RK30_CLOCKS_DEFAULT_FLAGS);
+	dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "gpu"), dvfs_gpu_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table);
+	printk("%s end\n", __func__);
+}
+
+
+MACHINE_START(RK2928, "RK2928board")
+	.boot_params	= PLAT_PHYS_OFFSET + 0x800,
+	.fixup		= rk2928_fixup,
+	.reserve	= &rk2928_reserve,
+	.map_io		= rk2928_map_io,
+	.init_irq	= rk2928_init_irq,
+	.timer		= &rk2928_timer,
+	.init_machine	= rk2928_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-rk2928/board-rk2928-phonepad-camera.c b/arch/arm/mach-rk2928/board-rk2928-phonepad-camera.c
index 496cc524180c..0b20e5dfe7c1 100755
--- a/arch/arm/mach-rk2928/board-rk2928-phonepad-camera.c
+++ b/arch/arm/mach-rk2928/board-rk2928-phonepad-camera.c
@@ -1,14 +1,14 @@
 #ifdef CONFIG_VIDEO_RK29
 /*---------------- Camera Sensor Macro Define Begin  ------------------------*/
 /*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
-#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5642						/* back camera sensor */
-#define CONFIG_SENSOR_IIC_ADDR_0		0
-#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  0
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_HM2057						/* back camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_0		0x48
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  1
 #define CONFIG_SENSOR_CIF_INDEX_0                    0
 #define CONFIG_SENSOR_ORIENTATION_0 	  90
 #define CONFIG_SENSOR_POWER_PIN_0		  INVALID_GPIO
 #define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_0 	        INVALID_GPIO//RK2928_PIN3_PB3
+#define CONFIG_SENSOR_POWERDN_PIN_0 	        RK2928_PIN3_PB3
 #define CONFIG_SENSOR_FALSH_PIN_0		  INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
@@ -93,14 +93,14 @@
 #define CONFIG_SENSOR_SVGA_FPS_FIXED_1		15000
 #define CONFIG_SENSOR_720P_FPS_FIXED_1		30000
 
-#define CONFIG_SENSOR_11 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 1 */
-#define CONFIG_SENSOR_IIC_ADDR_11 	    0x00
-#define CONFIG_SENSOR_IIC_ADAPTER_ID_11    3
+#define CONFIG_SENSOR_11 RK29_CAM_SENSOR_GC0329                      /* front camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_11 	    0x62
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_11    1
 #define CONFIG_SENSOR_CIF_INDEX_11				  0
 #define CONFIG_SENSOR_ORIENTATION_11       270
 #define CONFIG_SENSOR_POWER_PIN_11         INVALID_GPIO
 #define CONFIG_SENSOR_RESET_PIN_11         INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_11       INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_11       RK2928_PIN3_PD7
 #define CONFIG_SENSOR_FALSH_PIN_11         INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_11 RK29_CAM_POWERACTIVE_L
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_11 RK29_CAM_RESETACTIVE_L
@@ -159,8 +159,8 @@
 static void rk_cif_power(int on)
 {
     struct regulator *ldo_18,*ldo_28;
-	ldo_28 = regulator_get(NULL, "ldo7");	// vcc28_cif
-	ldo_18 = regulator_get(NULL, "ldo1");	// vcc18_cif
+	ldo_28 = regulator_get(NULL, "vaux1");	// vcc28_cif
+	ldo_18 = regulator_get(NULL, "vdig1");	// vcc18_cif
 	if (ldo_28 == NULL || IS_ERR(ldo_28) || ldo_18 == NULL || IS_ERR(ldo_18)){
         printk("get cif ldo failed!\n");
 		return;
diff --git a/arch/arm/mach-rk2928/board-rk2928-phonepad-key.c b/arch/arm/mach-rk2928/board-rk2928-phonepad-key.c
index 73248246e9a3..fc9b88db43af 100755
--- a/arch/arm/mach-rk2928/board-rk2928-phonepad-key.c
+++ b/arch/arm/mach-rk2928/board-rk2928-phonepad-key.c
@@ -16,20 +16,39 @@ static struct rk29_keys_button key_button[] = {
 		//.code_long_press = EV_ENCALL,
 		.wakeup	= 1,
 	},
+#if defined(CONFIG_MACH_RK2928_PHONEPAD_760)
 	{
 		.desc	= "vol+",
-		.code	= KEY_VOLUMEUP,
+		.code	= KEY_VOLUMEDOWN,
 		.gpio = INVALID_GPIO,
 		.adc_value	= 1,
 		.active_low = PRESS_LEV_LOW,
 	},
 	{
 		.desc	= "vol-",
-		.code	= KEY_VOLUMEDOWN,
+		.code	= KEY_VOLUMEUP,
 		.gpio = INVALID_GPIO,
 		.adc_value	= 512,
 		.active_low = PRESS_LEV_LOW,
 	},
+#else
+        {
+                .desc   = "vol+",
+                .code   = KEY_VOLUMEUP,
+                .gpio = INVALID_GPIO,
+                .adc_value      = 1,
+                .active_low = PRESS_LEV_LOW,
+        },
+        {
+                .desc   = "vol-",
+                .code   = KEY_VOLUMEDOWN,
+                .gpio = INVALID_GPIO,
+                .adc_value      = 512,
+                .active_low = PRESS_LEV_LOW,
+        },
+
+#endif
+
 };
 struct rk29_keys_platform_data rk29_keys_pdata = {
 	.buttons	= key_button,
diff --git a/arch/arm/mach-rk2928/board-rk2928-phonepad-sdmmc.c b/arch/arm/mach-rk2928/board-rk2928-phonepad-sdmmc.c
index ef301c9a2c31..b14b5bb33e6c 100644
--- a/arch/arm/mach-rk2928/board-rk2928-phonepad-sdmmc.c
+++ b/arch/arm/mach-rk2928/board-rk2928-phonepad-sdmmc.c
@@ -11,9 +11,991 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
+ * *
+ * History:
+ * ver1.0 add combo-wifi operateions. such as commit e049351a09c78db8a08aa5c49ce8eba0a3d6824e, at 2012-09-16
+ * ver2.0 Unify all the file versions of board_xxxx_sdmmc.c, at 2012-11-05
+ *
+ * Content:
+ * Part 1: define the gpio for SD-MMC-SDIO-Wifi functions according to your own projects.
+         ***********************************************************************************
+        * Please set the value according to your own project.
+        ***********************************************************************************
+ *
+ * Part 2: define the gpio for the SDMMC controller. Based on the chip datasheet.
+        ***********************************************************************************
+        * Please do not change, each platform has a fixed set.  !!!!!!!!!!!!!!!!!!
+        *  The system personnel will set the value depending on the specific arch datasheet,
+        *  such as RK29XX, RK30XX.
+        * If you have any doubt, please consult BangWang Xie.
+        ***********************************************************************************
+ *
+ *.Part 3: The various operations of the SDMMC-SDIO module
+        ***********************************************************************************
+        * Please do not change, each platform has a fixed set.  !!!!!!!!!!!!!!!!!!
+        * define the varaious operations for SDMMC module
+        * Generally only the author of SDMMC module will modify this section.
+        * If you have any doubt, please consult BangWang Xie.
+        ***********************************************************************************
+ *
+ *.Part 4: The various operations of the Wifi-BT module
+        ***********************************************************************************
+        * Please do not change, each module has a fixed set.  !!!!!!!!!!!!!!!!!!
+        * define the varaious operations for Wifi module
+        * Generally only the author of Wifi module will modify this section.
+        * If you have any doubt, please consult BangWang Xie, Weiguo Hu, and Weilong Gao.
+        ***********************************************************************************
+ *
  */
 
-#ifdef CONFIG_SDMMC_RK29
+//1.Part 1: define the gpio for SD-MMC-SDIO-Wifi functions  according to your own projects.
+
+/*************************************************************************
+* define the gpio for sd-sdio-wifi module
+*************************************************************************/
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+#define SDMMC0_WRITE_PROTECT_PIN	         RK30_PIN3_PB2	//According to your own project to set the value of write-protect-pin.
+#define SDMMC0_WRITE_PROTECT_ENABLE_VALUE    GPIO_HIGH
+#endif 
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+#define SDMMC1_WRITE_PROTECT_PIN	RK30_PIN3_PB3	//According to your own project to set the value of write-protect-pin.
+#define SDMMC1_WRITE_PROTECT_ENABLE_VALUE    GPIO_HIGH
+#endif
+    
+#if defined(CONFIG_RK29_SDIO_IRQ_FROM_GPIO)
+#define RK29SDK_WIFI_SDIO_CARD_INT         RK30_PIN3_PD2
+#endif
+
+//define the card-detect-pin.
+#if defined(CONFIG_ARCH_RK29)
+//refer to file /arch/arm/mach-rk29/include/mach/Iomux.h
+//define reset-pin
+#define RK29SDK_SD_CARD_DETECT_N                RK29_PIN2_PA2  //According to your own project to set the value of card-detect-pin.
+#define RK29SDK_SD_CARD_INSERT_LEVEL            GPIO_LOW         // set the voltage of insert-card. Please pay attention to the default setting.
+#define RK29SDK_SD_CARD_DETECT_PIN_NAME         GPIO2A2_SDMMC0DETECTN_NAME
+#define RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO      GPIO2L_GPIO2A2
+#define RK29SDK_SD_CARD_DETECT_IOMUX_FMUX       GPIO2L_SDMMC0_DETECT_N
+//define PowerEn-pin
+#define RK29SDK_SD_CARD_PWR_EN                  RK29_PIN5_PD5  
+#define RK29SDK_SD_CARD_PWR_EN_LEVEL            GPIO_LOW   
+#define RK29SDK_SD_CARD_PWR_EN_PIN_NAME         GPIO5D5_SDMMC0PWREN_NAME
+#define RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO      GPIO5H_GPIO5D5
+#define RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX       GPIO5H_SDMMC0_PWR_EN
+
+#elif defined(CONFIG_ARCH_RK3066B)
+//refer to file /arch/arm/mach-rk30/include/mach/iomux-rk3066b.h
+//define reset-pin
+#define RK29SDK_SD_CARD_DETECT_N                RK30_PIN3_PB0  //According to your own project to set the value of card-detect-pin.
+#define RK29SDK_SD_CARD_INSERT_LEVEL            GPIO_LOW         // set the voltage of insert-card. Please pay attention to the default setting.
+#define RK29SDK_SD_CARD_DETECT_PIN_NAME         GPIO3B0_SDMMC0DETECTN_NAME
+#define RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO      GPIO3B_GPIO3B0
+#define RK29SDK_SD_CARD_DETECT_IOMUX_FMUX       GPIO3B_SDMMC0_DETECT_N
+//define PowerEn-pin
+#define RK29SDK_SD_CARD_PWR_EN                  RK30_PIN3_PA1
+#define RK29SDK_SD_CARD_PWR_EN_LEVEL            GPIO_LOW 
+#define RK29SDK_SD_CARD_PWR_EN_PIN_NAME         GPIO3A1_SDMMC0PWREN_NAME
+#define RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO      GPIO3A_GPIO3A1
+#define RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX       GPIO3A_SDMMC0PWREN
+
+#elif defined(CONFIG_ARCH_RK30)&& !defined(CONFIG_ARCH_RK3066B) //for RK30,RK3066 SDK
+//refer to file /arch/arm/mach-rk30/include/mach/Iomux.h
+//define reset-pin
+#define RK29SDK_SD_CARD_DETECT_N                RK30_PIN3_PB6  //According to your own project to set the value of card-detect-pin.
+#define RK29SDK_SD_CARD_INSERT_LEVEL            GPIO_LOW         // set the voltage of insert-card. Please pay attention to the default setting.
+#define RK29SDK_SD_CARD_DETECT_PIN_NAME         GPIO3B6_SDMMC0DETECTN_NAME
+#define RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO      GPIO3B_GPIO3B6
+#define RK29SDK_SD_CARD_DETECT_IOMUX_FMUX       GPIO3B_SDMMC0_DETECT_N
+//define PowerEn-pin
+#define RK29SDK_SD_CARD_PWR_EN                  RK30_PIN3_PA7 
+#define RK29SDK_SD_CARD_PWR_EN_LEVEL            GPIO_LOW
+#define RK29SDK_SD_CARD_PWR_EN_PIN_NAME         GPIO3A7_SDMMC0PWREN_NAME
+#define RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO      GPIO3A_GPIO3A7
+#define RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX       GPIO3A_SDMMC0_PWR_EN
+
+#elif defined(CONFIG_ARCH_RK2928)
+//refer to file ./arch/arm/mach-rk2928/include/mach/iomux.h
+//define reset-pin
+    #if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO) && defined(CONFIG_MACH_RK2928_PHONEPAD)                           //for i30 no detect pin
+    //use gpio-interupt to dectec card in RK2926. Please pay attention to modify the default setting.
+    #define RK29SDK_SD_CARD_DETECT_N                INVALID_GPIO  //According to your own project to set the value of card-detect-pin.
+    #define RK29SDK_SD_CARD_INSERT_LEVEL            GPIO_LOW         // set the voltage of insert-card. Please pay attention to the default setting.
+    #define RK29SDK_SD_CARD_DETECT_PIN_NAME         GPIO2A7_NAND_DPS_EMMC_CLKOUT_NAME
+    #define RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO      GPIO2A_GPIO2A7
+    #define RK29SDK_SD_CARD_DETECT_IOMUX_FMUX       GPIO2A_EMMC_CLKOUT
+    #else
+	#define RK29SDK_SD_CARD_DETECT_N                RK2928_PIN1_PC1  //According to your own project to set the value of card-detect-pin.
+    #define RK29SDK_SD_CARD_INSERT_LEVEL            GPIO_LOW         // set the voltage of insert-card. Please pay attention to the default setting.
+    #define RK29SDK_SD_CARD_DETECT_PIN_NAME         GPIO1C1_MMC0_DETN_NAME
+    #define RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO      GPIO1C_GPIO1C1
+    #define RK29SDK_SD_CARD_DETECT_IOMUX_FMUX       GPIO1C_MMC0_DETN
+    #endif
+//define PowerEn-pin
+    #define RK29SDK_SD_CARD_PWR_EN                  INVALID_GPIO
+    //#define RK29SDK_SD_CARD_PWR_EN                  RK2928_PIN1_PB6
+    #define RK29SDK_SD_CARD_PWR_EN_LEVEL            GPIO_LOW 
+    //#define RK29SDK_SD_CARD_PWR_EN_PIN_NAME         GPIO1B6_MMC0_PWREN_NAME
+    //#define RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO      GPIO1B_GPIO1B6
+    //#define RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX       GPIO1B_MMC0_PWREN
+    #endif
+
+static void rk29_sdmmc_board_setpower(struct device *dev, char *regulator_supply_name)
+{
+#if !defined(RK29SDK_SD_CARD_PWR_EN) || (INVALID_GPIO == RK29SDK_SD_CARD_PWR_EN)
+        memset(regulator_supply_name, 0,4);
+#else
+    //set the PMU-LDO-supply name to NULL, if you use gpio to control power on-off.
+    memset(regulator_supply_name, 0,4);
+#endif
+}
+
+//
+// Define wifi module's power and reset gpio, and gpio sensitive level.
+// Please set the value according to your own project.
+//
+#if defined(CONFIG_ARCH_RK30) && !defined(CONFIG_ARCH_RK3066B) //for RK30,RK3066 SDK
+    #define WIFI_HOST_WAKE RK30_PIN3_PD2
+
+    #if defined(CONFIG_RK903) || defined(CONFIG_RK901) || defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU)
+    //power
+    #define RK30SDK_WIFI_GPIO_POWER_N               RK30_PIN3_PD0            
+    #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH        
+    //reset
+    #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME        GPIO3D0_SDMMC1PWREN_NAME
+    #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO     GPIO3D_GPIO3D0
+    
+    #elif defined(CONFIG_BCM4329) || defined(CONFIG_BCM4319) 
+    //power
+    #define RK30SDK_WIFI_GPIO_POWER_N               RK30_PIN3_PD0                 
+    #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH                   
+    #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME        GPIO3D0_SDMMC1PWREN_NAME
+    #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO     GPIO3D_GPIO3D0
+    //reset
+    #define RK30SDK_WIFI_GPIO_RESET_N               RK30_PIN3_PD1
+    #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE    GPIO_HIGH 
+    #define RK30SDK_WIFI_GPIO_RESET_PIN_NAME        GPIO3D1_SDMMC1BACKENDPWR_NAME
+    #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO     GPIO3D_GPIO3D1
+
+    #elif defined(CONFIG_MT6620)
+        #if !defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+            #define USE_SDMMC_CONTROLLER_FOR_WIFI 1
+        
+            #if defined(CONFIG_MACH_RK30_PHONE_PAD)     // define the gpio for MT6620 in RK30_PHONE_PAD project.
+                #define COMBO_MODULE_MT6620_CDT    0  //- 1--use Cdtech chip; 0--unuse CDT chip
+                //power, PMU_EN
+                #define RK30SDK_WIFI_GPIO_POWER_N                   RK30_PIN3_PC7            
+                #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE        GPIO_HIGH        
+                #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME            GPIO3C7_SDMMC1WRITEPRT_NAME
+                #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO         GPIO3C_GPIO3C7
+                #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FMUX          GPIO3C_SDMMC1_WRITE_PRT
+                //reset, DAIRST,SYSRST_B
+                #define RK30SDK_WIFI_GPIO_RESET_N                   RK30_PIN3_PD1
+                #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE        GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_RESET_PIN_NAME            GPIO3D1_SDMMC1BACKENDPWR_NAME
+                #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO         GPIO3D_GPIO3D1
+                #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FMUX          GPIO3D_SDMMC1_BACKEND_PWR
+                //VDDIO
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL                 RK30_PIN6_PB4
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL_ENABLE_VALUE    GPIO_HIGH       
+                //WIFI_INT_B
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B                RK30_PIN4_PD2
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_ENABLE_VALUE   GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_PIN_NAME       GPIO4D2_SMCDATA10_TRACEDATA10_NAME
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FGPIO    GPIO4D_GPIO4D2
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FMUX     GPIO4D_SMC_DATA10
+                //BGF_INT_B
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B                 RK30_PIN6_PA7
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_ENABLE_VALUE    GPIO_HIGH 
+                //#define RK30SDK_WIFI_GPIO_BGF_INT_B_PIN_NAME            GPIO3C6_SDMMC1DETECTN_NAME
+                //#define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FGPIO         GPIO3C_GPIO3C6
+                //#define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FMUX          GPIO3C_SDMMC1_DETECT_N
+                //GPS_SYNC
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC                  RK30_PIN3_PD0
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_ENABLE_VALUE     GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_PIN_NAME         GPIO3D0_SDMMC1PWREN_NAME
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FGPIO      GPIO3D_GPIO3D0
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FMUX       GPIO3D_SDMMC1_PWR_EN
+                
+            #elif defined(CONFIG_MACH_RK3066_M8000R)     // define the gpio for MT6620 in CONFIG_MACH_RK3066_M8000R project.
+                #define COMBO_MODULE_MT6620_CDT    1  //- 1--use Cdtech chip; 0--unuse CDT chip
+                //power, PMU_EN
+                #define RK30SDK_WIFI_GPIO_POWER_N                   RK30_PIN3_PC7            
+                #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE        GPIO_HIGH        
+                #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME            GPIO3C7_SDMMC1WRITEPRT_NAME
+                #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO         GPIO3C_GPIO3C7
+                #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FMUX          GPIO3C_SDMMC1_WRITE_PRT
+                //reset, DAIRST,SYSRST_B
+                #define RK30SDK_WIFI_GPIO_RESET_N                   RK30_PIN3_PD1
+                #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE        GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_RESET_PIN_NAME            GPIO3D1_SDMMC1BACKENDPWR_NAME
+                #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO         GPIO3D_GPIO3D1
+                #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FMUX          GPIO3D_SDMMC1_BACKEND_PWR
+                //VDDIO
+                #define RK30SDK_WIFI_GPIO_VCCIO_WL                  RK30_PIN0_PD2
+                #define RK30SDK_WIFI_GPIO_VCCIO_WL_ENABLE_VALUE     GPIO_HIGH
+                #define RK30SDK_WIFI_GPIO_VCCIO_WL_PIN_NAME         GPIO0D2_I2S22CHLRCKRX_SMCOEN_NAME
+                #define RK30SDK_WIFI_GPIO_VCCIO_WL_IOMUX_FGPIO      GPIO0D_GPIO0D2
+                #define RK30SDK_WIFI_GPIO_VCCIO_WL_IOMUX_FMUX       GPIO0D_I2S2_2CH_LRCK_RX
+                //WIFI_INT_B
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B                RK30_PIN3_PD2
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_ENABLE_VALUE   GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_PIN_NAME       GPIO3D2_SDMMC1INTN_NAME
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FGPIO    GPIO3D_GPIO3D2
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FMUX     GPIO3D_SDMMC1_INT_N
+                //BGF_INT_B
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B                 RK30_PIN6_PA7
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_ENABLE_VALUE    GPIO_HIGH 
+                //#define RK30SDK_WIFI_GPIO_BGF_INT_B_PIN_NAME        GPIO3C6_SDMMC1DETECTN_NAME
+                //#define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FGPIO     GPIO3C_GPIO3C6
+               // #define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FMUX      GPIO3C_SDMMC1_DETECT_N
+                //GPS_SYNC
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC                  RK30_PIN3_PD0
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_ENABLE_VALUE     GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_PIN_NAME         GPIO3D0_SDMMC1PWREN_NAME
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FGPIO      GPIO3D_GPIO3D0
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FMUX       GPIO3D_SDMMC1_PWR_EN
+
+                #if COMBO_MODULE_MT6620_CDT
+                //ANTSEL2
+                //#define RK30SDK_WIFI_GPIO_ANTSEL2                   RK30_PIN4_PD4
+                //#define RK30SDK_WIFI_GPIO_ANTSEL2_ENABLE_VALUE      GPIO_LOW    //use 6620 in CDT chip, LOW--work; High--no work.
+                //#define RK30SDK_WIFI_GPIO_ANTSEL2_PIN_NAME          GPIO4D4_SMCDATA12_TRACEDATA12_NAME
+                //#define RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FGPIO       GPIO4D_GPIO4D4
+                //#define RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FMUX        GPIO4D_TRACE_DATA12
+                //ANTSEL3
+                //#define RK30SDK_WIFI_GPIO_ANTSEL3                   RK30_PIN4_PD3
+                //#define RK30SDK_WIFI_GPIO_ANTSEL3_ENABLE_VALUE      GPIO_HIGH    //use 6620 in CDT chip, High--work; Low--no work..
+                //#define RK30SDK_WIFI_GPIO_ANTSEL3_PIN_NAME          GPIO4D3_SMCDATA11_TRACEDATA11_NAME
+                //#define RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FGPIO       GPIO4D_GPIO4D3
+                //#define RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FMUX        GPIO4D_TRACE_DATA11
+                //GPS_LAN
+                //#define RK30SDK_WIFI_GPIO_GPS_LAN                   RK30_PIN4_PD6
+                //#define RK30SDK_WIFI_GPIO_GPS_LAN_ENABLE_VALUE      GPIO_HIGH    //use 6620 in CDT chip, High--work; Low--no work..
+                //#define RK30SDK_WIFI_GPIO_GPS_LAN_PIN_NAME          GPIO4D6_SMCDATA14_TRACEDATA14_NAME
+                //#define RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FGPIO       GPIO4D_GPIO4D6
+                //#define RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FMUX        GPIO4D_TRACE_DATA14
+                #endif // #if COMBO_MODULE_MT6620_CDT--#endif
+                
+            #elif defined(CONFIG_MACH_SKYWORTH_T10_SDK)     // define the gpio for MT6620 in KYWORTH_T10 project.
+                #define COMBO_MODULE_MT6620_CDT    0  //- 1--use Cdtech chip; 0--unuse CDT chip
+                //power, PMU_EN
+                #define RK30SDK_WIFI_GPIO_POWER_N                   RK30_PIN3_PD0            
+                #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE        GPIO_HIGH        
+                #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME            GPIO3D0_SDMMC1PWREN_NAME
+                #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO         GPIO3D_GPIO3D0
+                #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FMUX          GPIO3D_SDMMC1_PWR_EN
+                //reset, DAIRST,SYSRST_B
+                #define RK30SDK_WIFI_GPIO_RESET_N                   RK30_PIN3_PD1
+                #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE        GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_RESET_PIN_NAME            GPIO3D1_SDMMC1BACKENDPWR_NAME
+                #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO         GPIO3D_GPIO3D1
+                #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FMUX          GPIO3D_SDMMC1_BACKEND_PWR
+                //VDDIO
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL                 RK30_PIN6_PB4
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL_ENABLE_VALUE    GPIO_HIGH       
+                //WIFI_INT_B
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B                RK30_PIN3_PD2
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_ENABLE_VALUE   GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_PIN_NAME       GPIO3D2_SDMMC1INTN_NAME
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FGPIO    GPIO3D_GPIO3D2
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FMUX     GPIO3D_SDMMC1_INT_N
+                //BGF_INT_B
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B                 RK30_PIN3_PC6
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_ENABLE_VALUE    GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_PIN_NAME        GPIO3C6_SDMMC1DETECTN_NAME
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FGPIO     GPIO3C_GPIO3C6
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FMUX      GPIO3C_SDMMC1_DETECT_N
+                //GPS_SYNC
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC                  RK30_PIN3_PC7
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_ENABLE_VALUE     GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_PIN_NAME         GPIO3C7_SDMMC1WRITEPRT_NAME
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FGPIO      GPIO3C_GPIO3C7
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FMUX       GPIO3C_SDMMC1_WRITE_PRT    
+            
+            #else //For exmpale, to define the gpio for MT6620 in RK30SDK project.
+                #define COMBO_MODULE_MT6620_CDT    1  //- 1--use Cdtech chip; 0--unuse CDT chip
+                //power
+                #define RK30SDK_WIFI_GPIO_POWER_N                   RK30_PIN3_PD0            
+                #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE        GPIO_HIGH        
+                #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME            GPIO3D0_SDMMC1PWREN_NAME
+                #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO         GPIO3D_GPIO3D0
+                #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FMUX          GPIO3D_SDMMC1_PWR_EN
+                //reset
+                #define RK30SDK_WIFI_GPIO_RESET_N                   RK30_PIN3_PD1
+                #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE        GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_RESET_PIN_NAME            GPIO3D1_SDMMC1BACKENDPWR_NAME
+                #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO         GPIO3D_GPIO3D1
+                #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FMUX          GPIO3D_SDMMC1_BACKEND_PWR
+                //VDDIO
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL                  RK30_PIN0_PD2
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL_ENABLE_VALUE     GPIO_HIGH
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL_PIN_NAME         GPIO0D2_I2S22CHLRCKRX_SMCOEN_NAME
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL_IOMUX_FGPIO      GPIO0D_GPIO0D2
+                //#define RK30SDK_WIFI_GPIO_VCCIO_WL_IOMUX_FMUX       GPIO0D_I2S2_2CH_LRCK_RX       
+                //WIFI_INT_B
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B                RK30_PIN3_PD2
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_ENABLE_VALUE   GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_PIN_NAME       GPIO3D2_SDMMC1INTN_NAME
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FGPIO    GPIO3D_GPIO3D2
+                #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FMUX     GPIO3D_SDMMC1_INT_N
+                //BGF_INT_B
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B                 RK30_PIN3_PC6
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_ENABLE_VALUE    GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_PIN_NAME        GPIO3C6_SDMMC1DETECTN_NAME
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FGPIO     GPIO3C_GPIO3C6
+                #define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FMUX      GPIO3C_SDMMC1_DETECT_N
+                //GPS_SYNC
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC                  RK30_PIN3_PC7
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_ENABLE_VALUE     GPIO_HIGH 
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_PIN_NAME         GPIO3C7_SDMMC1WRITEPRT_NAME
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FGPIO      GPIO3C_GPIO3C7
+                #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FMUX       GPIO3C_SDMMC1_WRITE_PRT
+
+                #if COMBO_MODULE_MT6620_CDT
+                //ANTSEL2
+                #define RK30SDK_WIFI_GPIO_ANTSEL2                   RK30_PIN4_PD4
+                #define RK30SDK_WIFI_GPIO_ANTSEL2_ENABLE_VALUE      GPIO_LOW    //use 6620 in CDT chip, LOW--work; High--no work.
+                #define RK30SDK_WIFI_GPIO_ANTSEL2_PIN_NAME          GPIO4D4_SMCDATA12_TRACEDATA12_NAME
+                #define RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FGPIO       GPIO4D_GPIO4D4
+                #define RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FMUX        GPIO4D_TRACE_DATA12
+                //ANTSEL3
+                #define RK30SDK_WIFI_GPIO_ANTSEL3                   RK30_PIN4_PD3
+                #define RK30SDK_WIFI_GPIO_ANTSEL3_ENABLE_VALUE      GPIO_HIGH    //use 6620 in CDT chip, High--work; Low--no work..
+                #define RK30SDK_WIFI_GPIO_ANTSEL3_PIN_NAME          GPIO4D3_SMCDATA11_TRACEDATA11_NAME
+                #define RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FGPIO       GPIO4D_GPIO4D3
+                #define RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FMUX        GPIO4D_TRACE_DATA11
+                //GPS_LAN
+                #define RK30SDK_WIFI_GPIO_GPS_LAN                   RK30_PIN4_PD6
+                #define RK30SDK_WIFI_GPIO_GPS_LAN_ENABLE_VALUE      GPIO_HIGH    //use 6620 in CDT chip, High--work; Low--no work..
+                #define RK30SDK_WIFI_GPIO_GPS_LAN_PIN_NAME          GPIO4D6_SMCDATA14_TRACEDATA14_NAME
+                #define RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FGPIO       GPIO4D_GPIO4D6
+                //#define RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FMUX        GPIO4D_TRACE_DATA14
+                #endif // #if COMBO_MODULE_MT6620_CDT--#endif
+            #endif
+        #endif// #endif --#if !defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+    #endif 
+#elif defined(CONFIG_ARCH_RK3066B)//refer to file /arch/arm/mach-rk30/include/mach/iomux-rk3066b.h
+    #define WIFI_HOST_WAKE RK30_PIN3_PD2
+     
+    #if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) 
+        #define RK30SDK_WIFI_GPIO_POWER_N               RK30_PIN3_PD0            
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH        
+        #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME        GPIO3D0_SDMMC1PWREN_MIIMD_NAME
+        #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO     GPIO3D_GPIO3D0
+        
+    #elif defined(CONFIG_BCM4329) || defined(CONFIG_BCM4319) || defined(CONFIG_RK903) || defined(CONFIG_RK901)
+        #define RK30SDK_WIFI_GPIO_POWER_N               RK30_PIN3_PD0                 
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH                   
+        #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME        GPIO3D0_SDMMC1PWREN_MIIMD_NAME
+        #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO     GPIO3D_GPIO3D0
+
+        #define RK30SDK_WIFI_GPIO_RESET_N               RK30_PIN2_PA7
+        #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE    GPIO_HIGH 
+        #define RK30SDK_WIFI_GPIO_RESET_PIN_NAME        GPIO2A7_LCDC1DATA7_SMCDATA7_TRACEDATA7_NAME
+        #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO     GPIO2A_GPIO2A7
+    #endif   
+#elif defined(CONFIG_ARCH_RK2928) //refer to file ./arch/arm/mach-rk2928/include/mach/iomux.h
+#define WIFI_HOST_WAKE RK2928_PIN3_PC0 
+
+	#if defined(CONFIG_RK903) || defined(CONFIG_RK901) || defined(CONFIG_BCM4329) || defined(CONFIG_BCM4319)
+        #define RK30SDK_WIFI_GPIO_POWER_N               RK2928_PIN0_PD6
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH
+        #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME        GPIO0D6_MMC1_PWREN_NAME
+        #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO     GPIO0D_GPIO0D6
+
+        #define RK30SDK_WIFI_GPIO_RESET_N               RK2928_PIN3_PC2
+        #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE    GPIO_HIGH
+        #define RK30SDK_WIFI_GPIO_RESET_PIN_NAME        GPIO3C2_SDMMC1DATA1_NAME
+        #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO     GPIO3C_GPIO3C2
+	
+    #elif  defined(CONFIG_RDA5990)
+        #define RK30SDK_WIFI_GPIO_POWER_N               INVALID_GPIO
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH
+        //#define RK30SDK_WIFI_GPIO_POWER_PIN_NAME        GPIO0B6_MMC1_PWREN_NAME
+        //#define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO     GPIO0B_GPIO0B6
+        
+        #define RK30SDK_WIFI_GPIO_RESET_N               INVALID_GPIO
+        #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE    GPIO_HIGH
+        //#define RK30SDK_WIFI_GPIO_RESET_PIN_NAME        GPIO3C2_SDMMC1DATA1_NAME
+        //#define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO     GPIO3C_GPIO3C2
+
+
+    #elif defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) || defined(CONFIG_RT5370)
+      #if defined(CONFIG_MACH_RK2926_V86)
+        #define CONFIG_USB_WIFI_POWER_CONTROLED_BY_GPIO
+        #define RK30SDK_WIFI_GPIO_POWER_N               RK2928_PIN0_PD3
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_LOW 
+      #elif defined(CONFIG_MACH_RK2928_TR726)
+        #define CONFIG_USB_WIFI_POWER_CONTROLED_BY_GPIO
+        #define RK30SDK_WIFI_GPIO_POWER_N               RK2928_PIN3_PD3
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_LOW 
+      #else
+        #define RK30SDK_WIFI_GPIO_POWER_N               RK2928_PIN0_PD6
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_LOW 
+      #endif
+        
+    #elif defined(CONFIG_MT5931) || defined(CONFIG_MT5931_MT6622)
+        #define RK30SDK_WIFI_GPIO_POWER_N               RK2928_PIN3_PD2
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH 
+        
+        #define RK30SDK_WIFI_GPIO_RESET_N               RK2928_PIN3_PD5
+        #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE    GPIO_HIGH 
+
+    #endif
+#endif
+
+    
+//1. Part 2: to define the gpio for the SDMMC controller. Based on the chip datasheet.
+/*************************************************************************
+* define the gpio for SDMMC module on various platforms
+* Generally only system personnel will modify this part
+*************************************************************************/
+
+#if defined(CONFIG_ARCH_RK30)&& !defined(CONFIG_ARCH_RK3066B)//for RK30,RK3066 SDK
+/*
+* define the gpio for sdmmc0
+*/
+struct rksdmmc_gpio_board rksdmmc0_gpio_init = {
+
+     .clk_gpio       = {
+        .io             = RK30_PIN3_PB0,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3B0_SDMMC0CLKOUT_NAME,
+            .fgpio      = GPIO3B_GPIO3B0,
+            .fmux       = GPIO3B_SDMMC0_CLKOUT,
+        },
+    },   
+
+    .cmd_gpio           = {
+        .io             = RK30_PIN3_PB1,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3B1_SDMMC0CMD_NAME,
+            .fgpio      = GPIO3B_GPIO3B1,
+            .fmux       = GPIO3B_SDMMC0_CMD,
+        },
+    },      
+
+   .data0_gpio       = {
+        .io             = RK30_PIN3_PB2,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3B2_SDMMC0DATA0_NAME,
+            .fgpio      = GPIO3B_GPIO3B2,
+            .fmux       = GPIO3B_SDMMC0_DATA0,
+        },
+    },      
+
+    .data1_gpio       = {
+        .io             = RK30_PIN3_PB3,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3B3_SDMMC0DATA1_NAME,
+            .fgpio      = GPIO3B_GPIO3B3,
+            .fmux       = GPIO3B_SDMMC0_DATA1,
+        },
+    },      
+
+    .data2_gpio       = {
+        .io             = RK30_PIN3_PB4,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3B4_SDMMC0DATA2_NAME,
+            .fgpio      = GPIO3B_GPIO3B4,
+            .fmux       = GPIO3B_SDMMC0_DATA2,
+        },
+    }, 
+
+    .data3_gpio       = {
+        .io             = RK30_PIN3_PB5,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3B5_SDMMC0DATA3_NAME,
+            .fgpio      = GPIO3B_GPIO3B5,
+            .fmux       = GPIO3B_SDMMC0_DATA3,
+        },
+    }, 
+    
+    .power_en_gpio      = {   
+#if defined(RK29SDK_SD_CARD_PWR_EN) || (INVALID_GPIO != RK29SDK_SD_CARD_PWR_EN)
+        .io             = RK29SDK_SD_CARD_PWR_EN,
+        .enable         = RK29SDK_SD_CARD_PWR_EN_LEVEL,
+        #ifdef RK29SDK_SD_CARD_PWR_EN_PIN_NAME
+        .iomux          = {
+            .name       = RK29SDK_SD_CARD_PWR_EN_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO
+            .fgpio      = RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX
+            .fmux       = RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX,
+            #endif
+        },
+        #endif
+#else
+        .io             = INVALID_GPIO,
+        .enable         = GPIO_LOW,
+#endif
+    }, 
+
+    .detect_irq       = {
+#if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+        .io             = RK29SDK_SD_CARD_DETECT_N,
+        .enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+        #ifdef RK29SDK_SD_CARD_DETECT_PIN_NAME
+        .iomux          = {
+            .name       = RK29SDK_SD_CARD_DETECT_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO
+            .fgpio      = RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FMUX
+            .fmux       = RK29SDK_SD_CARD_DETECT_IOMUX_FMUX,
+            #endif
+        },
+        #endif
+#else
+        .io             = INVALID_GPIO,
+        .enable         = GPIO_LOW,
+#endif            
+    },
+};
+
+
+/*
+* define the gpio for sdmmc1
+*/
+static struct rksdmmc_gpio_board rksdmmc1_gpio_init = {
+
+     .clk_gpio       = {
+        .io             = RK30_PIN3_PC5,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C5_SDMMC1CLKOUT_NAME,
+            .fgpio      = GPIO3C_GPIO3C5,
+            .fmux       = GPIO3B_SDMMC0_CLKOUT,
+        },
+    },   
+
+    .cmd_gpio           = {
+        .io             = RK30_PIN3_PC0,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C0_SMMC1CMD_NAME,
+            .fgpio      = GPIO3C_GPIO3C0,
+            .fmux       = GPIO3B_SDMMC0_CMD,
+        },
+    },      
+
+   .data0_gpio       = {
+        .io             = RK30_PIN3_PC1,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C1_SDMMC1DATA0_NAME,
+            .fgpio      = GPIO3C_GPIO3C1,
+            .fmux       = GPIO3B_SDMMC0_DATA0,
+        },
+    },      
+
+    .data1_gpio       = {
+        .io             = RK30_PIN3_PC2,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C2_SDMMC1DATA1_NAME,
+            .fgpio      = GPIO3C_GPIO3C2,
+            .fmux       = GPIO3B_SDMMC0_DATA1,
+        },
+    },      
+
+    .data2_gpio       = {
+        .io             = RK30_PIN3_PC3,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C3_SDMMC1DATA2_NAME,
+            .fgpio      = GPIO3C_GPIO3C3,
+            .fmux       = GPIO3B_SDMMC0_DATA2,
+        },
+    }, 
+
+    .data3_gpio       = {
+        .io             = RK30_PIN3_PC4,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C4_SDMMC1DATA3_NAME,
+            .fgpio      = GPIO3C_GPIO3C4,
+            .fmux       = GPIO3B_SDMMC0_DATA3,
+        },
+    }, 
+};
+ // ---end -#if defined(CONFIG_ARCH_RK30)
+
+#elif defined(CONFIG_ARCH_RK3066B)
+
+/*
+* define the gpio for sdmmc0
+*/
+static struct rksdmmc_gpio_board rksdmmc0_gpio_init = {
+
+     .clk_gpio       = {
+        .io             = RK30_PIN3_PB0,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3A2_SDMMC0CLKOUT_NAME,
+            .fgpio      = GPIO3A_GPIO3A2,
+            .fmux       = GPIO3A_SDMMC0CLKOUT,
+        },
+    },   
+
+    .cmd_gpio           = {
+        .io             = RK30_PIN3_PB1,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3A3_SDMMC0CMD_NAME,
+            .fgpio      = GPIO3A_GPIO3A3,
+            .fmux       = GPIO3A_SDMMC0CMD,
+        },
+    },      
+
+   .data0_gpio       = {
+        .io             = RK30_PIN3_PB2,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3A4_SDMMC0DATA0_NAME,
+            .fgpio      = GPIO3A_GPIO3A4,
+            .fmux       = GPIO3A_SDMMC0DATA0,
+        },
+    },      
+
+    .data1_gpio       = {
+        .io             = RK30_PIN3_PB3,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3A5_SDMMC0DATA1_NAME,
+            .fgpio      = GPIO3A_GPIO3A5,
+            .fmux       = GPIO3A_SDMMC0DATA1,
+        },
+    },      
+
+    .data2_gpio       = {
+        .io             = RK30_PIN3_PB4,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3A6_SDMMC0DATA2_NAME,
+            .fgpio      = GPIO3A_GPIO3A6,
+            .fmux       = GPIO3A_SDMMC0DATA2,
+        },
+    }, 
+
+    .data3_gpio       = {
+        .io             = RK30_PIN3_PB5,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3A7_SDMMC0DATA3_NAME,
+            .fgpio      = GPIO3A_GPIO3A7,
+            .fmux       = GPIO3A_SDMMC0DATA3,
+        },
+    }, 
+
+               
+    .power_en_gpio      = {   
+#if defined(RK29SDK_SD_CARD_PWR_EN) || (INVALID_GPIO != RK29SDK_SD_CARD_PWR_EN)
+                    .io             = RK29SDK_SD_CARD_PWR_EN,
+                    .enable         = RK29SDK_SD_CARD_PWR_EN_LEVEL,
+        #ifdef RK29SDK_SD_CARD_PWR_EN_PIN_NAME
+                    .iomux          = {
+                        .name       = RK29SDK_SD_CARD_PWR_EN_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO
+                        .fgpio      = RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX
+                        .fmux       = RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX,
+            #endif
+                    },
+        #endif
+#else
+                    .io             = INVALID_GPIO,
+                    .enable         = GPIO_LOW,
+#endif
+                }, 
+            
+        .detect_irq       = {
+#if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+                    .io             = RK29SDK_SD_CARD_DETECT_N,
+                    .enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+        #ifdef RK29SDK_SD_CARD_DETECT_PIN_NAME
+                    .iomux          = {
+                        .name       = RK29SDK_SD_CARD_DETECT_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO
+                        .fgpio      = RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FMUX
+                        .fmux       = RK29SDK_SD_CARD_DETECT_IOMUX_FMUX,
+            #endif
+                    },
+        #endif
+#else
+                    .io             = INVALID_GPIO,
+                    .enable         = GPIO_LOW,
+#endif            
+    },
+
+};
+
+
+/*
+* define the gpio for sdmmc1
+*/
+static struct rksdmmc_gpio_board rksdmmc1_gpio_init = {
+
+     .clk_gpio       = {
+        .io             = RK30_PIN3_PC5,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C5_SDMMC1CLKOUT_RMIICLKOUT_RMIICLKIN_NAME,
+            .fgpio      = GPIO3C_GPIO3C5,
+            .fmux       = GPIO3C_SDMMC1CLKOUT,
+        },
+    },   
+
+    .cmd_gpio           = {
+        .io             = RK30_PIN3_PC0,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C0_SDMMC1CMD_RMIITXEN_NAME,
+            .fgpio      = GPIO3C_GPIO3C0,
+            .fmux       = GPIO3C_SDMMC1CMD,
+        },
+    },      
+
+   .data0_gpio       = {
+        .io             = RK30_PIN3_PC1,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C1_SDMMC1DATA0_RMIITXD1_NAME,
+            .fgpio      = GPIO3C_GPIO3C1,
+            .fmux       = GPIO3C_SDMMC1DATA0,
+        },
+    },      
+
+    .data1_gpio       = {
+        .io             = RK30_PIN3_PC2,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C2_SDMMC1DATA1_RMIITXD0_NAME,
+            .fgpio      = GPIO3C_GPIO3C2,
+            .fmux       = GPIO3C_SDMMC1DATA1,
+        },
+    },      
+
+    .data2_gpio       = {
+        .io             = RK30_PIN3_PC3,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C3_SDMMC1DATA2_RMIIRXD0_NAME,
+            .fgpio      = GPIO3C_GPIO3C3,
+            .fmux       = GPIO3C_SDMMC1DATA2,
+        },
+    }, 
+
+    .data3_gpio       = {
+        .io             = RK30_PIN3_PC4,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C4_SDMMC1DATA3_RMIIRXD1_NAME,
+            .fgpio      = GPIO3C_GPIO3C4,
+            .fmux       = GPIO3C_SDMMC1DATA3,
+        },
+    }, 
+};
+// ---end -#if defined(CONFIG_ARCH_RK3066B)
+
+#elif defined(CONFIG_ARCH_RK2928)
+/*
+* define the gpio for sdmmc0
+*/
+static struct rksdmmc_gpio_board rksdmmc0_gpio_init = {
+
+     .clk_gpio       = {
+        .io             = RK2928_PIN1_PC0,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO1C0_MMC0_CLKOUT_NAME,
+            .fgpio      = GPIO1C_GPIO1C0,
+            .fmux       = GPIO1C_MMC0_CLKOUT,
+        },
+    },   
+
+    .cmd_gpio           = {
+        .io             = RK2928_PIN1_PC7,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO1B7_MMC0_CMD_NAME,
+            .fgpio      = GPIO1B_GPIO1B7,
+            .fmux       = GPIO1B_MMC0_CMD,
+        },
+    },      
+
+   .data0_gpio       = {
+        .io             = RK2928_PIN1_PC2,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO1C2_MMC0_D0_NAME,
+            .fgpio      = GPIO1C_GPIO1C2,
+            .fmux       = GPIO1C_MMC0_D0,
+        },
+    },      
+
+    .data1_gpio       = {
+        .io             = RK2928_PIN1_PC3,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO1C3_MMC0_D1_NAME,
+            .fgpio      = GPIO1C_GPIO1C3,
+            .fmux       = GPIO1C_MMC0_D1,
+        },
+    },      
+
+    .data2_gpio       = {
+        .io             = RK2928_PIN1_PC4,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO1C4_MMC0_D2_NAME,
+            .fgpio      = GPIO1C_GPIO1C4,
+            .fmux       = GPIO1C_MMC0_D2,
+        },
+    }, 
+
+    .data3_gpio       = {
+        .io             = RK2928_PIN1_PC5,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO1C5_MMC0_D3_NAME,
+            .fgpio      = GPIO1C_GPIO1C5,
+            .fmux       = GPIO1C_MMC0_D3,
+        },
+    }, 
+
+   
+    .power_en_gpio      = {   
+#if defined(RK29SDK_SD_CARD_PWR_EN) || (INVALID_GPIO != RK29SDK_SD_CARD_PWR_EN)
+        .io             = RK29SDK_SD_CARD_PWR_EN,
+        .enable         = RK29SDK_SD_CARD_PWR_EN_LEVEL,
+        #ifdef RK29SDK_SD_CARD_PWR_EN_PIN_NAME
+        .iomux          = {
+            .name       = RK29SDK_SD_CARD_PWR_EN_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO
+            .fgpio      = RK29SDK_SD_CARD_PWR_EN_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX
+            .fmux       = RK29SDK_SD_CARD_PWR_EN_IOMUX_FMUX,
+            #endif
+        },
+        #endif
+#else
+        .io             = INVALID_GPIO,
+        .enable         = GPIO_LOW,
+#endif
+    }, 
+
+    .detect_irq       = {
+#if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+        .io             = RK29SDK_SD_CARD_DETECT_N,
+        .enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+        #ifdef RK29SDK_SD_CARD_DETECT_PIN_NAME
+        .iomux          = {
+            .name       = RK29SDK_SD_CARD_DETECT_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO
+            .fgpio      = RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FMUX
+            .fmux       = RK29SDK_SD_CARD_DETECT_IOMUX_FMUX,
+            #endif
+        },
+        #endif
+#else
+        .io             = INVALID_GPIO,
+        .enable         = GPIO_LOW,
+#endif            
+    }, 
+};
+
+
+/*
+* define the gpio for sdmmc1
+*/
+static struct rksdmmc_gpio_board rksdmmc1_gpio_init = {
+
+     .clk_gpio       = {
+        .io             = RK2928_PIN0_PB1,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO0B1_MMC1_CLKOUT_NAME,
+            .fgpio      = GPIO0B_GPIO0B1,
+            .fmux       = GPIO0B_MMC1_CLKOUT,
+        },
+    },   
+
+    .cmd_gpio           = {
+        .io             = RK2928_PIN0_PB0,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO0B0_MMC1_CMD_NAME,
+            .fgpio      = GPIO0B_GPIO0B0,
+            .fmux       = GPIO0B_MMC1_CMD,
+        },
+    },      
+
+   .data0_gpio       = {
+        .io             = RK2928_PIN0_PB3,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO0B3_MMC1_D0_NAME,
+            .fgpio      = GPIO0B_GPIO0B3,
+            .fmux       = GPIO0B_MMC1_D0,
+        },
+    },      
+
+    .data1_gpio       = {
+        .io             = RK2928_PIN0_PB4,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO0B4_MMC1_D1_NAME,
+            .fgpio      = GPIO0B_GPIO0B4,
+            .fmux       = GPIO0B_MMC1_D1,
+        },
+    },      
+
+    .data2_gpio       = {
+        .io             = RK2928_PIN0_PB5,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO0B5_MMC1_D2_NAME,
+            .fgpio      = GPIO0B_GPIO0B5,
+            .fmux       = GPIO0B_MMC1_D2,
+        },
+    }, 
+
+    .data3_gpio       = {
+        .io             = RK2928_PIN0_PB6,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO0B6_MMC1_D3_NAME,
+            .fgpio      = GPIO0B_GPIO0B6,
+            .fmux       = GPIO0B_MMC1_D3,
+        },
+    }, 
+
+
+};
+// ---end -#if defined(CONFIG_ARCH_RK2928)
+#endif
+
+
+
+//1.Part 3: The various operations of the SDMMC-SDIO module
+/*************************************************************************
+* define the varaious operations for SDMMC module
+* Generally only the author of SDMMC module will modify this section.
+*************************************************************************/
 
 #if !defined(CONFIG_SDMMC_RK29_OLD)	
 static void rk29_sdmmc_gpio_open(int device_id, int on)
@@ -25,40 +1007,40 @@ static void rk29_sdmmc_gpio_open(int device_id, int on)
             #ifdef CONFIG_SDMMC0_RK29
             if(on)
             {
-                gpio_direction_output(RK2928_PIN1_PC0,GPIO_HIGH);//set mmc0-clk to high
-                gpio_direction_output(RK2928_PIN1_PB7,GPIO_HIGH);// set mmc0-cmd to high.
-                gpio_direction_output(RK2928_PIN1_PC2,GPIO_HIGH);//set mmc0-data0 to high.
-                gpio_direction_output(RK2928_PIN1_PC3,GPIO_HIGH);//set mmc0-data1 to high.
-                gpio_direction_output(RK2928_PIN1_PC4,GPIO_HIGH);//set mmc0-data2 to high.
-                gpio_direction_output(RK2928_PIN1_PC5,GPIO_HIGH);//set mmc0-data3 to high.
+                gpio_direction_output(rksdmmc0_gpio_init.clk_gpio.io, GPIO_HIGH);//set mmc0-clk to high
+                gpio_direction_output(rksdmmc0_gpio_init.cmd_gpio.io, GPIO_HIGH);// set mmc0-cmd to high.
+                gpio_direction_output(rksdmmc0_gpio_init.data0_gpio.io,GPIO_HIGH);//set mmc0-data0 to high.
+                gpio_direction_output(rksdmmc0_gpio_init.data1_gpio.io,GPIO_HIGH);//set mmc0-data1 to high.
+                gpio_direction_output(rksdmmc0_gpio_init.data2_gpio.io,GPIO_HIGH);//set mmc0-data2 to high.
+                gpio_direction_output(rksdmmc0_gpio_init.data3_gpio.io,GPIO_HIGH);//set mmc0-data3 to high.
 
                 mdelay(30);
             }
             else
             {
-                rk30_mux_api_set(GPIO1C0_MMC0_CLKOUT_NAME, GPIO1C_GPIO1C0);
-                gpio_request(RK2928_PIN1_PC0, "mmc0-clk");
-                gpio_direction_output(RK2928_PIN1_PC0,GPIO_LOW);//set mmc0-clk to low.
+                rk30_mux_api_set(rksdmmc0_gpio_init.clk_gpio.iomux.name, rksdmmc0_gpio_init.clk_gpio.iomux.fgpio);
+                gpio_request(rksdmmc0_gpio_init.clk_gpio.io, "mmc0-clk");
+                gpio_direction_output(rksdmmc0_gpio_init.clk_gpio.io,GPIO_LOW);//set mmc0-clk to low.
 
-                rk30_mux_api_set(GPIO1B7_MMC0_CMD_NAME, GPIO1B_GPIO1B7);
-                gpio_request(RK2928_PIN1_PB7, "mmc0-cmd");
-                gpio_direction_output(RK2928_PIN1_PB7,GPIO_LOW);//set mmc0-cmd to low.
+                rk30_mux_api_set(rksdmmc0_gpio_init.cmd_gpio.iomux.name, rksdmmc0_gpio_init.cmd_gpio.iomux.fgpio);
+                gpio_request(rksdmmc0_gpio_init.cmd_gpio.io, "mmc0-cmd");
+                gpio_direction_output(rksdmmc0_gpio_init.cmd_gpio.io,GPIO_LOW);//set mmc0-cmd to low.
 
-                rk30_mux_api_set(GPIO1C2_MMC0_D0_NAME, GPIO1C_GPIO1C2);
-                gpio_request(RK2928_PIN1_PC2, "mmc0-data0");
-                gpio_direction_output(RK2928_PIN1_PC2,GPIO_LOW);//set mmc0-data0 to low.
+                rk30_mux_api_set(rksdmmc0_gpio_init.data0_gpio.iomux.name, rksdmmc0_gpio_init.data0_gpio.iomux.fgpio);
+                gpio_request(rksdmmc0_gpio_init.data0_gpio.io, "mmc0-data0");
+                gpio_direction_output(rksdmmc0_gpio_init.data0_gpio.io,GPIO_LOW);//set mmc0-data0 to low.
 
-                rk30_mux_api_set(GPIO1C3_MMC0_D1_NAME, GPIO1C_GPIO1C3);
-                gpio_request(RK2928_PIN1_PC3, "mmc0-data1");
-                gpio_direction_output(RK2928_PIN1_PC3,GPIO_LOW);//set mmc0-data1 to low.
+                rk30_mux_api_set(rksdmmc0_gpio_init.data1_gpio.iomux.name, rksdmmc0_gpio_init.data1_gpio.iomux.fgpio);
+                gpio_request(rksdmmc0_gpio_init.data1_gpio.io, "mmc0-data1");
+                gpio_direction_output(rksdmmc0_gpio_init.data1_gpio.io,GPIO_LOW);//set mmc0-data1 to low.
 
-                rk30_mux_api_set(GPIO1C4_MMC0_D2_NAME, GPIO1C_GPIO1C4);
-                gpio_request(RK2928_PIN1_PC4, "mmc0-data2");
-                gpio_direction_output(RK2928_PIN1_PC4,GPIO_LOW);//set mmc0-data2 to low.
+                rk30_mux_api_set(rksdmmc0_gpio_init.data2_gpio.iomux.name, rksdmmc0_gpio_init.data2_gpio.iomux.fgpio);
+                gpio_request(rksdmmc0_gpio_init.data2_gpio.io, "mmc0-data2");
+                gpio_direction_output(rksdmmc0_gpio_init.data2_gpio.io,GPIO_LOW);//set mmc0-data2 to low.
 
-                rk30_mux_api_set(GPIO1C5_MMC0_D3_NAME, GPIO1C_GPIO1C5);
-                gpio_request(RK2928_PIN1_PC5, "mmc0-data3");
-                gpio_direction_output(RK2928_PIN1_PC5,GPIO_LOW);//set mmc0-data3 to low.
+                rk30_mux_api_set(rksdmmc0_gpio_init.data3_gpio.iomux.name, rksdmmc0_gpio_init.data3_gpio.iomux.fgpio);
+                gpio_request(rksdmmc0_gpio_init.data3_gpio.io, "mmc0-data3");
+                gpio_direction_output(rksdmmc0_gpio_init.data3_gpio.io,GPIO_LOW);//set mmc0-data3 to low.
 
                 mdelay(30);
             }
@@ -71,54 +1053,39 @@ static void rk29_sdmmc_gpio_open(int device_id, int on)
             #ifdef CONFIG_SDMMC1_RK29
             if(on)
             {
-                gpio_request(RK2928_PIN0_PB1, "mmc1-clk");
-                gpio_direction_output(RK2928_PIN0_PB1,GPIO_HIGH);//set mmc1-clk to high
-
-                gpio_request(RK2928_PIN0_PB0, "mmc1-cmd");
-                gpio_direction_output(RK2928_PIN0_PB0,GPIO_HIGH);//set mmc1-cmd to high.
-
-                gpio_request(RK2928_PIN0_PB3, "mmc1-data0");
-                gpio_direction_output(RK2928_PIN0_PB3,GPIO_HIGH);//set mmc1-data0 to high.
-
-				gpio_request(RK2928_PIN0_PB4, "mmc1-data1");
-                gpio_direction_output(RK2928_PIN0_PB4,GPIO_HIGH);//set mmc1-data1 to high.
-
-				gpio_request(RK2928_PIN0_PB5, "mmc1-data2");
-                gpio_direction_output(RK2928_PIN0_PB5,GPIO_HIGH);//set mmc1-data2 to high.
-
-				gpio_request(RK2928_PIN0_PB6, "mmc1-data3");
-                gpio_direction_output(RK2928_PIN0_PB6,GPIO_HIGH);//set mmc1-data3 to high.
+                gpio_direction_output(rksdmmc1_gpio_init.clk_gpio.io,GPIO_HIGH);//set mmc1-clk to high
+                gpio_direction_output(rksdmmc1_gpio_init.cmd_gpio.io,GPIO_HIGH);//set mmc1-cmd to high.
+                gpio_direction_output(rksdmmc1_gpio_init.data0_gpio.io,GPIO_HIGH);//set mmc1-data0 to high.
+                gpio_direction_output(rksdmmc1_gpio_init.data1_gpio.io,GPIO_HIGH);//set mmc1-data1 to high.
+                gpio_direction_output(rksdmmc1_gpio_init.data2_gpio.io,GPIO_HIGH);//set mmc1-data2 to high.
+                gpio_direction_output(rksdmmc1_gpio_init.data3_gpio.io,GPIO_HIGH);//set mmc1-data3 to high.
                 mdelay(100);
             }
             else
             {
-                rk30_mux_api_set(GPIO0B1_MMC1_CLKOUT_NAME, GPIO0B_GPIO0B1);
-                gpio_request(RK2928_PIN0_PB1, "mmc1-clk");
-                gpio_direction_output(RK2928_PIN0_PB1,GPIO_LOW);//set mmc1-clk to low.
-
-                rk30_mux_api_set(GPIO0B0_MMC1_CMD_NAME, GPIO0B_GPIO0B0);
-                gpio_request(RK2928_PIN0_PB0, "mmc1-cmd");
-                gpio_direction_output(RK2928_PIN0_PB0,GPIO_LOW);//set mmc1-cmd to low.
-
-                rk30_mux_api_set(GPIO0B3_MMC1_D0_NAME, GPIO0B_GPIO0B3);
-                gpio_request(RK2928_PIN0_PB3, "mmc1-data0");
-                gpio_direction_output(RK2928_PIN0_PB3,GPIO_LOW);//set mmc1-data0 to low.
-
-				#if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-				rk29_mux_api_set(GPIO0B4_MMC1_D1_NAME, GPIO0B_GPIO0B4);
-				gpio_request(RK2928_PIN0_PB4, "mmc1-data1");
-				gpio_direction_output(RK2928_PIN0_PB4,GPIO_LOW);//set mmc1-data1 to low.
-
-				rk29_mux_api_set(GPIO0B5_MMC1_D2_NAME, GPIO0B_GPIO0B5);
-				gpio_request(RK2928_PIN0_PB5, "mmc1-data2");
-				gpio_direction_output(RK2928_PIN0_PB5,GPIO_LOW);//set mmc1-data2 to low.
-
-				rk29_mux_api_set(GPIO0B6_MMC1_D3_NAME, GPIO0B_GPIO0B6);
-				gpio_request(RK2928_PIN0_PB6, "mmc1-data3");
-				gpio_direction_output(RK2928_PIN0_PB6,GPIO_LOW);//set mmc1-data3 to low.
-
-				//rk29_sdmmc_gpio_open(1, 0); //added by xbw at 2011-10-13
-				#endif
+                rk30_mux_api_set(rksdmmc1_gpio_init.clk_gpio.iomux.name, rksdmmc1_gpio_init.clk_gpio.iomux.fgpio);
+                gpio_request(rksdmmc1_gpio_init.clk_gpio.io, "mmc1-clk");
+                gpio_direction_output(rksdmmc1_gpio_init.clk_gpio.io,GPIO_LOW);//set mmc1-clk to low.
+
+                rk30_mux_api_set(rksdmmc1_gpio_init.cmd_gpio.iomux.name, rksdmmc1_gpio_init.cmd_gpio.iomux.fgpio);
+                gpio_request(rksdmmc1_gpio_init.cmd_gpio.io, "mmc1-cmd");
+                gpio_direction_output(rksdmmc1_gpio_init.cmd_gpio.io,GPIO_LOW);//set mmc1-cmd to low.
+
+                rk30_mux_api_set(rksdmmc1_gpio_init.data0_gpio.iomux.name, rksdmmc1_gpio_init.data0_gpio.iomux.fgpio);
+                gpio_request(rksdmmc1_gpio_init.data0_gpio.io, "mmc1-data0");
+                gpio_direction_output(rksdmmc1_gpio_init.data0_gpio.io,GPIO_LOW);//set mmc1-data0 to low.
+                
+                rk29_mux_api_set(rksdmmc1_gpio_init.data1_gpio.iomux.name, rksdmmc1_gpio_init.data1_gpio.iomux.fgpio);
+                gpio_request(rksdmmc1_gpio_init.data1_gpio.io, "mmc1-data1");
+                gpio_direction_output(rksdmmc1_gpio_init.data1_gpio.io,GPIO_LOW);//set mmc1-data1 to low.
+
+                rk29_mux_api_set(rksdmmc1_gpio_init.data2_gpio.iomux.name, rksdmmc1_gpio_init.data2_gpio.iomux.fgpio);
+                gpio_request(rksdmmc1_gpio_init.data2_gpio.io, "mmc1-data2");
+                gpio_direction_output(rksdmmc1_gpio_init.data2_gpio.io,GPIO_LOW);//set mmc1-data2 to low.
+
+                rk29_mux_api_set(rksdmmc1_gpio_init.data3_gpio.iomux.name, rksdmmc1_gpio_init.data3_gpio.iomux.fgpio);
+                gpio_request(rksdmmc1_gpio_init.data3_gpio.io, "mmc1-data3");
+                gpio_direction_output(rksdmmc1_gpio_init.data3_gpio.io,GPIO_LOW);//set mmc1-data3 to low.
 
                 mdelay(100);
             }
@@ -141,9 +1108,9 @@ static void rk29_sdmmc_set_iomux_mmc0(unsigned int bus_width)
         
     	case 1://SDMMC_CTYPE_4BIT:
     	{
-        	rk30_mux_api_set(GPIO1C3_MMC0_D1_NAME, GPIO1C_MMC0_D1);
-        	rk30_mux_api_set(GPIO1C4_MMC0_D2_NAME, GPIO1C_MMC0_D2);
-        	rk30_mux_api_set(GPIO1C5_MMC0_D3_NAME, GPIO1C_MMC0_D3);
+        	rk30_mux_api_set(rksdmmc0_gpio_init.data1_gpio.iomux.name, rksdmmc0_gpio_init.data1_gpio.iomux.fmux);
+        	rk30_mux_api_set(rksdmmc0_gpio_init.data2_gpio.iomux.name, rksdmmc0_gpio_init.data2_gpio.iomux.fmux);
+        	rk30_mux_api_set(rksdmmc0_gpio_init.data3_gpio.iomux.name, rksdmmc0_gpio_init.data3_gpio.iomux.fmux);
     	}
     	break;
 
@@ -151,35 +1118,39 @@ static void rk29_sdmmc_set_iomux_mmc0(unsigned int bus_width)
     	    break;
     	case 0xFFFF: //gpio_reset
     	{
-            rk30_mux_api_set(GPIO1B6_MMC0_PWREN_NAME, GPIO1B_GPIO1B6);
-            gpio_request(RK2928_PIN1_PB6,"sdmmc-power");
-            gpio_direction_output(RK2928_PIN1_PB6,GPIO_HIGH); //power-off
+	    if (rksdmmc0_gpio_init.power_en_gpio.io == INVALID_GPIO)
+		break;
+            rk30_mux_api_set(rksdmmc0_gpio_init.power_en_gpio.iomux.name, rksdmmc0_gpio_init.power_en_gpio.iomux.fgpio);
+            gpio_request(rksdmmc0_gpio_init.power_en_gpio.io,"sdmmc-power");
+            gpio_direction_output(rksdmmc0_gpio_init.power_en_gpio.io, !(rksdmmc0_gpio_init.power_en_gpio.enable)); //power-off
 
+        #if 0 //replace the power control into rk29_sdmmc_set_ios(); modifyed by xbw at 2012-08-12
             rk29_sdmmc_gpio_open(0, 0);
 
-            gpio_direction_output(RK2928_PIN1_PB6,GPIO_LOW); //power-on
+            gpio_direction_output(rksdmmc0_gpio_init.power_en_gpio.io, rksdmmc0_gpio_init.power_en_gpio.enable); //power-on
 
             rk29_sdmmc_gpio_open(0, 1);
+          #endif  
     	}
     	break;
 
     	default: //case 0://SDMMC_CTYPE_1BIT:
         {
-        	rk30_mux_api_set(GPIO1B7_MMC0_CMD_NAME, GPIO1B_MMC0_CMD);
-        	rk30_mux_api_set(GPIO1C0_MMC0_CLKOUT_NAME, GPIO1C_MMC0_CLKOUT);
-        	rk30_mux_api_set(GPIO1C2_MMC0_D0_NAME, GPIO1C_MMC0_D0);
+        	rk30_mux_api_set(rksdmmc0_gpio_init.cmd_gpio.iomux.name, rksdmmc0_gpio_init.cmd_gpio.iomux.fmux);
+        	rk30_mux_api_set(rksdmmc0_gpio_init.clk_gpio.iomux.name, rksdmmc0_gpio_init.clk_gpio.iomux.fmux);
+        	rk30_mux_api_set(rksdmmc0_gpio_init.data0_gpio.iomux.name, rksdmmc0_gpio_init.data0_gpio.iomux.fmux);
 
-            rk30_mux_api_set(GPIO1C3_MMC0_D1_NAME, GPIO1C_GPIO1C3);
-            gpio_request(RK2928_PIN1_PC3, "mmc0-data1");
-            gpio_direction_output(RK2928_PIN1_PC3,GPIO_HIGH);//set mmc0-data1 to high.
+            rk30_mux_api_set(rksdmmc0_gpio_init.data1_gpio.iomux.name, rksdmmc0_gpio_init.data1_gpio.iomux.fgpio);
+            gpio_request(rksdmmc0_gpio_init.data1_gpio.io, "mmc0-data1");
+            gpio_direction_output(rksdmmc0_gpio_init.data1_gpio.io,GPIO_HIGH);//set mmc0-data1 to high.
 
-            rk30_mux_api_set(GPIO1C4_MMC0_D2_NAME, GPIO1C_GPIO1C4);
-            gpio_request(RK2928_PIN1_PC4, "mmc0-data2");
-            gpio_direction_output(RK2928_PIN1_PC4,GPIO_HIGH);//set mmc0-data2 to high.
+            rk30_mux_api_set(rksdmmc0_gpio_init.data2_gpio.iomux.name, rksdmmc0_gpio_init.data2_gpio.iomux.fgpio);
+            gpio_request(rksdmmc0_gpio_init.data2_gpio.io, "mmc0-data2");
+            gpio_direction_output(rksdmmc0_gpio_init.data2_gpio.io,GPIO_HIGH);//set mmc0-data2 to high.
 
-            rk30_mux_api_set(GPIO1C5_MMC0_D3_NAME, GPIO1C_GPIO1C5);
-            gpio_request(RK2928_PIN1_PC5, "mmc0-data3");
-            gpio_direction_output(RK2928_PIN1_PC5,GPIO_HIGH);//set mmc0-data3 to high.
+            rk30_mux_api_set(rksdmmc0_gpio_init.data3_gpio.iomux.name, rksdmmc0_gpio_init.data3_gpio.iomux.fgpio);
+            gpio_request(rksdmmc0_gpio_init.data3_gpio.io, "mmc0-data3");
+            gpio_direction_output(rksdmmc0_gpio_init.data3_gpio.io,GPIO_HIGH);//set mmc0-data3 to high.
     	}
     	break;
 	}
@@ -187,12 +1158,12 @@ static void rk29_sdmmc_set_iomux_mmc0(unsigned int bus_width)
 
 static void rk29_sdmmc_set_iomux_mmc1(unsigned int bus_width)
 {
-    rk30_mux_api_set(GPIO0B0_MMC1_CMD_NAME, GPIO0B_MMC1_CMD);
-    rk30_mux_api_set(GPIO0B1_MMC1_CLKOUT_NAME, GPIO0B_MMC1_CLKOUT);
-    rk30_mux_api_set(GPIO0B3_MMC1_D0_NAME, GPIO0B_MMC1_D0);
-    rk30_mux_api_set(GPIO0B4_MMC1_D1_NAME, GPIO0B_MMC1_D1);
-    rk30_mux_api_set(GPIO0B5_MMC1_D2_NAME, GPIO0B_MMC1_D2);
-    rk30_mux_api_set(GPIO0B6_MMC1_D3_NAME, GPIO0B_MMC1_D3);
+    rk30_mux_api_set(rksdmmc1_gpio_init.cmd_gpio.iomux.name, rksdmmc1_gpio_init.cmd_gpio.iomux.fmux);
+    rk30_mux_api_set(rksdmmc1_gpio_init.clk_gpio.iomux.name, rksdmmc1_gpio_init.clk_gpio.iomux.fmux);
+    rk30_mux_api_set(rksdmmc1_gpio_init.data0_gpio.iomux.name, rksdmmc1_gpio_init.data0_gpio.iomux.fmux);
+    rk30_mux_api_set(rksdmmc1_gpio_init.data1_gpio.iomux.name, rksdmmc1_gpio_init.data1_gpio.iomux.fmux);
+    rk30_mux_api_set(rksdmmc1_gpio_init.data2_gpio.iomux.name, rksdmmc1_gpio_init.data2_gpio.iomux.fmux);
+    rk30_mux_api_set(rksdmmc1_gpio_init.data3_gpio.iomux.name, rksdmmc1_gpio_init.data3_gpio.iomux.fmux);
 }
 
 static void rk29_sdmmc_set_iomux_mmc2(unsigned int bus_width)
@@ -226,37 +1197,245 @@ static void rk29_sdmmc_set_iomux(int device_id, unsigned int bus_width)
 
 
 
-#ifdef CONFIG_WIFI_CONTROL_FUNC
+//1.Part 4: The various operations of the Wifi-BT module
+/*************************************************************************
+* define the varaious operations for Wifi module
+* Generally only the author of Wifi module will modify this section.
+*************************************************************************/
+
+static int rk29sdk_wifi_status(struct device *dev);
+static int rk29sdk_wifi_status_register(void (*callback)(int card_presend, void *dev_id), void *dev_id);
+
+#if defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC)
+static int rk29sdk_wifi_mmc0_status(struct device *dev);
+static int rk29sdk_wifi_mmc0_status_register(void (*callback)(int card_presend, void *dev_id), void *dev_id);
+static int rk29sdk_wifi_mmc0_cd = 0;   /* wifi virtual 'card detect' status */
+static void (*wifi_mmc0_status_cb)(int card_present, void *dev_id);
+static void *wifi_mmc0_status_cb_devid;
+
+int rk29sdk_wifi_power_state = 0;
+int rk29sdk_bt_power_state = 0;
+
+    #if defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+    	/////////////////////////////////////////////////////////////////////////////////////
+	    // set the gpio to develop wifi EVB if you select the macro of CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD
+	    #define USE_SDMMC_CONTROLLER_FOR_WIFI   0
+   		#define COMBO_MODULE_MT6620_CDT         0  //- 1--use Cdtech chip; 0--unuse CDT chip
+        //power
+        #define RK30SDK_WIFI_GPIO_POWER_N                   RK30_PIN3_PD0            
+        #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE        GPIO_HIGH        
+        #define RK30SDK_WIFI_GPIO_POWER_PIN_NAME            GPIO3D0_SDMMC1PWREN_NAME
+        #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO         GPIO3D_GPIO3D0
+        #define RK30SDK_WIFI_GPIO_POWER_IOMUX_FMUX          GPIO3D_SDMMC1_PWR_EN
+        //reset
+        #define RK30SDK_WIFI_GPIO_RESET_N                   RK30_PIN3_PD1
+        #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE        GPIO_HIGH 
+        #define RK30SDK_WIFI_GPIO_RESET_PIN_NAME            GPIO3D1_SDMMC1BACKENDPWR_NAME
+        #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO         GPIO3D_GPIO3D1
+        #define RK30SDK_WIFI_GPIO_RESET_IOMUX_FMUX          GPIO3D_SDMMC1_BACKEND_PWR
+        //VDDIO
+        //#define RK30SDK_WIFI_GPIO_VCCIO_WL                 RK30_PIN2_PC5
+        //#define RK30SDK_WIFI_GPIO_VCCIO_WL_ENABLE_VALUE    GPIO_HIGH       
+        //WIFI_INT_B
+        #define RK30SDK_WIFI_GPIO_WIFI_INT_B                RK30_PIN3_PD2
+        #define RK30SDK_WIFI_GPIO_WIFI_INT_B_ENABLE_VALUE   GPIO_HIGH 
+        #define RK30SDK_WIFI_GPIO_WIFI_INT_B_PIN_NAME       GPIO3D2_SDMMC1INTN_NAME
+        #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FGPIO    GPIO3D_GPIO3D2
+        #define RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FMUX     GPIO3D_SDMMC1_INT_N
+        //BGF_INT_B
+        #define RK30SDK_WIFI_GPIO_BGF_INT_B                 RK30_PIN3_PC6
+        #define RK30SDK_WIFI_GPIO_BGF_INT_B_ENABLE_VALUE    GPIO_HIGH 
+        #define RK30SDK_WIFI_GPIO_BGF_INT_B_PIN_NAME        GPIO3C6_SDMMC1DETECTN_NAME
+        #define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FGPIO     GPIO3C_GPIO3C6
+        #define RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FMUX      GPIO3C_SDMMC1_DETECT_N
+        //GPS_SYNC
+        #define RK30SDK_WIFI_GPIO_GPS_SYNC                  RK30_PIN3_PC7
+        #define RK30SDK_WIFI_GPIO_GPS_SYNC_ENABLE_VALUE     GPIO_HIGH 
+        #define RK30SDK_WIFI_GPIO_GPS_SYNC_PIN_NAME         GPIO3C7_SDMMC1WRITEPRT_NAME
+        #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FGPIO      GPIO3C_GPIO3C7
+        #define RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FMUX       GPIO3C_SDMMC1_WRITE_PRT
+
+        #if COMBO_MODULE_MT6620_CDT
+        //ANTSEL2
+        #define RK30SDK_WIFI_GPIO_ANTSEL2                   RK30_PIN4_PD4
+        #define RK30SDK_WIFI_GPIO_ANTSEL2_ENABLE_VALUE      GPIO_LOW    //use 6620 in CDT chip, LOW--work; High--no work.
+        #define RK30SDK_WIFI_GPIO_ANTSEL2_PIN_NAME          GPIO4D4_SMCDATA12_TRACEDATA12_NAME
+        #define RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FGPIO       GPIO4D_GPIO4D4
+        #define RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FMUX        GPIO4D_TRACE_DATA12
+        //ANTSEL3
+        #define RK30SDK_WIFI_GPIO_ANTSEL3                   RK30_PIN4_PD3
+        #define RK30SDK_WIFI_GPIO_ANTSEL3_ENABLE_VALUE      GPIO_HIGH    //use 6620 in CDT chip, High--work; Low--no work..
+        #define RK30SDK_WIFI_GPIO_ANTSEL3_PIN_NAME          GPIO4D3_SMCDATA11_TRACEDATA11_NAME
+        #define RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FGPIO       GPIO4D_GPIO4D3
+        #define RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FMUX        GPIO4D_TRACE_DATA11
+        //GPS_LAN
+        #define RK30SDK_WIFI_GPIO_GPS_LAN                   RK30_PIN4_PD6
+        #define RK30SDK_WIFI_GPIO_GPS_LAN_ENABLE_VALUE      GPIO_HIGH    //use 6620 in CDT chip, High--work; Low--no work..
+        #define RK30SDK_WIFI_GPIO_GPS_LAN_PIN_NAME          GPIO4D6_SMCDATA14_TRACEDATA14_NAME
+        #define RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FGPIO       GPIO4D_GPIO4D6
+        #define RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FMUX        GPIO4D_TRACE_DATA14
+        #endif // #if COMBO_MODULE_MT6620_CDT--#endif
+        
+    #endif // #if defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)---#endif
+#endif // #if defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC) ---#endif
 
-//
-// Define wifi module's power and reset gpio, and gpio sensitive level 
-//
+static int rk29sdk_wifi_cd = 0;   /* wifi virtual 'card detect' status */
+static void (*wifi_status_cb)(int card_present, void *dev_id);
+static void *wifi_status_cb_devid;
 
-#if defined(CONFIG_RK903) || defined(CONFIG_RK901)
-#define RK30SDK_WIFI_GPIO_POWER_N       RK2928_PIN0_PD6
-#define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE GPIO_HIGH 
-#define RK30SDK_WIFI_GPIO_RESET_N       RK2928_PIN3_PC2
-#define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE GPIO_HIGH 
+#if defined(CONFIG_RK29_SDIO_IRQ_FROM_GPIO)
+#define RK29SDK_WIFI_SDIO_CARD_INT         RK30SDK_WIFI_GPIO_WIFI_INT_B
 #endif
 
-#if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) 
-#define RK30SDK_WIFI_GPIO_POWER_N       RK2928_PIN0_PD6
-#define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE GPIO_LOW 
-#endif
+struct rksdmmc_gpio_wifi_moudle  rk_platform_wifi_gpio = {
+    .power_n = {
+            .io             = RK30SDK_WIFI_GPIO_POWER_N, 
+            .enable         = RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_POWER_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_POWER_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_POWER_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_POWER_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_POWER_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+     },
+     
+    #ifdef RK30SDK_WIFI_GPIO_RESET_N
+    .reset_n = {
+            .io             = RK30SDK_WIFI_GPIO_RESET_N,
+            .enable         = RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_RESET_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_RESET_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_RESET_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_RESET_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_RESET_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+    },
+    #endif
+    
+    #ifdef RK30SDK_WIFI_GPIO_WIFI_INT_B
+    .wifi_int_b = {
+            .io             = RK30SDK_WIFI_GPIO_WIFI_INT_B,
+            .enable         = RK30SDK_WIFI_GPIO_WIFI_INT_B_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_WIFI_INT_B_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_WIFI_INT_B_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_WIFI_INT_B_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+     },
+     #endif
+
+    #ifdef RK30SDK_WIFI_GPIO_VCCIO_WL 
+    .vddio = {
+            .io             = RK30SDK_WIFI_GPIO_VCCIO_WL,
+            .enable         = RK30SDK_WIFI_GPIO_VCCIO_WL_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_VCCIO_WL_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_VCCIO_WL_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_VCCIO_WL_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_VCCIO_WL_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_VCCIO_WL_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+     },
+     #endif
+     
+     #ifdef RK30SDK_WIFI_GPIO_BGF_INT_B
+    .bgf_int_b = {
+            .io             = RK30SDK_WIFI_GPIO_BGF_INT_B,
+            .enable         = RK30SDK_WIFI_GPIO_BGF_INT_B_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_BGF_INT_B_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_BGF_INT_B_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_BGF_INT_B_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+        },       
+    #endif
+    
+    #ifdef RK30SDK_WIFI_GPIO_GPS_SYNC
+    .gps_sync = {
+            .io             = RK30SDK_WIFI_GPIO_GPS_SYNC,
+            .enable         = RK30SDK_WIFI_GPIO_GPS_SYNC_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_GPS_SYNC_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_GPS_SYNC_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_GPS_SYNC_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+    },
+    #endif
+    
+#if COMBO_MODULE_MT6620_CDT
+    #ifdef RK30SDK_WIFI_GPIO_ANTSEL2
+    .ANTSEL2 = {
+            .io             = RK30SDK_WIFI_GPIO_ANTSEL2,
+            .enable         = RK30SDK_WIFI_GPIO_ANTSEL2_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_ANTSEL2_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_ANTSEL2_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_ANTSEL2_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+    },
+    #endif
+
+    #ifdef RK30SDK_WIFI_GPIO_ANTSEL3
+    .ANTSEL3 = {
+            .io             = RK30SDK_WIFI_GPIO_ANTSEL3,
+            .enable         = RK30SDK_WIFI_GPIO_ANTSEL3_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_ANTSEL3_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_ANTSEL3_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_ANTSEL3_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+    },
+    #endif
+
+    #ifdef RK30SDK_WIFI_GPIO_GPS_LAN
+    .GPS_LAN = {
+            .io             = RK30SDK_WIFI_GPIO_GPS_LAN,
+            .enable         = RK30SDK_WIFI_GPIO_GPS_LAN_ENABLE_VALUE,
+            #ifdef RK30SDK_WIFI_GPIO_GPS_LAN_PIN_NAME
+            .iomux          = {
+                .name       = RK30SDK_WIFI_GPIO_GPS_LAN_PIN_NAME,
+                .fgpio      = RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FGPIO,
+                #ifdef RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FMUX
+                .fmux       = RK30SDK_WIFI_GPIO_GPS_LAN_IOMUX_FMUX,
+                #endif
+            },
+            #endif
+    },
+    #endif
+#endif // #if COMBO_MODULE_MT6620_CDT--#endif   
+};
 
-#if defined(CONFIG_BCM4329) || defined(CONFIG_BCM4319) 
-#define RK30SDK_WIFI_GPIO_POWER_N       RK2928_PIN0_PD6
-#define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE GPIO_HIGH 
-#define RK30SDK_WIFI_GPIO_RESET_N       RK2928_PIN3_PC2
-#define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE GPIO_HIGH 
-#endif
-#if defined(CONFIG_RDA5990)
-#define RK30SDK_WIFI_GPIO_POWER_N       RK2928_PIN0_PD6
-#define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE GPIO_HIGH 
-#define RK30SDK_WIFI_GPIO_RESET_N       RK2928_PIN3_PC2
-#define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE GPIO_HIGH 
-#endif
 
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
 #define PREALLOC_WLAN_SEC_NUM           4
 #define PREALLOC_WLAN_BUF_NUM           160
 #define PREALLOC_WLAN_SECTION_HEADER    24
@@ -333,10 +1512,6 @@ static int __init rk29sdk_init_wifi_mem(void)
         return -ENOMEM;
 }
 
-static int rk29sdk_wifi_cd = 0;   /* wifi virtual 'card detect' status */
-static void (*wifi_status_cb)(int card_present, void *dev_id);
-static void *wifi_status_cb_devid;
-
 static int rk29sdk_wifi_status(struct device *dev)
 {
         return rk29sdk_wifi_cd;
@@ -351,92 +1526,138 @@ static int rk29sdk_wifi_status_register(void (*callback)(int card_present, void
         return 0;
 }
 
+#if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) || defined(CONFIG_RT5370)
 static int __init rk29sdk_wifi_bt_gpio_control_init(void)
 {
-    rk29sdk_init_wifi_mem();
-    
-    rk29_mux_api_set(GPIO0D6_MMC1_PWREN_NAME, GPIO0D_GPIO0D6);
+#if defined(CONFIG_USB_WIFI_POWER_CONTROLED_BY_GPIO)
+    if (gpio_request(rk_platform_wifi_gpio.power_n.io, "wifi_power")) {
+           pr_info("%s: request wifi power gpio failed\n", __func__);
+           return -1;
+    }
+    gpio_direction_output(rk_platform_wifi_gpio.power_n.io, !(rk_platform_wifi_gpio.power_n.enable) );
+#endif
+    pr_info("%s: init finished\n",__func__);
+    return 0;
+}
+#elif defined(CONFIG_RDA5990)
+static int __init rk29sdk_wifi_bt_gpio_control_init(void)
+{
+    #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
+    rk29_sdmmc_gpio_open(1, 0); //added by xbw at 2011-10-13
+    #endif
+    pr_info("%s: init finished\n",__func__);
+
+    return 0;
+}
+#else
+static int __init rk29sdk_wifi_bt_gpio_control_init(void)
+{
+    rk29sdk_init_wifi_mem();    
+    rk29_mux_api_set(rk_platform_wifi_gpio.power_n.iomux.name, rk_platform_wifi_gpio.power_n.iomux.fgpio);
     
-    if (gpio_request(RK30SDK_WIFI_GPIO_POWER_N, "wifi_power")) {
+    if (gpio_request(rk_platform_wifi_gpio.power_n.io, "wifi_power")) {
            pr_info("%s: request wifi power gpio failed\n", __func__);
            return -1;
     }
 
 #ifdef RK30SDK_WIFI_GPIO_RESET_N
-    if (gpio_request(RK30SDK_WIFI_GPIO_RESET_N, "wifi reset")) {
+    if (gpio_request(rk_platform_wifi_gpio.reset_n.io, "wifi reset")) {
            pr_info("%s: request wifi reset gpio failed\n", __func__);
-           gpio_free(RK30SDK_WIFI_GPIO_POWER_N);
+           gpio_free(rk_platform_wifi_gpio.reset_n.io);
            return -1;
     }
 #endif    
 
-    gpio_direction_output(RK30SDK_WIFI_GPIO_POWER_N, !RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE);
-#ifdef RK30SDK_WIFI_GPIO_RESET_N    
-    gpio_direction_output(RK30SDK_WIFI_GPIO_RESET_N, !RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE);
-#endif    
-
-    #if 0//defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-    
-    rk29_mux_api_set(GPIO0B4_MMC1_D1_NAME, GPIO0B_GPIO0B4);
-    gpio_request(RK2928_PIN0_PB4, "mmc1-data1");
-    gpio_direction_output(RK2928_PIN0_PB4,GPIO_LOW);//set mmc1-data1 to low.
+    gpio_direction_output(rk_platform_wifi_gpio.power_n.io, !(rk_platform_wifi_gpio.power_n.enable) );
 
-    rk29_mux_api_set(GPIO0B5_MMC1_D2_NAME, GPIO0B_GPIO0B5);
-    gpio_request(RK2928_PIN0_PB5, "mmc1-data2");
-    gpio_direction_output(RK2928_PIN0_PB5,GPIO_LOW);//set mmc1-data2 to low.
+#ifdef RK30SDK_WIFI_GPIO_RESET_N 
+    gpio_direction_output(rk_platform_wifi_gpio.reset_n.io, !(rk_platform_wifi_gpio.reset_n.enable) );
+#endif    
 
-    rk29_mux_api_set(GPIO0B6_MMC1_D3_NAME, GPIO0B_GPIO0B6);
-    gpio_request(RK2928_PIN0_PB6, "mmc1-data3");
-    gpio_direction_output(RK2928_PIN0_PB6,GPIO_LOW);//set mmc1-data3 to low.
-    
+    #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
     rk29_sdmmc_gpio_open(1, 0); //added by xbw at 2011-10-13
     #endif    
     pr_info("%s: init finished\n",__func__);
 
     return 0;
 }
+#endif
 
-#if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) 
+#if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) || defined(CONFIG_RT5370)
 static int usbwifi_power_status = 1;
 int rk29sdk_wifi_power(int on)
 {
         pr_info("%s: %d\n", __func__, on);
          if (on){
-                /*if(usbwifi_power_status == 1) {
+		#if defined(CONFIG_USB_WIFI_POWER_CONTROLED_BY_GPIO) 
+                gpio_set_value(rk_platform_wifi_gpio.power_n.io, rk_platform_wifi_gpio.power_n.enable);
+                mdelay(100);		
+		#else         	
+                if(usbwifi_power_status == 1) {
                     rkusb_wifi_power(0);
                     mdelay(50);
-                }*/
+                }
                 rkusb_wifi_power(1);
+		#endif
                 usbwifi_power_status = 1;
                  pr_info("wifi turn on power\n");  	
         }else{
+		#if defined(CONFIG_USB_WIFI_POWER_CONTROLED_BY_GPIO) 
+                gpio_set_value(rk_platform_wifi_gpio.power_n.io, !(rk_platform_wifi_gpio.power_n.enable));
+                mdelay(100);		
+		#else
                 rkusb_wifi_power(0);
+		#endif
                 usbwifi_power_status = 0;    	
                  pr_info("wifi shut off power\n");
         }
         return 0;
 }
+#elif  defined(CONFIG_RDA5990)
+int rk29sdk_wifi_power(int on)
+{
+        pr_info("%s: %d\n", __func__, on);
+        if (on){
+           mdelay(50);
+
+                #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)      
+                rk29_sdmmc_gpio_open(1, 1); //added by xbw at 2011-10-13
+                #endif
+
+                mdelay(100);
+                pr_info("wifi turn on power\n");
+        }else{
+                        #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)      
+                        rk29_sdmmc_gpio_open(1, 0); //added by xbw at 2011-10-13
+                        #endif
+
+                        mdelay(100);
+                        pr_info("wifi shut off power\n");
+        }
+
+        return 0;
+}
+
 #else
 int rk29sdk_wifi_power(int on)
 {
         pr_info("%s: %d\n", __func__, on);
         if (on){
-                //gpio_set_value(RK30SDK_WIFI_GPIO_POWER_N, RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE);
-                mdelay(50);
+                gpio_set_value(rk_platform_wifi_gpio.power_n.io, rk_platform_wifi_gpio.power_n.enable);
+	   mdelay(50);
 
                 #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)	
                 rk29_sdmmc_gpio_open(1, 1); //added by xbw at 2011-10-13
                 #endif
 
-#ifdef RK30SDK_WIFI_GPIO_RESET_N
-                //gpio_set_value(RK30SDK_WIFI_GPIO_RESET_N, RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE);
-#endif                
+            #ifdef RK30SDK_WIFI_GPIO_RESET_N
+                gpio_set_value(rk_platform_wifi_gpio.reset_n.io, rk_platform_wifi_gpio.reset_n.enable);
+            #endif                
                 mdelay(100);
                 pr_info("wifi turn on power\n");
         }else{
 //                if (!rk29sdk_bt_power_state){
-                       // gpio_set_value(RK30SDK_WIFI_GPIO_POWER_N, !RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE);
-
+                        gpio_set_value(rk_platform_wifi_gpio.power_n.io, !(rk_platform_wifi_gpio.power_n.enable));
                         #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)	
                         rk29_sdmmc_gpio_open(1, 0); //added by xbw at 2011-10-13
                         #endif
@@ -448,12 +1669,11 @@ int rk29sdk_wifi_power(int on)
 //                        pr_info("wifi shouldn't shut off power, bt is using it!\n");
 //                }
 #ifdef RK30SDK_WIFI_GPIO_RESET_N
-                //gpio_set_value(RK30SDK_WIFI_GPIO_RESET_N, !RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE);
+                gpio_set_value(rk_platform_wifi_gpio.reset_n.io, !(rk_platform_wifi_gpio.reset_n.enable));
 #endif 
-
         }
 
-        //rk29sdk_wifi_power_state = on;
+//        rk29sdk_wifi_power_state = on;
         return 0;
 }
 #endif
@@ -481,7 +1701,6 @@ int rk29sdk_wifi_set_carddetect(int val)
 }
 EXPORT_SYMBOL(rk29sdk_wifi_set_carddetect);
 
-#define WIFI_HOST_WAKE RK2928_PIN3_PC0
 
 static struct resource resources[] = {
 	{
@@ -490,7 +1709,261 @@ static struct resource resources[] = {
 		.name = "bcmdhd_wlan_irq",
 	},
 };
+ //#if defined(CONFIG_WIFI_CONTROL_FUNC)----#elif
+
+///////////////////////////////////////////////////////////////////////////////////
+#elif defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC)
+
+#define debug_combo_system 0
+
+int rk29sdk_wifi_combo_get_BGFgpio(void)
+{
+    return rk_platform_wifi_gpio.bgf_int_b.io;
+}
+EXPORT_SYMBOL(rk29sdk_wifi_combo_get_BGFgpio);
+
+
+int rk29sdk_wifi_combo_get_GPS_SYNC_gpio(void)
+{
+    return rk_platform_wifi_gpio.gps_sync.io;
+}
+EXPORT_SYMBOL(rk29sdk_wifi_combo_get_GPS_SYNC_gpio);
+
+
+static int rk29sdk_wifi_combo_module_gpio_init(void)
+{
+    //VDDIO
+    #ifdef RK30SDK_WIFI_GPIO_VCCIO_WL
+        #ifdef RK30SDK_WIFI_GPIO_VCCIO_WL_PIN_NAME
+        rk30_mux_api_set(rk_platform_wifi_gpio.vddio.iomux.name, rk_platform_wifi_gpio.vddio.iomux.fgpio);
+        #endif
+        gpio_request(rk_platform_wifi_gpio.vddio.io, "combo-VDDIO");	
+	    gpio_direction_output(rk_platform_wifi_gpio.vddio.io, !(rk_platform_wifi_gpio.power_n.enable));
+    #endif
+    
+    //BGF_INT_B
+    #ifdef RK30SDK_WIFI_GPIO_BGF_INT_B_PIN_NAME
+    rk30_mux_api_set(rk_platform_wifi_gpio.bgf_int_b.iomux.name, rk_platform_wifi_gpio.bgf_int_b.iomux.fgpio);
+    #endif
+    gpio_request(rk_platform_wifi_gpio.bgf_int_b.io, "combo-BGFINT");
+    gpio_pull_updown(rk_platform_wifi_gpio.bgf_int_b.io, GPIOPullUp);
+    gpio_direction_input(rk_platform_wifi_gpio.bgf_int_b.io);
+    
+    //WIFI_INT_B
+    #ifdef RK30SDK_WIFI_GPIO_WIFI_INT_B_PIN_NAME
+    rk30_mux_api_set(rk_platform_wifi_gpio.bgf_int_b.iomux.name, rk_platform_wifi_gpio.bgf_int_b.iomux.fgpio);
+    #endif
+    gpio_request(rk_platform_wifi_gpio.wifi_int_b.io, "combo-WIFIINT");
+    gpio_pull_updown(rk_platform_wifi_gpio.wifi_int_b.io, GPIOPullUp);
+    gpio_direction_input(rk_platform_wifi_gpio.wifi_int_b.io); 
+    
+    //reset
+    #ifdef RK30SDK_WIFI_GPIO_RESET_PIN_NAME
+    rk30_mux_api_set(rk_platform_wifi_gpio.reset_n.iomux.name, rk_platform_wifi_gpio.reset_n.iomux.fgpio);
+    #endif
+    gpio_request(rk_platform_wifi_gpio.reset_n.io, "combo-RST");
+    gpio_direction_output(rk_platform_wifi_gpio.reset_n.io, !(rk_platform_wifi_gpio.reset_n.enable));
+
+    //power
+    #ifdef RK30SDK_WIFI_GPIO_POWER_PIN_NAME
+    rk30_mux_api_set(rk_platform_wifi_gpio.power_n.iomux.name, rk_platform_wifi_gpio.power_n.iomux.fgpio);
+    #endif
+    gpio_request(rk_platform_wifi_gpio.power_n.io, "combo-PMUEN");	
+	gpio_direction_output(rk_platform_wifi_gpio.power_n.io, !(rk_platform_wifi_gpio.power_n.enable));
+
+	#if COMBO_MODULE_MT6620_CDT
+	//ANTSEL2
+	#ifdef RK30SDK_WIFI_GPIO_ANTSEL2
+	    #ifdef RK30SDK_WIFI_GPIO_ANTSEL2_PIN_NAME
+        rk30_mux_api_set(rk_platform_wifi_gpio.ANTSEL2.iomux.name, rk_platform_wifi_gpio.ANTSEL2.iomux.fgpio);
+        #endif
+    gpio_request(rk_platform_wifi_gpio.ANTSEL2.io, "combo-ANTSEL2");
+    gpio_direction_output(rk_platform_wifi_gpio.reset_n.io, rk_platform_wifi_gpio.ANTSEL2.enable);
+    #endif
+
+    //ANTSEL3
+    #ifdef RK30SDK_WIFI_GPIO_ANTSEL3
+        #ifdef RK30SDK_WIFI_GPIO_ANTSEL3_PIN_NAME
+        rk30_mux_api_set(rk_platform_wifi_gpio.ANTSEL3.iomux.name, rk_platform_wifi_gpio.ANTSEL3.iomux.fgpio);
+        #endif
+    gpio_request(rk_platform_wifi_gpio.ANTSEL3.io, "combo-ANTSEL3");
+    gpio_direction_output(rk_platform_wifi_gpio.ANTSEL3.io, rk_platform_wifi_gpio.ANTSEL3.enable);
+    #endif
+
+    //GPS_LAN
+    #ifdef RK30SDK_WIFI_GPIO_GPS_LAN
+        #ifdef RK30SDK_WIFI_GPIO_GPS_LAN_PIN_NAME
+        rk30_mux_api_set(rk_platform_wifi_gpio.GPS_LAN.iomux.name, rk_platform_wifi_gpio.GPS_LAN.iomux.fgpio);
+        #endif
+    gpio_request(rk_platform_wifi_gpio.GPS_LAN.io, "combo-GPSLAN");
+    gpio_direction_output(rk_platform_wifi_gpio.GPS_LAN.io, rk_platform_wifi_gpio.GPS_LAN.enable);
+	#endif
+
+	#endif//#if COMBO_MODULE_MT6620_CDT ---#endif 
+
+    return 0;
+}
+
+
+int rk29sdk_wifi_combo_module_power(int on)
+{
+     if(on)
+    {
+    #ifdef RK30SDK_WIFI_GPIO_VCCIO_WL
+        gpio_set_value(rk_platform_wifi_gpio.vddio.io, rk_platform_wifi_gpio.vddio.enable);
+        mdelay(10);
+    #endif
+	
+        gpio_set_value(rk_platform_wifi_gpio.power_n.io, rk_platform_wifi_gpio.power_n.enable);     
+        mdelay(10);
+        pr_info("combo-module turn on power\n");
+    }
+    else
+    {
+        gpio_set_value(rk_platform_wifi_gpio.power_n.io, !(rk_platform_wifi_gpio.power_n.enable) );        
+        mdelay(10);
+
+	 #ifdef RK30SDK_WIFI_GPIO_VCCIO_WL	
+        gpio_set_value(rk_platform_wifi_gpio.vddio.io, !(rk_platform_wifi_gpio.vddio.enable));
+	 #endif
+	 
+        pr_info("combo-module turn off power\n");
+    }
+     return 0;
+    
+}
+EXPORT_SYMBOL(rk29sdk_wifi_combo_module_power);
+
+
+int rk29sdk_wifi_combo_module_reset(int on)
+{
+    if(on)
+    {
+        gpio_set_value(rk_platform_wifi_gpio.reset_n.io, rk_platform_wifi_gpio.reset_n.enable);     
+        pr_info("combo-module reset out 1\n");
+    }
+    else
+    {
+        gpio_set_value(rk_platform_wifi_gpio.reset_n.io, !(rk_platform_wifi_gpio.reset_n.enable) );        
+        pr_info("combo-module  reset out 0\n");
+    }
+
+    return 0;   
+}
+EXPORT_SYMBOL(rk29sdk_wifi_combo_module_reset);
+
+
+static int rk29sdk_wifi_mmc0_status(struct device *dev)
+{
+        return rk29sdk_wifi_mmc0_cd;
+}
+
+static int rk29sdk_wifi_mmc0_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
+{
+        if(wifi_mmc0_status_cb)
+                return -EAGAIN;
+        wifi_mmc0_status_cb = callback;
+        wifi_mmc0_status_cb_devid = dev_id;
+        return 0;
+}
+
+
+static int rk29sdk_wifi_status(struct device *dev)
+{
+        return rk29sdk_wifi_cd;
+}
+
+static int rk29sdk_wifi_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
+{
+        if(wifi_status_cb)
+                return -EAGAIN;
+        wifi_status_cb = callback;
+        wifi_status_cb_devid = dev_id;
+        return 0;
+}
+
+int rk29sdk_wifi_power(int on)
+{
+    pr_info("%s: %d\n", __func__, on);
+    if (on){
+    
+        #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)  
+            
+          #if defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+             rk29_sdmmc_gpio_open(0, 1); 
+          #else
+            rk29_sdmmc_gpio_open(1, 0);                
+            mdelay(10);
+            rk29_sdmmc_gpio_open(1, 1); 
+          #endif 
+        #endif
+    
+            mdelay(100);
+            pr_info("wifi turn on power\n");
+    }
+    else
+    {    
+#if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
+        #if defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+        rk29_sdmmc_gpio_open(0, 0);
+        #else
+        rk29_sdmmc_gpio_open(1, 0);
+        #endif
+#endif      
+        mdelay(100);
+        pr_info("wifi shut off power\n");
+         
+    }
+    
+    rk29sdk_wifi_power_state = on;
+    return 0;
+
+}
+EXPORT_SYMBOL(rk29sdk_wifi_power);
+
+
+int rk29sdk_wifi_reset(int on)
+{    
+    return 0;
+}
+EXPORT_SYMBOL(rk29sdk_wifi_reset);
+
 
+#if defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+int rk29sdk_wifi_set_carddetect(int val)
+{
+    pr_info("%s:%d\n", __func__, val);
+    rk29sdk_wifi_mmc0_cd = val;
+    if (wifi_mmc0_status_cb){
+            wifi_mmc0_status_cb(val, wifi_mmc0_status_cb_devid);
+    }else {
+            pr_warning("%s,in mmc0 nobody to notify\n", __func__);
+    }
+    return 0; 
+}
+
+#else
+int rk29sdk_wifi_set_carddetect(int val)
+{
+    pr_info("%s:%d\n", __func__, val);
+    rk29sdk_wifi_cd = val;
+    if (wifi_status_cb){
+            wifi_status_cb(val, wifi_status_cb_devid);
+    }else {
+            pr_warning("%s,in mmc1 nobody to notify\n", __func__);
+    }
+    return 0; 
+}
+#endif
+
+EXPORT_SYMBOL(rk29sdk_wifi_set_carddetect);
+
+///////////////////////////////////////////////////////////////////////////////////
+#endif  //#if defined(CONFIG_WIFI_CONTROL_FUNC)---#elif defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC) --#endif
+
+
+
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
 static struct wifi_platform_data rk29sdk_wifi_control = {
         .set_power = rk29sdk_wifi_power,
         .set_reset = rk29sdk_wifi_reset,
@@ -507,8 +1980,38 @@ static struct platform_device rk29sdk_wifi_device = {
                 .platform_data = &rk29sdk_wifi_control,
          },
 };
-#endif
 
+#elif defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC)
+
+    #if debug_combo_system
+        static struct combo_module_platform_data rk29sdk_combo_module_control = {
+            .set_power = rk29sdk_wifi_combo_module_power,
+            .set_reset = rk29sdk_wifi_combo_module_reset,  
+        };
+
+        static struct platform_device  rk29sdk_combo_module_device = {
+                .name = "combo-system",
+                .id = 1,
+                .dev = {
+                        .platform_data = &rk29sdk_combo_module_control,
+                 },
+        };
+    #endif
+
+static struct wifi_platform_data rk29sdk_wifi_control = {
+        .set_power = rk29sdk_wifi_power,
+        .set_reset = rk29sdk_wifi_reset,
+        .set_carddetect = rk29sdk_wifi_set_carddetect,
+};
+
+static struct platform_device rk29sdk_wifi_device = {
+        .name = "combo-wifi",
+        .id = 1,
+        .dev = {
+                .platform_data = &rk29sdk_wifi_control,
+         },
+};
+
+#endif
 
-#endif // endif --#ifdef CONFIG_SDMMC_RK29
 
diff --git a/arch/arm/mach-rk2928/board-rk2928-phonepad-tps65910.c b/arch/arm/mach-rk2928/board-rk2928-phonepad-tps65910.c
new file mode 100755
index 000000000000..48acf44d25f7
--- /dev/null
+++ b/arch/arm/mach-rk2928/board-rk2928-phonepad-tps65910.c
@@ -0,0 +1,638 @@
+#include <linux/regulator/machine.h>
+#include <linux/i2c/twl.h>
+#include <linux/mfd/tps65910.h>
+#include <mach/sram.h>
+#include <linux/platform_device.h>
+
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#define PMU_POWER_SLEEP RK2928_PIN1_PA1
+#ifdef CONFIG_MFD_TPS65910
+
+extern int platform_device_register(struct platform_device *pdev);
+
+int tps65910_pre_init(struct tps65910 *tps65910){
+
+	int val = 0;
+	int i 	= 0;
+	int err = -1;
+		
+	printk("%s,line=%d\n", __func__,__LINE__);	
+#ifdef CONFIG_RK_CONFIG
+        if(sram_gpio_init(get_port_config(pmic_slp).gpio, &pmic_sleep) < 0){
+                printk(KERN_ERR "sram_gpio_init failed\n");
+                return -EINVAL;
+        }
+        if(port_output_init(pmic_slp, 0, "pmic_slp") < 0){
+                printk(KERN_ERR "port_output_init failed\n");
+                return -EINVAL;
+        }
+#else
+        if(sram_gpio_init(PMU_POWER_SLEEP, &pmic_sleep) < 0){
+                printk(KERN_ERR "sram_gpio_init failed\n");
+                return -EINVAL;
+        }
+//	GPIO1A1_I2S_SCLK_NAME
+	rk30_mux_api_set(GPIO1A1_I2S_SCLK_NAME, 0);
+
+	gpio_request(PMU_POWER_SLEEP, "NULL");
+	gpio_direction_output(PMU_POWER_SLEEP, GPIO_LOW);
+#endif
+
+	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL2);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_DEVCTRL2 reg\n");
+		return val;
+	}
+	/* Set sleep state active high and allow device turn-off after PWRON long press */
+	val |= (DEVCTRL2_SLEEPSIG_POL_MASK | DEVCTRL2_PWON_LP_OFF_MASK);
+
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL2, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_DEVCTRL2 reg\n");
+		return err;
+	}
+	 #if 1
+	/* set PSKIP=0 */
+        val = tps65910_reg_read(tps65910, TPS65910_DCDCCTRL);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+
+	val &= ~DEVCTRL_DEV_OFF_MASK;
+	val &= ~DEVCTRL_DEV_SLP_MASK;
+        err = tps65910_reg_write(tps65910, TPS65910_DCDCCTRL, val);
+        if (err) {
+                printk(KERN_ERR "Unable to write TPS65910_DCDCCTRL reg\n");
+                return err;
+        }
+	#endif
+	/* Set the maxinum load current */
+	/* VDD1 */
+	val = tps65910_reg_read(tps65910, TPS65910_VDD1);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VDD1 reg\n");
+		return val;
+	}
+
+	val |= (1<<5);		//when 1: 1.5 A
+	val |= (0x07<<2);	//TSTEP[2:0] = 111 : 2.5 mV/|s(sampling 3 Mhz/5)
+	err = tps65910_reg_write(tps65910, TPS65910_VDD1, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VDD1 reg\n");
+		return err;
+	}
+
+	/* VDD2 */
+	val = tps65910_reg_read(tps65910, TPS65910_VDD2);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VDD2 reg\n");
+		return val;
+	}
+
+	val |= (1<<5);		//when 1: 1.5 A
+	err = tps65910_reg_write(tps65910, TPS65910_VDD2, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VDD2 reg\n");
+		return err;
+	}
+
+	/* VIO */
+	val = tps65910_reg_read(tps65910, TPS65910_VIO);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VIO reg\n");
+		return -EIO;
+	}
+
+	val |= (1<<6);	//when 01: 1.0 A
+	err = tps65910_reg_write(tps65910, TPS65910_VIO, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VIO reg\n");
+		return err;
+	}
+	#if 1
+	/* Mask ALL interrupts */
+	err = tps65910_reg_write(tps65910,TPS65910_INT_MSK, 0xFF);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_INT_MSK reg\n");
+		return err;
+	}
+	
+	err = tps65910_reg_write(tps65910, TPS65910_INT_MSK2, 0x03);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_INT_MSK2 reg\n");
+		return err;
+	}
+
+	/* Set RTC Power, disable Smart Reflex in DEVCTRL_REG */
+	#if 1
+	val = 0;
+	val |= (DEVCTRL_SR_CTL_I2C_SEL_MASK);
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_DEVCTRL reg\n");
+		return err;
+	}
+	printk(KERN_INFO "TPS65910 Set default voltage.\n");
+	#endif
+	#if 0
+	//read sleep control register  for debug
+	for(i=0; i<6; i++)
+	{
+        err = tps65910_reg_read(tps65910, &val, TPS65910_DEVCTRL+i);
+        if (err) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return -EIO;
+        }
+		else
+		printk("%s.......is  0x%04x\n",__FUNCTION__,val);
+	}
+	#endif
+
+	#if 1
+	//sleep control register
+	/*set func when in sleep mode */
+	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val |= (1 << 1);
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	
+	/* open ldo when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_KEEP_LDO_ON);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val &= 0;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_KEEP_LDO_ON, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+		
+	/*set dc mode when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_KEEP_RES_ON);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val  |= 0xff;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_KEEP_RES_ON, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	
+	/*close ldo when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_SET_LDO_OFF);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val |= 0x90;
+	//val |= 0x00;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_SET_LDO_OFF, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	
+	#endif
+	#if 0
+	//read sleep control register  for debug
+	for(i=0; i<6; i++)
+	{
+        err = tps65910_reg_read(tps65910, &val, TPS65910_DEVCTRL+i);
+        if (err) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return -EIO;
+        }
+		else
+		printk("%s.......is  0x%4x\n",__FUNCTION__,val);
+	}
+	#endif
+	#endif
+	
+	printk("%s,line=%d\n", __func__,__LINE__);
+	return 0;
+
+}
+
+
+int tps65910_post_init(struct tps65910 *tps65910)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+	int i = 0;
+	printk("%s,line=%d\n", __func__,__LINE__);
+
+#ifndef CONFIG_RK_CONFIG
+	g_pmic_type = PMIC_TYPE_TPS65910;
+#endif
+	printk("%s:g_pmic_type=%d\n",__func__,g_pmic_type);
+
+	#ifdef CONFIG_RK30_PWM_REGULATOR
+	platform_device_register(&pwm_regulator_device[0]);
+	#endif
+	
+	dcdc = regulator_get(NULL, "vio");	//vcc_io
+	regulator_set_voltage(dcdc, 3300000, 3300000);
+	regulator_enable(dcdc);
+	printk("%s set vio vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+#if defined(CONFIG_MACH_RK2928_TB) || defined(CONFIG_MACH_RK2926_TB) || defined(CONFIG_MACH_RK2926_V86)
+	ldo = regulator_get(NULL, "vpll");	// vcc25
+	regulator_set_voltage(ldo, 2500000, 2500000);
+	regulator_enable(ldo);
+	printk("%s set vpll vcc25=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+#endif
+	ldo = regulator_get(NULL, "vdig2");	// vdd12
+	regulator_set_voltage(ldo, 1200000, 1200000);
+	regulator_enable(ldo);
+	printk("%s set vdig2 vdd12=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "vaux33");	 //vcc_tp
+	regulator_set_voltage(ldo, 3300000, 3300000);
+	regulator_enable(ldo);
+	printk("%s set vaux33 vcc_tp=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+	
+	dcdc = regulator_get(NULL, "vdd_cpu");	//vdd_cpu
+	regulator_set_voltage(dcdc, 1200000, 1200000);
+	regulator_enable(dcdc);
+	printk("%s set vdd1 vdd_cpu=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+	
+	dcdc = regulator_get(NULL, "vdd2");	//vcc_ddr 
+	regulator_set_voltage(dcdc, 1200000, 1200000);	// 1.5*4/5 = 1.2 and Vout=1.5v
+	regulator_enable(dcdc);
+	printk("%s set vdd2 vcc_ddr=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+	
+	ldo = regulator_get(NULL, "vdig1");	//vcc18_cif
+	regulator_set_voltage(ldo, 1800000, 1800000);
+	regulator_enable(ldo);
+	printk("%s set vdig1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+	
+	dcdc = regulator_get(NULL, "vaux1"); //vcc28_cif
+	regulator_set_voltage(dcdc,2800000,2800000);
+	regulator_enable(dcdc); 
+	printk("%s set vaux1 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "vaux2");	//vcca33
+	regulator_set_voltage(ldo, 3300000, 3300000);
+	regulator_enable(ldo);
+	printk("%s set vaux2 vcca33=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+#if defined(CONFIG_MACH_RK2928_TB) || defined(CONFIG_MACH_RK2926_TB)
+	ldo = regulator_get(NULL, "vdac"); // vccio_wl
+	regulator_set_voltage(ldo,1800000,1800000);
+	regulator_enable(ldo); 
+	printk("%s set vdac vccio_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+#endif
+	ldo = regulator_get(NULL, "vmmc");  //vccio_wl
+	regulator_set_voltage(ldo,3300000,3300000);
+	regulator_enable(ldo); 
+	printk("%s set vmmc vccio_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
+#if defined(CONFIG_MACH_RK2928_TB) || defined(CONFIG_MACH_RK2926_TB) || defined(CONFIG_MACH_RK2926_V86) || defined(CONFIG_MACH_RK2928_PHONEPAD_760)
+        //do not disable vccio wl
+#else
+	regulator_disable(ldo);      //for i30 sdcard used vcc_io so must close
+#endif
+	regulator_put(ldo);
+	udelay(100);
+
+	printk("%s,line=%d END\n", __func__,__LINE__);
+	
+	return 0;
+}
+static struct regulator_consumer_supply tps65910_smps1_supply[] = {
+	{
+		.supply = "vdd1",
+	},
+	{
+		.supply = "vdd_cpu",
+	},
+};
+static struct regulator_consumer_supply tps65910_smps2_supply[] = {
+	{
+		.supply = "vdd2",
+	},
+	{
+		.supply = "vdd_core",
+	},
+	
+};
+static struct regulator_consumer_supply tps65910_smps3_supply[] = {
+	{
+		.supply = "vdd3",
+	},
+};
+static struct regulator_consumer_supply tps65910_smps4_supply[] = {
+	{
+		.supply = "vio",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo1_supply[] = {
+	{
+		.supply = "vdig1",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo2_supply[] = {
+	{
+		.supply = "vdig2",
+	},
+};
+
+static struct regulator_consumer_supply tps65910_ldo3_supply[] = {
+	{
+		.supply = "vaux1",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo4_supply[] = {
+	{
+		.supply = "vaux2",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo5_supply[] = {
+	{
+		.supply = "vaux33",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo6_supply[] = {
+	{
+		.supply = "vmmc",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo7_supply[] = {
+	{
+		.supply = "vdac",
+	},
+};
+
+static struct regulator_consumer_supply tps65910_ldo8_supply[] = {
+	{
+		.supply = "vpll",
+	},
+};
+
+static struct regulator_init_data tps65910_smps1 = {
+	.constraints = {
+		.name           = "VDD1",
+		.min_uV			= 600000,
+		.max_uV			= 1500000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps1_supply),
+	.consumer_supplies =  tps65910_smps1_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_smps2 = {
+	.constraints = {
+		.name           = "VDD2",
+		.min_uV			= 600000,
+		.max_uV			= 1500000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps2_supply),
+	.consumer_supplies =  tps65910_smps2_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_smps3 = {
+	.constraints = {
+		.name           = "VDD3",
+		.min_uV			= 1000000,
+		.max_uV			= 1400000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps3_supply),
+	.consumer_supplies =  tps65910_smps3_supply,
+};
+
+static struct regulator_init_data tps65910_smps4 = {
+	.constraints = {
+		.name           = "VIO",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps4_supply),
+	.consumer_supplies =  tps65910_smps4_supply,
+};
+static struct regulator_init_data tps65910_ldo1 = {
+	.constraints = {
+		.name           = "VDIG1",
+		.min_uV			= 1200000,
+		.max_uV			= 2700000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo1_supply),
+	.consumer_supplies =  tps65910_ldo1_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo2 = {
+	.constraints = {
+		.name           = "VDIG2",
+		.min_uV			= 1000000,
+		.max_uV			= 1800000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo2_supply),
+	.consumer_supplies =  tps65910_ldo2_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo3 = {
+	.constraints = {
+		.name           = "VAUX1",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo3_supply),
+	.consumer_supplies =  tps65910_ldo3_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo4 = {
+	.constraints = {
+		.name           = "VAUX2",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo4_supply),
+	.consumer_supplies =  tps65910_ldo4_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo5 = {
+	.constraints = {
+		.name           = "VAUX33",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo5_supply),
+	.consumer_supplies =  tps65910_ldo5_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo6 = {
+	.constraints = {
+		.name           = "VMMC",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo6_supply),
+	.consumer_supplies =  tps65910_ldo6_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo7 = {
+	.constraints = {
+		.name           = "VDAC",
+		.min_uV			= 1800000,
+		.max_uV			= 2850000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo7_supply),
+	.consumer_supplies =  tps65910_ldo7_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo8 = {
+	.constraints = {
+		.name           = "VPLL",
+		.min_uV			= 1000000,
+		.max_uV			= 2500000,
+		.apply_uV		= 1,
+                #if defined(CONFIG_MACH_RK2926_V86)
+                #else
+		.always_on = 1,
+                #endif
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo8_supply),
+	.consumer_supplies =  tps65910_ldo8_supply,
+};
+void __sramfunc board_pmu_tps65910_suspend(void)
+{
+//	sram_udelay(100);	
+        sram_gpio_set_value(pmic_sleep, GPIO_HIGH);  
+}
+void __sramfunc board_pmu_tps65910_resume(void)
+{
+       sram_gpio_set_value(pmic_sleep, GPIO_LOW);  
+	sram_udelay(2000);
+}
+static struct tps65910_board tps65910_data = {
+	.irq 	= (unsigned)TPS65910_HOST_IRQ,		
+	.irq_base = IRQ_BOARD_BASE,
+	.gpio_base = TPS65910_GPIO_EXPANDER_BASE,
+	
+	.pre_init = tps65910_pre_init,
+	.post_init = tps65910_post_init,
+
+	//TPS65910_NUM_REGS = 13
+	// Regulators
+	.tps65910_pmic_init_data[TPS65910_REG_VRTC] = NULL,		
+	.tps65910_pmic_init_data[TPS65910_REG_VIO] = &tps65910_smps4,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD1] = &tps65910_smps1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD2] = &tps65910_smps2,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD3] = &tps65910_smps3,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG1] = &tps65910_ldo1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG2] = &tps65910_ldo2,
+	.tps65910_pmic_init_data[TPS65910_REG_VPLL] = &tps65910_ldo8,
+	.tps65910_pmic_init_data[TPS65910_REG_VDAC] = &tps65910_ldo7,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX1] = &tps65910_ldo3,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX2] = &tps65910_ldo4,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX33] = &tps65910_ldo5,
+	.tps65910_pmic_init_data[TPS65910_REG_VMMC] = &tps65910_ldo6,
+
+ 
+};
+
+#endif
+
diff --git a/arch/arm/mach-rk2928/include/mach/board.h b/arch/arm/mach-rk2928/include/mach/board.h
index 71b354deea87..862e91c16f68 100755
--- a/arch/arm/mach-rk2928/include/mach/board.h
+++ b/arch/arm/mach-rk2928/include/mach/board.h
@@ -23,6 +23,17 @@ void __init rk2928_fixup(struct machine_desc *desc, struct tag *tags, char **cmd
 void __init rk2928_clock_data_init(unsigned long gpll,unsigned long cpll,u32 flags);
 void __init rk2928_iomux_init(void);
 extern struct sys_timer rk2928_timer;
+#if defined (CONFIG_TOUCHSCREEN_I30) || defined (CONFIG_TP_760_TS)
+struct ft5306_platform_data {
+    int rest_pin;
+    int irq_pin ;
+    int     (*get_pendown_state)(void);
+    int     (*init_platform_hw)(void);
+    int     (*platform_sleep)(void);
+    int     (*platform_wakeup)(void);
+    void    (*exit_platform_hw)(void);
+};
+#endif
 
 enum _periph_pll {
 	periph_pll_1485mhz = 148500000,
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 75325d878862..b0dceff4bb05 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -992,7 +992,10 @@ config TOUCHSCREEN_86V_GT811_IIC
 config TOUCHSCREEN_GT82X_IIC
 	tristate "GT82x_IIC based touchscreens"
 	depends on I2C2_RK30
-
+		
+config TOUCHSCREEN_GT82X_IIC_760
+	tristate "GT82x_IIC based touchscreens for 760"
+	depends on I2C2_RK30
 config TOUCHSCREEN_GT818_IIC
 	tristate "GT818_IIC based touchscreens"
 	depends on I2C2_RK29
@@ -1022,7 +1025,9 @@ config TOUCHSCREEN_GT819
 config TOUCHSCREEN_GT8110
         tristate "GT8110 based touchscreens"
         depends on I2C2_RK29 || I2C_RK30
-
+config TP_760_TS
+	tristate "tp for 760"
+	depends on I2C2_RK29 || I2C_RK30
 config TOUCHSCREEN_CT360_IIC
 	tristate "CT360 based touchscreens"
 	depends on I2C_RK29 || I2C_RK30
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 10dacabbfc4a..dfb8971ecebc 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -78,6 +78,7 @@ obj-$(CONFIG_TOUCHSCREEN_GT801_IIC)	+= gt801_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT811_IIC)	+= gt811_ts.o
 obj-$(CONFIG_TOUCHSCREEN_86V_GT811_IIC)	+= 86v_gt811_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT82X_IIC)	+= goodix_touch_82x.o
+obj-$(CONFIG_TOUCHSCREEN_GT82X_IIC_760)	+= goodix_touch_82x_760.o
 obj-$(CONFIG_TOUCHSCREEN_GT818_IIC)	+= gt818_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT8110)        += gt8110_ts.o
 obj-$(CONFIG_TOUCHSCREEN_CT360_IIC)	+= ct360_ts.o
@@ -102,4 +103,4 @@ obj-$(CONFIG_TOUCHSCREEN_FT5X0X)	+= ft5x0x.o
 obj-$(CONFIG_TOUCHSCREEN_GSLX680)	+= rockchip_gslX680.o
 # Make VTL TouchScreen Driver
 obj-$(CONFIG_TOUCHSCREEN_CT36X)		+= ct36x_ts/
-
+obj-$(CONFIG_TP_760_TS)                    += tp_760_ts.o
diff --git a/drivers/input/touchscreen/goodix_touch_82x_760.c b/drivers/input/touchscreen/goodix_touch_82x_760.c
new file mode 100755
index 000000000000..b28836a4e060
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_touch_82x_760.c
@@ -0,0 +1,882 @@
+/*
+ * 
+ * Copyright (C) 2011 Goodix, Inc.
+ * 
+ * Author: Scott
+ * Date: 2012.01.05
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <mach/gpio.h>
+//#include <plat/gpio-cfg.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include<linux/workqueue.h>
+#include<linux/slab.h>
+#include <linux/goodix_touch_82x.h>    //w++
+
+#include <linux/input/mt.h>
+
+#define READ_TOUCH_ADDR_H   0x0F
+#define READ_TOUCH_ADDR_L   0x40
+#define READ_KEY_ADDR_H     0x0F
+#define READ_KEY_ADDR_L     0x41
+#define READ_COOR_ADDR_H    0x0F
+#define READ_COOR_ADDR_L    0x42
+#define RESOLUTION_LOC      71
+#define TRIGGER_LOC         66
+//#typedef s32 int    //w++
+
+struct goodix_ts_data {
+	uint16_t addr;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	bool use_irq;
+	bool use_reset;
+	bool init_finished;
+	struct hrtimer timer;
+	struct work_struct  work;
+	char phys[32];
+	int bad_data;
+	int retry;
+	s32 (*power)(struct goodix_ts_data * ts, s32 on);
+	struct early_suspend early_suspend;
+	int xmax;
+	int ymax;
+	bool swap_xy;
+	bool xpol;
+	bool ypol;
+	int irq_is_disable;
+	int interrupt_port;
+	int reset_port;
+};
+struct goodix_ts_data *ts82x_temp;		//w++
+
+static struct workqueue_struct *goodix_wq;
+static const char *goodix_ts_name ="Goodix TouchScreen of Guitar ";//"Goodix Capacitive TouchScreen";
+
+static s32 goodix_ts_remove(struct i2c_client *);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h);
+static void goodix_ts_late_resume(struct early_suspend *h);
+#endif
+
+#ifdef CREATE_WR_NODE
+extern s32 init_wr_node(struct i2c_client*);
+extern void uninit_wr_node(void);
+#endif
+
+#ifdef AUTO_UPDATE_GUITAR
+extern s32 init_update_proc(struct goodix_ts_data *);
+#else
+static void guitar_reset( struct goodix_ts_data *ts,u8 ms);
+#endif
+
+static int err_gt82x = 0;   //w++
+//#define LONGPRESS_LOCK_SPECKEY
+#ifdef LONGPRESS_LOCK_SPECKEY
+#define KEY_LOCK KEY_F13
+#define LOCK_LONG_PRESS_CNT 20
+static int Origin2LockPressCnt = 0;
+static int lockflag =0;
+//static int touch_key_hold_press = 0;
+
+ssize_t glock_status_show_gt82x(struct device *dev, char *buf)
+{
+	return sprintf(buf, "%d", lockflag);
+}
+struct timer_list longkey_timer_82x;
+#endif
+#ifdef LONGPRESS_LOCK_SPECKEY
+static DRIVER_ATTR(get_lock_status, 0777, glock_status_show_gt82x, NULL);
+#endif
+
+#if 1
+#define TOUCH_MAX_HEIGHT   1024   //w++2
+#define TOUCH_MAX_WIDTH     600
+#else
+#define AUTO_SET
+u16 TOUCH_MAX_HEIGHT;
+u16 TOUCH_MAX_WIDTH;
+#endif
+
+#define GT828_I2C_RATE 200000
+
+/*Function as i2c_master_send */
+static s32 i2c_read_bytes(struct i2c_client *client, u8 *buf, s32 len)
+{
+    struct i2c_msg msgs[2];
+    s32 ret=-1;
+
+    msgs[0].flags=!I2C_M_RD;
+    msgs[0].addr=client->addr;
+    msgs[0].len=2;
+    msgs[0].buf=&buf[0];
+    msgs[0].scl_rate=100000;
+    msgs[0].udelay=2000;
+
+    msgs[1].flags=I2C_M_RD;
+    msgs[1].addr=client->addr;
+    msgs[1].len=len - ADDR_LENGTH;
+    msgs[1].buf=&buf[2];
+    msgs[1].scl_rate=100000;
+    msgs[1].udelay=2000;	
+
+    ret=i2c_transfer(client->adapter,msgs, 2);
+
+    return ret;
+}
+
+/*Function as i2c_master_send */
+static s32 i2c_write_bytes(struct i2c_client *client,u8 *data,s32 len)
+{
+    struct i2c_msg msg;
+    s32 ret=-1;
+    
+    msg.flags=!I2C_M_RD;
+    msg.addr=client->addr;
+    msg.len=len;
+    msg.buf=data;        
+    msg.scl_rate=100000;
+    msg.udelay=2000;
+    ret=i2c_transfer(client->adapter,&msg, 1);
+
+    return ret;
+}
+
+static s32 i2c_pre_cmd(struct goodix_ts_data *ts)
+{
+    s32 ret;
+    u8 pre_cmd_data[2]={0x0f, 0xff};
+
+    ret=i2c_write_bytes(ts->client,pre_cmd_data,2);
+    return ret;//*/
+}
+
+static s32 i2c_end_cmd(struct goodix_ts_data *ts)
+{
+    s32 ret;
+    u8 end_cmd_data[2]={0x80, 0x00};    
+
+    ret=i2c_write_bytes(ts->client,end_cmd_data,2);
+    return ret;//*/
+}
+
+
+s32 goodix_init_panel(struct goodix_ts_data *ts, u8 send)
+{
+    s32 ret = -1;
+    u8 config_info[]=
+    {
+    0x0F,0x80,/*config address*/
+#if 1	
+// 300-N3216E-A00
+/*
+	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+	0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x21,0x00,0x00,0x09,0x00,
+	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x25,0x29,
+	0x27,0x2B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x13,0x01,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x01
+*/
+//300-N3788E-A00-V1.0             1024*768
+/*
+	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
+	0x18,0x0A,0x19,0xFF,0x13,0xFF,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,
+	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0x00,0xFF,
+	0x0E,0x0F,0x10,0x11,0x12,0x09,0x03,0x88,0x88,0x88,0x25,0x00,0x00,0x08,0x00,
+	0x00,0x02,0x3C,0x28,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x33,0x38,
+	0x30,0x35,0x25,0x00,0x25,0x19,0x05,0x14,0x10,0x02,0x30,0x01,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x01
+*/
+	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
+	0x18,0x0A,0x19,0x0B,0x1A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x19,0x00,0x00,0x08,0x00,
+	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x2D,0x38,
+	0x2F,0x3B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x01,0x01,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x01
+#else
+	0x02,0x11,0x03,0x12,0x04,0x13,0x05,0x14,0x06,0x15,0x07,0x16,0x08,0x17,0x09,
+	0x18,0x0A,0x19,0x0B,0x1A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+	0x12,0x08,0x11,0x07,0x10,0x06,0x0F,0x05,0x0E,0x04,0x0D,0x03,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,0xE0,0x10,0x10,0x19,0x00,0x00,0x08,0x00,
+	0x00,0x02,0x45,0x2D,0x1C,0x03,0x00,0x05,0x00,0x02,0x58,0x03,0x20,0x2D,0x38,
+	0x2F,0x3B,0x25,0x00,0x06,0x19,0x25,0x14,0x10,0x00,0x01,0x01,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x01
+#endif
+    };
+
+#ifdef AUTO_SET
+	TOUCH_MAX_WIDTH  = ((config_info[RESOLUTION_LOC] << 8)|config_info[RESOLUTION_LOC + 1]);
+	TOUCH_MAX_HEIGHT = ((config_info[RESOLUTION_LOC + 2] << 8)|config_info[RESOLUTION_LOC + 3]);
+	
+	GTDEBUG_MSG("TOUCH_MAX_WIDTH  : 0x%d\n", (s32)TOUCH_MAX_WIDTH);
+	GTDEBUG_MSG("TOUCH_MAX_HEIGHT : 0x%d\n", (s32)TOUCH_MAX_HEIGHT);
+#else
+
+	config_info[RESOLUTION_LOC]     = TOUCH_MAX_WIDTH >> 8;
+	config_info[RESOLUTION_LOC + 1] = TOUCH_MAX_WIDTH & 0xff;
+	config_info[RESOLUTION_LOC + 2] = TOUCH_MAX_HEIGHT >> 8;
+	config_info[RESOLUTION_LOC + 3] = TOUCH_MAX_HEIGHT & 0xff;
+
+#endif
+
+    if (INT_TRIGGER == GT_IRQ_FALLING) {
+        config_info[TRIGGER_LOC] &= 0xf7; 
+    } else if (INT_TRIGGER == GT_IRQ_RISING) {
+        config_info[TRIGGER_LOC] |= 0x08;
+    }
+
+    if (send) {
+        ret=i2c_write_bytes(ts->client,config_info, (sizeof(config_info)/sizeof(config_info[0])));
+        if (ret <= 0) {
+            return fail;
+        }
+        i2c_end_cmd(ts);
+        msleep(10);
+    }
+    return success;
+}
+
+static s32 touch_num(u8 value, s32 max)
+{
+    s32 tmp = 0;
+
+    while((tmp < max) && value) {
+        if ((value & 0x01) == 1) {
+            tmp++;
+        }
+        value = value >> 1;
+    }
+
+    return tmp;
+}
+
+#ifdef LONGPRESS_LOCK_SPECKEY   //w++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+static void open_longkey_timer_82x(unsigned long data)
+{
+	if((++Origin2LockPressCnt>LOCK_LONG_PRESS_CNT)&&(Origin2LockPressCnt<LOCK_LONG_PRESS_CNT+2)) {  //w++,
+		Origin2LockPressCnt = LOCK_LONG_PRESS_CNT + 3;
+		//if(lockflag ==0) {
+			input_report_key(ts82x_temp->input_dev, KEY_LOCK, 1);
+			lockflag = (lockflag)? 0 : 1;
+			input_sync(ts82x_temp->input_dev);
+		//}
+	}
+	longkey_timer_82x.expires=jiffies+msecs_to_jiffies(100);
+	add_timer(&longkey_timer_82x);
+	printk("w++++++++   Origin2LockPressCnt = %d\n",Origin2LockPressCnt); 
+	printk("lockflag = %d\n",lockflag);
+}
+#endif
+
+static void goodix_ts_work_func(struct work_struct *work)
+{
+    u8 finger = 0;
+    u8 chk_sum = 0;
+    u8 key = 0;
+    static u8 last_key = 0;
+    u16 X_value;
+    u16 Y_value;
+	u16 value_tmp;
+    u32 count = 0;
+    u32 position = 0;
+    s32 ret = -1;
+    s32 tmp = 0;
+    s32 i;
+    u8 *coor_point;
+    u8 touch_data[2 + 2 + 5*MAX_FINGER_NUM + 1] = {READ_TOUCH_ADDR_H,READ_TOUCH_ADDR_L,0, 0};
+    static u8 finger_last[MAX_FINGER_NUM]={0};
+    u8 finger_current[MAX_FINGER_NUM] = {0};
+
+    struct goodix_ts_data *ts = container_of(work, struct goodix_ts_data, work);
+    struct i2c_client *client = ts->client;
+	struct goodix_i2c_rmi_platform_data *pdata = client->dev.platform_data;
+	
+#ifndef INT_PORT
+COORDINATE_POLL:
+#endif
+    if( tmp > 9) {
+        dev_info(&(ts->client->dev), "Because of transfer error,touchscreen stop working.\n");
+        goto XFER_ERROR ;
+    }
+
+    ret=i2c_read_bytes(ts->client, touch_data,sizeof(touch_data)/sizeof(touch_data[0])); 
+    i2c_end_cmd(ts);
+    if(ret <= 0) {
+        dev_err(&(ts->client->dev),"I2C transfer error. Number:%d\n ", ret);
+        ts->bad_data = 1;
+        tmp ++;
+#ifndef INT_PORT
+        goto COORDINATE_POLL;
+#else
+        goto XFER_ERROR;
+#endif
+    }
+
+    if(ts->bad_data) {
+        //TODO:Is sending config once again (to reset the chip) useful?    
+        ts->bad_data = 0;
+        msleep(20);
+    }
+
+    if((touch_data[2]&0xC0)!=0x80) {
+        goto DATA_NO_READY;        
+    }
+
+
+    key = touch_data[3]&0x0f; // 1, 2, 4, 8
+    if (key == 0x0f) {
+        if (fail == goodix_init_panel(ts, 1)) {
+			GTDEBUG_COOR("Reload config failed!\n");
+        } else {   
+			GTDEBUG_COOR("Reload config successfully!\n");
+        }
+        goto XFER_ERROR;
+    }
+
+    finger = (u8)touch_num(touch_data[2]&0x1f, MAX_FINGER_NUM);
+
+	GTDEBUG_COOR("touch num:%x\n", finger);
+
+    for (i = 0;i < MAX_FINGER_NUM; i++) {
+        finger_current[i] = !!(touch_data[2] & (0x01<<(i)));
+    }
+
+    coor_point = &touch_data[4];
+    chk_sum = 0;
+    for ( i = 0; i < 5*finger; i++) {
+        chk_sum += coor_point[i];
+		//GTDEBUG_COOR("%5x", coor_point[i]);
+    }
+	//GTDEBUG_COOR("\ncheck sum:%x\n", chk_sum);
+	//GTDEBUG_COOR("check sum byte:%x\n", coor_point[5*finger]);
+    if (chk_sum != coor_point[5*finger]) {
+        goto XFER_ERROR;
+    }
+
+    if (finger) {
+        for(i = 0, position=0;position < MAX_FINGER_NUM; position++) {  
+            if(finger_current[position]) {     
+				X_value = (coor_point[i] << 8) | coor_point[i + 1];
+				Y_value = (coor_point[i + 2] << 8) | coor_point[i + 3];
+				
+				input_mt_slot(ts->input_dev, position);
+				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, FLAG_DOWN);
+				
+				//input_report_key(ts->input_dev, BTN_TOUCH, 1);
+				//input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, position - 1);
+				if(pdata->swap_xy) {
+					value_tmp = X_value;
+					X_value = Y_value;
+					Y_value = value_tmp;
+				}
+				//printk("goodix_touch_82x X_value=%d,Y_value=%d\n",X_value,Y_value);
+				//if(pdata->xpol)
+					X_value = 1024 - X_value;
+			//	if(pdata->ypol)
+			//		Y_value = 600 - Y_value;
+			//				
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, X_value);  //can change x-y!!!
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, Y_value);
+				//input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,15);
+				//input_mt_sync(ts->input_dev);
+				i += 5;
+
+				//GTDEBUG_COOR("FI:%x X:%04d Y:%04d\n",position, (s32)Y_value,(s32)X_value);
+				//printk("-----------touch_num:%d;--------FI:%x----------- X:%04d ----------Y:%04d\n",finger,position, (s32)X_value,(s32)Y_value);
+				//GTDEBUG_COOR("Y:%d\n", (s32)Y_value);
+			} else if(finger_last[position]) {
+				input_mt_slot(ts->input_dev, position);
+				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+				GTDEBUG_COOR(" Finger  %d  release!!\n",position);
+			}
+		}
+	} else {
+		for(position=0;position < MAX_FINGER_NUM; position++) {
+			if( finger_last[position]) {
+				input_mt_slot(ts->input_dev, position);
+				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+				GTDEBUG_COOR(" Finger  %d  release!!\n",position);
+			}
+		}
+	}
+
+    input_sync(ts->input_dev);
+    
+    for(position=0;position<MAX_FINGER_NUM; position++) {
+        finger_last[position] = finger_current[position];
+    }
+
+DATA_NO_READY:
+XFER_ERROR:
+	if(ts->use_irq && ts->irq_is_disable == 1) {
+		ts->irq_is_disable = 0;
+		enable_irq(ts->client->irq);
+	}
+}
+
+static enum hrtimer_restart goodix_ts_timer_func(struct hrtimer *timer)
+{
+    struct goodix_ts_data *ts = container_of(timer, struct goodix_ts_data, timer);
+
+    queue_work(goodix_wq, &ts->work);
+    hrtimer_start(&ts->timer, ktime_set(0, (POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
+
+    return HRTIMER_NORESTART;
+}
+
+static irqreturn_t goodix_ts_irq_handler(s32 irq, void *dev_id)
+{
+	struct goodix_ts_data *ts = (struct goodix_ts_data*)dev_id;
+	
+	if (ts->use_irq && (!ts->irq_is_disable)) {
+		disable_irq_nosync(ts->client->irq);
+		ts->irq_is_disable = 1;
+	}
+	
+	queue_work(goodix_wq, &ts->work);
+	
+	return IRQ_HANDLED;
+}
+
+//#if defined(INT_PORT)    // 0 : sleep  1 wake up
+static s32 goodix_ts_power(struct goodix_ts_data * ts, s32 on)
+{
+    s32 ret = -1;
+    u8 i2c_control_buf[3] = {0x0f,0xf2,0xc0};        //suspend cmd
+
+    if(ts == NULL || !ts->use_irq)
+        return -2;
+
+    switch(on)
+    {
+    case 0:
+        ret = i2c_write_bytes(ts->client, i2c_control_buf, 3);
+        return ret;
+
+    case 1:
+        GPIO_DIRECTION_OUTPUT(ts->interrupt_port, 0);
+        mdelay(10);
+        GPIO_SET_VALUE(ts->interrupt_port, 1);
+        GPIO_DIRECTION_INPUT(ts->interrupt_port);
+        GPIO_PULL_UPDOWN(ts->interrupt_port, 0);
+        return success;
+
+    default:
+        GTDEBUG_MSG(KERN_DEBUG "%s: Cant't support this command.", goodix_ts_name);
+        return -EINVAL;
+    }
+
+}
+
+static s32 init_input_dev(struct goodix_ts_data *ts)
+{
+    s32 i;
+    s32 ret = 0;
+
+    ts->input_dev = input_allocate_device();
+    if (ts->input_dev == NULL)
+    {
+        dev_dbg(&ts->client->dev,"goodix_ts_probe: Failed to allocate input device\n");
+        return fail;
+    }
+ 
+	//ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	//ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	//ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);// absolute coor (x,y)
+	
+    goodix_init_panel(ts, 0);
+ 
+#ifdef GOODIX_MULTI_TOUCH
+
+	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+	__set_bit(EV_ABS, ts->input_dev->evbit);
+	input_mt_init_slots(ts->input_dev, MAX_FINGER_NUM);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
+
+	/* 
+	input_mt_init_slots(ts->input_dev, MAX_FINGER_NUM);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
+	*/
+#else
+    input_set_abs_params(ts->input_dev, ABS_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
+    input_set_abs_params(ts->input_dev, ABS_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
+    input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+#endif    
+
+    memcpy(ts->phys, "input/ts", 8);
+    ts->input_dev->name = goodix_ts_name;
+    ts->input_dev->phys = ts->phys;
+    ts->input_dev->id.bustype = BUS_I2C;
+    ts->input_dev->id.vendor = 0xDEAD;
+    ts->input_dev->id.product = 0xBEEF;
+    ts->input_dev->id.version = 10427;    //screen firmware version
+
+#ifdef LONGPRESS_LOCK_SPECKEY    //w++
+    set_bit(KEY_LOCK, ts->input_dev->keybit);
+#endif
+    ret = input_register_device(ts->input_dev);
+    if (ret) {
+        dev_err(&ts->client->dev,"Probe: Unable to register %s input device\n", ts->input_dev->name);
+        input_free_device(ts->input_dev);
+        return fail;
+    }
+    GTDEBUG_MSG("Register input device successfully!\n");
+
+    return success;
+}
+
+static s32 set_pins(struct goodix_ts_data *ts)
+{
+    s32 ret = -1;
+    
+	//ts->client->irq=TS_INT;        //If not defined in client
+	if (ts->client->irq) {
+		ret = GPIO_REQUEST(ts->interrupt_port, "TS_INT");    //Request IO
+		if (ret < 0) {
+		    dev_err(&ts->client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(s32)ts->interrupt_port,ret);
+		    goto err_gpio_request_failed;
+		}
+		GTDEBUG_MSG("Request int port successfully!\n");
+		
+		GPIO_DIRECTION_INPUT(ts->interrupt_port);
+		GPIO_PULL_UPDOWN(ts->interrupt_port, 0);
+		//GPIO_CFG_PIN(INT_PORT, INT_CFG);        //Set IO port function    
+		
+		ret = request_irq(gpio_to_irq(ts->interrupt_port), goodix_ts_irq_handler,
+				IRQF_TRIGGER_FALLING, ts->client->name, ts);
+
+		if (ret != 0) {
+			dev_err(&ts->client->dev,"Cannot allocate ts INT!ERRNO:%d\n", ret);
+			GPIO_DIRECTION_INPUT(ts->interrupt_port);
+			GPIO_FREE(ts->interrupt_port);
+			goto err_gpio_request_failed;
+		} else {
+		    disable_irq(ts->client->irq);
+		    ts->use_irq = 1;
+		    ts->irq_is_disable = 1;
+		    dev_dbg(&ts->client->dev, "Reques EIRQ %d successed on GPIO:%d\n", gpio_to_irq(ts->interrupt_port), ts->interrupt_port);
+		}
+	}
+
+err_gpio_request_failed:
+    if (!ts->use_irq) {
+        hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+        ts->timer.function = goodix_ts_timer_func;
+        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+        GTDEBUG_MSG("Use timer!\n");
+    }
+
+    ret = GPIO_REQUEST(ts->reset_port, "TS_RESET");    //Request IO
+    if (ret < 0) {
+        dev_err(&ts->client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(s32)ts->reset_port,ret);
+    } else {
+        ts->use_reset = 1;
+        GPIO_DIRECTION_OUTPUT(ts->reset_port,1);
+        GPIO_PULL_UPDOWN(ts->reset_port, 0);
+		GTDEBUG_MSG("Request reset port successfully!\n");	
+    }
+
+    dev_info(&ts->client->dev,"Start %s in %s mode\n", 
+              ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+
+    return ts->use_irq;
+}
+
+static s32 goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    s32 ret = 0;
+    s32 retry=0;
+    struct goodix_ts_data *ts = NULL;
+    struct goodix_i2c_rmi_platform_data *pdata = client->dev.platform_data;
+	//struct ft5406_platform_data *pdata = pdata = client->dev.platform_data;
+    printk("w++++++goodix_ts_probe gt28x ");
+
+	if (pdata->init_platform_hw) {
+		pdata->init_platform_hw();
+	}
+
+	//printk("gt82x---0000000000000000\n");
+    //Check I2C function
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+        return -ENODEV;
+    }
+
+    ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+    if (ts == NULL) {
+        return -ENOMEM;
+    }
+	pdata = client->dev.platform_data;
+
+    INIT_WORK(&ts->work, goodix_ts_work_func);        //init work_struct
+    ts->client = client;
+    ts->power = goodix_ts_power;
+    ts->bad_data = 0;
+    ts->use_irq = 1;
+    ts->use_reset =1;
+    ts->irq_is_disable = 0;
+    ts->interrupt_port=pdata->gpio_irq;
+    ts->reset_port=pdata->gpio_reset;
+    i2c_set_clientdata(client, ts);
+ 
+    if (fail == init_input_dev(ts)) {
+    	kfree(ts);
+        return -1;
+    }
+    set_pins(ts);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    ts->early_suspend.suspend = goodix_ts_early_suspend;
+    ts->early_suspend.resume = goodix_ts_late_resume;
+    register_early_suspend(&ts->early_suspend);
+#endif
+#ifdef CREATE_WR_NODE
+    init_wr_node(client);
+#endif
+#ifdef AUTO_UPDATE_GUITAR
+    if (0xff == init_update_proc(ts)) {
+        GTDEBUG_MSG("Need update!\n");
+        return 0;
+    }
+#else
+    msleep(5);
+    guitar_reset(ts,10);
+#endif
+
+    //Test I2C connection. 
+	//GTDEBUG_MSG("GT82X++++++   Testing I2C connection...\n");
+    for(retry = 0;retry < 3; retry++) {
+		ret = i2c_pre_cmd(ts);
+		if (ret > 0)
+		    break;
+		msleep(20);
+    }
+    if(ret <= 0) {
+		dev_err(&client->dev, "Warnning: I2C communication might be ERROR!\n");
+		GTDEBUG_MSG("I2C test failed. I2C addr:%x\n", client->addr);
+		goodix_ts_remove(ts->client); 
+		return -1;
+    }
+	//printk("gt82x---777777777777777\n");
+	//Send config
+	for (retry = 0; retry < 3; retry++) {
+	    if (success == goodix_init_panel(ts, 1)) {
+	        GTDEBUG_MSG("Initialize successfully!\n");
+	        break;
+	    }
+	}
+    if (retry >= 3) {
+        ts->bad_data=1;
+        GTDEBUG_MSG("Initialize failed!\n");
+        goodix_ts_remove(ts->client);
+        return -1;
+    }
+    //Enable interrupt
+    if(ts->use_irq && ts->irq_is_disable == 1) {
+        ts->irq_is_disable = 0;
+        enable_irq(client->irq);
+    }
+
+    return 0;
+}
+
+static s32 goodix_ts_remove(struct i2c_client *client)
+{
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+    dev_notice(&client->dev,"The driver is removing...\n");
+    
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&ts->early_suspend);
+#endif
+
+#ifdef CREATE_WR_NODE
+    uninit_wr_node();
+#endif
+
+    if (ts && ts->use_irq) {
+        free_irq(client->irq, ts);
+        GPIO_DIRECTION_INPUT(ts->interrupt_port);
+        GPIO_FREE(ts->interrupt_port);
+    } else if(ts) {
+        hrtimer_cancel(&ts->timer);
+	}
+
+    if (ts && ts->use_reset) {
+        GPIO_DIRECTION_INPUT(ts->reset_port);
+        GPIO_FREE(ts->interrupt_port);
+    }
+    
+    i2c_set_clientdata(client, NULL);
+    input_unregister_device(ts->input_dev);
+    input_free_device(ts->input_dev);
+    kfree(ts);
+    return success;
+}
+
+static s32 goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+    s32 ret;
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+    if (ts->irq_is_disable == 2) {
+        return 0;
+    }
+
+    if (ts->use_irq) {
+        if (!ts->irq_is_disable) {
+            disable_irq(client->irq);
+            ts->irq_is_disable = 1;
+        }
+    } else {
+        hrtimer_cancel(&ts->timer);
+    }
+    
+    if (ts->power) {
+        ret = ts->power(ts, 0);
+        if (ret <= 0)
+            GTDEBUG_MSG(KERN_ERR "goodix_ts_resume power off failed\n");
+	}
+	printk("-----gt813------suspend.\n");
+    return 0;
+}
+
+static s32 goodix_ts_resume(struct i2c_client *client)
+{
+    s32 ret;
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+    if (ts->irq_is_disable == 2) {
+        return 0;
+    }
+
+    if (ts->power) {
+        ret = ts->power(ts, 1);
+        if (ret <= 0)
+            GTDEBUG_MSG(KERN_ERR "goodix_ts_resume power on failed\n");
+    }
+
+    if (ts->use_irq) {
+        ts->irq_is_disable = 0;
+        enable_irq(client->irq);
+    } else {
+        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+    }
+	printk("-----gt813------goodix_ts_resume.\n");
+
+    return success;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h)
+{
+    struct goodix_ts_data *ts;
+    ts = container_of(h, struct goodix_ts_data, early_suspend);
+    goodix_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void goodix_ts_late_resume(struct early_suspend *h)
+{
+    struct goodix_ts_data *ts;
+    ts = container_of(h, struct goodix_ts_data, early_suspend);
+    goodix_ts_resume(ts->client);
+}
+#endif
+
+//******************************Begin of firmware update surpport*******************************
+#ifndef AUTO_UPDATE_GUITAR
+static void guitar_reset( struct goodix_ts_data *ts,u8 ms)
+{
+    GPIO_DIRECTION_OUTPUT(ts->reset_port, 0);
+    GPIO_SET_VALUE(ts->reset_port, 0);
+    msleep(ms);
+
+	//GPIO_DIRECTION_OUTPUT(ts->reset_port);
+    GPIO_SET_VALUE(ts->reset_port, 1);
+    GPIO_PULL_UPDOWN(ts->reset_port, 0);
+
+    msleep(20);
+err_gpio_request_failed:	
+    return;
+}
+#endif
+
+//only one client
+static const struct i2c_device_id goodix_ts_id[] = {
+    {"Goodix-TS-82X", 0 },
+    { }
+};
+
+static struct i2c_driver goodix_ts_driver = {
+    .probe      = goodix_ts_probe,
+    .remove     = goodix_ts_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+    .suspend    = goodix_ts_suspend,
+    .resume     = goodix_ts_resume,
+#endif
+    .id_table   = goodix_ts_id,
+    .driver     = {
+        .name   =  "Goodix-TS-82X",
+        .owner  = THIS_MODULE,
+    },
+};
+
+static s32 __devinit goodix_ts_init(void)
+{
+	int ret; 
+	
+	printk("+++++++++++++++++++++++++++++liqing.\n");
+    goodix_wq = create_workqueue("goodix_wq");        //create a work queue and worker thread
+    if (!goodix_wq) {
+		GTDEBUG_MSG(KERN_ALERT "creat workqueue faiked\n");
+		return -ENOMEM;
+    }
+    ret = i2c_add_driver(&goodix_ts_driver);
+	if (ret) {
+		printk("Register raydium_ts driver failed gt82x.\n");
+		return ret;   //w++
+	}
+#ifdef LONGPRESS_LOCK_SPECKEY
+	if(err_gt82x>=0)   //w++
+
+	ret =driver_create_file(&goodix_ts_driver.driver, &driver_attr_get_lock_status);
+#endif
+    return ret;
+}
+
+static void __exit goodix_ts_exit(void)
+{
+	GTDEBUG_MSG(KERN_ALERT "Touchscreen driver of guitar exited.\n");
+	i2c_del_driver(&goodix_ts_driver);
+	if (goodix_wq)
+		destroy_workqueue(goodix_wq);        //release our work queue
+#ifdef LONGPRESS_LOCK_SPECKEY   //w++
+	driver_remove_file(&goodix_ts_driver.driver, &driver_attr_get_lock_status);
+#endif
+}
+
+module_init(goodix_ts_init);               
+module_exit(goodix_ts_exit);
+
+MODULE_DESCRIPTION("Goodix Touchscreen Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/tp_760_ts.c b/drivers/input/touchscreen/tp_760_ts.c
new file mode 100755
index 000000000000..9fcc8912286a
--- /dev/null
+++ b/drivers/input/touchscreen/tp_760_ts.c
@@ -0,0 +1,922 @@
+/* 
+ * drivers/input/touchscreen/ft5x0x_ts.c
+ *
+ * FocalTech ft5x0x TouchScreen driver. 
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *	note: only support mulititouch	Wenfs 2010-10-01
+ */
+
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/input-polldev.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#ifdef CONFIG_ANDROID_POWER
+#include <linux/android_power.h>
+#endif
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+#include <mach/iomux.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+//#include <mach/rk29_iomap.h>
+#include <mach/board.h>
+//#include <mach/rk29_nand.h>
+//#include <mach/rk29_camera.h>                          /* ddl@rock-chips.com : camera support */
+#include <media/soc_camera.h>                               /* ddl@rock-chips.com : camera support */
+//#include <mach/vpu_mem.h>
+#include <mach/sram.h>
+#include <linux/earlysuspend.h>
+static struct early_suspend ft5306_power;
+
+
+
+
+#define CONFIG_FT5X0X_MULTITOUCH  1
+#define MAX_POINT                 5
+#define FT5306_IIC_SPEED          50*1000    //300*1000
+#define FT5X0X_REG_THRES          0x80         /* Thresshold, the threshold be low, the sensitivy will be high */
+#define FT5X0X_REG_REPORT_RATE    0x88         /* **************report rate, in unit of 10Hz **************/
+#define FT5X0X_REG_PMODE          0xA5         /* Power Consume Mode 0 -- active, 1 -- monitor, 3 -- sleep */    
+#define FT5X0X_REG_FIRMID         0xA6         /* ***************firmware version **********************/
+#define FT5X0X_REG_NOISE_MODE     0xb2         /* to enable or disable power noise, 1 -- enable, 0 -- disable */
+#define SCREEN_MAX_X              800
+#define SCREEN_MAX_Y              480
+#define FT5X0X_SWAP_XY			0
+#define PRESS_MAX                 255
+#define FT5X0X_NAME	              "ft5x0x_ts"//"synaptics_i2c_rmi"//"synaptics-rmi-ts"// 
+#define TOUCH_MAJOR_MAX           200
+#define WIDTH_MAJOR_MAX           200
+//FT5X0X_REG_PMODE
+#define PMODE_ACTIVE              0x00
+#define PMODE_MONITOR             0x01
+#define PMODE_STANDBY             0x02
+#define PMODE_HIBERNATE           0x03
+
+
+struct ts_event {
+	s16  cur_touch_id[MAX_POINT];
+    s16  last_touch_id[MAX_POINT];
+};
+
+struct tp_event {
+	u16	x;
+	u16	y;
+    s16 id;
+	u16	pressure;
+	u8  touch_point;
+	u8  flag;
+};
+
+struct ft5x0x_ts_data {
+	struct i2c_client *client;
+	struct input_dev	*input_dev;
+	int    irq;
+	struct ts_event		event;
+	struct work_struct 	pen_event_work;
+	struct workqueue_struct *ts_workqueue;
+};
+static struct i2c_client *this_client;
+
+/***********************************************************************/
+
+#define    FTS_PACKET_LENGTH        128
+
+
+static u8 CTPM_FW[]=
+{
+//#include "ft5406_app.i"
+};
+
+typedef enum
+{
+    ERR_OK,
+    ERR_MODE,
+    ERR_READID,
+    ERR_ERASE,
+    ERR_STATUS,
+    ERR_ECC,
+    ERR_DL_ERASE_FAIL,
+    ERR_DL_PROGRAM_FAIL,
+    ERR_DL_VERIFY_FAIL
+}E_UPGRADE_ERR_TYPE;
+
+/***********************************************************************/
+
+/***********************************************************************
+    [function]: 
+		           callback:                send data to ctpm by i2c interface;
+    [parameters]:
+			    txdata[in]:              data buffer which is used to send data;
+			    length[in]:              the length of the data buffer;
+    [return]:
+			    FTS_TRUE:              success;
+			    FTS_FALSE:             fail;
+************************************************************************/
+static int fts_i2c_txdata(u8 *txdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msg;
+
+	msg.addr = this_client->addr;
+	msg.flags = 0;
+	msg.len = length;
+	msg.buf = txdata;
+	msg.scl_rate = FT5306_IIC_SPEED;
+	
+	ret = i2c_transfer(this_client->adapter, &msg, 1);
+	if (ret < 0)
+		pr_err("%s i2c write error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+/***********************************************************************
+    [function]: 
+		           callback:               write data to ctpm by i2c interface;
+    [parameters]:
+			    buffer[in]:             data buffer;
+			    length[in]:            the length of the data buffer;
+    [return]:
+			    FTS_TRUE:            success;
+			    FTS_FALSE:           fail;
+************************************************************************/
+static bool  i2c_write_interface(u8* pbt_buf, int dw_lenth)
+{
+    int ret;
+    ret=i2c_master_send(this_client, pbt_buf, dw_lenth);
+    if(ret<=0)
+    {
+        printk("[TSP]i2c_write_interface error line = %d, ret = %d\n", __LINE__, ret);
+        return false;
+    }
+
+    return true;
+}
+
+/***********************************************************************
+    [function]: 
+		           callback:                read register value ftom ctpm by i2c interface;
+    [parameters]:
+                        reg_name[in]:         the register which you want to write;
+			    tx_buf[in]:              buffer which is contained of the writing value;
+    [return]:
+			    FTS_TRUE:              success;
+			    FTS_FALSE:             fail;
+************************************************************************/
+static bool fts_register_write(u8 reg_name, u8* tx_buf)
+{
+	u8 write_cmd[2] = {0};
+
+	write_cmd[0] = reg_name;
+	write_cmd[1] = *tx_buf;
+
+	/*call the write callback function*/
+	return i2c_write_interface(write_cmd, 2);
+}
+
+/***********************************************************************
+[function]: 
+                      callback:         send a command to ctpm.
+[parameters]:
+			  btcmd[in]:       command code;
+			  btPara1[in]:     parameter 1;    
+			  btPara2[in]:     parameter 2;    
+			  btPara3[in]:     parameter 3;    
+                      num[in]:         the valid input parameter numbers, 
+                                           if only command code needed and no 
+                                           parameters followed,then the num is 1;    
+[return]:
+			  FTS_TRUE:      success;
+			  FTS_FALSE:     io fail;
+************************************************************************/
+static bool cmd_write(u8 btcmd,u8 btPara1,u8 btPara2,u8 btPara3,u8 num)
+{
+    u8 write_cmd[4] = {0};
+
+    write_cmd[0] = btcmd;
+    write_cmd[1] = btPara1;
+    write_cmd[2] = btPara2;
+    write_cmd[3] = btPara3;
+    return i2c_write_interface(write_cmd, num);
+}
+
+/***********************************************************************
+    [function]: 
+		           callback:              read data from ctpm by i2c interface;
+    [parameters]:
+			    buffer[in]:            data buffer;
+			    length[in]:           the length of the data buffer;
+    [return]:
+			    FTS_TRUE:            success;
+			    FTS_FALSE:           fail;
+************************************************************************/
+static bool i2c_read_interface(u8* pbt_buf, int dw_lenth)
+{
+    int ret;
+    
+    ret=i2c_master_recv(this_client, pbt_buf, dw_lenth);
+
+    if(ret<=0)
+    {
+        printk("[TSP]i2c_read_interface error\n");
+        return false;
+    }
+  
+    return true;
+}
+
+
+/***********************************************************************
+[function]: 
+                      callback:         read a byte data  from ctpm;
+[parameters]:
+			  buffer[in]:       read buffer;
+			  length[in]:      the size of read data;    
+[return]:
+			  FTS_TRUE:      success;
+			  FTS_FALSE:     io fail;
+************************************************************************/
+static bool byte_read(u8* buffer, int length)
+{
+    return i2c_read_interface(buffer, length);
+}
+
+/***********************************************************************
+[function]: 
+                      callback:         write a byte data  to ctpm;
+[parameters]:
+			  buffer[in]:       write buffer;
+			  length[in]:      the size of write data;    
+[return]:
+			  FTS_TRUE:      success;
+			  FTS_FALSE:     io fail;
+************************************************************************/
+static bool byte_write(u8* buffer, int length)
+{
+    
+    return i2c_write_interface(buffer, length);
+}
+
+/***********************************************************************
+    [function]: 
+		           callback:                 read register value ftom ctpm by i2c interface;
+    [parameters]:
+                        reg_name[in]:         the register which you want to read;
+			    rx_buf[in]:              data buffer which is used to store register value;
+			    rx_length[in]:          the length of the data buffer;
+    [return]:
+			    FTS_TRUE:              success;
+			    FTS_FALSE:             fail;
+************************************************************************/
+static bool fts_register_read(u8 reg_name, u8* rx_buf, int rx_length)
+{
+	u8 read_cmd[2]= {0};
+	u8 cmd_len 	= 0;
+
+	read_cmd[0] = reg_name;
+	cmd_len = 1;	
+
+	/*send register addr*/
+	if(!i2c_write_interface(&read_cmd[0], cmd_len))
+	{
+		return false;
+	}
+
+	/*call the read callback function to get the register value*/		
+	if(!i2c_read_interface(rx_buf, rx_length))
+	{
+		return false;
+	}
+	return true;
+}
+
+
+
+/***********************************************************************
+[function]: 
+                        callback:          burn the FW to ctpm.
+[parameters]:
+			    pbt_buf[in]:     point to Head+FW ;
+			    dw_lenth[in]:   the length of the FW + 6(the Head length);    
+[return]:
+			    ERR_OK:          no error;
+			    ERR_MODE:      fail to switch to UPDATE mode;
+			    ERR_READID:   read id fail;
+			    ERR_ERASE:     erase chip fail;
+			    ERR_STATUS:   status error;
+			    ERR_ECC:        ecc error.
+************************************************************************/
+E_UPGRADE_ERR_TYPE  fts_ctpm_fw_upgrade(u8* pbt_buf, int dw_lenth)
+{
+    u8  cmd,reg_val[2] = {0};
+	u8  buffer[2] = {0};
+    u8  packet_buf[FTS_PACKET_LENGTH + 6];
+    u8  auc_i2c_write_buf[10];
+    u8  bt_ecc;
+	
+    int  j,temp,lenght,i_ret,packet_number, i = 0;
+    int  i_is_new_protocol = 0;
+	
+
+    /******write 0xaa to register 0xfc******/
+    cmd=0xaa;
+    fts_register_write(0xfc,&cmd);
+    mdelay(50);
+	
+     /******write 0x55 to register 0xfc******/
+    cmd=0x55;
+    fts_register_write(0xfc,&cmd);
+    printk("[TSP] Step 1: Reset CTPM test\n");
+   
+    mdelay(10);   
+
+
+    /*******Step 2:Enter upgrade mode ****/
+    printk("\n[TSP] Step 2:enter new update mode\n");
+    auc_i2c_write_buf[0] = 0x55;
+    auc_i2c_write_buf[1] = 0xaa;
+    do
+    {
+        i ++;
+        i_ret = fts_i2c_txdata(auc_i2c_write_buf, 2);
+        mdelay(5);
+    }while(i_ret <= 0 && i < 10 );
+
+    if (i > 1)
+    {
+        i_is_new_protocol = 1;
+    }
+
+    /********Step 3:check READ-ID********/        
+    cmd_write(0x90,0x00,0x00,0x00,4);
+    byte_read(reg_val,2);
+    if (reg_val[0] == 0x79 && reg_val[1] == 0x3)
+    {
+        printk("[TSP] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0],reg_val[1]);
+    }
+    else
+    {
+        printk("[TSP] Step 3: error CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0],reg_val[1]);
+        return ERR_READID;
+        //i_is_new_protocol = 1;
+    }
+    
+
+     /*********Step 4:erase app**********/
+    if (i_is_new_protocol)
+    {
+        cmd_write(0x61,0x00,0x00,0x00,1);
+    }
+    else
+    {
+        cmd_write(0x60,0x00,0x00,0x00,1);
+    }
+    mdelay(1500);
+    printk("[TSP] Step 4: erase. \n");
+
+
+
+    /*Step 5:write firmware(FW) to ctpm flash*/
+    bt_ecc = 0;
+    printk("[TSP] Step 5: start upgrade. \n");
+    dw_lenth = dw_lenth - 8;
+    packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+    packet_buf[0] = 0xbf;
+    packet_buf[1] = 0x00;
+    for (j=0;j<packet_number;j++)
+    {
+        temp = j * FTS_PACKET_LENGTH;
+        packet_buf[2] = (u8)(temp>>8);
+        packet_buf[3] = (u8)temp;
+        lenght = FTS_PACKET_LENGTH;
+        packet_buf[4] = (u8)(lenght>>8);
+        packet_buf[5] = (u8)lenght;
+
+        for (i=0;i<FTS_PACKET_LENGTH;i++)
+        {
+            packet_buf[6+i] = pbt_buf[j*FTS_PACKET_LENGTH + i]; 
+            bt_ecc ^= packet_buf[6+i];
+        }
+        
+        byte_write(&packet_buf[0],FTS_PACKET_LENGTH + 6);
+        mdelay(FTS_PACKET_LENGTH/6 + 1);
+        if ((j * FTS_PACKET_LENGTH % 1024) == 0)
+        {
+              printk("[TSP] upgrade the 0x%x th byte.\n", ((unsigned int)j) * FTS_PACKET_LENGTH);
+        }
+    }
+
+    if ((dw_lenth) % FTS_PACKET_LENGTH > 0)
+    {
+        temp = packet_number * FTS_PACKET_LENGTH;
+        packet_buf[2] = (u8)(temp>>8);
+        packet_buf[3] = (u8)temp;
+
+        temp = (dw_lenth) % FTS_PACKET_LENGTH;
+        packet_buf[4] = (u8)(temp>>8);
+        packet_buf[5] = (u8)temp;
+
+        for (i=0;i<temp;i++)
+        {
+            packet_buf[6+i] = pbt_buf[ packet_number*FTS_PACKET_LENGTH + i]; 
+            bt_ecc ^= packet_buf[6+i];
+        }
+
+        byte_write(&packet_buf[0],temp+6);    
+        mdelay(20);
+    }
+
+    /***********send the last six byte**********/
+    for (i = 0; i<6; i++)
+    {
+        temp = 0x6ffa + i;
+        packet_buf[2] = (u8)(temp>>8);
+        packet_buf[3] = (u8)temp;
+        temp =1;
+        packet_buf[4] = (u8)(temp>>8);
+        packet_buf[5] = (u8)temp;
+        packet_buf[6] = pbt_buf[ dw_lenth + i]; 
+        bt_ecc ^= packet_buf[6];
+
+        byte_write(&packet_buf[0],7);  
+        mdelay(20);
+    }
+
+    /********send the opration head************/
+    cmd_write(0xcc,0x00,0x00,0x00,1);
+    byte_read(reg_val,1);
+    printk("[TSP] Step 6:  ecc read 0x%x, new firmware 0x%x. \n", reg_val[0], bt_ecc);
+    if(reg_val[0] != bt_ecc)
+    {
+        return ERR_ECC;
+    }
+
+    /*******Step 7: reset the new FW**********/
+    cmd_write(0x07,0x00,0x00,0x00,1);
+	mdelay(100);//100ms	
+	fts_register_read(0xfc, buffer, 1);	
+	if (buffer[0] == 1)
+	{
+	cmd=4;
+	fts_register_write(0xfc, &cmd);
+	mdelay(2500);//2500ms	
+	 do	
+	 {	
+	 fts_register_read(0xfc, buffer, 1);	
+	 mdelay(100);//100ms	
+	 }while (buffer[0] != 1); 		   	
+	}
+    return ERR_OK;
+}
+
+
+/***********************************************************************/
+
+int fts_ctpm_fw_upgrade_with_i_file(void)
+{
+   u8*     pbt_buf = 0;
+   int i_ret;
+    
+   pbt_buf = CTPM_FW;
+   i_ret =  fts_ctpm_fw_upgrade(pbt_buf,sizeof(CTPM_FW));
+   
+   return i_ret;
+}
+
+/***********************************************************************/
+
+unsigned char fts_ctpm_get_upg_ver(void)
+{
+    unsigned int ui_sz;
+	
+    ui_sz = sizeof(CTPM_FW);
+    if (ui_sz > 2)
+    {
+        return CTPM_FW[ui_sz - 2];
+    }
+    else
+        return 0xff; 
+ 
+}
+
+static int ft5306_init_touchid(s16 touch_buf[], unsigned len,s16 init_val)
+{
+	int i;
+	for(i=0;i<len;i++){
+		touch_buf[i] = init_val;
+	}
+	return 0;
+}
+
+/*read the it7260 register ,used i2c bus*/
+static int ft5306_read_regs(struct i2c_client *client, u8 reg, u8 buf[], unsigned len)
+{
+	int ret; 
+	ret = i2c_master_reg8_recv(client, reg, buf, len, FT5306_IIC_SPEED);
+	return ret; 
+}
+
+
+/* set the it7260 registe,used i2c bus*/
+static int ft5306_set_regs(struct i2c_client *client, u8 reg, u8 const buf[], unsigned short len)
+{
+	int ret; 
+	ret = i2c_master_reg8_send(client, reg, buf, (int)len, FT5306_IIC_SPEED);
+	return ret;
+}
+
+static void ft5306_queue_work(struct work_struct *work)
+{
+	struct ft5x0x_ts_data *data = container_of(work, struct ft5x0x_ts_data, pen_event_work);
+	struct tp_event event;
+	u8 start_reg=0x0;
+	u8 buf[32] = {0};
+	int ret,i,offset,points;
+		
+#if CONFIG_FT5X0X_MULTITOUCH
+	ret = ft5306_read_regs(data->client,start_reg, buf, 6*MAX_POINT+1);
+#else
+	ret = ft5306_read_regs(data->client,start_reg, buf, 7);
+#endif
+	if (ret < 0) {
+		dev_err(&data->client->dev, "ft5306_read_regs fail:%d!\n",ret);
+		enable_irq(data->irq);
+		return;
+	}
+	
+	points = buf[2] & 0x07;
+	memset(&event, 0, sizeof(struct tp_event));
+#if CONFIG_FT5X0X_MULTITOUCH
+	ft5306_init_touchid(data->event.cur_touch_id,MAX_POINT,-1);
+//	dev_info(&data->client->dev, 
+//		"ft5306 multiple report points = %d :\n",points);
+	for(i=0;i<points;i++){
+		offset = i*6+3;
+#if (FT5X0X_SWAP_XY == 1)
+		event.y = (((s16)(buf[offset+0] & 0x0F))<<8) | ((s16)buf[offset+1]);
+		event.x = (((s16)(buf[offset+2] & 0x0F))<<8) | ((s16)buf[offset+3]);
+#else
+		event.x = (((s16)(buf[offset+0] & 0x0F))<<8) | ((s16)buf[offset+1]);
+		event.y = (((s16)(buf[offset+2] & 0x0F))<<8) | ((s16)buf[offset+3]);
+#endif
+		event.id = (s16)(buf[offset+2] & 0xF0)>>4;
+		event.flag = ((buf[offset+0] & 0xc0) >> 6);
+		event.pressure = 200;
+		if(event.x<=SCREEN_MAX_X && event.y<=SCREEN_MAX_Y && event.id < MAX_POINT){
+//			dev_info(&data->client->dev, 
+//				"ft5306 multiple report event[%d]:x = %d,y = %d,last_id = %d,cur_id = %d,flag = %d,pressure = %d\n",
+//				i,event.x,event.y,data->event.last_touch_id[event.id],event.id,event.flag,event.pressure);
+			input_mt_slot(data->input_dev, event.id);
+			data->event.cur_touch_id[event.id] = event.id;
+			if(data->event.last_touch_id[event.id] != event.id){
+				input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event.id);
+				data->event.last_touch_id[event.id] = event.id;
+			}
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X,  event.x);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y,  event.y);
+//			dev_info(&data->client->dev,"new last_id=%d,cur_id = %d\n",data->event.last_touch_id[event.id],
+//				data->event.cur_touch_id[event.id]);
+		}
+	}
+	for(i=0;i<MAX_POINT;i++){
+		if(data->event.last_touch_id[i] != data->event.cur_touch_id[i]){
+//			dev_info(&data->client->dev,"release id=%d: last_id=%d,cur_id = %d\n",i,data->event.last_touch_id[i],
+//				data->event.cur_touch_id[i]);
+			data->event.last_touch_id[i] = data->event.cur_touch_id[i];
+			input_mt_slot(data->input_dev, i);
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, data->event.cur_touch_id[i]);
+		}
+	}
+#else
+	if (points == 0) {
+		input_report_abs(data->input_dev, ABS_PRESSURE, 0);
+		input_report_key(data->input_dev, BTN_TOUCH, 0);
+		input_sync(data->input_dev);
+		enable_irq(data->irq);
+//		dev_info(&data->client->dev, "ft5306 touch release\n");
+		return; 
+	}
+	event.x = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+	event.y = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+	event.pressure =200;
+	input_report_abs(data->input_dev, ABS_X, event.x);
+	input_report_abs(data->input_dev, ABS_Y, event.y);
+	input_report_abs(data->input_dev, ABS_PRESSURE, event.pressure);
+	input_report_key(data->input_dev, BTN_TOUCH, 1);
+	//dev_info(&data->client->dev, "ft5306 single report event:x = %d,y = %d\n",event.x,event.y);
+#endif
+	input_sync(data->input_dev);
+	enable_irq(data->irq);
+	return;
+}
+
+static irqreturn_t ft5306_interrupt(int irq, void *dev_id)
+{
+	struct ft5x0x_ts_data *ft5x0x_ts = dev_id;
+
+	//printk("ft5306_interrupt\n");
+	disable_irq_nosync(ft5x0x_ts->irq);
+	if (!work_pending(&ft5x0x_ts->pen_event_work)) 
+		queue_work(ft5x0x_ts->ts_workqueue, &ft5x0x_ts->pen_event_work);
+	return IRQ_HANDLED;
+}
+
+static int ft5306_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct ft5x0x_ts_data *ft5x0x_ts = i2c_get_clientdata(client);
+	struct ft5306_platform_data *pdata = client->dev.platform_data;
+	char buf_w[1] = {3};
+
+	ft5306_set_regs(ft5x0x_ts->client, 0xA5, buf_w,1);
+	
+	if (pdata->platform_sleep)                              
+		pdata->platform_sleep();
+	disable_irq(ft5x0x_ts->irq);
+	return 0;
+}
+
+
+static int ft5306_resume(struct i2c_client *client)
+{
+	struct ft5x0x_ts_data *ft5x0x_ts = i2c_get_clientdata(client);
+	struct ft5306_platform_data *pdata = client->dev.platform_data;
+	
+	enable_irq(ft5x0x_ts->irq);
+	if (pdata->platform_wakeup)                              
+		pdata->platform_wakeup();
+	return 0;
+}
+
+static void ft5306_suspend_early(struct early_suspend *h)
+{
+	ft5306_suspend(this_client,PMSG_SUSPEND);
+}
+
+static void ft5306_resume_early(struct early_suspend *h)
+{
+	ft5306_resume(this_client);
+}
+static int __devexit ft5306_remove(struct i2c_client *client)
+{
+	struct ft5x0x_ts_data *ft5x0x_ts = i2c_get_clientdata(client);
+
+	free_irq(ft5x0x_ts->irq, ft5x0x_ts);
+	input_unregister_device(ft5x0x_ts->input_dev);
+	kfree(ft5x0x_ts);
+	cancel_work_sync(&ft5x0x_ts->pen_event_work);
+	destroy_workqueue(ft5x0x_ts->ts_workqueue);
+	i2c_set_clientdata(client, NULL);
+    unregister_early_suspend(&ft5306_power);
+    this_client = NULL;
+	return 0;
+}
+
+static int  ft5306_probe(struct i2c_client *client ,const struct i2c_device_id *id)
+{
+	struct ft5x0x_ts_data *ft5x0x_ts;
+	struct input_dev *input_dev;
+	struct ft5306_platform_data *pdata = client->dev.platform_data;
+	int err = 0;
+	int ret = 0;
+	int retry = 0;
+	u8 buf_w[1];
+	u8 buf_r[1];
+	const u8 buf_test[1] = {0};
+    unsigned char reg_value;
+    unsigned char reg_version;
+
+	dev_info(&client->dev, "ft5x0x_ts_probe!\n");
+	if (!pdata) {
+		dev_err(&client->dev, "platform data is required!\n");
+		return -EINVAL;
+	}
+
+	if (pdata->init_platform_hw)                              
+		pdata->init_platform_hw();
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)){
+		dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+		return -ENODEV;
+	}
+	
+	ft5x0x_ts = kzalloc(sizeof(*ft5x0x_ts), GFP_KERNEL);
+	if (!ft5x0x_ts)	{
+		return -ENOMEM;
+	}
+
+	while(retry < 5)
+	{
+		ret=ft5306_set_regs(client,FT5X0X_REG_PMODE, buf_test,1);
+		if(ret > 0)break;
+		retry++;
+	}
+	if(ret <= 0)
+	{
+		printk("FT5306 I2C TEST ERROR!\n");
+		err = -ENODEV;
+		goto exit_i2c_test_fail;
+	}
+	buf_r[0] = 0xff;
+	err = ft5306_read_regs(client,FT5X0X_REG_PMODE,buf_r,1);
+	printk("read buf[FT5X0X_REG_PMODE] = %d\n", buf_r[0]);
+
+	
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		printk("failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+	ft5x0x_ts->client = this_client = client;
+	ft5x0x_ts->irq = pdata->irq_pin;
+	ft5x0x_ts->input_dev = input_dev;
+
+	set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+	set_bit(EV_ABS, input_dev->evbit);
+	
+#if CONFIG_FT5X0X_MULTITOUCH
+	ft5306_init_touchid(ft5x0x_ts->event.cur_touch_id,MAX_POINT,-1);
+	ft5306_init_touchid(ft5x0x_ts->event.last_touch_id,MAX_POINT,-1);
+	input_mt_init_slots(input_dev, MAX_POINT);
+	input_set_abs_params(input_dev,ABS_MT_POSITION_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(input_dev,ABS_MT_POSITION_Y, 0, SCREEN_MAX_Y, 0, 0);
+#else
+	set_bit(ABS_X, input_dev->absbit);
+	set_bit(ABS_Y, input_dev->absbit);
+	set_bit(ABS_PRESSURE, input_dev->absbit);
+	set_bit(BTN_TOUCH, input_dev->keybit);
+	input_set_abs_params(input_dev, ABS_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, SCREEN_MAX_Y, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, PRESS_MAX, 0 , 0);
+#endif
+	
+	input_dev->name		= FT5X0X_NAME;
+	input_dev->id.bustype = BUS_I2C;
+	
+	err = input_register_device(input_dev);
+	if (err) {
+		printk("ft5x0x_ts_probe: failed to register input device: \n");
+		goto exit_input_register_device_failed;
+	}
+
+	if (!ft5x0x_ts->irq) {
+		err = -ENODEV;
+		dev_err(&ft5x0x_ts->client->dev, "no IRQ?\n");
+		goto exit_no_irq_fail;
+	}else{
+		ft5x0x_ts->irq = gpio_to_irq(ft5x0x_ts->irq);
+	}
+
+	//INIT_WORK(&ft5x0x_ts->pen_event_work, ft5306_ts_pen_irq_work);
+	INIT_WORK(&ft5x0x_ts->pen_event_work, ft5306_queue_work);
+	ft5x0x_ts->ts_workqueue = create_singlethread_workqueue("ft5x0x_ts");
+	if (!ft5x0x_ts->ts_workqueue) {
+		err = -ESRCH;
+		goto exit_create_singlethread;
+	}
+
+	/***wait CTP to bootup normally***/
+	 msleep(200); 
+	 
+	 fts_register_read(FT5X0X_REG_FIRMID, &reg_version,1);
+	 printk("[TSP] firmware version = 0x%2x\n", reg_version);
+	 fts_register_read(FT5X0X_REG_REPORT_RATE, &reg_value,1);
+	 printk("[TSP]firmware report rate = %dHz\n", reg_value*10);
+	 fts_register_read(FT5X0X_REG_THRES, &reg_value,1);
+	 printk("[TSP]firmware threshold = %d\n", reg_value * 4);
+	 fts_register_read(FT5X0X_REG_NOISE_MODE, &reg_value,1);
+	 printk("[TSP]nosie mode = 0x%2x\n", reg_value);
+
+#if 0
+	  if (fts_ctpm_get_upg_ver() != reg_version)  
+	  {
+		  printk("[TSP] start upgrade new verison 0x%2x\n", fts_ctpm_get_upg_ver());
+		  msleep(200);
+		  err =  fts_ctpm_fw_upgrade_with_i_file();
+		  if (err == 0)
+		  {
+			  printk("[TSP] ugrade successfuly.\n");
+			  msleep(300);
+			  fts_register_read(FT5X0X_REG_FIRMID, &reg_value,1);
+			  printk("FTS_DBG from old version 0x%2x to new version = 0x%2x\n", reg_version, reg_value);
+		  }
+		  else
+		  {
+			  printk("[TSP]  ugrade fail err=%d, line = %d.\n",err, __LINE__);
+		  }
+		  msleep(4000);
+	  }
+#endif
+
+	//printk("client->dev.driver->name %s  ,%d \n",client->dev.driver->name,ft5x0x_ts->irq);
+	ret = request_irq(ft5x0x_ts->irq, ft5306_interrupt, IRQF_TRIGGER_FALLING, client->dev.driver->name, ft5x0x_ts);
+	if (ret < 0) {
+		dev_err(&client->dev, "irq %d busy?\n", ft5x0x_ts->irq);
+		goto exit_irq_request_fail;
+	}
+	
+	i2c_set_clientdata(client, ft5x0x_ts);
+	ft5306_power.suspend =ft5306_suspend_early;
+	ft5306_power.resume =ft5306_resume_early;
+	ft5306_power.level = 0x2;
+	register_early_suspend(&ft5306_power);
+
+	buf_w[0] = 6;
+	err = ft5306_set_regs(client,0x88,buf_w,1);
+	buf_r[0] = 0;
+	err = ft5306_read_regs(client,0x88,buf_r,1);
+	printk("read buf[0x88] = %d\n", buf_r[0]);
+    return 0;
+
+	i2c_set_clientdata(client, NULL);
+	free_irq(ft5x0x_ts->irq,ft5x0x_ts);
+exit_irq_request_fail:
+	cancel_work_sync(&ft5x0x_ts->pen_event_work);
+	destroy_workqueue(ft5x0x_ts->ts_workqueue);
+exit_create_singlethread:
+exit_no_irq_fail:
+	input_unregister_device(input_dev);
+exit_input_register_device_failed:
+	input_free_device(input_dev);
+exit_input_dev_alloc_failed:
+exit_i2c_test_fail:
+	if (pdata->exit_platform_hw)                              
+		pdata->exit_platform_hw();
+	kfree(ft5x0x_ts);
+	return err;
+}
+
+
+
+static struct i2c_device_id ft5306_idtable[] = {
+	{ FT5X0X_NAME, 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ft5306_idtable);
+
+static struct i2c_driver ft5306_driver  = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= FT5X0X_NAME
+	},
+	.id_table	= ft5306_idtable,
+	.probe      = ft5306_probe,
+	.remove 	= __devexit_p(ft5306_remove),
+};
+
+static int __init ft5306_ts_init(void)
+{
+	return i2c_add_driver(&ft5306_driver);
+}
+
+static void __exit ft5306_ts_exit(void)
+{
+	printk("Touchscreen driver of ft5306 exited.\n");
+	i2c_del_driver(&ft5306_driver);
+}
+
+/***********************************************************************/
+
+module_init(ft5306_ts_init);
+module_exit(ft5306_ts_exit);
+
+MODULE_AUTHOR("<wenfs@Focaltech-systems.com>");
+MODULE_DESCRIPTION("FocalTech ft5x0x TouchScreen driver");
+
diff --git a/drivers/misc/bp/chips/c66a.c b/drivers/misc/bp/chips/c66a.c
index 2ec6c3656b21..ab7aba6f18ec 100644
--- a/drivers/misc/bp/chips/c66a.c
+++ b/drivers/misc/bp/chips/c66a.c
@@ -130,6 +130,7 @@ static int bp_resume(struct bp_private_data *bp)
 
 
 struct bp_operate bp_c66a_ops = {
+#if defined(CONFIG_ARCH_RK2928)
 	.name			= "c66a",
 	.bp_id			= BP_ID_C66A,
 	.bp_bus			= BP_BUS_TYPE_UART,		
@@ -159,6 +160,69 @@ struct bp_operate bp_c66a_ops = {
 	.resume			= bp_resume,
 	.misc_name		= NULL,
 	.private_miscdev	= NULL,
+#elif defined(CONFIG_ARCH_RK30)
+	.name			= "c66a",
+	.bp_id			= BP_ID_C66A,
+	.bp_bus			= BP_BUS_TYPE_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
+	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.bp_assert		= BP_UNKNOW_DATA,//RK2928_PIN3_PC5,
+	.trig				= IRQF_TRIGGER_RISING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#else
+	.name			= "c66a",
+	.bp_id			= BP_ID_C66A,
+	.bp_bus			= BP_BUS_TYPE_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
+	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.bp_assert		= BP_UNKNOW_DATA,//RK2928_PIN3_PC5,
+	.trig				= IRQF_TRIGGER_RISING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#endif
+
+
 };
 
 /****************operate according to bp chip:end************/
diff --git a/drivers/misc/bp/chips/m51.c b/drivers/misc/bp/chips/m51.c
index e1542b0b0ee1..8684e018c89f 100755
--- a/drivers/misc/bp/chips/m51.c
+++ b/drivers/misc/bp/chips/m51.c
@@ -157,6 +157,67 @@ static int bp_resume(struct bp_private_data *bp)
 
 
 struct bp_operate bp_m51_ops = {
+#if defined(CONFIG_ARCH_RK2928)
+	.name			= "m51",
+	.bp_id			= BP_ID_M50,
+	.bp_bus			= BP_BUS_TYPE_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= RK2928_PIN0_PB6,
+	.ap_ready		= RK2928_PIN0_PD6,	//
+	.bp_ready		= RK2928_PIN0_PD0,
+	.ap_wakeup_bp	= RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
+	.bp_assert		= BP_UNKNOW_DATA,
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig				= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#elif defined(CONFIG_ARCH_RK30)
+	.name			= "m51",
+	.bp_id			= BP_ID_M50,
+	.bp_bus			= BP_BUS_TYPE_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
+	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,	//
+	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,
+	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
+	.bp_assert		= BP_UNKNOW_DATA,
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig				= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#else
 	.name			= "m51",
 	.bp_id			= BP_ID_M50,
 	.bp_bus			= BP_BUS_TYPE_UART,		
@@ -186,6 +247,8 @@ struct bp_operate bp_m51_ops = {
 	.resume			= bp_resume,
 	.misc_name		= NULL,
 	.private_miscdev	= NULL,
+#endif
+
 };
 
 /****************operate according to bp chip:end************/
diff --git a/drivers/misc/bp/chips/mi700.c b/drivers/misc/bp/chips/mi700.c
index ff6b525117de..2ce93e913a57 100755
--- a/drivers/misc/bp/chips/mi700.c
+++ b/drivers/misc/bp/chips/mi700.c
@@ -147,6 +147,7 @@ static int bp_resume(struct bp_private_data *bp)
 
 
 struct bp_operate bp_mi700_ops = {
+#if defined(CONFIG_ARCH_RK2928)
 	.name			= "mi700",
 	.bp_id			= BP_ID_MI700,
 	.bp_bus			= BP_BUS_TYPE_USB,		
@@ -175,6 +176,65 @@ struct bp_operate bp_mi700_ops = {
 	.resume			= bp_resume,
 	.misc_name		= NULL,
 	.private_miscdev	= NULL,
+#elif defined(CONFIG_ARCH_RK30)
+	.name			= "mi700",
+	.bp_id			= BP_ID_MI700,
+	.bp_bus			= BP_BUS_TYPE_USB,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp	= BP_UNKNOW_DATA,
+	.bp_wakeup_ap	= BP_UNKNOW_DATA,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig				= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#else
+	.name			= "mi700",
+	.bp_id			= BP_ID_MI700,
+	.bp_bus			= BP_BUS_TYPE_USB,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp	= BP_UNKNOW_DATA,
+	.bp_wakeup_ap	= BP_UNKNOW_DATA,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig				= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#endif
 };
 
 /****************operate according to bp chip:end************/
diff --git a/drivers/misc/bp/chips/mt6229.c b/drivers/misc/bp/chips/mt6229.c
index 94648abd276e..a4b3e243e980 100755
--- a/drivers/misc/bp/chips/mt6229.c
+++ b/drivers/misc/bp/chips/mt6229.c
@@ -174,6 +174,7 @@ static int bp_resume(struct bp_private_data *bp)
 
 
 struct bp_operate bp_mt6229_ops = {
+#if defined(CONFIG_ARCH_RK2928)
 	.name			= "mt6229",
 	.bp_id			= BP_ID_MT6229,
 	.bp_bus			= BP_BUS_TYPE_USB_UART,		
@@ -201,6 +202,63 @@ struct bp_operate bp_mt6229_ops = {
 	.resume			= bp_resume,
 	.misc_name		= NULL,
 	.private_miscdev	= NULL,
+#elif defined(CONFIG_ARCH_RK30)
+	.name			= "mt6229",
+	.bp_id			= BP_ID_MT6229,
+	.bp_bus			= BP_BUS_TYPE_USB_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp		= BP_UNKNOW_DATA,
+	.bp_wakeup_ap		= BP_UNKNOW_DATA,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig			= IRQF_TRIGGER_RISING,
+
+	.active			= bp_active,
+	.init			= bp_init,
+	.ap_wake_bp		= ap_wake_bp,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#else
+	.name			= "mt6229",
+	.bp_id			= BP_ID_MT6229,
+	.bp_bus			= BP_BUS_TYPE_USB_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp		= BP_UNKNOW_DATA,
+	.bp_wakeup_ap		= BP_UNKNOW_DATA,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig			= IRQF_TRIGGER_RISING,
+
+	.active			= bp_active,
+	.init			= bp_init,
+	.ap_wake_bp		= ap_wake_bp,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#endif
 };
 
 /****************operate according to bp chip:end************/
diff --git a/drivers/misc/bp/chips/mtk6250.c b/drivers/misc/bp/chips/mtk6250.c
index c7b0460c24f9..0ba2e2a9fe6a 100644
--- a/drivers/misc/bp/chips/mtk6250.c
+++ b/drivers/misc/bp/chips/mtk6250.c
@@ -154,6 +154,37 @@ static int bp_resume(struct bp_private_data *bp)
 
 
 struct bp_operate bp_mt6250_ops = {
+#if defined(CONFIG_ARCH_RK2928)
+	.name			= "mt6250",
+	.bp_id			= BP_ID_MT6250,
+	.bp_bus			= BP_BUS_TYPE_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= RK2928_PIN0_PB6,
+	.ap_ready		= RK2928_PIN0_PD0,	//
+	.bp_ready		= RK2928_PIN0_PD6,
+	.ap_wakeup_bp	= RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
+	.bp_assert		= BP_UNKNOW_DATA,
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig				= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#elif defined(CONFIG_ARCH_RK30)
 	.name			= "mt6250",
 	.bp_id			= BP_ID_MT6250,
 	.bp_bus			= BP_BUS_TYPE_UART,		
@@ -183,6 +214,37 @@ struct bp_operate bp_mt6250_ops = {
 	.resume			= bp_resume,
 	.misc_name		= NULL,
 	.private_miscdev	= NULL,
+#else
+	.name			= "mt6250",
+	.bp_id			= BP_ID_MT6250,
+	.bp_bus			= BP_BUS_TYPE_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
+	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,	//
+	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,
+	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
+	.bp_assert		= BP_UNKNOW_DATA,
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig				= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#endif
 };
 
 /****************operate according to bp chip:end************/
diff --git a/drivers/misc/bp/chips/mu509.c b/drivers/misc/bp/chips/mu509.c
index c7e85fc95cc2..7de6ae707b1f 100755
--- a/drivers/misc/bp/chips/mu509.c
+++ b/drivers/misc/bp/chips/mu509.c
@@ -206,6 +206,65 @@ static int bp_resume(struct bp_private_data *bp)
 
 
 struct bp_operate bp_mu509_ops = {
+#if defined(CONFIG_ARCH_RK2928)
+	.name			= "mu509",
+	.bp_id			= BP_ID_MU509,
+	.bp_bus			= BP_BUS_TYPE_USB_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= RK2928_PIN1_PA3,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp		= RK2928_PIN3_PC4,
+	.bp_wakeup_ap		= RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig			= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init			= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= ap_wake_bp,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#elif defined(CONFIG_ARCH_RK30)
+	.name			= "mu509",
+	.bp_id			= BP_ID_MU509,
+	.bp_bus			= BP_BUS_TYPE_USB_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
+	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig			= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init			= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= ap_wake_bp,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#else
 	.name			= "mu509",
 	.bp_id			= BP_ID_MU509,
 	.bp_bus			= BP_BUS_TYPE_USB_UART,		
@@ -234,6 +293,7 @@ struct bp_operate bp_mu509_ops = {
 	.resume			= bp_resume,
 	.misc_name		= NULL,
 	.private_miscdev	= NULL,
+#endif
 };
 
 /****************operate according to bp chip:end************/
diff --git a/drivers/misc/bp/chips/mw100.c b/drivers/misc/bp/chips/mw100.c
index 71cf5b45ef78..6305a36467b2 100755
--- a/drivers/misc/bp/chips/mw100.c
+++ b/drivers/misc/bp/chips/mw100.c
@@ -166,6 +166,36 @@ static int bp_resume(struct bp_private_data *bp)
 
 
 struct bp_operate bp_mw100_ops = {
+#if defined(CONFIG_ARCH_RK2928)
+	.name			= "mw100",
+	.bp_id			= BP_ID_MW100,
+	.bp_bus			= BP_BUS_TYPE_USB,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= RK2928_PIN3_PC5,	// 3g_en
+	.bp_reset			= RK2928_PIN1_PA3,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp	= RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig				= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#elif defined(CONFIG_ARCH_RK30)
 	.name			= "mw100",
 	.bp_id			= BP_ID_MW100,
 	.bp_bus			= BP_BUS_TYPE_USB,		
@@ -194,6 +224,36 @@ struct bp_operate bp_mw100_ops = {
 	.resume			= bp_resume,
 	.misc_name		= NULL,
 	.private_miscdev	= NULL,
+#else
+	.name			= "mw100",
+	.bp_id			= BP_ID_MW100,
+	.bp_bus			= BP_BUS_TYPE_USB,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,//RK2928_PIN3_PC5,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp	= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.trig				= IRQF_TRIGGER_FALLING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#endif
 };
 
 /****************operate according to bp chip:end************/
diff --git a/drivers/misc/bp/chips/sc6610.c b/drivers/misc/bp/chips/sc6610.c
index cd67c07ff9fc..684f7fc14920 100755
--- a/drivers/misc/bp/chips/sc6610.c
+++ b/drivers/misc/bp/chips/sc6610.c
@@ -130,6 +130,67 @@ static int bp_resume(struct bp_private_data *bp)
 
 
 struct bp_operate bp_sc6610_ops = {
+#if defined(CONFIG_ARCH_RK2928)
+	.name			= "sc6610",
+	.bp_id			= BP_ID_SC6610,
+	.bp_bus			= BP_BUS_TYPE_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp	= RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.bp_assert		= RK2928_PIN3_PC5,
+	.trig				= IRQF_TRIGGER_RISING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#elif defined(CONFIG_ARCH_RK30)
+	.name			= "sc6610",
+	.bp_id			= BP_ID_SC6610,
+	.bp_bus			= BP_BUS_TYPE_UART,		
+	.bp_pid			= 0,	
+	.bp_vid			= 0,	
+	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
+	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
+	.bp_reset			= BP_UNKNOW_DATA,
+	.ap_ready		= BP_UNKNOW_DATA,	//
+	.bp_ready		= BP_UNKNOW_DATA,
+	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
+	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
+	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
+	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
+	.bp_assert		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,
+	.trig				= IRQF_TRIGGER_RISING,
+
+	.active			= bp_active,
+	.init				= bp_init,
+	.reset			= bp_reset,
+	.ap_wake_bp		= NULL,
+	.bp_wake_ap		= bp_wake_ap,
+	.shutdown		= bp_shutdown,
+	.read_status		= NULL,
+	.write_status		= NULL,
+	.suspend 		= bp_suspend,
+	.resume			= bp_resume,
+	.misc_name		= NULL,
+	.private_miscdev	= NULL,
+#else
 	.name			= "sc6610",
 	.bp_id			= BP_ID_SC6610,
 	.bp_bus			= BP_BUS_TYPE_UART,		
@@ -159,6 +220,7 @@ struct bp_operate bp_sc6610_ops = {
 	.resume			= bp_resume,
 	.misc_name		= NULL,
 	.private_miscdev	= NULL,
+#endif
 };
 
 /****************operate according to bp chip:end************/
diff --git a/drivers/misc/modem_sound.c b/drivers/misc/modem_sound.c
index b767cb964617..329122560665 100755
--- a/drivers/misc/modem_sound.c
+++ b/drivers/misc/modem_sound.c
@@ -14,7 +14,7 @@
 #include <asm/uaccess.h>
 #include <linux/wait.h>
 #include "modem_sound.h"
-#if 1
+#if 0
 #define DBG(x...)	printk(KERN_INFO x)
 #else
 #define DBG(x...)
@@ -24,7 +24,7 @@
 
 static struct modem_sound_data *modem_sound;
 #ifdef CONFIG_SND_RK_SOC_RK2928
-extern void call_set_spk(bool on);
+extern void call_set_spk(int on);
 #endif
 int modem_sound_spkctl(int status)
 {
@@ -78,33 +78,32 @@ static long modem_sound_ioctl(struct file *filp, unsigned int cmd, unsigned long
 	switch (cmd){
 		case IOCTL_MODEM_EAR_PHOEN:
 			DBG("modem_sound_ioctl: MODEM_EAR_PHONE\n");
-			call_set_spk(0);
+			call_set_spk(3);
 			modem_sound_spkctl(DISABLE);
 			break;
 		case IOCTL_MODEM_SPK_PHONE:
 			DBG("modem_sound_ioctl: MODEM_SPK_PHONE\n");
-			call_set_spk(0);
+			call_set_spk(1);
 			modem_sound_spkctl(ENABLE);
 			break;
 	  	case IOCTL_MODEM_HP_PHONE:
 	  		DBG("modem_sound_ioctl: MODEM_HP_PHONE\n");
-	  		call_set_spk(0);
+	  		call_set_spk(2);
 			modem_sound_spkctl(DISABLE);
 			break;
 			
 		case IOCTL_MODEM_BT_PHONE:
-			call_set_spk(0);
+			call_set_spk(3);
 			modem_sound_spkctl(DISABLE);
 			DBG("modem_sound_ioctl: MODEM_BT_PHONE\n");
 			break;
 		case IOCTL_MODEM_STOP_PHONE:
 		  	DBG("modem_sound_ioctl: MODEM_STOP_PHONE\n");
-			call_set_spk(1);
+			call_set_spk(0);
 			break;
 
 		default:
 			printk("unknown ioctl cmd!\n");
-			up(&pdata->power_sem);
 			ret = -EINVAL;
 			break;
 	}
diff --git a/drivers/video/display/screen/Kconfig b/drivers/video/display/screen/Kconfig
index 838bab69f947..2c325269d62a 100755
--- a/drivers/video/display/screen/Kconfig
+++ b/drivers/video/display/screen/Kconfig
@@ -143,6 +143,10 @@ config LCD_DS1006H
 config LCD_B101UANO_1920x1200
           bool "Lvds screen B101UANO for u30gt2"
 
+config LCD_WY_800X480
+	bool "lcd for 760"
+config LCD_HH070D_LVDS
+	bool "lcd lvds for 760"
 
 endchoice
 
diff --git a/drivers/video/display/screen/Makefile b/drivers/video/display/screen/Makefile
index 61f93b1a3ddd..8b158a9f5bbf 100755
--- a/drivers/video/display/screen/Makefile
+++ b/drivers/video/display/screen/Makefile
@@ -57,3 +57,5 @@ obj-$(CONFIG_LCD_TL5001_MIPI)    += lcd_tl5001_mipi.o
 obj-$(CONFIG_LCD_LP097QX1)    += lcd_LP097QX1.o
 obj-$(CONFIG_LCD_DS1006H)    += lcd_ds1006h.o
 obj-$(CONFIG_LCD_B101UANO_1920x1200)	+= lcd_b101uano_1920x1200.o
+obj-$(CONFIG_LCD_WY_800X480)    += lcd_wy_800x480.o
+obj-$(CONFIG_LCD_HH070D_LVDS)   += lcd_hh070d_lvds.o
\ No newline at end of file
diff --git a/drivers/video/display/screen/lcd_hh070d_lvds.c b/drivers/video/display/screen/lcd_hh070d_lvds.c
new file mode 100755
index 000000000000..9e8683593751
--- /dev/null
+++ b/drivers/video/display/screen/lcd_hh070d_lvds.c
@@ -0,0 +1,77 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_LVDS
+#define OUT_FORMAT      1//LVDS_8BIT_2
+
+#define OUT_FACE		OUT_D888_P666
+#define OUT_CLK			60000000
+#define LCDC_ACLK       300000000//500000000//312000000           //29 lcdc axi DMA 
+
+/* Timing */
+#define H_PW			100
+#define H_BP			100
+#define H_VD			1024
+#define H_FP			120
+
+#define V_PW			10
+#define V_BP			10
+#define V_VD			600
+#define V_FP			150
+
+#define LCD_WIDTH       202
+#define LCD_HEIGHT      152
+/* Other */
+#define DCLK_POL		1
+#define SWAP_RB			0   
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    screen->width = LCD_WIDTH;
+    screen->height = LCD_HEIGHT;
+    screen->hw_format = OUT_FORMAT;
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = NULL;
+    screen->standby = NULL;
+}
+
+
+
diff --git a/drivers/video/display/screen/lcd_wy_800x480.c b/drivers/video/display/screen/lcd_wy_800x480.c
new file mode 100755
index 000000000000..5be80d6c5d5a
--- /dev/null
+++ b/drivers/video/display/screen/lcd_wy_800x480.c
@@ -0,0 +1,109 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "screen.h"
+
+/* Base */
+#define LCD_WIDTH       154    //need modify
+#define LCD_HEIGHT      85
+
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P666
+#define OUT_CLK			 33000000
+#define LCDC_ACLK       150000000     //29 lcdc axi DMA 
+
+/* Timing */
+#define H_PW			30
+#define H_BP			16
+#define H_VD			800
+#define H_FP			210
+
+#define V_PW			13
+#define V_BP			10
+#define V_VD			480
+#define V_FP			22
+
+/* Other */
+#define DCLK_POL	0	
+#define SWAP_RB		0	
+
+static struct rk29lcd_info *gLcd_info = NULL;
+
+static int init(void)
+{
+	int ret = 0;
+	
+	if(gLcd_info && gLcd_info->io_init)
+		gLcd_info->io_init();
+
+	return 0;
+}
+
+static int standby(u8 enable)
+{
+	if(!enable)
+	{
+		if(gLcd_info && gLcd_info->io_enable)
+			gLcd_info->io_enable();
+	}
+	else 
+	{
+		if(gLcd_info && gLcd_info->io_disable)
+			gLcd_info->io_disable();
+	}
+	return 0;
+}
+
+void set_lcd_info(struct rk29fb_screen *screen,  struct rk29lcd_info *lcd_info )
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    screen->width = LCD_WIDTH;
+    screen->height = LCD_HEIGHT;
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+	/* Operation function*/
+	screen->init = init;
+	screen->standby = standby;
+	if(lcd_info)
+	{
+		gLcd_info = lcd_info;
+	}
+	else
+	{
+		printk("%s lcd_info==NULL\n", __func__);
+	}
+
+}
+
diff --git a/sound/soc/codecs/rk2928_codec.c b/sound/soc/codecs/rk2928_codec.c
index a9feb0aa7eab..db03786f1340 100755
--- a/sound/soc/codecs/rk2928_codec.c
+++ b/sound/soc/codecs/rk2928_codec.c
@@ -27,10 +27,10 @@
 #include <linux/gpio.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-
+#include <linux/workqueue.h>
 #include <asm/io.h>
 #include <asm/delay.h>
-
+#include <linux/wakelock.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -42,7 +42,6 @@
 #include <mach/cpu.h>
 #include <linux/clk.h>
 #include "rk2928_codec.h"
-
 #define HP_OUT 0
 #define HP_IN  1
 
@@ -56,13 +55,55 @@ static struct rk2928_codec_data {
 	int				mute;
 	int				hdmi_enable;
 	int				spkctl;
+	int				hp_ctl;
 	int             call_enable;
 	int             headset_status;	
+	struct rk2928_codec_pdata *pdata;
+	bool			stop_phone_depop;
+	struct delayed_work h_delayed_work;	
+	struct mutex mutex_lock;
 } rk2928_data;
 
+static int DAC_event(struct snd_soc_dapm_widget *w,
+			  struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct rk2928_codec_data *priv = snd_soc_codec_get_drvdata(codec);
+	
+	DBG("%s::%d event = %d\n",__FUNCTION__,__LINE__,event);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMD:
+#ifdef CONFIG_MODEM_SOUND	
+	if(rk2928_data.call_enable)
+		return 0;
+#endif			
+		//before widget power down
+		if(rk2928_data.spkctl != INVALID_GPIO) {
+			gpio_direction_output(rk2928_data.spkctl, GPIO_LOW);
+		}	
+		if(rk2928_data.hp_ctl != 0 && rk2928_data.headset_status == HP_IN) {
+		//	gpio_direction_output(rk2928_data.hp_ctl, GPIO_LOW);
+		}			
+		break;
+	case SND_SOC_DAPM_POST_PMU:	
+		//after widget power up	
+		if(rk2928_data.spkctl != INVALID_GPIO && rk2928_data.headset_status == HP_OUT) {
+			gpio_direction_output(rk2928_data.spkctl, GPIO_HIGH);
+			msleep(200);
+		}
+		if(rk2928_data.hp_ctl != 0 ) {//&& rk2928_data.headset_status == HP_IN
+			gpio_direction_output(rk2928_data.hp_ctl, GPIO_HIGH);
+		}
+		break;
+	}
+
+	return 0;
+}
+
 static const struct snd_soc_dapm_widget rk2928_dapm_widgets[] = {
-	SND_SOC_DAPM_DAC("DACL", "HIFI Playback", CODEC_REG_POWER, 5, 1),
-	SND_SOC_DAPM_DAC("DACR", "HIFI Playback", CODEC_REG_POWER, 4, 1),
+	SND_SOC_DAPM_DAC_E("DACL", "HIFI Playback", CODEC_REG_POWER, 5, 1,DAC_event, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_DAC_E("DACR", "HIFI Playback", CODEC_REG_POWER, 4, 1,DAC_event, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_PGA("DACL Amp", CODEC_REG_DAC_GAIN, 2, 0, NULL, 0),
 	SND_SOC_DAPM_PGA("DACR Amp", CODEC_REG_DAC_GAIN, 0, 0, NULL, 0),
 	SND_SOC_DAPM_OUTPUT("SPKL"),
@@ -97,26 +138,37 @@ static const struct snd_soc_dapm_route rk2926_audio_map[] = {
 	{"ADCR", NULL, "MICR"},
 };
 
-
-
 static unsigned int rk2928_read(struct snd_soc_codec *codec, unsigned int reg)
 {	
 	return readl(rk2928_data.regbase + reg*4);
 }
 
 static int rk2928_write(struct snd_soc_codec *codec, unsigned int reg, unsigned int value)
-{
-#ifdef CONFIG_MODEM_SOUND
+{	
+#ifdef CONFIG_MODEM_SOUND	
 	if(rk2928_data.call_enable)
 		return 0;
 #endif		
 	DBG("%s reg 0x%02x value 0x%02x", __FUNCTION__, reg, value);
+       if(reg == 0xc)
+               value &= ~0x31;	
 	writel(value, rk2928_data.regbase + reg*4);
 	if( (reg == CODEC_REG_POWER) && ( (value & m_PD_DAC) == 0)) {
 		msleep(100);
 	}
 	return 0;
 }
+static int rk2928_write_incall(struct snd_soc_codec *codec, unsigned int reg, unsigned int value)
+{
+        DBG("%s reg 0x%02x value 0x%02x", __FUNCTION__, reg, value);
+       if(reg == 0xc)
+               value &= ~0x31;
+        writel(value, rk2928_data.regbase + reg*4);
+        if( (reg == CODEC_REG_POWER) && ( (value & m_PD_DAC) == 0)) {
+                msleep(100);
+        }
+        return 0;
+}
 
 static int rk2928_write_mask(struct snd_soc_codec *codec, unsigned int reg, 
 					unsigned int mask, unsigned int value)
@@ -147,32 +199,67 @@ void codec_set_spk(bool on)
 		rk2928_data.hdmi_enable = 0;
 		if(rk2928_data.mute == 0) {
 			rk2928_write(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(0));
-			if(rk2928_data.spkctl != INVALID_GPIO && rk2928_data.headset_status == HP_OUT) {
+			if((rk2928_data.spkctl != INVALID_GPIO) && (rk2928_data.headset_status == HP_OUT)) {
 				gpio_direction_output(rk2928_data.spkctl, GPIO_HIGH);
 			}
 		}
 	}
 }
+
+static void call_delay_work(struct work_struct *work)
+{
+	        struct snd_soc_codec *codec = rk2928_data.codec;
+        if(codec == NULL)
+                return;
+	 printk("%s speaker is disabled\n", __FUNCTION__);
+         rk2928_write_incall(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(0));
+         rk2928_write_incall(codec, CODEC_REG_POWER, 0x0c);
+         rk2928_write_incall(codec, CODEC_REG_ADC_SOURCE, 0x03);
+         rk2928_write_incall(codec, CODEC_REG_ADC_PGA_GAIN, 0x33);//spk 0x33        
+         rk2928_data.call_enable = 1;
+	mutex_unlock(&rk2928_data.mutex_lock);
+
+}
 #ifdef CONFIG_MODEM_SOUND
-void call_set_spk(bool on)
+void call_set_spk(int on)
 {
 	struct snd_soc_codec *codec = rk2928_data.codec;
 	if(codec == NULL)
 		return;	
-	if(on == 0) {
-		printk("%s speaker is disabled\n", __FUNCTION__);
-	//	rk2928_write(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(1));
-		rk2928_write(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(0));
-		rk2928_write(codec, CODEC_REG_POWER, 0x0c);
-		rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x03);
-		rk2928_data.call_enable = 1;
-	}
-	else {
+	mutex_lock(&rk2928_data.mutex_lock);
+	switch(on)
+	{
+	case 0:
 		printk("%s speaker is enabled\n", __FUNCTION__);
 		rk2928_data.call_enable = 0;
 	//	rk2928_write(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(0));
 		rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x00);
+		printk("rk2928 codec stop phone need depop\n");
+		rk2928_data.stop_phone_depop = true;	
+		break;
+	case 1:
+		rk2928_write_incall(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(1));
+		schedule_delayed_work(&rk2928_data.h_delayed_work, msecs_to_jiffies(1000));
+		return;
+	case 2:
+		printk("%s speaker is disabled\n", __FUNCTION__);
+		rk2928_write(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(0));
+		rk2928_write(codec, CODEC_REG_POWER, 0x0c);
+		rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x03);
+		rk2928_write(codec, CODEC_REG_ADC_PGA_GAIN, 0x11);//headset
+		rk2928_data.call_enable = 1;	
+		break;
+	case 3:
+                printk("%s speaker is disabled\n", __FUNCTION__);
+                rk2928_write(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(0));
+                rk2928_write(codec, CODEC_REG_POWER, 0x0c);
+                rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x03);
+                rk2928_write(codec, CODEC_REG_ADC_PGA_GAIN, 0x33);//spk 0x33            
+                rk2928_data.call_enable = 1;
+                break;
 	}
+	mutex_unlock(&rk2928_data.mutex_lock);
+	return;
 }
 #endif
 #ifdef CONFIG_RK_HEADSET_DET
@@ -182,20 +269,28 @@ void rk2928_codec_set_spk(bool on)
 	struct snd_soc_codec *codec = rk2928_data.codec;
 	if(codec == NULL)
 		return;
+	if(on)
+		rk2928_data.headset_status = HP_IN;
+	else
+		rk2928_data.headset_status = HP_OUT;
+	if(rk2928_data.call_enable)
+		return;
 	printk("%s: headset %s %s PA bias_level=%d\n",__FUNCTION__,on?"in":"out",on?"disable":"enable",codec->dapm.bias_level);
 	if(on) {
-		rk2928_data.headset_status = HP_IN;	
 		if(rk2928_data.spkctl != INVALID_GPIO)
+		{
 			gpio_direction_output(rk2928_data.spkctl, GPIO_LOW);
+		}
 	}
 	else {
-		rk2928_data.headset_status = HP_OUT;
 		if(codec->dapm.bias_level == SND_SOC_BIAS_STANDBY 
 		|| codec->dapm.bias_level == SND_SOC_BIAS_OFF){
 			return;
 		}		
 		if(rk2928_data.spkctl != INVALID_GPIO)
+		{
 			gpio_direction_output(rk2928_data.spkctl, GPIO_HIGH);
+		}
 	}
 }
 #endif
@@ -229,55 +324,72 @@ static int rk2928_audio_trigger(struct snd_pcm_substream *substream, int cmd,
 		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 //				rk2928_write(codec, CODEC_REG_DAC_GAIN, v_GAIN_DAC(DAC_GAIN_3DB_P));
-				data = rk2928_read(codec, CODEC_REG_POWER);
-				if(soc_is_rk2928g()){
-					if( (data & m_PD_ADC) == 0) {
-						data &= ~m_PD_ADC;
-						data |= v_PD_ADC(1);
-						pd_adc = 1;
+				if(!rk2928_data.hdmi_enable) {
+					data = rk2928_read(codec, CODEC_REG_POWER);
+					if(soc_is_rk2928g()){
+						if( (data & m_PD_ADC) == 0) {
+							data &= ~m_PD_ADC;
+							data |= v_PD_ADC(1);
+							pd_adc = 1;
+						}
+						else
+							pd_adc = 0;
 					}
-					else
-						pd_adc = 0;
-				}
-				else{
-					if( (data & m_PD_ADC_R) == 0) {
-						data &= ~m_PD_ADC_R;
-						data |= v_PD_ADC_R(1);
-						pd_adc = 1;
+					else{
+						if( (data & m_PD_ADC_R) == 0) {
+							data &= ~m_PD_ADC_R;
+							data |= v_PD_ADC_R(1);
+							pd_adc = 1;
+						}
+						else
+							pd_adc = 0;
 					}
-					else
-						pd_adc = 0;
-				}
-				if(pd_adc == 1) {
-					DBG("%s reg 0x%02x value 0x%02x", __FUNCTION__, CODEC_REG_POWER, data);
-					writel(data, rk2928_data.regbase + CODEC_REG_POWER*4);
-					udelay(100);						
-				}
-				rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x03);
-				udelay(100);
-				rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x00);
-				
-				if(pd_adc == 1) {
-					udelay(100);
-					data = rk2928_read(codec, CODEC_REG_POWER);
-					if( soc_is_rk2928g() ) {
-						data &= ~m_PD_ADC;
-						data |= v_PD_ADC(0);
+					if(pd_adc == 1) {
+						DBG("%s reg 0x%02x value 0x%02x", __FUNCTION__, CODEC_REG_POWER, data);
+						writel(data, rk2928_data.regbase + CODEC_REG_POWER*4);
+						udelay(100);						
 					}
-					else {
-						data &= ~m_PD_ADC_R;
-						data |= v_PD_ADC_R(0);
+
+					rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x03);
+					udelay(100);
+					rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x00);
+					
+					udelay(100);
+					rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x03);
+					udelay(100);
+					rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x00);
+					
+					udelay(100);
+					rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x03);
+					udelay(100);
+					rk2928_write(codec, CODEC_REG_ADC_SOURCE, 0x00);
+
+					if(pd_adc == 1) {
+						udelay(100);
+						data = rk2928_read(codec, CODEC_REG_POWER);
+						if( soc_is_rk2928g() ) {
+							data &= ~m_PD_ADC;
+							data |= v_PD_ADC(0);
+						}
+						else {
+							data &= ~m_PD_ADC_R;
+							data |= v_PD_ADC_R(0);
+						}
+						DBG("%s reg 0x%02x value 0x%02x", __FUNCTION__, CODEC_REG_POWER, data);
+						writel(data, rk2928_data.regbase + CODEC_REG_POWER*4);
 					}
-					DBG("%s reg 0x%02x value 0x%02x", __FUNCTION__, CODEC_REG_POWER, data);
-					writel(data, rk2928_data.regbase + CODEC_REG_POWER*4);
-				}
-				if(!rk2928_data.hdmi_enable) {
+					
 					rk2928_write(codec, CODEC_REG_DAC_MUTE, v_MUTE_DAC(0));
-					if(rk2928_data.spkctl != INVALID_GPIO && rk2928_data.headset_status == HP_OUT) {
+					if(rk2928_data.spkctl != INVALID_GPIO && rk2928_data.headset_status == HP_OUT && rk2928_data.stop_phone_depop ) {
+						mdelay(100);
 						gpio_direction_output(rk2928_data.spkctl, GPIO_HIGH);
+						rk2928_data.stop_phone_depop = false;
 					}
 				}
 				rk2928_data.mute = 0;
+			//	if(rk2928_data.spkctl != INVALID_GPIO && rk2928_data.headset_status == HP_OUT) {
+			//		gpio_direction_output(rk2928_data.spkctl, GPIO_HIGH);
+			//	}
 			}
 			else {
 				rk2928_write(codec, CODEC_REG_ADC_PGA_GAIN, 0xFF);
@@ -293,9 +405,9 @@ static int rk2928_audio_trigger(struct snd_pcm_substream *substream, int cmd,
 		return err;
 #endif		
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-				if(rk2928_data.spkctl != INVALID_GPIO) {
-					gpio_direction_output(rk2928_data.spkctl, GPIO_LOW);
-				}
+				//if(rk2928_data.spkctl != INVALID_GPIO) {
+					//gpio_direction_output(rk2928_data.spkctl, GPIO_LOW);
+				//}
 				rk2928_write(codec, CODEC_REG_DAC_MUTE, v_MUTE_DAC(1));
 				rk2928_data.mute = 1;
 			}
@@ -320,8 +432,6 @@ static int rk2928_set_bias_level(struct snd_soc_codec *codec,
 {
 	DBG("%s level %d\n", __FUNCTION__, level);
 	
-        msleep(100);
-
 	if(codec == NULL)
 		return -1;
 		
@@ -334,10 +444,14 @@ static int rk2928_set_bias_level(struct snd_soc_codec *codec,
 			break;
 		case SND_SOC_BIAS_STANDBY:
 		case SND_SOC_BIAS_OFF:
+			printk("rk2928 codec standby\n");
 #ifdef CONFIG_MODEM_SOUND	
 	if(rk2928_data.call_enable)
 		break;
 #endif				
+		//	if(rk2928_data.spkctl != INVALID_GPIO) {
+		//		gpio_direction_output(rk2928_data.spkctl, GPIO_LOW);
+		//	}
 			rk2928_write(codec, CODEC_REG_POWER, v_PWR_OFF);
 			break;
 		default:
@@ -360,13 +474,16 @@ static int rk2928_probe(struct snd_soc_codec *codec)
 	struct platform_device *pdev = to_platform_device(codec->dev);
 	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	struct resource *res, *mem;
+	struct rk2928_codec_pdata *pdata;
 	int ret;
 	
 	DBG("%s", __FUNCTION__);
 	
 	snd_soc_codec_set_drvdata(codec, &rk2928_data);
-	
+
 	rk2928_data.dev = &pdev->dev;
+	rk2928_data.pdata = pdev->dev.platform_data;	
+	pdata = rk2928_data.pdata;
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "Unable to get register resource\n");
@@ -382,7 +499,6 @@ static int rk2928_probe(struct snd_soc_codec *codec)
     	ret = -ENOENT;
     	goto err0;
 	}
-
 	
 	rk2928_data.regbase = (int)ioremap(res->start, (res->end - res->start) + 1);
 	if (!rk2928_data.regbase) {
@@ -416,7 +532,14 @@ static int rk2928_probe(struct snd_soc_codec *codec)
 		else
 			gpio_direction_output(rk2928_data.spkctl, GPIO_LOW);
 	}
-
+//------------------------------------------------------------------
+	if (pdata->hpctl) {
+		ret = pdata->hpctl_io_init();
+		if (ret) 
+			goto err1;
+		rk2928_data.hp_ctl = pdata->hpctl;
+		gpio_direction_output(rk2928_data.hp_ctl, GPIO_LOW);
+	}
 	//Reset Codec
 	rk2929_codec_reset();
 
@@ -436,9 +559,12 @@ static int rk2928_probe(struct snd_soc_codec *codec)
 	    snd_soc_dapm_add_routes(dapm, rk2926_audio_map, ARRAY_SIZE(rk2926_audio_map));
 	}
 
+	INIT_DELAYED_WORK(&rk2928_data.h_delayed_work, call_delay_work);
+	mutex_init(&rk2928_data.mutex_lock);
 	rk2928_data.call_enable = 0;
 	rk2928_data.headset_status = HP_OUT;
 	rk2928_data.codec=codec;
+	rk2928_data.stop_phone_depop=false;
 	return 0;
 	
 err1:
@@ -466,7 +592,7 @@ static int rk2928_resume(struct snd_soc_codec *codec)
 {
 	DBG("%s", __FUNCTION__);
 	clk_enable(rk2928_data.pclk);
-	rk2928_write(codec, CODEC_REG_POWER, v_PD_ADC(1) | v_PD_DAC(1) | v_PD_MIC_BIAS(1));
+	rk2928_write(codec, CODEC_REG_POWER, v_PD_ADC(1) | v_PD_DAC(1) | v_PD_MIC_BIAS(0));
 	return 0;
 }
 
@@ -531,6 +657,14 @@ static int __devexit rk2928_codec_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void rk2928_codec_shutdown(struct platform_device *pdev)
+{
+	printk("%s .....\n", __FUNCTION__);
+	if(rk2928_data.spkctl != INVALID_GPIO)
+		gpio_direction_output(rk2928_data.spkctl, GPIO_LOW);
+	if(rk2928_data.hp_ctl != 0 ) 
+		gpio_direction_output(rk2928_data.hp_ctl, GPIO_LOW);	
+}
 static struct platform_driver rk2928_codec_driver = {
 	.probe          = rk2928_codec_probe,
 	.remove         = __devexit_p(rk2928_codec_remove),
@@ -538,6 +672,7 @@ static struct platform_driver rk2928_codec_driver = {
 		.name   = "rk2928-codec",
 		.owner  = THIS_MODULE,
 	},
+	.shutdown = rk2928_codec_shutdown,
 };
 
 static int __init rk2928_codec_init(void)
diff --git a/sound/soc/codecs/rk2928_codec.h b/sound/soc/codecs/rk2928_codec.h
index 604bc6849b70..a7ec8693c8c0 100755
--- a/sound/soc/codecs/rk2928_codec.h
+++ b/sound/soc/codecs/rk2928_codec.h
@@ -35,7 +35,7 @@
 	#define v_PD_DAC_L(n)		(n << 5)
 	#define v_PD_ADC(n)			(v_PD_ADC_L(n) | v_PD_ADC_R(n))
 	#define v_PD_DAC(n)			(v_PD_DAC_L(n) | v_PD_DAC_R(n))
-	#define v_PWR_OFF			v_PD_DAC_L(1) | v_PD_DAC_R(1) | v_PD_ADC_L(1) | v_PD_ADC_R(1) | v_PD_MIC_BIAS(1) | v_PD_CODEC(1)
+	#define v_PWR_OFF			v_PD_DAC_L(1) | v_PD_DAC_R(1) | v_PD_ADC_L(1) | v_PD_ADC_R(1) | v_PD_MIC_BIAS(0) | v_PD_CODEC(1) //mic_bias for phone_pad
 	
 #define CODEC_REG_VCM_BIAS		0x0d
 	#define v_MIC_BIAS(n)		(n)
@@ -81,6 +81,9 @@
 #define DBG(format, ...)
 #endif
 
-
+struct rk2928_codec_pdata {
+	int	hpctl;
+	int (*hpctl_io_init)(void);	
+};
 
 #endif /* __RK2928_CODEC_H__ */
-- 
2.35.3

