From 6c07e13c08c1e8b8c04f5a78cb3b1c35e49d2ce3 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Sat, 3 Nov 2018 13:00:36 +0800
Subject: [PATCH] drivers/misc: remove unused rk29_modem drivers

Change-Id: If161f790d2b4a19bafff7a0cca0288eb4be1792e
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/misc/rk29_modem/Kconfig               |  26 --
 drivers/misc/rk29_modem/Makefile              |   6 -
 .../misc/rk29_modem/modem_longcheer_u6300v.c  | 169 ---------
 drivers/misc/rk29_modem/modem_rockchip_demo.c |  84 -----
 .../misc/rk29_modem/modem_thinkwill_mw100g.c  | 131 -------
 drivers/misc/rk29_modem/rk29_modem.c          | 340 ------------------
 drivers/misc/rk29_modem/rk29_modem.h          |  47 ---
 7 files changed, 803 deletions(-)
 delete mode 100644 drivers/misc/rk29_modem/Kconfig
 delete mode 100644 drivers/misc/rk29_modem/Makefile
 delete mode 100644 drivers/misc/rk29_modem/modem_longcheer_u6300v.c
 delete mode 100644 drivers/misc/rk29_modem/modem_rockchip_demo.c
 delete mode 100644 drivers/misc/rk29_modem/modem_thinkwill_mw100g.c
 delete mode 100644 drivers/misc/rk29_modem/rk29_modem.c
 delete mode 100644 drivers/misc/rk29_modem/rk29_modem.h

diff --git a/drivers/misc/rk29_modem/Kconfig b/drivers/misc/rk29_modem/Kconfig
deleted file mode 100644
index f3fb88610634..000000000000
--- a/drivers/misc/rk29_modem/Kconfig
+++ /dev/null
@@ -1,26 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# USB Serial device configuration
-#
-
-menuconfig RK29_SUPPORT_MODEM
-	tristate "RK29 support Modem"
-#	depends on USB11_HOST_EN
-	---help---
-	  Say Y here if you have a support modem
-
-choice
-	depends on RK29_SUPPORT_MODEM
-	prompt  "Select 3G Modem"
-
-    config MODEM_ROCKCHIP_DEMO
-  	bool "ROCKCHIP_GENERAL_MODEM_DEVICE"
-
-    config MODEM_LONGCHEER_U6300V
-  	bool "LONGCHEER_U6300V"
-
-    config MODEM_THINKWILL_MW100G
-        bool "THINKWILL_MW100G"
-
-endchoice
-
diff --git a/drivers/misc/rk29_modem/Makefile b/drivers/misc/rk29_modem/Makefile
deleted file mode 100644
index f652985e2b64..000000000000
--- a/drivers/misc/rk29_modem/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_RK29_SUPPORT_MODEM)                += rk29_modem.o
-obj-$(CONFIG_MODEM_ROCKCHIP_DEMO)		+= modem_rockchip_demo.o
-obj-$(CONFIG_MODEM_LONGCHEER_U6300V)		+=modem_longcheer_u6300v.o
-obj-$(CONFIG_MODEM_THINKWILL_MW100G)		+=modem_thinkwill_mw100g.o
-
diff --git a/drivers/misc/rk29_modem/modem_longcheer_u6300v.c b/drivers/misc/rk29_modem/modem_longcheer_u6300v.c
deleted file mode 100644
index 5045dd7383ce..000000000000
--- a/drivers/misc/rk29_modem/modem_longcheer_u6300v.c
+++ /dev/null
@@ -1,169 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/stat.h>	 /* permission constants */
-#include <linux/io.h>
-#include <linux/vmalloc.h>
-#include <asm/io.h>
-#include <asm/sizes.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <linux/delay.h>
-
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/gpio.h>
-#include <mach/board.h>
-
-#include <linux/platform_device.h>
-
-#include "rk29_modem.h"
-
-// 确保不出现重复处理wakeup
-static int do_wakeup_handle = 0;
-static irqreturn_t u6300v_irq_handler(int irq, void *dev_id);
-static int __devinit u6300v_resume(struct platform_device *pdev);
-
-static struct rk29_io_t u6300v_io_ap_ready = {
-    .io_addr    = RK29_PIN3_PC2,
-    .enable     = GPIO_LOW,
-    .disable    = GPIO_HIGH,
-};
-
-static struct rk29_io_t u6300v_io_power = {
-    .io_addr    = RK29_PIN6_PB1,
-    .enable     = GPIO_HIGH,
-    .disable    = GPIO_LOW,
-};
-
-static struct rk29_irq_t u6300v_irq_bp_wakeup_ap= {
-    .irq_addr   = RK29_PIN3_PD7,
-    .irq_trigger = IRQF_TRIGGER_FALLING, // 下降沿触发
-};
-
-static struct platform_driver u6300v_platform_driver = {
-	.driver		= {
-		.name		= "longcheer_u6300v",
-	},
-	.suspend    = rk29_modem_suspend,
-	.resume     = rk29_modem_resume,
-};
-
-static struct rk29_modem_t u6300v_driver = {
-    .driver         = &u6300v_platform_driver,
-    .modem_power    = &u6300v_io_power,
-    .ap_ready       = &u6300v_io_ap_ready,
-    .bp_wakeup_ap   = &u6300v_irq_bp_wakeup_ap,
-    .status         = MODEM_ENABLE,
-    .dev_init       = NULL,
-    .dev_uninit     = NULL,
-    .irq_handler    = u6300v_irq_handler,
-    .suspend        = NULL,
-    .resume         = u6300v_resume,
-    
-    .enable         = NULL,
-    .disable        = NULL,
-    .sleep          = NULL,
-    .wakeup         = NULL,
-};
-
-static void do_test1(struct work_struct *work)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    // 标志AP已就绪，BB可以上报数据给AP
-    gpio_direction_output(u6300v_driver.ap_ready->io_addr, u6300v_driver.ap_ready->enable);
-}
-
-static DECLARE_DELAYED_WORK(test1, do_test1);
-
-static int __devinit u6300v_resume(struct platform_device *pdev)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-/* cmy: 目前在系统被唤醒后，在这边设置AP_RDY，但由于通信依赖于其它的设备驱动(比如USB或者串口)
-        需要延时设置AP_RDY信号
-        更好的做法是在它所依赖的设备就绪后(唤醒)，再设置AP_RDY。做法两种:
-            1 将设置AP_RDY的函数注入到目标设备的resume函数中
-            2 在rk29_modem_resume中，等待目标设备resume之后，再设置AP_RDY
- */
-    schedule_delayed_work(&test1, 2*HZ);
-
-    return 0;
-}
-
-/*
-    u6300v 模组的 IRQ 处理函数，该函数由rk29_modem中的IRQ处理函数调用
- */
-static irqreturn_t u6300v_irq_handler(int irq, void *dev_id)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-    if( irq == gpio_to_irq(u6300v_driver.bp_wakeup_ap->irq_addr) )
-    {
-        if( !do_wakeup_handle )
-        {
-            do_wakeup_handle = 1;
-            // 当接收到 bb wakeup ap 的IRQ后，申请一个8秒的suspend锁，时间到后自动释放
-            // 释放时如果没有其它的锁，就将再次挂起.
-            wake_lock_timeout(&u6300v_driver.wakelock_bbwakeupap, 8 * HZ);
-        } else
-            printk("%s: already wakeup\n", __FUNCTION__);
-        return IRQ_HANDLED;
-    }
-    
-    return IRQ_NONE;
-}
-
-static int __init u6300v_init(void)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-    return rk29_modem_init(&u6300v_driver);
-}
-
-static void __exit u6300v_exit(void)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    rk29_modem_exit();
-}
-
-module_init(u6300v_init);
-module_exit(u6300v_exit);
-
-MODULE_AUTHOR("lintao lintao@rock-chips.com");
-MODULE_DESCRIPTION("ROCKCHIP modem driver");
-MODULE_LICENSE("GPL");
-
-#if 0
-int test(void)
-{
-    printk(">>>>>> test \n ");
-    int ret = gpio_request(IRQ_BB_WAKEUP_AP, NULL);
-    if(ret != 0)
-    {
-        printk(">>>>>> gpio_request failed! \n ");
-        gpio_free(IRQ_BB_WAKEUP_AP);
-        return ret;
-    }
-
-//    printk(">>>>>> set GPIOPullUp \n ");
-//    gpio_pull_updown(IRQ_BB_WAKEUP_AP, GPIOPullUp);
-//    printk(">>>>>> set GPIO_HIGH \n ");
-//    gpio_direction_output(IRQ_BB_WAKEUP_AP, GPIO_HIGH);
-
-//    printk(">>>>>> set GPIO_LOW \n ");
-//    gpio_direction_output(IRQ_BB_WAKEUP_AP, GPIO_LOW);
-//    msleep(1000);
-    
-    gpio_free(IRQ_BB_WAKEUP_AP);
-
-    printk(">>>>>> END \n ");
-}
-#endif
-
diff --git a/drivers/misc/rk29_modem/modem_rockchip_demo.c b/drivers/misc/rk29_modem/modem_rockchip_demo.c
deleted file mode 100644
index 2c41e4e5fc49..000000000000
--- a/drivers/misc/rk29_modem/modem_rockchip_demo.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/stat.h>
-#include <linux/io.h>
-#include <linux/vmalloc.h>
-#include <asm/io.h>
-#include <asm/sizes.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <linux/delay.h>
-
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/gpio.h>
-#include <mach/board.h>
-
-#include <linux/platform_device.h>
-
-#include "rk29_modem.h"
-
-static int rk30_modem_probe(struct platform_device *pdev);
-
-static struct platform_driver demo_platform_driver = {
-    .probe  = rk30_modem_probe,
-    .driver = {
-        .name   = "rk30_modem",
-    },
-};
-
-static struct rk29_modem_t demo_driver = {
-    .driver         = &demo_platform_driver,
-    .modem_power    = NULL,//&demo_io_power,
-    .ap_ready       = NULL,
-    .bp_wakeup_ap   = NULL,
-    .status         = MODEM_ENABLE,
-    .dev_init       = NULL,
-    .dev_uninit     = NULL,
-    .irq_handler    = NULL,
-    
-    .enable         = NULL,
-    .disable        = NULL,
-    .sleep          = NULL,
-    .wakeup         = NULL,
-};
-
-static int rk30_modem_probe(struct platform_device *pdev)
-{
-    int ret = 0;
-    struct rk29_io_t *rk29_io_info = pdev->dev.platform_data;
-
-    printk("%s\n", __FUNCTION__);
-    demo_driver.modem_power = rk29_io_info;
-    demo_driver.modem_power->io_init();
-
-    return 0;
-}
-
-static int __init demo_init(void)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-    return rk29_modem_init(&demo_driver);
-}
-
-static void __exit demo_exit(void)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    rk29_modem_exit();
-}
-
-module_init(demo_init);
-module_exit(demo_exit);
-
-MODULE_AUTHOR("lintao lintao@rock-chips.com, cmy@rock-chips.com");
-MODULE_DESCRIPTION("ROCKCHIP modem driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/misc/rk29_modem/modem_thinkwill_mw100g.c b/drivers/misc/rk29_modem/modem_thinkwill_mw100g.c
deleted file mode 100644
index acef01ff0fd5..000000000000
--- a/drivers/misc/rk29_modem/modem_thinkwill_mw100g.c
+++ /dev/null
@@ -1,131 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/stat.h>	 /* permission constants */
-#include <linux/io.h>
-#include <linux/vmalloc.h>
-#include <asm/io.h>
-#include <asm/sizes.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <linux/delay.h>
-
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/gpio.h>
-#include <mach/board.h>
-
-#include <linux/platform_device.h>
-
-#include "rk29_modem.h"
-
-// 确保不出现重复处理wakeup
-static int do_wakeup_handle = 0;
-static irqreturn_t mw100g_irq_handler(int irq, void *dev_id);
-
-static int __devinit mw100g_suspend(struct platform_device *pdev, pm_message_t state)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    do_wakeup_handle = 0;
-    return rk29_modem_suspend(pdev, state);
-}
-
-static int __devinit mw100g_resume(struct platform_device *pdev)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    return rk29_modem_resume(pdev);
-}
-
-static struct rk29_io_t mw100g_io_power = {
-    .io_addr    = RK29_PIN6_PB1,
-    .enable     = GPIO_HIGH,
-    .disable    = GPIO_LOW,
-};
-
-static struct rk29_irq_t mw100g_irq_bp_wakeup_ap= {
-    .irq_addr   = RK29_PIN3_PC4,
-    .irq_trigger = IRQF_TRIGGER_FALLING, // 下降沿触发
-};
-
-static struct platform_driver mw100g_platform_driver = {
-	.driver		= {
-		.name		= "thinkwill_mw100g",
-	},
-	.suspend    = mw100g_suspend,
-	.resume     = mw100g_resume,
-};
-
-static struct rk29_modem_t mw100g_driver = {
-    .driver         = &mw100g_platform_driver,
-    .modem_power    = &mw100g_io_power,
-    .ap_ready       = NULL,
-    .bp_wakeup_ap   = &mw100g_irq_bp_wakeup_ap,
-    .status         = MODEM_ENABLE,
-    .dev_init       = NULL,
-    .dev_uninit     = NULL,
-    .irq_handler    = mw100g_irq_handler,
-    
-    .enable         = NULL,
-    .disable        = NULL,
-    .sleep          = NULL,
-    .wakeup         = NULL,
-};
-
-static void do_wakeup(struct work_struct *work)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-//    rk28_send_wakeup_key();
-}
-
-static DECLARE_DELAYED_WORK(wakeup_work, do_wakeup);
-
-/*
-    mw100g 模组的 IRQ 处理函数，该函数由rk29_modem中的IRQ处理函数调用
- */
-static irqreturn_t mw100g_irq_handler(int irq, void *dev_id)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-    if( irq == gpio_to_irq(mw100g_driver.bp_wakeup_ap->irq_addr) )
-    {
-        if( !do_wakeup_handle )
-        {
-            do_wakeup_handle = 1;
-            // 当接收到 bb wakeup ap 的IRQ后，申请一个8秒的suspend锁，时间到后自动释放
-            // 释放时如果没有其它的锁，就将再次挂起.
-            wake_lock_timeout(&mw100g_driver.wakelock_bbwakeupap, 20 * HZ);
-            schedule_delayed_work(&wakeup_work, HZ / 10);
-        } else
-            printk("%s: already wakeup\n", __FUNCTION__);
-        return IRQ_HANDLED;
-    }
-    
-    return IRQ_NONE;
-}
-
-static int __init mw100g_init(void)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-    return rk29_modem_init(&mw100g_driver);
-}
-
-static void __exit mw100g_exit(void)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    rk29_modem_exit();
-}
-
-module_init(mw100g_init);
-module_exit(mw100g_exit);
-
-MODULE_AUTHOR("lintao lintao@rock-chips.com");
-MODULE_DESCRIPTION("ROCKCHIP modem driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/misc/rk29_modem/rk29_modem.c b/drivers/misc/rk29_modem/rk29_modem.c
deleted file mode 100644
index 7f99917eaa18..000000000000
--- a/drivers/misc/rk29_modem/rk29_modem.c
+++ /dev/null
@@ -1,340 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/vmalloc.h>
-#include <asm/io.h>
-#include <asm/sizes.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <linux/delay.h>
-
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/gpio.h>
-#include <mach/board.h>
-
-#include "rk29_modem.h"
-
-struct rk29_modem_t *g_rk29_modem;
-//static struct wake_lock wakelock_bbwakeupap;
-static struct class *rk29_modem_class = NULL;
-static void rk29_modem_turnon(struct rk29_io_t *modem_power, int onoff);
-
-int rk29_modem_change_status(struct rk29_modem_t *rk29_modem, int status)
-{
-    int ret = 0;
-    switch(status)
-    {
-    case MODEM_DISABLE:
-        rk29_modem_turnon(rk29_modem->modem_power, 0);
-        break;
-    case MODEM_ENABLE :
-        rk29_modem_turnon(rk29_modem->modem_power, 1);
-        break;
-    case MODEM_SLEEP:
-        ret = -1;
-    case MODEM_WAKEUP:
-        ret = -1;
-        break;
-    }
-    
-    return ret;
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-static ssize_t modem_status_write(struct class *cls, struct class_attribute *attr, const char *_buf, size_t _count)
-#else
-static ssize_t modem_status_write(struct class *cls, const char *_buf, size_t _count)
-#endif
-{
-    struct rk29_modem_t *rk29_modem = g_rk29_modem;
-    int ret = 0;
-    int new_state = simple_strtoul(_buf, NULL, 16);
-
-    if(rk29_modem == NULL){
-        printk("!!!! g_rk29_modem is NULL !!!!\n");
-        return _count;
-    }
-    
-    printk("[%s] statue change: %d -> %d\n", __func__, rk29_modem->status, new_state);
-
-    if(new_state == rk29_modem->status) return _count;
-
-
-    switch(new_state)
-    {
-    case MODEM_DISABLE:
-        if(rk29_modem->disable)
-            ret = rk29_modem->disable(rk29_modem);
-        else
-            ret = rk29_modem_change_status(rk29_modem, new_state);
-        break;
-    case MODEM_ENABLE :
-        if(rk29_modem->enable)
-            ret = rk29_modem->enable(rk29_modem);
-        else
-            ret = rk29_modem_change_status(rk29_modem, new_state);
-        break;
-    case MODEM_SLEEP:
-        if(rk29_modem->sleep)
-            ret = rk29_modem->sleep(rk29_modem);
-        else
-            ret = rk29_modem_change_status(rk29_modem, new_state);
-        break;
-    case MODEM_WAKEUP:
-        if(rk29_modem->wakeup)
-            ret = rk29_modem->wakeup(rk29_modem);
-        else
-            ret = rk29_modem_change_status(rk29_modem, new_state);
-        break;
-    default:
-        ret = -1;
-        printk("[%s] Invalid new status: %d\n", __func__, new_state);
-        break;
-    }
-
-    if( !ret ) rk29_modem->status = new_state;
-    
-    return _count;
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-static ssize_t modem_status_read(struct class *cls, struct class_attribute *attr, char *_buf)
-#else
-static ssize_t modem_status_read(struct class *cls, char *_buf)
-#endif
-{
-    struct rk29_modem_t *rk29_modem = g_rk29_modem;
-
-    return sprintf(_buf, "%d\n", rk29_modem->status);
-}
-static CLASS_ATTR(modem_status, 0666, modem_status_read, modem_status_write);
-
-int __devinit rk29_modem_suspend(struct platform_device *pdev, pm_message_t state)
-{
-#ifdef CONFIG_PM
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-    if( g_rk29_modem->suspend )
-        g_rk29_modem->suspend(pdev, state);
-    else
-    {
-        if(g_rk29_modem->ap_ready) // 标志AP已挂起
-            gpio_direction_output(g_rk29_modem->ap_ready->io_addr, g_rk29_modem->ap_ready->disable);
-    }
-#endif
-	return 0;
-}
-
-int __devinit rk29_modem_resume(struct platform_device *pdev)
-{
-#ifdef CONFIG_PM
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    if( g_rk29_modem->resume )
-        g_rk29_modem->resume(pdev);
-    else
-    {
-        if(g_rk29_modem->ap_ready) // 标志AP已恢复
-            gpio_direction_output(g_rk29_modem->ap_ready->io_addr, g_rk29_modem->ap_ready->enable);
-    }
-#endif
-	return 0;
-}
-
-static irqreturn_t irq_bbwakeupap_handler(int irq, void *dev_id)
-{
-    irqreturn_t irqret = IRQ_NONE;
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-    if( g_rk29_modem->irq_handler )
-    {
-        irqret = g_rk29_modem->irq_handler(irq, dev_id);
-        if( irqret != IRQ_NONE ) return irqret;
-    }
-
-    // 具体设备没有 irq_handler 函数，或者它的irq_handler函数没有处理该 irq，则使用
-    // 以下的公共irq处理.
-
-    return IRQ_HANDLED;
-}
-
-static void uninstall_irq(struct rk29_irq_t *irq)
-{
-    gpio_free(irq->irq_addr);
-}
-
-static int install_irq(struct rk29_irq_t *rk29_irq, const char* label)
-{
-	int ret;
-    int irq;
-    
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-	irq = gpio_to_irq(rk29_irq->irq_addr);
-    printk("%s: %ld ==> %d\n", __func__, rk29_irq->irq_addr, irq);
-
-	ret = gpio_request(rk29_irq->irq_addr, label);
-	if (ret < 0) {
-		pr_err("%s: gpio_request(%ld) failed\n", __func__, rk29_irq->irq_addr);
-		return ret;
-	}
-
-	gpio_direction_input(rk29_irq->irq_addr);
-    gpio_pull_updown(rk29_irq->irq_addr, 0);
-	ret = request_irq(irq, irq_bbwakeupap_handler, rk29_irq->irq_trigger, label, NULL);
-	if (ret < 0) {
-		pr_err("%s: request_irq(%d) failed\n", __func__, irq);
-		gpio_free(rk29_irq->irq_addr);
-		return ret;
-	}
-
-	enable_irq_wake(irq);
-	return 0;
-}
-
-// 给modem上电
-static void rk29_modem_turnon(struct rk29_io_t *modem_power, int onoff)
-{
-    if( modem_power )
-        gpio_direction_output(modem_power->io_addr, onoff?modem_power->enable:modem_power->disable);
-}
-
-/*
-    RK29 modem 通用的设备初始化函数
-    主要设置各个GPIO以及IRQ的申请等
- */
-static int rk29_modem_dev_init(struct rk29_modem_t *rk29_modem)
-{
-    int ret=0;
-    
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-// 申请控制modem电源的GPIO
-    if( rk29_modem->modem_power )
-    {
-        ret = gpio_request(rk29_modem->modem_power->io_addr, "modem_power");
-        if(ret != 0)
-        {
-            gpio_free(rk29_modem->modem_power->io_addr);
-            printk(">>>>>> Modem power io request failed!\n");
-            return ret;
-        }
-        
-        // 设置初始的modem状态
-        rk29_modem_change_status(rk29_modem, rk29_modem->status);
-    }
-
-// 申请控制AP就绪状态的GPIO
-    if( rk29_modem->ap_ready )
-    {
-        ret = gpio_request(rk29_modem->ap_ready->io_addr, "ap_ready");
-        if(ret != 0)
-        {
-            gpio_free(rk29_modem->ap_ready->io_addr);
-            printk(">>>>>> AP ready io request failed!\n");
-            return ret;
-        }
-
-        // 默认 AP is ready
-        gpio_direction_output(rk29_modem->ap_ready->io_addr, rk29_modem->ap_ready->enable);
-    }
-
-// 设置 bb_wakeup_ap 的irq，用于ap挂起之后，由bb来唤醒ap
-    if( rk29_modem->bp_wakeup_ap )
-    {
-        ret = install_irq(rk29_modem->bp_wakeup_ap, "bb_wakeup_ap");
-    }
-    
-    wake_lock_init(&rk29_modem->wakelock_bbwakeupap, WAKE_LOCK_SUSPEND, "bb_wakeup_ap");
-
-    return ret;
-}
-
-/*
-    modem下电、释放gpio wait_lock 等
- */
-static void rk29_modem_dev_uninit(struct rk29_modem_t *rk29_modem)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    
-// 给modem下电
-    if( rk29_modem->modem_power )
-        rk29_modem_turnon(rk29_modem->modem_power, 0);
-
-// 释放GPIO
-    if( rk29_modem->modem_power )
-        gpio_free(rk29_modem->modem_power->io_addr);
-
-    if(rk29_modem->ap_ready)
-        gpio_free(rk29_modem->ap_ready->io_addr);
-
-    if(rk29_modem->bp_wakeup_ap)
-        uninstall_irq(rk29_modem->bp_wakeup_ap);
-
-// 释放 wake lock
-    wake_lock_destroy(&rk29_modem->wakelock_bbwakeupap);
-}
-
-/*
-    驱动加载
- */
-int rk29_modem_init(struct rk29_modem_t *rk29_modem)
-{
-    int retval = 0;
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-
-    retval = platform_driver_register(rk29_modem->driver);
-    if( retval )
-    {
-        printk("could not register rk29_modem!\n");
-        return retval;
-    }
-
-	rk29_modem_class = class_create(THIS_MODULE, "rk291x_modem");
-    if(rk29_modem_class == NULL){
-        printk("create class rk291x_modem failed!\n");
-        return -1;
-    }
-    retval = class_create_file(rk29_modem_class, &class_attr_modem_status);
-    if(retval != 0){
-        printk("create rk291x_modem class file failed!\n");
-        goto failed_create_class;
-    }
-    
-// 对modem初始化
-    if( rk29_modem->dev_init )
-        retval = rk29_modem->dev_init(rk29_modem);
-    else
-        retval = rk29_modem_dev_init(rk29_modem);
-        
-    if( retval )
-        goto failed_device_init;
-
-    g_rk29_modem = rk29_modem;
-
-    return 0;
-
-failed_device_init:
-    platform_driver_unregister(rk29_modem->driver);
-
-failed_create_class:
-    class_destroy(rk29_modem_class);
-    
-    return retval;
-}
-
-/*
-    退出驱动时调用
-    目前driver是build-in，不存在退出的情况，不会调用到这边
- */
-void rk29_modem_exit(void)
-{
-    printk("%s[%d]: %s\n", __FILE__, __LINE__, __FUNCTION__);
-    platform_driver_unregister(g_rk29_modem->driver);
-
-// 对modem反初始化
-    if( g_rk29_modem->dev_uninit )
-        g_rk29_modem->dev_uninit(g_rk29_modem);
-    else
-        rk29_modem_dev_uninit(g_rk29_modem);
-}
-
diff --git a/drivers/misc/rk29_modem/rk29_modem.h b/drivers/misc/rk29_modem/rk29_modem.h
deleted file mode 100644
index 95814bfa646f..000000000000
--- a/drivers/misc/rk29_modem/rk29_modem.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/platform_device.h>
-#include <mach/board.h>
-
-/* Modem states */
-#define MODEM_DISABLE       0
-#define MODEM_ENABLE        1
-#define MODEM_SLEEP         2
-#define MODEM_WAKEUP        3
-#define MODEM_MAX_STATUS    4
-
-struct rk29_irq_t {
-    unsigned long irq_addr;
-    unsigned long irq_trigger;
-};
-
-struct rk29_modem_t {
-    struct platform_driver *driver;
-    // 控制modem电源的IO
-    struct rk29_io_t *modem_power;
-    // 当AP就绪或者未就绪时，通过 ap_ready 这个IO来通知BP。
-    struct rk29_io_t *ap_ready;
-    // 当BP接收到短信或者来电时，通过 bp_wakeup_ap 这个IRQ来唤醒AP
-    struct rk29_irq_t *bp_wakeup_ap;
-    // 当前modem状态，目前只用到MODEM_ENABLE(上电)、MODEM_DISABLE(下电)
-    // 同时，status的初始值也决定开机时的modem是否上电
-    int status;
-    struct wake_lock wakelock_bbwakeupap;
-
-    // 设备初始化函数, 主要设置各个GPIO以及IRQ的申请等
-    int (*dev_init)(struct rk29_modem_t *driver);
-    int (*dev_uninit)(struct rk29_modem_t *driver);
-    irqreturn_t (*irq_handler)(int irq, void *dev_id);
-    int (*suspend)(struct platform_device *pdev, pm_message_t state);
-    int (*resume)(struct platform_device *pdev);
-
-    int (*enable)(struct rk29_modem_t *driver);
-    int (*disable)(struct rk29_modem_t *driver);
-    int (*sleep)(struct rk29_modem_t *driver);
-    int (*wakeup)(struct rk29_modem_t *driver);
-};
-
-void rk29_modem_exit(void);
-int rk29_modem_init(struct rk29_modem_t *rk29_modem);
-int rk29_modem_suspend(struct platform_device *pdev, pm_message_t state);
-int rk29_modem_resume(struct platform_device *pdev);
-
-- 
2.35.3

