From e5235d6a08e70caf86151718f5a27211bb710f91 Mon Sep 17 00:00:00 2001
From: Yao Xiao <xiaoyao@rock-chips.com>
Date: Fri, 4 Dec 2020 15:24:13 +0800
Subject: [PATCH] net: rockchip_wlan: update cywdhd to "1.363.125.19 (r)"

Signed-off-by: Yao Xiao <xiaoyao@rock-chips.com>
Change-Id: I4be636719d780978486d8ad204472cfb1023ca99
---
 .../net/wireless/rockchip_wlan/cywdhd/Kconfig |    9 +-
 .../rockchip_wlan/cywdhd/bcmdhd/Kconfig       |    1 +
 .../rockchip_wlan/cywdhd/bcmdhd/Makefile      |  263 +-
 .../rockchip_wlan/cywdhd/bcmdhd/aiutils.c     |   47 +-
 .../cywdhd/bcmdhd/bcm_app_utils.c             |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/bcmevent.c    |  142 +-
 .../rockchip_wlan/cywdhd/bcmdhd/bcmsdh.c      |    3 +-
 .../cywdhd/bcmdhd/bcmsdh_linux.c              |    7 +-
 .../cywdhd/bcmdhd/bcmsdh_sdmmc.c              |   20 +-
 .../cywdhd/bcmdhd/bcmsdh_sdmmc_linux.c        |   28 +-
 .../cywdhd/bcmdhd/bcmsdspi_linux.c            |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/bcmspibrcm.c  |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/bcmutils.c    |   70 +-
 .../cywdhd/bcmdhd/bcmwifi_channels.c          |   41 +-
 .../cywdhd/bcmdhd/bcmwifi_channels.h          |   35 +-
 .../cywdhd/bcmdhd/bcmwifi_rates.h             |  140 +-
 .../rockchip_wlan/cywdhd/bcmdhd/bcmxtlv.c     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dbus.c        | 2501 +++++++++
 .../rockchip_wlan/cywdhd/bcmdhd/dbus_usb.c    | 1228 +++++
 .../cywdhd/bcmdhd/dbus_usb_linux.c            | 4601 +++++++++++++++++
 .../rockchip_wlan/cywdhd/bcmdhd/dhd.h         |   43 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_bta.c     |   17 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_bta.h     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_bus.h     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_buzzz.h   |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_cdc.c     |  149 +-
 .../cywdhd/bcmdhd/dhd_cfg80211.c              |    6 +-
 .../cywdhd/bcmdhd/dhd_cfg80211.h              |    3 +-
 .../cywdhd/bcmdhd/dhd_cfg_vendor.c            |    3 +-
 .../cywdhd/bcmdhd/dhd_chip_info.c             |   63 +
 .../cywdhd/bcmdhd/dhd_chip_info.h             |   56 +
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_common.c  |  151 +-
 .../cywdhd/bcmdhd/dhd_custom_gpio.c           |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_dbg.h     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_debug.c   |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_debug.h   |    3 +-
 .../cywdhd/bcmdhd/dhd_debug_linux.c           |    3 +-
 .../cywdhd/bcmdhd/dhd_flowring.c              |    3 +-
 .../cywdhd/bcmdhd/dhd_flowring.h              |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_gpio.c    |    1 +
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_ip.c      |   24 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_ip.h      |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_linux.c   | 1449 +++++-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_linux.h   |    3 +-
 .../cywdhd/bcmdhd/dhd_linux_platdev.c         |   78 +-
 .../cywdhd/bcmdhd/dhd_linux_sched.c           |    3 +-
 .../cywdhd/bcmdhd/dhd_linux_wq.c              |    3 +-
 .../cywdhd/bcmdhd/dhd_linux_wq.h              |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_msgbuf.c  |   11 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.c    |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.h    |    3 +-
 .../cywdhd/bcmdhd/dhd_pcie_linux.c            |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_pno.c     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_pno.h     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_proto.h   |    6 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.c     |   11 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.h     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_sdio.c    |  181 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.c    |   41 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.h    |    8 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dngl_stats.h  |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/dngl_wlhdr.h  |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/hnd_pktpool.c |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/hnd_pktq.c    |    7 +-
 .../rockchip_wlan/cywdhd/bcmdhd/hndpmu.c      |    3 +-
 .../cywdhd/bcmdhd/include/aidmp.h             |    3 +-
 .../cywdhd/bcmdhd/include/bcm_cfg.h           |    3 +-
 .../cywdhd/bcmdhd/include/bcm_mpool_pub.h     |    3 +-
 .../cywdhd/bcmdhd/include/bcm_ring.h          |    3 +-
 .../cywdhd/bcmdhd/include/bcmcdc.h            |    3 +-
 .../cywdhd/bcmdhd/include/bcmdefs.h           |    7 +-
 .../cywdhd/bcmdhd/include/bcmdevs.h           |   13 +-
 .../cywdhd/bcmdhd/include/bcmendian.h         |    3 +-
 .../cywdhd/bcmdhd/include/bcmmsgbuf.h         |    3 +-
 .../cywdhd/bcmdhd/include/bcmnvram.h          |    3 +-
 .../cywdhd/bcmdhd/include/bcmpcie.h           |    3 +-
 .../cywdhd/bcmdhd/include/bcmpcispi.h         |    3 +-
 .../cywdhd/bcmdhd/include/bcmperf.h           |    3 +-
 .../cywdhd/bcmdhd/include/bcmsdbus.h          |    3 +-
 .../cywdhd/bcmdhd/include/bcmsdh.h            |    3 +-
 .../cywdhd/bcmdhd/include/bcmsdh_sdmmc.h      |   15 +-
 .../cywdhd/bcmdhd/include/bcmsdpcm.h          |    3 +-
 .../cywdhd/bcmdhd/include/bcmsdspi.h          |    3 +-
 .../cywdhd/bcmdhd/include/bcmsdstd.h          |    3 +-
 .../cywdhd/bcmdhd/include/bcmspi.h            |    3 +-
 .../cywdhd/bcmdhd/include/bcmspibrcm.h        |    3 +-
 .../cywdhd/bcmdhd/include/bcmsrom_fmt.h       |    3 +-
 .../cywdhd/bcmdhd/include/bcmsrom_tbl.h       |    3 +-
 .../cywdhd/bcmdhd/include/bcmutils.h          |    6 +-
 .../cywdhd/bcmdhd/include/brcm_nl80211.h      |    3 +-
 .../cywdhd/bcmdhd/include/dbus.h              |    3 +-
 .../bcmdhd/include/devctrl_if/wlioctl_defs.h  |   72 +-
 .../cywdhd/bcmdhd/include/dhdioctl.h          |    3 +-
 .../cywdhd/bcmdhd/include/epivers.h           |   11 +-
 .../cywdhd/bcmdhd/include/event_log.h         |    3 +-
 .../cywdhd/bcmdhd/include/event_trace.h       |    3 +-
 .../cywdhd/bcmdhd/include/hnd_armtrap.h       |    3 +-
 .../cywdhd/bcmdhd/include/hnd_cons.h          |    3 +-
 .../cywdhd/bcmdhd/include/hnd_debug.h         |    3 +-
 .../cywdhd/bcmdhd/include/hnd_pktpool.h       |    3 +-
 .../cywdhd/bcmdhd/include/hnd_pktq.h          |    3 +-
 .../cywdhd/bcmdhd/include/hndpmu.h            |    3 +-
 .../cywdhd/bcmdhd/include/hndsoc.h            |    3 +-
 .../cywdhd/bcmdhd/include/linux_osl.h         |    3 +-
 .../cywdhd/bcmdhd/include/linuxver.h          |    3 +-
 .../cywdhd/bcmdhd/include/miniopt.h           |    3 +-
 .../cywdhd/bcmdhd/include/msgtrace.h          |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/include/osl.h |    3 +-
 .../cywdhd/bcmdhd/include/osl_decl.h          |    3 +-
 .../cywdhd/bcmdhd/include/osl_ext.h           |    3 +-
 .../bcmdhd/include/packed_section_end.h       |    3 +-
 .../bcmdhd/include/packed_section_start.h     |    3 +-
 .../cywdhd/bcmdhd/include/pcicfg.h            |    3 +-
 .../cywdhd/bcmdhd/include/pcie_core.h         |    3 +-
 .../cywdhd/bcmdhd/include/proto/802.11.h      |  220 +-
 .../cywdhd/bcmdhd/include/proto/802.11_bta.h  |    3 +-
 .../cywdhd/bcmdhd/include/proto/802.11e.h     |    3 +-
 .../cywdhd/bcmdhd/include/proto/802.1d.h      |    3 +-
 .../cywdhd/bcmdhd/include/proto/802.3.h       |    3 +-
 .../cywdhd/bcmdhd/include/proto/bcmdhcp.h     |    3 +-
 .../cywdhd/bcmdhd/include/proto/bcmeth.h      |    3 +-
 .../cywdhd/bcmdhd/include/proto/bcmevent.h    |  133 +-
 .../cywdhd/bcmdhd/include/proto/bcmip.h       |    3 +-
 .../cywdhd/bcmdhd/include/proto/bcmipv6.h     |    3 +-
 .../cywdhd/bcmdhd/include/proto/bcmtcp.h      |    3 +-
 .../cywdhd/bcmdhd/include/proto/bcmudp.h      |    3 +-
 .../cywdhd/bcmdhd/include/proto/bt_amp_hci.h  |    3 +-
 .../cywdhd/bcmdhd/include/proto/eapol.h       |    3 +-
 .../cywdhd/bcmdhd/include/proto/ethernet.h    |    3 +-
 .../bcmdhd/include/proto/event_log_set.h      |    3 +-
 .../bcmdhd/include/proto/event_log_tag.h      |   32 +-
 .../cywdhd/bcmdhd/include/proto/nan.h         |  680 +++
 .../cywdhd/bcmdhd/include/proto/p2p.h         |    3 +-
 .../cywdhd/bcmdhd/include/proto/sdspi.h       |    3 +-
 .../cywdhd/bcmdhd/include/proto/vlan.h        |    3 +-
 .../cywdhd/bcmdhd/include/proto/wpa.h         |    3 +-
 .../cywdhd/bcmdhd/include/proto/wps.h         |    3 +-
 .../cywdhd/bcmdhd/include/rte_ioctl.h         |    3 +-
 .../cywdhd/bcmdhd/include/sbchipc.h           |   30 +-
 .../cywdhd/bcmdhd/include/sbconfig.h          |    3 +-
 .../cywdhd/bcmdhd/include/sbhnddma.h          |    3 +-
 .../cywdhd/bcmdhd/include/sbpcmcia.h          |    3 +-
 .../cywdhd/bcmdhd/include/sbsdio.h            |    3 +-
 .../cywdhd/bcmdhd/include/sbsdpcmdev.h        |    3 +-
 .../cywdhd/bcmdhd/include/sbsocram.h          |    3 +-
 .../cywdhd/bcmdhd/include/sbsysmem.h          |    3 +-
 .../cywdhd/bcmdhd/include/sdio.h              |    3 +-
 .../cywdhd/bcmdhd/include/sdioh.h             |    3 +-
 .../cywdhd/bcmdhd/include/sdiovar.h           |    3 +-
 .../cywdhd/bcmdhd/include/siutils.h           |    3 +-
 .../cywdhd/bcmdhd/include/spid.h              |    3 +-
 .../cywdhd/bcmdhd/include/trxhdr.h            |    3 +-
 .../cywdhd/bcmdhd/include/typedefs.h          |    3 +-
 .../cywdhd/bcmdhd/include/usbrdl.h            |  135 +
 .../cywdhd/bcmdhd/include/wlfc_proto.h        |    3 +-
 .../cywdhd/bcmdhd/include/wlioctl.h           |  241 +-
 .../cywdhd/bcmdhd/include/wlioctl_utils.h     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/linux_osl.c   |   19 +-
 .../rockchip_wlan/cywdhd/bcmdhd/pcie_core.c   |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/rkversion.c   |   18 -
 .../rockchip_wlan/cywdhd/bcmdhd/sbutils.c     |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/siutils.c     |   36 +-
 .../cywdhd/bcmdhd/siutils_priv.h              |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/uamp_api.h    |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_android.c  |   12 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_android.h  |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.c |  468 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.h |   29 +-
 .../cywdhd/bcmdhd/wl_cfg_btcoex.c             |   17 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.c   | 2127 ++++++++
 .../rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.h   |  227 +
 .../rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.c   |   19 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.h   |   21 +-
 .../cywdhd/bcmdhd/wl_cfgvendor.c              |  148 +-
 .../cywdhd/bcmdhd/wl_cfgvendor.h              |    6 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_dbg.h      |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_iw.c       |   19 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_iw.h       |    3 +-
 .../cywdhd/bcmdhd/wl_linux_mon.c              |    3 +-
 .../rockchip_wlan/cywdhd/bcmdhd/wl_roam.c     |    3 +-
 .../cywdhd/bcmdhd/wldev_common.c              |    3 +-
 .../cywdhd/bcmdhd/wldev_common.h              |    3 +-
 .../rkwifi/bcmdhd_indep_power/wl_cfg80211.c   |    3 +-
 183 files changed, 15918 insertions(+), 647 deletions(-)
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus_usb.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus_usb_linux.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_chip_info.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_chip_info.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/nan.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/usbrdl.h
 delete mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/rkversion.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.h

diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/Kconfig b/drivers/net/wireless/rockchip_wlan/cywdhd/Kconfig
index 33228f73210d..e0fa55bf91de 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/Kconfig
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/Kconfig
@@ -1,9 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0
 config CYW_BCMDHD
 	tristate "Cypress wireless sdio cards support"
+	depends on (!AP6XXX)
 	select WIRELESS_EXT
 	select WEXT_PRIV
-	depends on (!BCMDHD)
 	#select CFG80211
 	#select MAC80211
 	select CFG80211_WEXT
@@ -16,3 +16,10 @@ config CYW_BCMDHD
 	  If you choose to build a module, it'll be called dhd. Say M if
 	  unsure.
 
+if CYW_BCMDHD
+config SDIO_CIS_CYW43438
+	bool "Cypress 43438 for keepalive"
+config SDIO_CIS_CYW43012
+	bool "Cypress 43012 for keepalive"
+endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/Kconfig b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/Kconfig
index da2a8120a234..c99cda4cc7a8 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/Kconfig
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/Kconfig
@@ -1,3 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
 config BCMDHD
 	tristate "Broadcom FullMAC wireless cards support"
 	---help---
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/Makefile b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/Makefile
index a8f4207ec32d..b1026e1782e9 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/Makefile
@@ -1,41 +1,36 @@
 # SPDX-License-Identifier: GPL-2.0
 # cywdhd
+#################
+# Usage and porting guide for this Makefile
+#################
+# 1 Default to the module external build, that is, no need to copy the driver into the kernel source tree
+#  Build with:
+#       make KDIR=/path/to/your/kernel
+# 2 Default to x86 build: Build the x86 driver without any modification outside of kernel
+# 3 Just change the 'DHD_PLATFORM=imx' and the IMx OOB version can work!
+# 4 Copy DHD_PLATFORM=imx as the start point and create your own name
+
 #####################
 # SDIO Basic feature
 #####################
-CONFIG_BCMDHD := y
-CONFIG_CFG80211 := y
-CONFIG_BCMDHD_SDIO := y
-CONFIG_BCMDHD_OOB := y
-CONFIG_BCM43455 := y
-CONFIG_PLAT_ROCKCHIP := y
 
 DHDCFLAGS += -Wall -Wstrict-prototypes -Dlinux -DLINUX -DBCMDRIVER            \
 	-DBCMDONGLEHOST -DUNRELEASEDCHIP -DBCMDMA32 -DBCMFILEIMAGE            \
-	-DDHDTHREAD -DSHOW_EVENTS -DBCMDBG -DWLP2P                            \
+	-DSHOW_EVENTS -DBCMDBG -DWLP2P                                        \
 	-DWIFI_ACT_FRAME -DARP_OFFLOAD_SUPPORT                                \
 	-DKEEP_ALIVE -DCSCAN -DPKT_FILTER_SUPPORT                             \
 	-DEMBEDDED_PLATFORM -DPNO_SUPPORT                                     \
-	-DDHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT                           \
-	-DCUSTOMER_HW2 -DGET_CUSTOM_MAC_ENABLE
+	-DCUSTOMER_HW2
+#	-DCUSTOMER_HW2 -DENABLE_INSMOD_NO_FW_LOAD -DGET_OTP_MAC_ENABLE
+
+#ifeq ($(CONFIG_SDIO_CIS_CYW43438)$(CONFIG_SDIO_CIS_CYW43012),)
+#DHDCFLAGS += -DDHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT
+#endif
 
 #################
 # Common feature
 #################
-ifneq ($(CONFIG_BCMDHD_SDIO),)
-  DHDCFLAGS += -DBDC -DDHD_BCMEVENTS -DMMC_SDIO_ABORT
-  DHDCFLAGS += -DBCMSDIO -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR
-  DHDCFLAGS += -DPROP_TXSTATUS
-endif
-
-ifneq ($(CONFIG_BCMDHD_OOB),)
-  DHDCFLAGS += -DOOB_INTR_ONLY -DCUSTOMER_OOB -DHW_OOB
-else
-  DHDCFLAGS += -DSDIO_ISR_THREAD
-endif
-
 DHDCFLAGS += -DWL_CFG80211
-DHDCFLAGS += -DWL_VIRTUAL_APSTA #-DWL_WIRELESS_EXT
 # Print out kernel panic point of file and line info when assertion happened
 DHDCFLAGS += -DBCMASSERT_LOG
 
@@ -44,11 +39,17 @@ DHDCFLAGS += -DCUSTOM_KEEP_ALIVE_SETTING=28000
 
 DHDCFLAGS += -DVSDB
 
+# Fix __DATE__ & __TIME__ error on gcc version 4.9 or later
+GCCVERSION = $(shell $(CC) -dumpversion | cut -f1-2 -d.)
+ifeq ($(shell expr $(GCCVERSION) \>= 4.9),1)
+  DHDCFLAGS += -Wno-error=date-time
+endif
+
 # For p2p connection issue
 DHDCFLAGS += -DWL_SCB_TIMEOUT=10
 
 # TDLS enable
-DHDCFLAGS += -DWLTDLS -DWLTDLS_AUTO_ENABLE
+DHDCFLAGS += -DWLTDLS
 # For TDLS tear down inactive time 40 sec
 DHDCFLAGS += -DCUSTOM_TDLS_IDLE_MODE_SETTING=40000
 # for TDLS RSSI HIGH for establishing TDLS link
@@ -63,14 +64,15 @@ DHDCFLAGS += -DENABLE_FW_ROAM_SUSPEND
 # Roaming trigger
 DHDCFLAGS += -DCUSTOM_ROAM_TRIGGER_SETTING=-75
 DHDCFLAGS += -DCUSTOM_ROAM_DELTA_SETTING=10
+# Voice Enterprise
+DHDCFLAGS += -DWLFBT
 # Set PM 2 always regardless suspend/resume
 DHDCFLAGS += -DSUPPORT_PM2_ONLY
 
 # For special PNO Event keep wake lock for 10sec
 DHDCFLAGS += -DCUSTOM_PNO_EVENT_LOCK_xTIME=10
 DHDCFLAGS += -DMIRACAST_AMPDU_SIZE=8
-#Vendor Extension
-DHDCFLAGS += -DWL_VENDOR_EXT_SUPPORT
+
 #Gscan
 DHDCFLAGS += -DGSCAN_SUPPORT
 #RTT
@@ -101,14 +103,11 @@ DHDCFLAGS += -DIOCTL_RESP_TIMEOUT=5000
 # Prevent rx thread monopolize
 DHDCFLAGS += -DWAIT_DEQUEUE
 
-# Config PM Control
-DHDCFLAGS += -DCONFIG_CONTROL_PM
-
 # idle count
 DHDCFLAGS += -DDHD_USE_IDLECOUNT
 
 # SKB TAILPAD to avoid out of boundary memory access
-#DHDCFLAGS += -DDHDENABLE_TAILPAD
+DHDCFLAGS += -DDHDENABLE_TAILPAD
 
 # Wi-Fi Direct
 DHDCFLAGS += -DWL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
@@ -121,63 +120,123 @@ DHDCFLAGS += -DCUSTOM_FORCE_NODFS_FLAG
 
 
 # SoftAP
-DHDCFLAGS += -DDISABLE_11H_SOFTAP
 DHDCFLAGS += -DSET_RANDOM_MAC_SOFTAP
 DHDCFLAGS += -DWL_CFG80211_ACL
 
-#Disable FRAMEBURST on VSDB
-DHDCFLAGS += -DDISABLE_FRAMEBURST_VSDB
-
-
-#Rochip Platform
-ifneq ($(CONFIG_PLAT_ROCKCHIP),)
-DHDCFLAGS += -DCONFIG_PLAT_ROCKCHIP
-DHDCFLAGS += -DDHD_OF_SUPPORT
-endif
-
 ##########################
 # driver type
 # m: module type driver
 # y: built-in type driver
 ##########################
-DRIVER_TYPE ?= $(CONFIG_BCMDHD)
+DRIVER_TYPE ?= $(CONFIG_CYW_BCMDHD)
 
 #########################
 # Chip dependent feature
 #########################
 
-ifneq ($(filter y, $(CONFIG_BCM4354) $(CONFIG_BCM4356) $(CONFIG_BCM43455)),)
-  DHDCFLAGS += -DUSE_WL_TXBF
-  DHDCFLAGS += -DUSE_WL_FRAMEBURST
-  DHDCFLAGS += -DCUSTOM_DPC_CPUCORE=0
-  DHDCFLAGS += -DPROP_TXSTATUS_VSDB
-  DHDCFLAGS += -DCUSTOM_PSPRETEND_THR=30
-  DHDCFLAGS += -DMAX_AP_CLIENT_CNT=10
-  DHDCFLAGS += -DMAX_GO_CLIENT_CNT=5
+DHDCFLAGS += -DUSE_WL_TXBF
+# DHDCFLAGS += -DUSE_WL_FRAMEBURST
+DHDCFLAGS += -DCUSTOM_DPC_CPUCORE=0
+DHDCFLAGS += -DPROP_TXSTATUS_VSDB
+DHDCFLAGS += -DCUSTOM_PSPRETEND_THR=30
 # New Features
-  DHDCFLAGS += -DWL11U
-  DHDCFLAGS += -DMFP
-  DHDCFLAGS += -DDHD_ENABLE_LPC
-  DHDCFLAGS += -DCUSTOM_COUNTRY_CODE
-  DHDCFLAGS += -DSAR_SUPPORT
-# debug info
-  DHDCFLAGS += -DDHD_WAKE_STATUS
+DHDCFLAGS += -DWL11U
+DHDCFLAGS += -DMFP
+# The LPC would have the Tx 5G tput drop around 10Mbps but saving powers
+# DHDCFLAGS += -DDHD_ENABLE_LPC
+DHDCFLAGS += -DCUSTOM_COUNTRY_CODE
+
+### Platform dependent START
+DHD_PLATFORM ?= rockchip
+
+#Rochip Platform
+ifeq ($(DHD_PLATFORM), rockchip)
+  CONFIG_BCMDHD_SDIO = y
+  CONFIG_BCMDHD_OOB = y
+  CONFIG_PLAT_ROCKCHIP = y
+
+  ## We only add here for the flags in our rockchip code
+  DHDCFLAGS += -DANDROID_SDIO_RESET
+  DHDCFLAGS += -DCUSTOM_SDIO_F2_BLKSIZE=256
+  DHDCFLAGS += -DDHD_OF_SUPPORT 
+  DHDCFLAGS += -DCONFIG_PLAT_ROCKCHIP
+ifeq ($(CONFIG_BCMDHD_OOB),y)
+DHDCFLAGS += -DOOB_INTR_ONLY -DCUSTOMER_OOB -DHW_OOB
+ifeq ($(CONFIG_BCMDHD_DISABLE_WOWLAN),y)
+DHDCFLAGS += -DDISABLE_WOWLAN
+endif
+else
+DHDCFLAGS += -DSDIO_ISR_THREAD
+endif
+  DHDCFLAGS += -DHOST_FLAG
+  DHDCFLAGS += -DLOAD_DHD_WITH_FW_ALIVE
+  FW_ALIVE = 1
+endif
+
+ifeq ($(DHD_PLATFORM), ingenic)
+  CONFIG_BCMDHD_SDIO = y
+  ## We only add here for the flags in our generic code
+  DHDCFLAGS += -DOOB_INTR_ONLY -DHW_OOB
+  DHDCFLAGS += -DCUSTOM_SDIO_F2_BLKSIZE=128
+  DHDCFLAGS += -DDHD_OF_SUPPORT -DCUSTOMER_OOB
+  DHDCFLAGS += -DLOAD_DHD_WITH_FW_ALIVE
+  FW_ALIVE = 1
+endif
+
+
+ifeq ($(DHD_PLATFORM), imx_android)
+  CONFIG_BCMDHD_SDIO = y
+# Config DTS support
+  DHDCFLAGS += -DCONFIG_DTS
+# for iMX platform
+  DHDCFLAGS += -DCUSTOMER_IMX
+  DHDCFLAGS += -DOOB_INTR_ONLY -DHW_OOB
+  DHDCFLAGS += -DANDROID_SDIO_RESET
+# The flags only worked for supported host
+# Remove it if you found the dhdsdio_rxglom erros
+  DHDCFLAGS += -DCUSTOM_RXCHAIN=1
+endif
+
+ifeq ($(DHD_PLATFORM), imx)
+  CONFIG_BCMDHD_SDIO = y
+# Config DTS support
+  DHDCFLAGS += -DCONFIG_DTS
+# for iMX platform
+  DHDCFLAGS += -DCUSTOMER_IMX
+  DHDCFLAGS += -DOOB_INTR_ONLY -DHW_OOB
+# The flags only worked for supported host
+# Remove it if you found the dhdsdio_rxglom erros
+  DHDCFLAGS += -DCUSTOM_RXCHAIN=1
+endif
+
+ifeq ($(CONFIG_BCMDHD_PCIE), y)
+  CONFIG_BCMDHD_PCIE = y
+else
+ifeq ($(CONFIG_BCMDHD_USB), y)
+  CONFIG_BCMDHD_USB = y
+else
+  CONFIG_BCMDHD_SDIO = y
+endif
+endif
+
+### Platform dependent END
+
 ifneq ($(CONFIG_BCMDHD_SDIO),)
+  DHDCFLAGS += -DBDC -DTOE -DDHD_BCMEVENTS -DMMC_SDIO_ABORT
+  DHDCFLAGS += -DBCMSDIO -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR
+  DHDCFLAGS += -DPROP_TXSTATUS
   DHDCFLAGS += -DCUSTOM_AMPDU_MPDU=16
   DHDCFLAGS += -DCUSTOM_AMPDU_BA_WSIZE=64
 # tput enhancement
-  DHDCFLAGS += -DCUSTOM_GLOM_SETTING=8 -DCUSTOM_RXCHAIN=1
-  DHDCFLAGS += -DUSE_DYNAMIC_F2_BLKSIZE -DDYNAMIC_F2_BLKSIZE_FOR_NONLEGACY=128
-  DHDCFLAGS += -DBCMSDIOH_TXGLOM -DCUSTOM_TXGLOM=1 -DBCMSDIOH_TXGLOM_HIGHSPEED
+  DHDCFLAGS += -DCUSTOM_GLOM_SETTING=8
+  DHDCFLAGS += -DBCMSDIOH_TXGLOM -DCUSTOM_TXGLOM=1
   DHDCFLAGS += -DDHDTCPACK_SUPPRESS
   DHDCFLAGS += -DRXFRAME_THREAD
-  DHDCFLAGS += -DREPEAT_READFRAME
   DHDCFLAGS += -DCUSTOM_MAX_TXGLOM_SIZE=31
   DHDCFLAGS += -DMAX_HDR_READ=128
   DHDCFLAGS += -DDHD_FIRSTREAD=128
   # bcn_timeout
   DHDCFLAGS += -DCUSTOM_BCN_TIMEOUT=5
-  DHDCFLAGS += -DWLFC_STATE_PREALLOC
  endif
 
 ifneq ($(CONFIG_BCMDHD_PCIE),)
@@ -191,51 +250,52 @@ ifneq ($(CONFIG_BCMDHD_PCIE),)
   DHDCFLAGS += -DCUSTOM_DHD_WATCHDOG_MS=0
   DHDCFLAGS += -DMAX_CNTL_TX_TIMEOUT=1
   DHDCFLAGS += -DSUPPORT_LINKDOWN_RECOVERY
-  endif
+endif
+
+ifneq ($(CONFIG_BCMDHD_USB),)
+  DHDCFLAGS += -DBDC -DTOE
+  DHDCFLAGS += -DDHD_BCMEVENTS -DSHOW_EVENTS -DSHOW_LOGTRACE
+  DHDCFLAGS += -DBCMDHDUSB -DBCMDBUS -DBCMTRXV2 -DDBUS_USB_LOOPBACK
+  DHDCFLAGS += -DPROP_TXSTATUS
+  DHDCFLAGS += -DLIMIT_BORROW
+endif
+
 ifeq ($(CONFIG_DHD_USE_STATIC_BUF),y)
   DHDCFLAGS += -DDHD_USE_STATIC_IOCTLBUF
 endif
-  DHDCFLAGS += -DDONGLE_ENABLE_ISOLATION
 # Print 802.1X packets
-  DHDCFLAGS += -DDHD_8021X_DUMP
+DHDCFLAGS += -DDHD_8021X_DUMP
 # Print DHCP packets
-  DHDCFLAGS += -DDHD_DHCP_DUMP
-endif
-
-
-ifneq ($(CONFIG_BCM4339),)
-  DHDCFLAGS += -DBCM4339_CHIP -DHW_OOB
-
-  # tput enhancement
-  DHDCFLAGS += -DCUSTOM_GLOM_SETTING=8 -DCUSTOM_RXCHAIN=1
-  DHDCFLAGS += -DUSE_DYNAMIC_F2_BLKSIZE -DDYNAMIC_F2_BLKSIZE_FOR_NONLEGACY=128
-  DHDCFLAGS += -DBCMSDIOH_TXGLOM -DCUSTOM_TXGLOM=1 -DBCMSDIOH_TXGLOM_HIGHSPEED
-  DHDCFLAGS += -DDHDTCPACK_SUPPRESS
-  DHDCFLAGS += -DUSE_WL_TXBF
-  DHDCFLAGS += -DUSE_WL_FRAMEBURST
-  DHDCFLAGS += -DRXFRAME_THREAD
-  DHDCFLAGS += -DCUSTOM_AMPDU_BA_WSIZE=64
-  DHDCFLAGS += -DCUSTOM_DPC_CPUCORE=0
-  DHDCFLAGS += -DPROP_TXSTATUS_VSDB
-  DHDCFLAGS += -DCUSTOM_MAX_TXGLOM_SIZE=40
+DHDCFLAGS += -DDHD_DHCP_DUMP
 
-  # New Features
-  DHDCFLAGS += -DWL11U
-  DHDCFLAGS += -DDHD_ENABLE_LPC
-  DHDCFLAGS += -DCUSTOM_PSPRETEND_THR=30
-endif
 
-
-#EXTRA_LDFLAGS += --strip-debug
+EXTRA_LDFLAGS += --strip-debug
 
 ifeq ($(DRIVER_TYPE),y)
-  DHDCFLAGS += -DENABLE_INSMOD_NO_FW_LOAD
   DHDCFLAGS += -DUSE_LATE_INITCALL_SYNC
 endif
 
 ## Attend to fix the suspend/resume -16 error issue, refer to SWDHD-409
 DHDCFLAGS += -DSUSPEND16
 
+
+## Flags merged from Linux build
+DHDCFLAGS += -DCUSTOMER_IPCAM -DWL11ULB -DWL_NAN -DWL_SUPPORT_AUTO_CHANNEL -DWL_VIRTUAL_APSTA
+
+## Flags that may depends on Linux kernel versions
+DHDCFLAGS += -DTSQ_MULTIPLIER=10
+
+## Flags maybe useful but disable it
+
+# The WLFC AC queue credit borrow
+# DHDCFLAGS += -DLIMIT_BORROW
+
+# Advanced IBSS features
+# DHDCFLAGS += -DWLAIBSS -DWLAIBSS_PS
+
+# p2P service discovery offload
+# DHDCFLAGS += -DWL_SDO
+
 EXTRA_CFLAGS += $(DHDCFLAGS) -DDHD_DEBUG
 EXTRA_CFLAGS += -DSRCBASE=\"$(src)\"
 EXTRA_CFLAGS += -I$(src)/include/ -I$(src)/
@@ -246,7 +306,14 @@ DHDOFILES := dhd_pno.o dhd_common.o dhd_ip.o dhd_custom_gpio.o \
 	bcmutils.o bcmwifi_channels.o hndpmu.o linux_osl.o sbutils.o siutils.o \
 	wl_android.o wl_cfg80211.o wl_cfgp2p.o wl_cfg_btcoex.o wldev_common.o wl_linux_mon.o  \
 	dhd_linux_platdev.o dhd_pno.o dhd_rtt.o dhd_linux_wq.o wl_cfg_btcoex.o \
-        hnd_pktq.o hnd_pktpool.o wl_cfgvendor.o dhd_debug_linux.o bcmxtlv.o dhd_debug.o bcm_app_utils.o
+        hnd_pktq.o hnd_pktpool.o wl_cfgvendor.o dhd_debug_linux.o bcmxtlv.o dhd_debug.o bcm_app_utils.o \
+	wl_cfgnan.o
+
+ifeq ($(FW_ALIVE), 1)
+  DHDCFLAGS += -DLOAD_DHD_WITH_FW_ALIVE
+  DHDOFILES += dhd_chip_info.o
+endif
+
 
 ifneq ($(CONFIG_BCMDHD_SDIO),)
   DHDOFILES += bcmsdh.o bcmsdh_linux.o bcmsdh_sdmmc.o bcmsdh_sdmmc_linux.o
@@ -258,13 +325,17 @@ ifneq ($(CONFIG_BCMDHD_PCIE),)
   DHDOFILES += pcie_core.o
 endif
 
+ifneq ($(CONFIG_BCMDHD_USB),)
+  DHDOFILES += dbus.o dbus_usb.o dbus_usb_linux.o
+  DHDOFILES += dhd_cdc.o dhd_wlfc.o
+endif
+
 ifneq ($(CONFIG_PLAT_ROCKCHIP),)
-DHDOFILES += dhd_gpio.o
-DHDOFILES += rkversion.o
+  DHDOFILES += dhd_gpio.o
 endif
 
-bcmdhd-objs := $(DHDOFILES)
-obj-$(DRIVER_TYPE)   += bcmdhd.o
+cywdhd-objs := $(DHDOFILES)
+obj-$(DRIVER_TYPE)   += cywdhd.o
 
 all:
 	@echo "$(MAKE) --no-print-directory -C $(KDIR) SUBDIRS=$(CURDIR) modules"
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/aiutils.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/aiutils.c
index 2de4a66f3fd5..bcdda3fefc59 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/aiutils.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/aiutils.c
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc utility routines for accessing chip-specific features
  * of the SiliconBackplane-based Broadcom chips.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -25,7 +26,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: aiutils.c 526024 2015-01-13 03:59:33Z $
+ * $Id: aiutils.c 708487 2018-10-31 05:33:14Z $
  */
 #include <bcm_cfg.h>
 #include <typedefs.h>
@@ -39,6 +40,12 @@
 
 #include "siutils_priv.h"
 
+
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+#include <bcmdevs.h>
+#include <dhd_chip_info.h>
+#endif
+
 #define BCM47162_DMP() (0)
 #define BCM5357_DMP() (0)
 #define BCM53573_DMP() (0)
@@ -142,6 +149,42 @@ ai_scan(si_t *sih, void *regs, uint devid)
 	chipcregs_t *cc = (chipcregs_t *)regs;
 	uint32 erombase, *eromptr, *eromlim;
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	if(alive == FW_ALIVE_MAGIC) {
+		switch(card_dev) {
+			case BCM43430_CHIP_ID:
+				sii->numcores = ai_core_43430;
+				sii->oob_router = oob_router_43430;
+				memcpy(&cores_info->coreid, &bcm43430_coreid, sii->numcores * 4);
+				memcpy(&cores_info->coresba, &bcm43430_coresba, sii->numcores * 4);
+				memcpy(&cores_info->coresba_size, &bcm43430_coresba_size, sii->numcores * 4);
+				memcpy(&cores_info->wrapba, &bcm43430_wrapba, sii->numcores * 4);
+				memcpy(&cores_info->cia, &bcm43430_cia, sii->numcores * 4);
+				if(card_rev == 2) {
+					memcpy(&cores_info->cib, &bcm43436_cib, sii->numcores * 4);
+				} else {
+					memcpy(&cores_info->cib, &bcm43430_cib, sii->numcores * 4);
+				}
+				break;
+
+			case BCM43012_CHIP_ID:
+				sii->numcores = ai_core_43012;
+				sii->oob_router = oob_router_43012;
+				memcpy(&cores_info->coreid, &bcm43012_coreid, sii->numcores * 4);
+				memcpy(&cores_info->coresba, &bcm43012_coresba, sii->numcores * 4);
+				memcpy(&cores_info->coresba_size, &bcm43012_coresba_size, sii->numcores * 4);
+				memcpy(&cores_info->wrapba, &bcm43012_wrapba, sii->numcores * 4);
+				memcpy(&cores_info->cia, &bcm43012_cia, sii->numcores * 4);
+				memcpy(&cores_info->cib, &bcm43012_cib, sii->numcores * 4);
+
+			default:
+				break;
+		}
+
+		return;
+	}
+#endif
+
 	erombase = R_REG(sii->osh, &cc->eromptr);
 
 	switch (BUSTYPE(sih->bustype)) {
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcm_app_utils.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcm_app_utils.c
index 907d0411faa2..f5b8819a0bfb 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcm_app_utils.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcm_app_utils.c
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc utility routines used by kernel or app-level.
  * Contents are wifi-specific, used by any kernel or app-level
  * software that might want wifi things as it grows.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmevent.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmevent.c
index 681b4c50e486..23a5560fc43a 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmevent.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmevent.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * bcmevent read-only data shared by kernel or app layers
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: bcmevent.c 606400 2015-12-15 09:59:42Z $
+ * $Id: bcmevent.c 715966 2019-05-30 02:36:59Z $
  */
 
 #include <typedefs.h>
@@ -33,6 +34,7 @@
 #include <proto/ethernet.h>
 #include <proto/bcmeth.h>
 #include <proto/bcmevent.h>
+#include <proto/802.11.h>
 
 
 /* Table of event name strings for UIs and debugging dumps */
@@ -165,6 +167,9 @@ static const bcmevent_name_str_t bcmevent_names[] = {
 #if defined(BT_WIFI_HANDOVER) || defined(WL_TBOW)
 	BCMEVENT_NAME(WLC_E_BT_WIFI_HANDOVER_REQ),
 #endif
+#ifdef WLFBT
+	BCMEVENT_NAME(WLC_E_FBT_AUTH_REQ_IND),
+#endif /* WLFBT */
 	BCMEVENT_NAME(WLC_E_AUTHORIZED),
 	BCMEVENT_NAME(WLC_E_PROBREQ_MSG_RX),
 	BCMEVENT_NAME(WLC_E_CSA_START_IND),
@@ -200,6 +205,139 @@ const char *bcmevent_get_name(uint event_type)
 	return ((event_name) ? event_name : "Unknown Event");
 }
 
+/*
+ * Validate if the event is proper and if valid copy event header to event.
+ * If proper event pointer is passed, to just validate, pass NULL to event.
+ *
+ * Return values are
+ *	BCME_OK - It is a BRCM event or BRCM dongle event
+ *	BCME_NOTFOUND - Not BRCM, not an event, may be okay
+ *	BCME_BADLEN - Bad length, should not process, just drop
+ */
+int
+is_wlc_event_frame(void *pktdata, uint pktlen, uint16 exp_usr_subtype,
+	bcm_event_msg_u_t *out_event)
+{
+	uint16 evlen = 0;	/* length in bcmeth_hdr */
+	uint16 subtype;
+	uint16 usr_subtype;
+	bcm_event_t *bcm_event;
+	uint8 *pktend;
+	uint8 *evend;
+	int err = BCME_OK;
+	uint32 data_len = 0; /* data length in bcm_event */
+
+	pktend = (uint8 *)pktdata + pktlen;
+	bcm_event = (bcm_event_t *)pktdata;
+
+	/* only care about 16-bit subtype / length versions */
+	if ((uint8 *)&bcm_event->bcm_hdr < pktend) {
+		uint8 short_subtype = *(uint8 *)&bcm_event->bcm_hdr;
+		if (!(short_subtype & 0x80)) {
+			err = BCME_NOTFOUND;
+			goto done;
+		}
+	}
+
+	/* must have both ether_header and bcmeth_hdr */
+	if (pktlen < OFFSETOF(bcm_event_t, event)) {
+		err = BCME_BADLEN;
+		goto done;
+	}
+
+	/* check length in bcmeth_hdr */
+	/* temporary - header length not always set properly. When the below
+	 * !BCMDONGLEHOST is in all branches that use trunk DHD, the code
+	 * under BCMDONGLEHOST can be removed.
+	 */
+	evlen = (uint16)(pktend - (uint8 *)&bcm_event->bcm_hdr.version);
+	evend = (uint8 *)&bcm_event->bcm_hdr.version + evlen;
+	if (evend > pktend) {
+		err = BCME_BADLEN;
+		goto done;
+	}
+
+	/* match on subtype, oui and usr subtype for BRCM events */
+	subtype = ntoh16_ua((void *)&bcm_event->bcm_hdr.subtype);
+	if (subtype != BCMILCP_SUBTYPE_VENDOR_LONG) {
+		err = BCME_NOTFOUND;
+		goto done;
+	}
+
+	if (bcmp(BRCM_OUI, &bcm_event->bcm_hdr.oui[0], DOT11_OUI_LEN)) {
+		err = BCME_NOTFOUND;
+		goto done;
+	}
+
+	/* if it is a bcm_event or bcm_dngl_event_t, validate it */
+	usr_subtype = ntoh16_ua((void *)&bcm_event->bcm_hdr.usr_subtype);
+	switch (usr_subtype) {
+	case BCMILCP_BCM_SUBTYPE_EVENT:
+		/* check that header length and pkt length are sufficient */
+		if ((pktlen < sizeof(bcm_event_t)) ||
+			(evend < ((uint8 *)bcm_event + sizeof(bcm_event_t)))) {
+			err = BCME_BADLEN;
+			goto done;
+		}
+
+		/* ensure data length in event is not beyond the packet. */
+		data_len = ntoh32_ua((void *)&bcm_event->event.datalen);
+		if (data_len > (pktlen - sizeof(bcm_event_t))) {
+			err = BCME_BADLEN;
+			goto done;
+		}
+
+		if (exp_usr_subtype && (exp_usr_subtype != usr_subtype)) {
+			err = BCME_NOTFOUND;
+			goto done;
+		}
+
+		if (out_event) {
+			/* ensure BRCM event pkt aligned */
+			memcpy(&out_event->event, &bcm_event->event, sizeof(wl_event_msg_t));
+		}
+
+		break;
+	case BCMILCP_BCM_SUBTYPE_DNGLEVENT:
+#ifdef HEALTH_CHECK
+		if ((pktlen < sizeof(bcm_dngl_event_t)) ||
+			(evend < ((uint8 *)bcm_event + sizeof(bcm_dngl_event_t)))) {
+			err = BCME_BADLEN;
+			goto done;
+		}
+
+		/* ensure data length in event is not beyond the packet. */
+		data_len = ntoh16_ua((void *)&((bcm_dngl_event_t *)pktdata)->dngl_event.datalen);
+		if (data_len > (pktlen - sizeof(bcm_dngl_event_t))) {
+			err = BCME_BADLEN;
+			goto done;
+		}
+
+		if (exp_usr_subtype && (exp_usr_subtype != usr_subtype)) {
+			err = BCME_NOTFOUND;
+			goto done;
+		}
+
+		if (out_event) {
+			/* ensure BRCM dngl event pkt aligned */
+			memcpy(&out_event->dngl_event, &((bcm_dngl_event_t *)pktdata)->dngl_event,
+				sizeof(bcm_dngl_event_msg_t));
+		}
+
+		break;
+#endif /* HEALTH_CHECK */
+		err = BCME_UNSUPPORTED;
+		break;
+	default:
+		err = BCME_NOTFOUND;
+		goto done;
+	}
+
+	BCM_REFERENCE(data_len);
+done:
+	return err;
+}
+
 void
 wl_event_to_host_order(wl_event_msg_t * evt)
 {
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh.c
index 378c4e42e1ed..1ebf5272a878 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh.c
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  *  BCMSDH interface glue
  *  implement bcmsdh API for SDIOH driver
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_linux.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_linux.c
index 7f3f143680b3..77a220693e21 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_linux.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SDIO access interface for drivers - linux specific (pci only)
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -84,7 +85,7 @@ typedef struct bcmsdh_os_info {
 } bcmsdh_os_info_t;
 
 /* debugging macros */
-#define SDLX_MSG(x)		printf x
+#define SDLX_MSG(x)		do { printf x; } while (0)
 
 /**
  * Checks to see if vendor and device IDs match a supported SDIO Host Controller.
@@ -391,7 +392,7 @@ void bcmsdh_oob_intr_unregister(bcmsdh_info_t *bcmsdh)
 /* Module parameters specific to each host-controller driver */
 
 extern uint sd_msglevel;	/* Debug message level */
-module_param(sd_msglevel, uint, 0);
+module_param(sd_msglevel, uint, 0664);
 
 extern uint sd_power;	/* 0 = SD Power OFF, 1 = SD Power ON. */
 module_param(sd_power, uint, 0);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_sdmmc.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_sdmmc.c
index ddb5d117069d..76367e0585f5 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_sdmmc.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_sdmmc.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BCMSDH Function Driver for the native SDIO/MMC driver in the Linux Kernel
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Proprietary,Open:>>
  *
- * $Id: bcmsdh_sdmmc.c 666459 2017-08-22 06:08:52Z $
+ * $Id: bcmsdh_sdmmc.c 712404 2019-03-20 06:20:25Z $
  */
 #include <typedefs.h>
 
@@ -62,7 +63,15 @@ static void IRQHandler(struct sdio_func *func);
 static void IRQHandlerF2(struct sdio_func *func);
 #endif /* !defined(OOB_INTR_ONLY) */
 static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, uint32 regaddr);
+
+#if defined(ANDROID_SDIO_RESET)
 extern int sdio_reset_comm(struct mmc_card *card);
+#else
+static int sdio_reset_comm(struct mmc_card *card)
+{
+	return 0;
+}
+#endif /* ANDROID_SDIO_RESET */
 
 #define DEFAULT_SDIO_F2_BLKSIZE		512
 #ifndef CUSTOM_SDIO_F2_BLKSIZE
@@ -84,7 +93,7 @@ uint sd_divisor = 2;			/* Default 48MHz/2 = 24MHz */
 uint sd_power = 1;		/* Default to SD Slot powered ON */
 uint sd_clock = 1;		/* Default to SD Clock turned ON */
 uint sd_hiok = FALSE;	/* Don't use hi-speed mode by default */
-uint sd_msglevel = SDH_ERROR_VAL;
+uint sd_msglevel = 0x01;
 uint sd_use_dma = TRUE;
 
 #ifndef CUSTOM_RXCHAIN
@@ -97,7 +106,7 @@ uint sd_use_dma = TRUE;
  */
 #ifdef BCMSDIOH_TXGLOM
 uint sd_txglom = 1;
-module_param(sd_txglom, uint, 0);
+module_param(sd_txglom, uint, 0664);
 #endif /* BCMSDIOH_TXGLOM */
 
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_byte_wait);
@@ -1398,7 +1407,8 @@ sdioh_start(sdioh_info_t *sd, int stage)
 			and enable the fucntion 1 for in preparation for
 			downloading the code
 		*/
-		/* sdio_reset_comm() - has been fixed in latest kernel/msm.git for Linux
+		/* sdio_reset_comm() For Android kernel only
+		   has been fixed in latest kernel/msm.git for Linux
 		   2.6.27. The implementation prior to that is buggy, and needs broadcom's
 		   patch for it
 		*/
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_sdmmc_linux.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_sdmmc_linux.c
index a10bf5073057..81ff2795d501 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_sdmmc_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdh_sdmmc_linux.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BCMSDH Function Driver for the native SDIO/MMC driver in the Linux Kernel
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Proprietary,Open:>>
  *
- * $Id: bcmsdh_sdmmc_linux.c 665039 2017-05-12 08:38:09Z $
+ * $Id: bcmsdh_sdmmc_linux.c 708487 2018-10-31 05:33:14Z $
  */
 
 #include <typedefs.h>
@@ -44,6 +45,11 @@
 #include <bcmsdh_sdmmc.h>
 #include <dhd_dbg.h>
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+#include <dhd_chip_info.h>
+#endif
+
+
 #if !defined(SDIO_VENDOR_ID_BROADCOM)
 #define SDIO_VENDOR_ID_BROADCOM		0x02d0
 #endif /* !defined(SDIO_VENDOR_ID_BROADCOM) */
@@ -107,6 +113,10 @@ static int sdioh_probe(struct sdio_func *func)
 	osl_t *osh = NULL;
 	sdioh_info_t *sdioh = NULL;
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	int ready = 0;
+#endif
+
 	sd_err(("bus num (host idx)=%d, slot num (rca)=%d\n", host_idx, rca));
 	adapter = dhd_wifi_platform_get_adapter(SDIO_BUS, host_idx, rca);
 	if (adapter  != NULL)
@@ -130,6 +140,17 @@ static int sdioh_probe(struct sdio_func *func)
 		 sd_err(("%s: sdioh_attach failed\n", __FUNCTION__));
 		 goto fail;
 	 }
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	sdioh_cfg_read(sdioh, SDIO_FUNC_0, SDIOD_CCCR_IORDY, (uint8 *)&ready);
+
+	sd_err(("%s, %d, ready = %08x\n", __func__, __LINE__, ready));
+	if(ready == (SDIO_FUNC_READY_1|SDIO_FUNC_READY_2)) {
+		alive = FW_ALIVE_MAGIC;	//func->card->nr_parts;
+		card_dev = func->card->cis.device;
+	}
+
+	sd_info(("alive  = %08x, card_dev = %08x\n", alive, card_dev));
+#endif /* LOAD_DHD_WITH_FW_ALIVE */
 	 sdioh->bcmsdh = bcmsdh_probe(osh, &func->dev, sdioh, adapter, SDIO_BUS, host_idx, rca);
 	 if (sdioh->bcmsdh == NULL) {
 		 sd_err(("%s: bcmsdh_probe failed\n", __FUNCTION__));
@@ -189,13 +210,14 @@ static int bcmsdh_sdmmc_probe(struct sdio_func *func,
 		while( tuple != NULL) {
 //			printf("Got tuple code=0x%x\n", tuple->code);
 			if(tuple->code == 0x81 && tuple->size == 0x01 && tuple->data[0] == 0x01) {
-				printf("Got the chip vendor, tuple code=0x81\n");
+				printf("Got the chip vendor, tuple code=0x81 , Azurewave Module\n");
 				cis_chipvendor = 0x81;
 				break;
 			}
 			tuple = tuple->next;
 		}
 	}
+
 	/* 4318 doesn't have function 2 */
 	if ((func->num == 2) || (func->num == 1 && func->device == 0x4))
 		ret = sdioh_probe(func);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdspi_linux.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdspi_linux.c
index b7091e5985f9..566a70189d2c 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdspi_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmsdspi_linux.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom SPI Host Controller Driver - Linux Per-port
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmspibrcm.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmspibrcm.c
index d8591b796039..afe6780bcc4f 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmspibrcm.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmspibrcm.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom BCMSDH to gSPI Protocol Conversion Layer
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmutils.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmutils.c
index c001378bea17..2a8aa0a7f5bf 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmutils.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmutils.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Driver O/S-independent utility routines
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: bcmutils.c 674349 2017-10-19 07:59:24Z $
+ * $Id: bcmutils.c 692666 2018-07-30 08:58:07Z $
  */
 
 #include <bcm_cfg.h>
@@ -2361,7 +2362,7 @@ bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...)
 
 	r = vsnprintf(b->buf, b->size, fmt, ap);
 	if (bcm_bprintf_bypass == TRUE) {
-		printf(b->buf);
+		printf("%s\n", b->buf);
 		goto exit;
 	}
 
@@ -3612,3 +3613,66 @@ dll_pool_free_tail(dll_pool_t * dll_pool_p, void * elem_p)
 }
 
 #endif 
+
+/* calculate partial checksum */
+static uint32
+ip_cksum_partial(uint32 sum, uint8 *val8, uint32 count)
+{
+	uint32 i;
+	uint16 *val16 = (uint16 *)val8;
+
+	ASSERT(val8 != NULL);
+	/* partial chksum calculated on 16-bit values */
+	ASSERT((count % 2) == 0);
+
+	count /= 2;
+
+	for (i = 0; i < count; i++) {
+		sum += *val16++;
+	}
+	return sum;
+}
+
+/* calculate IP checksum */
+static uint16
+ip_cksum(uint32 sum, uint8 *val8, uint32 count)
+{
+	uint16 *val16 = (uint16 *)val8;
+
+	ASSERT(val8 != NULL);
+
+	while (count > 1) {
+		sum += *val16++;
+		count -= 2;
+	}
+	/*  add left-over byte, if any */
+	if (count > 0) {
+		sum += (*(uint8 *)val16);
+	}
+
+	/*  fold 32-bit sum to 16 bits */
+	sum = (sum >> 16) + (sum & 0xffff);
+	sum += (sum >> 16);
+	return ((uint16)~sum);
+}
+
+/* calculate IPv4 header checksum
+ * - input ip points to IP header in network order
+ * - output cksum is in network order
+ */
+uint16
+ipv4_hdr_cksum(uint8 *ip, int ip_len)
+{
+	uint32 sum = 0;
+	uint8 *ptr = ip;
+
+	ASSERT(ip != NULL);
+	ASSERT(ip_len >= IPV4_MIN_HEADER_LEN);
+
+	/* partial cksum skipping the hdr_chksum field */
+	sum = ip_cksum_partial(sum, ptr, OFFSETOF(struct ipv4_hdr, hdr_chksum));
+	ptr += OFFSETOF(struct ipv4_hdr, hdr_chksum) + 2;
+
+	/* return calculated chksum */
+	return ip_cksum(sum, ptr, ip_len - OFFSETOF(struct ipv4_hdr, src_ip));
+}
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_channels.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_channels.c
index 83475223f312..3a138ede52c2 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_channels.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_channels.c
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc utility routines used by kernel or app-level.
  * Contents are wifi-specific, used by any kernel or app-level
  * software that might want wifi things as it grows.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -1251,3 +1252,41 @@ wf_chspec_channel(chanspec_t chspec)
 	}
 }
 #endif /* WL11AC_80P80 */
+
+#ifdef WL_OLDPPR
+/* given a chanspec and a string buffer, format the chanspec as a
+ * string, and return the original pointer a.
+ * Min buffer length must be CHANSPEC_STR_LEN.
+ * On error return NULL
+ */
+char *
+wf_chspec_ntoa_old(chanspec_t chspec, char *buf)
+{
+	const char *band, *bw, *sb;
+	uint channel;
+
+	band = "";
+	bw = "";
+	sb = "";
+	channel = CHSPEC_CHANNEL_OLD(chspec);
+	/* check for non-default band spec */
+	if ((CHSPEC_IS2G_OLD(chspec) && channel > CH_MAX_2G_CHANNEL) ||
+	    (CHSPEC_IS5G_OLD(chspec) && channel <= CH_MAX_2G_CHANNEL))
+		band = (CHSPEC_IS2G_OLD(chspec)) ? "b" : "a";
+	if (CHSPEC_IS40_OLD(chspec)) {
+		if (CHSPEC_SB_UPPER_OLD(chspec)) {
+			sb = "u";
+			channel += CH_10MHZ_APART;
+		} else {
+			sb = "l";
+			channel -= CH_10MHZ_APART;
+		}
+	} else if (CHSPEC_IS10_OLD(chspec)) {
+		bw = "n";
+	}
+
+	/* Outputs a max of 6 chars including '\0'  */
+	snprintf(buf, 6, "%d%s%s%s", channel, band, bw, sb);
+	return (buf);
+}
+#endif /* WL_OLDPPR */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_channels.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_channels.h
index 8e78c2c1227b..093adddf7b19 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_channels.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_channels.h
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc utility routines for WL and Apps
  * This header file housing the define and function prototype use by
  * both the wl driver, tools & Apps.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -628,4 +629,36 @@ extern chanspec_t wf_chspec_primary80_chspec(chanspec_t chspec);
  */
 extern uint8 wf_chspec_channel(chanspec_t chspec);
 #endif
+
+#ifdef WL_OLDPPR
+#define WL_CHANSPEC_CTL_SB_MASK_OLD	0x0300
+#define WL_CHANSPEC_CTL_SB_SHIFT_OLD	8
+#define WL_CHANSPEC_CTL_SB_LOWER_OLD	0x0100
+#define WL_CHANSPEC_CTL_SB_UPPER_OLD	0x0200
+#define WL_CHANSPEC_CTL_SB_NONE_OLD	0x0300
+
+#define WL_CHANSPEC_BW_MASK_OLD		0x0C00
+#define WL_CHANSPEC_BW_SHIFT_OLD	10
+#define WL_CHANSPEC_BW_10_OLD		0x0400
+#define WL_CHANSPEC_BW_20_OLD		0x0800
+#define WL_CHANSPEC_BW_40_OLD		0x0C00
+
+#define WL_CHANSPEC_BAND_MASK_OLD	0xf000
+#define WL_CHANSPEC_BAND_SHIFT_OLD	12
+#define WL_CHANSPEC_BAND_5G_OLD		0x1000
+#define WL_CHANSPEC_BAND_2G_OLD		0x2000
+
+#define CHSPEC_CHANNEL_OLD(chspec)  ((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
+#define CHSPEC_BAND_OLD(chspec)     ((chspec) & WL_CHANSPEC_BAND_MASK_OLD)
+
+#define CHSPEC_IS10_OLD(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK_OLD) == WL_CHANSPEC_BW_10_OLD)
+#define CHSPEC_IS20_OLD(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK_OLD) == WL_CHANSPEC_BW_20_OLD)
+#define CHSPEC_IS40_OLD(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK_OLD) == WL_CHANSPEC_BW_40_OLD)
+#define CHSPEC_IS5G_OLD(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK_OLD) == WL_CHANSPEC_BAND_5G_OLD)
+#define CHSPEC_IS2G_OLD(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK_OLD) == WL_CHANSPEC_BAND_2G_OLD)
+#define CHSPEC_SB_NONE_OLD(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK_OLD) == WL_CHANSPEC_CTL_SB_NONE_OLD)
+#define CHSPEC_SB_UPPER_OLD(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK_OLD) == WL_CHANSPEC_CTL_SB_UPPER_OLD)
+#define CHSPEC_SB_LOWER_OLD(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK_OLD) == WL_CHANSPEC_CTL_SB_LOWER_OLD)
+#endif /* WL_OLDPPR */
+
 #endif	/* _bcmwifi_channels_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_rates.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_rates.h
index 412fd8fba1f5..da9297108a42 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_rates.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmwifi_rates.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Indices for 802.11 a/b/g/n/ac 1-3 chain symmetric transmit rates
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -110,6 +111,143 @@ typedef enum wl_tx_nss {
 /* This enum maps each rate to a CLM index */
 
 typedef enum clm_rates {
+#ifdef WL_OLDPPR
+	/************
+	 * 1 chain  *
+	 ************
+	 */
+
+	CLM_RATE_1X1_DSSS_1			= 0,
+	CLM_RATE_1X1_DSSS_2			= 1,
+	CLM_RATE_1X1_DSSS_5_5		= 2,
+	CLM_RATE_1X1_DSSS_11		= 3,
+
+	CLM_RATE_1X1_OFDM_6			= 4,
+	CLM_RATE_1X1_OFDM_9			= 5,
+	CLM_RATE_1X1_OFDM_12		= 6,
+	CLM_RATE_1X1_OFDM_18		= 7,
+	CLM_RATE_1X1_OFDM_24		= 8,
+	CLM_RATE_1X1_OFDM_36		= 9,
+	CLM_RATE_1X1_OFDM_48		= 10,
+	CLM_RATE_1X1_OFDM_54		= 11,
+
+	CLM_RATE_1X1_MCS0			= 12,
+	CLM_RATE_1X1_MCS1			= 13,
+	CLM_RATE_1X1_MCS2			= 14,
+	CLM_RATE_1X1_MCS3			= 15,
+	CLM_RATE_1X1_MCS4			= 16,
+	CLM_RATE_1X1_MCS5			= 17,
+	CLM_RATE_1X1_MCS6			= 18,
+	CLM_RATE_1X1_MCS7			= 19,
+
+	/************
+	 * 2 chains *
+	 ************
+	 */
+
+	/* 1 Stream expanded + 1 */
+	CLM_RATE_1X2_DSSS_1			= 20,
+	CLM_RATE_1X2_DSSS_2			= 21,
+	CLM_RATE_1X2_DSSS_5_5		= 22,
+	CLM_RATE_1X2_DSSS_11		= 23,
+
+	CLM_RATE_1X2_CDD_OFDM_6		= 24,
+	CLM_RATE_1X2_CDD_OFDM_9		= 25,
+	CLM_RATE_1X2_CDD_OFDM_12	= 26,
+	CLM_RATE_1X2_CDD_OFDM_18	= 27,
+	CLM_RATE_1X2_CDD_OFDM_24	= 28,
+	CLM_RATE_1X2_CDD_OFDM_36	= 29,
+	CLM_RATE_1X2_CDD_OFDM_48	= 30,
+	CLM_RATE_1X2_CDD_OFDM_54	= 31,
+
+	CLM_RATE_1X2_CDD_MCS0		= 32,
+	CLM_RATE_1X2_CDD_MCS1		= 33,
+	CLM_RATE_1X2_CDD_MCS2		= 34,
+	CLM_RATE_1X2_CDD_MCS3		= 35,
+	CLM_RATE_1X2_CDD_MCS4		= 36,
+	CLM_RATE_1X2_CDD_MCS5		= 37,
+	CLM_RATE_1X2_CDD_MCS6		= 38,
+	CLM_RATE_1X2_CDD_MCS7		= 39,
+
+	/* 2 Streams */
+	CLM_RATE_2X2_STBC_MCS0		= 40,
+	CLM_RATE_2X2_STBC_MCS1		= 41,
+	CLM_RATE_2X2_STBC_MCS2		= 42,
+	CLM_RATE_2X2_STBC_MCS3		= 43,
+	CLM_RATE_2X2_STBC_MCS4		= 44,
+	CLM_RATE_2X2_STBC_MCS5		= 45,
+	CLM_RATE_2X2_STBC_MCS6		= 46,
+	CLM_RATE_2X2_STBC_MCS7		= 47,
+
+	CLM_RATE_2X2_SDM_MCS8		= 48,
+	CLM_RATE_2X2_SDM_MCS9		= 49,
+	CLM_RATE_2X2_SDM_MCS10		= 50,
+	CLM_RATE_2X2_SDM_MCS11		= 51,
+	CLM_RATE_2X2_SDM_MCS12		= 52,
+	CLM_RATE_2X2_SDM_MCS13		= 53,
+	CLM_RATE_2X2_SDM_MCS14		= 54,
+	CLM_RATE_2X2_SDM_MCS15		= 55,
+
+
+	/************
+	 * 3 chains *
+	 ************
+	 */
+
+	/* 1 Stream expanded + 2 */
+	CLM_RATE_1X3_DSSS_1			= 56,
+	CLM_RATE_1X3_DSSS_2			= 57,
+	CLM_RATE_1X3_DSSS_5_5		= 58,
+	CLM_RATE_1X3_DSSS_11		= 59,
+
+	CLM_RATE_1X3_CDD_OFDM_6		= 60,
+	CLM_RATE_1X3_CDD_OFDM_9		= 61,
+	CLM_RATE_1X3_CDD_OFDM_12	= 62,
+	CLM_RATE_1X3_CDD_OFDM_18	= 63,
+	CLM_RATE_1X3_CDD_OFDM_24	= 64,
+	CLM_RATE_1X3_CDD_OFDM_36	= 65,
+	CLM_RATE_1X3_CDD_OFDM_48	= 66,
+	CLM_RATE_1X3_CDD_OFDM_54	= 67,
+
+	CLM_RATE_1X3_CDD_MCS0		= 68,
+	CLM_RATE_1X3_CDD_MCS1		= 69,
+	CLM_RATE_1X3_CDD_MCS2		= 70,
+	CLM_RATE_1X3_CDD_MCS3		= 71,
+	CLM_RATE_1X3_CDD_MCS4		= 72,
+	CLM_RATE_1X3_CDD_MCS5		= 73,
+	CLM_RATE_1X3_CDD_MCS6		= 74,
+	CLM_RATE_1X3_CDD_MCS7		= 75,
+
+	/* 2 Streams expanded + 1 */
+	CLM_RATE_2X3_STBC_MCS0		= 76,
+	CLM_RATE_2X3_STBC_MCS1		= 77,
+	CLM_RATE_2X3_STBC_MCS2		= 78,
+	CLM_RATE_2X3_STBC_MCS3		= 79,
+	CLM_RATE_2X3_STBC_MCS4		= 80,
+	CLM_RATE_2X3_STBC_MCS5		= 81,
+	CLM_RATE_2X3_STBC_MCS6		= 82,
+	CLM_RATE_2X3_STBC_MCS7		= 83,
+
+	CLM_RATE_2X3_SDM_MCS8		= 84,
+	CLM_RATE_2X3_SDM_MCS9		= 85,
+	CLM_RATE_2X3_SDM_MCS10		= 86,
+	CLM_RATE_2X3_SDM_MCS11		= 87,
+	CLM_RATE_2X3_SDM_MCS12		= 88,
+	CLM_RATE_2X3_SDM_MCS13		= 89,
+	CLM_RATE_2X3_SDM_MCS14		= 90,
+	CLM_RATE_2X3_SDM_MCS15		= 91,
+
+	/* 3 Streams */
+	CLM_RATE_3X3_SDM_MCS16		= 92,
+	CLM_RATE_3X3_SDM_MCS17		= 93,
+	CLM_RATE_3X3_SDM_MCS18		= 94,
+	CLM_RATE_3X3_SDM_MCS19		= 95,
+	CLM_RATE_3X3_SDM_MCS20		= 96,
+	CLM_RATE_3X3_SDM_MCS21		= 97,
+	CLM_RATE_3X3_SDM_MCS22		= 98,
+	CLM_RATE_3X3_SDM_MCS23		= 99,
+#endif /* WL_OLDPPR */
+
 	/************
 	* 1 chain  *
 	************
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmxtlv.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmxtlv.c
index 90023b2f2977..f300cb1250a7 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmxtlv.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/bcmxtlv.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Driver O/S-independent utility routines
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus.c
new file mode 100644
index 000000000000..3647557ef5ad
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus.c
@@ -0,0 +1,2501 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/** @file dbus.c
+ *
+ * Hides details of USB / SDIO / SPI interfaces and OS details. It is intended to shield details and
+ * provide the caller with one common bus interface for all dongle devices. In practice, it is only
+ * used for USB interfaces. DBUS is not a protocol, but an abstraction layer.
+ *
+ * Copyright (C) 1999-2019, Broadcom Corporation
+ * 
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ * 
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ * 
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * $Id: dbus.c 553311 2015-04-29 10:23:08Z $
+ */
+
+
+#include "osl.h"
+#include "dbus.h"
+#include <bcmutils.h>
+
+#if defined(BCM_DNGL_EMBEDIMAGE)
+#include <bcmsrom_fmt.h>
+#include <trxhdr.h>
+#include <usbrdl.h>
+#include <bcmendian.h>
+#include <zutil.h>
+#include <sbpcmcia.h>
+#include <bcmnvram.h>
+#include <bcmdevs.h>
+#elif defined(BCM_REQUEST_FW)
+#include <bcmsrom_fmt.h>
+#include <trxhdr.h>
+#include <usbrdl.h>
+#include <bcmendian.h>
+#include <sbpcmcia.h>
+#include <bcmnvram.h>
+#include <bcmdevs.h>
+#endif /* #if defined(BCM_DNGL_EMBEDIMAGE) */
+#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
+#include <linux/usb.h>
+#endif /* EHCI_FASTPATH_TX || EHCI_FASTPATH_RX */
+
+
+#if defined(BCM_DNGL_EMBEDIMAGE)
+/* zlib file format field ids etc from gzio.c */
+#define Z_DEFLATED     8
+#define ASCII_FLAG     0x01 /* bit 0 set: file probably ascii text */
+#define HEAD_CRC       0x02 /* bit 1 set: header CRC present */
+#define EXTRA_FIELD    0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME      0x08 /* bit 3 set: original file name present */
+#define COMMENT        0x10 /* bit 4 set: file comment present */
+#define RESERVED       0xE0 /* bits 5..7: reserved */
+
+#ifdef WL_FW_DECOMP
+#define UNZIP_ENAB(info)  1
+#else
+#define UNZIP_ENAB(info)  0
+
+#ifdef inflateInit2
+#undef inflateInit2
+#define inflateInit2(a, b)  Z_ERRNO
+#endif
+#define inflate(a, b)       Z_STREAM_ERROR
+#define inflateEnd(a)       do {} while (0)
+#define crc32(a, b, c)      -1
+#define free(a)             do {} while (0)
+#endif /* WL_FW_DECOMP */
+
+#elif defined(BCM_REQUEST_FW)
+#ifndef VARS_MAX
+#define VARS_MAX            8192
+#endif
+#endif /* #if defined(BCM_DNGL_EMBEDIMAGE) */
+
+#ifdef DBUS_USB_LOOPBACK
+extern bool is_loopback_pkt(void *buf);
+extern int matches_loopback_pkt(void *buf);
+#endif
+
+/** General info for all BUS types */
+typedef struct dbus_irbq {
+	dbus_irb_t *head;
+	dbus_irb_t *tail;
+	int cnt;
+} dbus_irbq_t;
+
+/**
+ * This private structure dbus_info_t is also declared in dbus_usb_linux.c.
+ * All the fields must be consistent in both declarations.
+ */
+typedef struct dbus_info {
+	dbus_pub_t   pub; /* MUST BE FIRST */
+
+	void        *cbarg;
+	dbus_callbacks_t *cbs; /* callbacks to higher level, e.g. dhd_linux.c */
+	void        *bus_info;
+	dbus_intf_t *drvintf;  /* callbacks to lower level, e.g. dbus_usb.c or dbus_usb_linux.c */
+	uint8       *fw;
+	int         fwlen;
+	uint32      errmask;
+	int         rx_low_watermark;  /* avoid rx overflow by filling rx with free IRBs */
+	int         tx_low_watermark;
+	bool        txoff;
+	bool        txoverride;   /* flow control related */
+	bool        rxoff;
+	bool        tx_timer_ticking;
+
+
+	dbus_irbq_t *rx_q;
+	dbus_irbq_t *tx_q;
+
+#ifdef EHCI_FASTPATH_RX
+	atomic_t    rx_outstanding;
+#endif
+	uint8        *nvram;
+	int          nvram_len;
+	uint8        *image;  /* buffer for combine fw and nvram */
+	int          image_len;
+	uint8        *orig_fw;
+	int          origfw_len;
+	int          decomp_memsize;
+	dbus_extdl_t extdl;
+	int          nvram_nontxt;
+#if defined(BCM_REQUEST_FW)
+	void         *firmware;
+	void         *nvfile;
+#endif
+} dbus_info_t;
+
+struct exec_parms {
+	union {
+		/* Can consolidate same params, if need be, but this shows
+		 * group of parameters per function
+		 */
+		struct {
+			dbus_irbq_t  *q;
+			dbus_irb_t   *b;
+		} qenq;
+
+		struct {
+			dbus_irbq_t  *q;
+		} qdeq;
+	};
+};
+
+#define EXEC_RXLOCK(info, fn, a) \
+	info->drvintf->exec_rxlock(dbus_info->bus_info, ((exec_cb_t)fn), ((struct exec_parms *) a))
+
+#define EXEC_TXLOCK(info, fn, a) \
+	info->drvintf->exec_txlock(dbus_info->bus_info, ((exec_cb_t)fn), ((struct exec_parms *) a))
+
+/*
+ * Callbacks common for all BUS
+ */
+static void dbus_if_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb);
+static void dbus_if_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status);
+static void dbus_if_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status);
+static void dbus_if_errhandler(void *handle, int err);
+static void dbus_if_ctl_complete(void *handle, int type, int status);
+static void dbus_if_state_change(void *handle, int state);
+static void *dbus_if_pktget(void *handle, uint len, bool send);
+static void dbus_if_pktfree(void *handle, void *p, bool send);
+static struct dbus_irb *dbus_if_getirb(void *cbarg, bool send);
+static void dbus_if_rxerr_indicate(void *handle, bool on);
+
+/** functions in this file that are called by lower DBUS levels, e.g. dbus_usb.c */
+static dbus_intf_callbacks_t dbus_intf_cbs = {
+	dbus_if_send_irb_timeout,
+	dbus_if_send_irb_complete,
+	dbus_if_recv_irb_complete,
+	dbus_if_errhandler,
+	dbus_if_ctl_complete,
+	dbus_if_state_change,
+	NULL,			/* isr */
+	NULL,			/* dpc */
+	NULL,			/* watchdog */
+	dbus_if_pktget,
+	dbus_if_pktfree,
+	dbus_if_getirb,
+	dbus_if_rxerr_indicate
+};
+
+/*
+ * Need global for probe() and disconnect() since
+ * attach() is not called at probe and detach()
+ * can be called inside disconnect()
+ */
+static dbus_intf_t     *g_busintf = NULL;
+static probe_cb_t      probe_cb = NULL;
+static disconnect_cb_t disconnect_cb = NULL;
+static void            *probe_arg = NULL;
+static void            *disc_arg = NULL;
+
+#if defined(BCM_REQUEST_FW)
+int8 *nonfwnvram = NULL; /* stand-alone multi-nvram given with driver load */
+int nonfwnvramlen = 0;
+#endif /* #if defined(BCM_REQUEST_FW) */
+
+static void* q_enq(dbus_irbq_t *q, dbus_irb_t *b);
+static void* q_enq_exec(struct exec_parms *args);
+static dbus_irb_t*q_deq(dbus_irbq_t *q);
+static void* q_deq_exec(struct exec_parms *args);
+static int   dbus_tx_timer_init(dbus_info_t *dbus_info);
+static int   dbus_tx_timer_start(dbus_info_t *dbus_info, uint timeout);
+static int   dbus_tx_timer_stop(dbus_info_t *dbus_info);
+static int   dbus_irbq_init(dbus_info_t *dbus_info, dbus_irbq_t *q, int nq, int size_irb);
+static int   dbus_irbq_deinit(dbus_info_t *dbus_info, dbus_irbq_t *q, int size_irb);
+static int   dbus_rxirbs_fill(dbus_info_t *dbus_info);
+static int   dbus_send_irb(dbus_pub_t *pub, uint8 *buf, int len, void *pkt, void *info);
+static void  dbus_disconnect(void *handle);
+static void *dbus_probe(void *arg, const char *desc, uint32 bustype, uint32 hdrlen);
+
+#if (defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW))
+#if defined(BCM_REQUEST_FW)
+extern char * dngl_firmware;
+extern unsigned int dngl_fwlen;
+#endif  /* #if defined(BCM_REQUEST_FW) */
+static int dbus_get_nvram(dbus_info_t *dbus_info);
+static int dbus_jumbo_nvram(dbus_info_t *dbus_info);
+static int dbus_otp(dbus_info_t *dbus_info, uint16 *boardtype, uint16 *boardrev);
+static int dbus_select_nvram(dbus_info_t *dbus_info, int8 *jumbonvram, int jumbolen,
+uint16 boardtype, uint16 boardrev, int8 **nvram, int *nvram_len);
+#ifndef BCM_REQUEST_FW
+static int dbus_zlib_decomp(dbus_info_t *dbus_info);
+extern void *dbus_zlib_calloc(int num, int size);
+extern void dbus_zlib_free(void *ptr);
+#endif
+#endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
+
+/* function */
+void
+dbus_flowctrl_tx(void *dbi, bool on)
+{
+	dbus_info_t *dbus_info = dbi;
+
+	if (dbus_info == NULL)
+		return;
+
+	DBUSTRACE(("%s on %d\n", __FUNCTION__, on));
+
+	if (dbus_info->txoff == on)
+		return;
+
+	dbus_info->txoff = on;
+
+	if (dbus_info->cbs && dbus_info->cbs->txflowcontrol)
+		dbus_info->cbs->txflowcontrol(dbus_info->cbarg, on);
+}
+
+/**
+ * if lower level DBUS signaled a rx error, more free rx IRBs should be allocated or flow control
+ * should kick in to make more free rx IRBs available.
+ */
+static void
+dbus_if_rxerr_indicate(void *handle, bool on)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) handle;
+
+	DBUSTRACE(("%s, on %d\n", __FUNCTION__, on));
+
+	if (dbus_info == NULL)
+		return;
+
+	if (dbus_info->txoverride == on)
+		return;
+
+	dbus_info->txoverride = on;	/* flow control */
+
+	if (!on)
+		dbus_rxirbs_fill(dbus_info);
+
+}
+
+/** q_enq()/q_deq() are executed with protection via exec_rxlock()/exec_txlock() */
+static void*
+q_enq(dbus_irbq_t *q, dbus_irb_t *b)
+{
+	ASSERT(q->tail != b);
+	ASSERT(b->next == NULL);
+	b->next = NULL;
+	if (q->tail) {
+		q->tail->next = b;
+		q->tail = b;
+	} else
+		q->head = q->tail = b;
+
+	q->cnt++;
+
+	return b;
+}
+
+static void*
+q_enq_exec(struct exec_parms *args)
+{
+	return q_enq(args->qenq.q, args->qenq.b);
+}
+
+static dbus_irb_t*
+q_deq(dbus_irbq_t *q)
+{
+	dbus_irb_t *b;
+
+	b = q->head;
+	if (b) {
+		q->head = q->head->next;
+		b->next = NULL;
+
+		if (q->head == NULL)
+			q->tail = q->head;
+
+		q->cnt--;
+	}
+	return b;
+}
+
+static void*
+q_deq_exec(struct exec_parms *args)
+{
+	return q_deq(args->qdeq.q);
+}
+
+/**
+ * called during attach phase. Status @ Dec 2012: this function does nothing since for all of the
+ * lower DBUS levels dbus_info->drvintf->tx_timer_init is NULL.
+ */
+static int
+dbus_tx_timer_init(dbus_info_t *dbus_info)
+{
+	if (dbus_info && dbus_info->drvintf && dbus_info->drvintf->tx_timer_init)
+		return dbus_info->drvintf->tx_timer_init(dbus_info->bus_info);
+	else
+		return DBUS_ERR;
+}
+
+static int
+dbus_tx_timer_start(dbus_info_t *dbus_info, uint timeout)
+{
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if (dbus_info->tx_timer_ticking)
+		return DBUS_OK;
+
+	if (dbus_info->drvintf && dbus_info->drvintf->tx_timer_start) {
+		if (dbus_info->drvintf->tx_timer_start(dbus_info->bus_info, timeout) == DBUS_OK) {
+			dbus_info->tx_timer_ticking = TRUE;
+			return DBUS_OK;
+		}
+	}
+
+	return DBUS_ERR;
+}
+
+static int
+dbus_tx_timer_stop(dbus_info_t *dbus_info)
+{
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if (!dbus_info->tx_timer_ticking)
+		return DBUS_OK;
+
+	if (dbus_info->drvintf && dbus_info->drvintf->tx_timer_stop) {
+		if (dbus_info->drvintf->tx_timer_stop(dbus_info->bus_info) == DBUS_OK) {
+			dbus_info->tx_timer_ticking = FALSE;
+			return DBUS_OK;
+		}
+	}
+
+	return DBUS_ERR;
+}
+
+/** called during attach phase. */
+static int
+dbus_irbq_init(dbus_info_t *dbus_info, dbus_irbq_t *q, int nq, int size_irb)
+{
+	int i;
+	dbus_irb_t *irb;
+
+	ASSERT(q);
+	ASSERT(dbus_info);
+
+	for (i = 0; i < nq; i++) {
+		/* MALLOC dbus_irb_tx or dbus_irb_rx, but cast to simple dbus_irb_t linkedlist */
+		irb = (dbus_irb_t *) MALLOC(dbus_info->pub.osh, size_irb);
+		if (irb == NULL) {
+			ASSERT(irb);
+			return DBUS_ERR;
+		}
+		bzero(irb, size_irb);
+
+		/* q_enq() does not need to go through EXEC_xxLOCK() during init() */
+		q_enq(q, irb);
+	}
+
+	return DBUS_OK;
+}
+
+/** called during detach phase or when attach failed */
+static int
+dbus_irbq_deinit(dbus_info_t *dbus_info, dbus_irbq_t *q, int size_irb)
+{
+	dbus_irb_t *irb;
+
+	ASSERT(q);
+	ASSERT(dbus_info);
+
+	/* q_deq() does not need to go through EXEC_xxLOCK()
+	 * during deinit(); all callbacks are stopped by this time
+	 */
+	while ((irb = q_deq(q)) != NULL) {
+		MFREE(dbus_info->pub.osh, irb, size_irb);
+	}
+
+	if (q->cnt)
+		DBUSERR(("deinit: q->cnt=%d > 0\n", q->cnt));
+	return DBUS_OK;
+}
+
+/** multiple code paths require the rx queue to be filled with more free IRBs */
+static int
+dbus_rxirbs_fill(dbus_info_t *dbus_info)
+{
+	int err = DBUS_OK;
+
+#ifdef EHCI_FASTPATH_RX
+	while (atomic_read(&dbus_info->rx_outstanding) < 100)
+	{
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+		/* NOCOPY force new packet allocation */
+		optimize_submit_rx_request(&dbus_info->pub, 1, NULL, NULL);
+#else
+		/* Copy mode - allocate own buffer to be reused */
+		void *buf = MALLOC(dbus_info->pub.osh, 4000); /* usbos_info->rxbuf_len */
+		optimize_submit_rx_request(&dbus_info->pub, 1, NULL, buf);
+#endif /* BCM_RPC_NOCOPY || BCM_RPC_RXNOCOPY */
+		atomic_inc(&dbus_info->rx_outstanding);
+	}
+#else /* EHCI_FASTPATH_RX */
+
+	dbus_irb_rx_t *rxirb;
+	struct exec_parms args;
+
+	ASSERT(dbus_info);
+	if (dbus_info->pub.busstate != DBUS_STATE_UP) {
+		DBUSERR(("dbus_rxirbs_fill: DBUS not up \n"));
+		return DBUS_ERR;
+	} else if (!dbus_info->drvintf || (dbus_info->drvintf->recv_irb == NULL)) {
+		/* Lower edge bus interface does not support recv_irb().
+		 * No need to pre-submit IRBs in this case.
+		 */
+		return DBUS_ERR;
+	}
+
+	/* The dongle recv callback is freerunning without lock. So multiple callbacks(and this
+	 *  refill) can run in parallel. While the rxoff condition is triggered outside,
+	 *  below while loop has to check and abort posting more to avoid RPC rxq overflow.
+	 */
+	args.qdeq.q = dbus_info->rx_q;
+	while ((!dbus_info->rxoff) &&
+	       (rxirb = (EXEC_RXLOCK(dbus_info, q_deq_exec, &args))) != NULL) {
+		err = dbus_info->drvintf->recv_irb(dbus_info->bus_info, rxirb);
+		if (err == DBUS_ERR_RXDROP || err == DBUS_ERR_RXFAIL) {
+			/* Add the the free rxirb back to the queue
+			 * and wait till later
+			 */
+			bzero(rxirb, sizeof(dbus_irb_rx_t));
+			args.qenq.q = dbus_info->rx_q;
+			args.qenq.b = (dbus_irb_t *) rxirb;
+			EXEC_RXLOCK(dbus_info, q_enq_exec, &args);
+			break;
+		} else if (err != DBUS_OK) {
+			int i = 0;
+			while (i++ < 100) {
+				DBUSERR(("%s :: memory leak for rxirb note?\n", __FUNCTION__));
+			}
+		}
+	}
+#endif /* EHCI_FASTPATH_RX */
+	return err;
+} /* dbus_rxirbs_fill */
+
+/** called when the DBUS interface state changed. */
+void
+dbus_flowctrl_rx(dbus_pub_t *pub, bool on)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	if (dbus_info == NULL)
+		return;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info->rxoff == on)
+		return;
+
+	dbus_info->rxoff = on;
+
+	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
+		if (!on) {
+			/* post more irbs, resume rx if necessary */
+			dbus_rxirbs_fill(dbus_info);
+			if (dbus_info && dbus_info->drvintf->recv_resume) {
+				dbus_info->drvintf->recv_resume(dbus_info->bus_info);
+			}
+		} else {
+			/* ??? cancell posted irbs first */
+
+			if (dbus_info && dbus_info->drvintf->recv_stop) {
+				dbus_info->drvintf->recv_stop(dbus_info->bus_info);
+			}
+		}
+	}
+}
+
+/**
+ * Several code paths in this file want to send a buffer to the dongle. This function handles both
+ * sending of a buffer or a pkt.
+ */
+static int
+dbus_send_irb(dbus_pub_t *pub, uint8 *buf, int len, void *pkt, void *info)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_OK;
+#ifndef EHCI_FASTPATH_TX
+	dbus_irb_tx_t *txirb = NULL;
+	int txirb_pending;
+	struct exec_parms args;
+#endif /* EHCI_FASTPATH_TX */
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info->pub.busstate == DBUS_STATE_UP ||
+		dbus_info->pub.busstate == DBUS_STATE_SLEEP) {
+#ifdef EHCI_FASTPATH_TX
+		struct ehci_qtd *qtd;
+		int token = EHCI_QTD_SET_CERR(3);
+		int len;
+
+		ASSERT(buf == NULL); /* Not handled */
+		ASSERT(pkt != NULL);
+
+		qtd = optimize_ehci_qtd_alloc(GFP_KERNEL);
+
+		if (qtd == NULL)
+			return DBUS_ERR;
+
+		len = PKTLEN(pub->osh, pkt);
+
+		len = ROUNDUP(len, sizeof(uint32));
+
+
+		optimize_qtd_fill_with_rpc(pub, 0, qtd, pkt, token, len);
+		err = optimize_submit_async(qtd, 0);
+
+		if (err) {
+			optimize_ehci_qtd_free(qtd);
+			err = DBUS_ERR_TXDROP;
+		}
+
+#else
+		args.qdeq.q = dbus_info->tx_q;
+		if (dbus_info->drvintf)
+			txirb = EXEC_TXLOCK(dbus_info, q_deq_exec, &args);
+
+		if (txirb == NULL) {
+			DBUSERR(("Out of tx dbus_bufs\n"));
+			return DBUS_ERR;
+		}
+
+		if (pkt != NULL) {
+			txirb->pkt = pkt;
+			txirb->buf = NULL;
+			txirb->len = 0;
+		} else if (buf != NULL) {
+			txirb->pkt = NULL;
+			txirb->buf = buf;
+			txirb->len = len;
+		} else {
+			ASSERT(0); /* Should not happen */
+		}
+		txirb->info = info;
+		txirb->arg = NULL;
+		txirb->retry_count = 0;
+
+		if (dbus_info->drvintf && dbus_info->drvintf->send_irb) {
+			/* call lower DBUS level send_irb function */
+			err = dbus_info->drvintf->send_irb(dbus_info->bus_info, txirb);
+			if (err == DBUS_ERR_TXDROP) {
+				/* tx fail and no completion routine to clean up, reclaim irb NOW */
+				DBUSERR(("%s: send_irb failed, status = %d\n", __FUNCTION__, err));
+				bzero(txirb, sizeof(dbus_irb_tx_t));
+				args.qenq.q = dbus_info->tx_q;
+				args.qenq.b = (dbus_irb_t *) txirb;
+				EXEC_TXLOCK(dbus_info, q_enq_exec, &args);
+			} else {
+				dbus_tx_timer_start(dbus_info, DBUS_TX_TIMEOUT_INTERVAL);
+				txirb_pending = dbus_info->pub.ntxq - dbus_info->tx_q->cnt;
+				if (txirb_pending > (dbus_info->tx_low_watermark * 3)) {
+					dbus_flowctrl_tx(dbus_info, TRUE);
+				}
+			}
+		}
+#endif /* EHCI_FASTPATH_TX */
+	} else {
+		err = DBUS_ERR_TXFAIL;
+		DBUSTRACE(("%s: bus down, send_irb failed\n", __FUNCTION__));
+	}
+
+	return err;
+} /* dbus_send_irb */
+
+#if (defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW))
+
+/**
+ * Before downloading a firmware image into the dongle, the validity of the image must be checked.
+ */
+static int
+check_file(osl_t *osh, unsigned char *headers)
+{
+	struct trx_header *trx;
+	int actual_len = -1;
+
+	/* Extract trx header */
+	trx = (struct trx_header *)headers;
+	if (ltoh32(trx->magic) != TRX_MAGIC) {
+		printf("Error: trx bad hdr %x\n", ltoh32(trx->magic));
+		return -1;
+	}
+
+	headers += SIZEOF_TRX(trx);
+
+	/* TRX V1: get firmware len */
+	/* TRX V2: get firmware len and DSG/CFG lengths */
+	if (ltoh32(trx->flag_version) & TRX_UNCOMP_IMAGE) {
+		actual_len = ltoh32(trx->offsets[TRX_OFFSETS_DLFWLEN_IDX]) +
+		                     SIZEOF_TRX(trx);
+#ifdef BCMTRXV2
+		if (ISTRX_V2(trx)) {
+			actual_len += ltoh32(trx->offsets[TRX_OFFSETS_DSG_LEN_IDX]) +
+				ltoh32(trx->offsets[TRX_OFFSETS_CFG_LEN_IDX]);
+		}
+#endif
+		return actual_len;
+	}  else {
+		printf("compressed image\n");
+	}
+
+	return -1;
+}
+
+/**
+ * It is easy for the user to pass one jumbo nvram file to the driver than a set of smaller files.
+ * The 'jumbo nvram' file format is essentially a set of nvram files. Before commencing firmware
+ * download, the dongle needs to be probed so that the correct nvram contents within the jumbo nvram
+ * file is selected.
+ */
+static int
+dbus_jumbo_nvram(dbus_info_t *dbus_info)
+{
+	int8 *nvram = NULL;
+	int nvram_len = 0;
+	int ret = DBUS_OK;
+	uint16 boardrev = 0xFFFF;
+	uint16 boardtype = 0xFFFF;
+
+	/* read the otp for boardrev & boardtype
+	* if boardtype/rev are present in otp
+	* select nvram data for that boardtype/rev
+	*/
+	dbus_otp(dbus_info, &boardtype, &boardrev);
+
+	ret = dbus_select_nvram(dbus_info, dbus_info->extdl.vars, dbus_info->extdl.varslen,
+		boardtype, boardrev, &nvram, &nvram_len);
+
+	if (ret == DBUS_JUMBO_BAD_FORMAT)
+			return DBUS_ERR_NVRAM;
+	else if (ret == DBUS_JUMBO_NOMATCH &&
+		(boardtype != 0xFFFF || boardrev  != 0xFFFF)) {
+			DBUSERR(("No matching NVRAM for boardtype 0x%02x boardrev 0x%02x\n",
+				boardtype, boardrev));
+			return DBUS_ERR_NVRAM;
+	}
+	dbus_info->nvram = nvram;
+	dbus_info->nvram_len =  nvram_len;
+
+	return DBUS_OK;
+}
+
+/** before commencing fw download, the correct NVRAM image to download has to be picked */
+static int
+dbus_get_nvram(dbus_info_t *dbus_info)
+{
+	int len, i;
+	struct trx_header *hdr;
+	int	actual_fwlen;
+	uint32 img_offset = 0;
+
+	dbus_info->nvram_len = 0;
+	if (dbus_info->extdl.varslen) {
+		if (DBUS_OK != dbus_jumbo_nvram(dbus_info))
+			return DBUS_ERR_NVRAM;
+		DBUSERR(("NVRAM %d bytes downloaded\n", dbus_info->nvram_len));
+	}
+#if defined(BCM_REQUEST_FW)
+	else if (nonfwnvram) {
+		dbus_info->nvram = nonfwnvram;
+		dbus_info->nvram_len = nonfwnvramlen;
+		DBUSERR(("NVRAM %d bytes downloaded\n", dbus_info->nvram_len));
+	}
+#endif
+	if (dbus_info->nvram) {
+		uint8 nvram_words_pad = 0;
+		/* Validate the format/length etc of the file */
+		if ((actual_fwlen = check_file(dbus_info->pub.osh, dbus_info->fw)) <= 0) {
+			DBUSERR(("%s: bad firmware format!\n", __FUNCTION__));
+			return DBUS_ERR_NVRAM;
+		}
+
+		if (!dbus_info->nvram_nontxt) {
+			/* host supplied nvram could be in .txt format
+			* with all the comments etc...
+			*/
+			dbus_info->nvram_len = process_nvram_vars(dbus_info->nvram,
+				dbus_info->nvram_len);
+		}
+		if (dbus_info->nvram_len % 4)
+			nvram_words_pad = 4 - dbus_info->nvram_len % 4;
+
+		len = actual_fwlen + dbus_info->nvram_len + nvram_words_pad;
+		dbus_info->image = MALLOC(dbus_info->pub.osh, len);
+		dbus_info->image_len = len;
+		if (dbus_info->image == NULL) {
+			DBUSERR(("%s: malloc failed!\n", __FUNCTION__));
+			return DBUS_ERR_NVRAM;
+		}
+		hdr = (struct trx_header *)dbus_info->fw;
+		/* Step1: Copy trx header + firmwre */
+		img_offset = SIZEOF_TRX(hdr) + hdr->offsets[TRX_OFFSETS_DLFWLEN_IDX];
+		bcopy(dbus_info->fw, dbus_info->image, img_offset);
+		/* Step2: Copy NVRAM + pad */
+		bcopy(dbus_info->nvram, (uint8 *)(dbus_info->image + img_offset),
+			dbus_info->nvram_len);
+		img_offset += dbus_info->nvram_len;
+		if (nvram_words_pad) {
+			bzero(&dbus_info->image[img_offset],
+				nvram_words_pad);
+			img_offset += nvram_words_pad;
+		}
+#ifdef BCMTRXV2
+		/* Step3: Copy DSG/CFG for V2 */
+		if (ISTRX_V2(hdr) &&
+			(hdr->offsets[TRX_OFFSETS_DSG_LEN_IDX] ||
+			hdr->offsets[TRX_OFFSETS_CFG_LEN_IDX])) {
+
+			bcopy(dbus_info->fw + SIZEOF_TRX(hdr) +
+				hdr->offsets[TRX_OFFSETS_DLFWLEN_IDX] +
+				hdr->offsets[TRX_OFFSETS_NVM_LEN_IDX],
+				dbus_info->image + img_offset,
+				hdr->offsets[TRX_OFFSETS_DSG_LEN_IDX] +
+				hdr->offsets[TRX_OFFSETS_CFG_LEN_IDX]);
+
+			img_offset += hdr->offsets[TRX_OFFSETS_DSG_LEN_IDX] +
+				hdr->offsets[TRX_OFFSETS_CFG_LEN_IDX];
+		}
+#endif /* BCMTRXV2 */
+		/* Step4: update TRX header for nvram size */
+		hdr = (struct trx_header *)dbus_info->image;
+		hdr->len = htol32(len);
+		/* Pass the actual fw len */
+		hdr->offsets[TRX_OFFSETS_NVM_LEN_IDX] =
+			htol32(dbus_info->nvram_len + nvram_words_pad);
+		/* Calculate CRC over header */
+		hdr->crc32 = hndcrc32((uint8 *)&hdr->flag_version,
+			SIZEOF_TRX(hdr) - OFFSETOF(struct trx_header, flag_version),
+			CRC32_INIT_VALUE);
+
+		/* Calculate CRC over data */
+		for (i = SIZEOF_TRX(hdr); i < len; ++i)
+				hdr->crc32 = hndcrc32((uint8 *)&dbus_info->image[i], 1, hdr->crc32);
+		hdr->crc32 = htol32(hdr->crc32);
+	} else {
+		dbus_info->image = dbus_info->fw;
+		dbus_info->image_len = (uint32)dbus_info->fwlen;
+	}
+
+	return DBUS_OK;
+} /* dbus_get_nvram */
+
+/**
+ * during driver initialization ('attach') or after PnP 'resume', firmware needs to be loaded into
+ * the dongle
+ */
+static int
+dbus_do_download(dbus_info_t *dbus_info)
+{
+	int err = DBUS_OK;
+#ifndef BCM_REQUEST_FW
+	int decomp_override = 0;
+#endif
+#ifdef BCM_REQUEST_FW
+	uint16 boardrev = 0xFFFF, boardtype = 0xFFFF;
+	int8 *temp_nvram;
+	int temp_len;
+#endif
+
+#if defined(BCM_DNGL_EMBEDIMAGE)
+	if (dbus_info->extdl.fw && (dbus_info->extdl.fwlen > 0)) {
+		dbus_info->fw = (uint8 *)dbus_info->extdl.fw;
+		dbus_info->fwlen = dbus_info->extdl.fwlen;
+		DBUSERR(("dbus_do_download: using override firmmware %d bytes\n",
+			dbus_info->fwlen));
+	} else
+		dbus_bus_fw_get(dbus_info->bus_info, &dbus_info->fw, &dbus_info->fwlen,
+			&decomp_override);
+
+	if (!dbus_info->fw) {
+		DBUSERR(("dbus_do_download: devid 0x%x / %d not supported\n",
+			dbus_info->pub.attrib.devid, dbus_info->pub.attrib.devid));
+		return DBUS_ERR;
+	}
+#elif defined(BCM_REQUEST_FW)
+	dbus_info->firmware = dbus_get_fw_nvfile(dbus_info->pub.attrib.devid,
+		dbus_info->pub.attrib.chiprev, &dbus_info->fw, &dbus_info->fwlen,
+		DBUS_FIRMWARE, 0, 0);
+	if (!dbus_info->firmware)
+		return DBUS_ERR;
+#endif /* defined(BCM_DNGL_EMBEDIMAGE) */
+
+	dbus_info->image = dbus_info->fw;
+	dbus_info->image_len = (uint32)dbus_info->fwlen;
+
+#ifndef BCM_REQUEST_FW
+	if (UNZIP_ENAB(dbus_info) && !decomp_override) {
+		err = dbus_zlib_decomp(dbus_info);
+		if (err) {
+			DBUSERR(("dbus_attach: fw decompress fail %d\n", err));
+			return err;
+		}
+	}
+#endif
+
+#if defined(BCM_REQUEST_FW)
+	/* check if firmware is appended with nvram file */
+	err = dbus_otp(dbus_info, &boardtype, &boardrev);
+	/* check if nvram is provided as separte file */
+	nonfwnvram = NULL;
+	nonfwnvramlen = 0;
+	dbus_info->nvfile = dbus_get_fw_nvfile(dbus_info->pub.attrib.devid,
+		dbus_info->pub.attrib.chiprev, (void *)&temp_nvram, &temp_len,
+		DBUS_NVFILE, boardtype, boardrev);
+	if (dbus_info->nvfile) {
+		int8 *tmp = MALLOC(dbus_info->pub.osh, temp_len);
+		if (tmp) {
+			bcopy(temp_nvram, tmp, temp_len);
+			nonfwnvram = tmp;
+			nonfwnvramlen = temp_len;
+		} else {
+			err = DBUS_ERR;
+			goto fail;
+		}
+	}
+#endif /* defined(BCM_REQUEST_FW) */
+
+	err = dbus_get_nvram(dbus_info);
+	if (err) {
+		DBUSERR(("dbus_do_download: fail to get nvram %d\n", err));
+		return err;
+	}
+
+
+	if (dbus_info->drvintf->dlstart && dbus_info->drvintf->dlrun) {
+		err = dbus_info->drvintf->dlstart(dbus_info->bus_info,
+			dbus_info->image, dbus_info->image_len);
+
+		if (err == DBUS_OK)
+			err = dbus_info->drvintf->dlrun(dbus_info->bus_info);
+	} else
+		err = DBUS_ERR;
+
+	if (dbus_info->nvram) {
+		MFREE(dbus_info->pub.osh, dbus_info->image, dbus_info->image_len);
+		dbus_info->image = dbus_info->fw;
+		dbus_info->image_len = (uint32)dbus_info->fwlen;
+	}
+
+#ifndef BCM_REQUEST_FW
+	if (UNZIP_ENAB(dbus_info) && (!decomp_override) && dbus_info->orig_fw) {
+		MFREE(dbus_info->pub.osh, dbus_info->fw, dbus_info->decomp_memsize);
+		dbus_info->image = dbus_info->fw = dbus_info->orig_fw;
+		dbus_info->image_len = dbus_info->fwlen = dbus_info->origfw_len;
+	}
+#endif
+
+#if defined(BCM_REQUEST_FW)
+fail:
+	if (dbus_info->firmware) {
+		dbus_release_fw_nvfile(dbus_info->firmware);
+		dbus_info->firmware = NULL;
+	}
+	if (dbus_info->nvfile) {
+		dbus_release_fw_nvfile(dbus_info->nvfile);
+		dbus_info->nvfile = NULL;
+	}
+	if (nonfwnvram) {
+		MFREE(dbus_info->pub.osh, nonfwnvram, nonfwnvramlen);
+		nonfwnvram = NULL;
+		nonfwnvramlen = 0;
+	}
+#endif
+	return err;
+} /* dbus_do_download */
+
+#endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
+
+/** required for DBUS deregistration */
+static void
+dbus_disconnect(void *handle)
+{
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (disconnect_cb)
+		disconnect_cb(disc_arg);
+}
+
+/**
+ * This function is called when the sent irb times out without a tx response status.
+ * DBUS adds reliability by resending timed out IRBs DBUS_TX_RETRY_LIMIT times.
+ */
+static void
+dbus_if_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) handle;
+
+	if ((dbus_info == NULL) || (dbus_info->drvintf == NULL) || (txirb == NULL)) {
+		return;
+	}
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	return;
+
+} /* dbus_if_send_irb_timeout */
+
+/**
+ * When lower DBUS level signals that a send IRB completed, either successful or not, the higher
+ * level (e.g. dhd_linux.c) has to be notified, and transmit flow control has to be evaluated.
+ */
+static void BCMFASTPATH
+dbus_if_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) handle;
+	int txirb_pending;
+	struct exec_parms args;
+	void *pktinfo;
+
+	if ((dbus_info == NULL) || (txirb == NULL)) {
+		return;
+	}
+
+	DBUSTRACE(("%s: status = %d\n", __FUNCTION__, status));
+
+	dbus_tx_timer_stop(dbus_info);
+
+	/* re-queue BEFORE calling send_complete which will assume that this irb
+	   is now available.
+	 */
+	pktinfo = txirb->info;
+	bzero(txirb, sizeof(dbus_irb_tx_t));
+	args.qenq.q = dbus_info->tx_q;
+	args.qenq.b = (dbus_irb_t *) txirb;
+	EXEC_TXLOCK(dbus_info, q_enq_exec, &args);
+
+	if (dbus_info->pub.busstate != DBUS_STATE_DOWN) {
+		if ((status == DBUS_OK) || (status == DBUS_ERR_NODEVICE)) {
+			if (dbus_info->cbs && dbus_info->cbs->send_complete)
+				dbus_info->cbs->send_complete(dbus_info->cbarg, pktinfo,
+					status);
+
+			if (status == DBUS_OK) {
+				txirb_pending = dbus_info->pub.ntxq - dbus_info->tx_q->cnt;
+				if (txirb_pending)
+					dbus_tx_timer_start(dbus_info, DBUS_TX_TIMEOUT_INTERVAL);
+				if ((txirb_pending < dbus_info->tx_low_watermark) &&
+					dbus_info->txoff && !dbus_info->txoverride) {
+					dbus_flowctrl_tx(dbus_info, OFF);
+				}
+			}
+		} else {
+			DBUSERR(("%s: %d WARNING freeing orphan pkt %p\n", __FUNCTION__, __LINE__,
+				pktinfo));
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) || defined(BCM_RPC_TOC)
+			if (pktinfo)
+				if (dbus_info->cbs && dbus_info->cbs->send_complete)
+					dbus_info->cbs->send_complete(dbus_info->cbarg, pktinfo,
+						status);
+#else
+			dbus_if_pktfree(dbus_info, (void*)pktinfo, TRUE);
+#endif /* defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) || defined(BCM_RPC_TOC) */
+		}
+	} else {
+		DBUSERR(("%s: %d WARNING freeing orphan pkt %p\n", __FUNCTION__, __LINE__,
+			pktinfo));
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) || defined(BCM_RPC_TOC)
+		if (pktinfo)
+			if (dbus_info->cbs && dbus_info->cbs->send_complete)
+				dbus_info->cbs->send_complete(dbus_info->cbarg, pktinfo,
+					status);
+#else
+		dbus_if_pktfree(dbus_info, (void*)pktinfo, TRUE);
+#endif /* defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) defined(BCM_RPC_TOC) */
+	}
+} /* dbus_if_send_irb_complete */
+
+/**
+ * When lower DBUS level signals that a receive IRB completed, either successful or not, the higher
+ * level (e.g. dhd_linux.c) has to be notified, and fresh free receive IRBs may have to be given
+ * to lower levels.
+ */
+static void BCMFASTPATH
+dbus_if_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) handle;
+	int rxirb_pending;
+	struct exec_parms args;
+
+	if ((dbus_info == NULL) || (rxirb == NULL)) {
+		return;
+	}
+	DBUSTRACE(("%s\n", __FUNCTION__));
+	if (dbus_info->pub.busstate != DBUS_STATE_DOWN &&
+		dbus_info->pub.busstate != DBUS_STATE_SLEEP) {
+		if (status == DBUS_OK) {
+			if ((rxirb->buf != NULL) && (rxirb->actual_len > 0)) {
+#ifdef DBUS_USB_LOOPBACK
+				if (is_loopback_pkt(rxirb->buf)) {
+					matches_loopback_pkt(rxirb->buf);
+				} else
+#endif
+				if (dbus_info->cbs && dbus_info->cbs->recv_buf) {
+					dbus_info->cbs->recv_buf(dbus_info->cbarg, rxirb->buf,
+					rxirb->actual_len);
+				}
+			} else if (rxirb->pkt != NULL) {
+				if (dbus_info->cbs && dbus_info->cbs->recv_pkt)
+					dbus_info->cbs->recv_pkt(dbus_info->cbarg, rxirb->pkt);
+			} else {
+				ASSERT(0); /* Should not happen */
+			}
+
+			rxirb_pending = dbus_info->pub.nrxq - dbus_info->rx_q->cnt - 1;
+			if ((rxirb_pending <= dbus_info->rx_low_watermark) &&
+				!dbus_info->rxoff) {
+				DBUSTRACE(("Low watermark so submit more %d <= %d \n",
+					dbus_info->rx_low_watermark, rxirb_pending));
+				dbus_rxirbs_fill(dbus_info);
+			} else if (dbus_info->rxoff)
+				DBUSTRACE(("rx flow controlled. not filling more. cut_rxq=%d\n",
+					dbus_info->rx_q->cnt));
+		} else if (status == DBUS_ERR_NODEVICE) {
+			DBUSERR(("%s: %d status = %d, buf %p\n", __FUNCTION__, __LINE__, status,
+				rxirb->buf));
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+			if (rxirb->buf) {
+				PKTFRMNATIVE(dbus_info->pub.osh, rxirb->buf);
+				PKTFREE(dbus_info->pub.osh, rxirb->buf, FALSE);
+			}
+#endif /* BCM_RPC_NOCOPY || BCM_RPC_TXNOCOPY || BCM_RPC_TOC */
+		} else {
+			if (status != DBUS_ERR_RXZLP)
+				DBUSERR(("%s: %d status = %d, buf %p\n", __FUNCTION__, __LINE__,
+					status, rxirb->buf));
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+			if (rxirb->buf) {
+				PKTFRMNATIVE(dbus_info->pub.osh, rxirb->buf);
+				PKTFREE(dbus_info->pub.osh, rxirb->buf, FALSE);
+			}
+#endif /* BCM_RPC_NOCOPY || BCM_RPC_TXNOCOPY || BCM_RPC_TOC */
+		}
+	} else {
+		DBUSTRACE(("%s: DBUS down, ignoring recv callback. buf %p\n", __FUNCTION__,
+			rxirb->buf));
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+		if (rxirb->buf) {
+			PKTFRMNATIVE(dbus_info->pub.osh, rxirb->buf);
+			PKTFREE(dbus_info->pub.osh, rxirb->buf, FALSE);
+		}
+#endif /* BCM_RPC_NOCOPY || BCM_RPC_TXNOCOPY || BCM_RPC_TOC */
+	}
+	if (dbus_info->rx_q != NULL) {
+		bzero(rxirb, sizeof(dbus_irb_rx_t));
+		args.qenq.q = dbus_info->rx_q;
+		args.qenq.b = (dbus_irb_t *) rxirb;
+		EXEC_RXLOCK(dbus_info, q_enq_exec, &args);
+	} else
+		MFREE(dbus_info->pub.osh, rxirb, sizeof(dbus_irb_tx_t));
+} /* dbus_if_recv_irb_complete */
+
+/**
+ *  Accumulate errors signaled by lower DBUS levels and signal them to higher (e.g. dhd_linux.c)
+ *  level.
+ */
+static void
+dbus_if_errhandler(void *handle, int err)
+{
+	dbus_info_t *dbus_info = handle;
+	uint32 mask = 0;
+
+	if (dbus_info == NULL)
+		return;
+
+	switch (err) {
+		case DBUS_ERR_TXFAIL:
+			dbus_info->pub.stats.tx_errors++;
+			mask |= ERR_CBMASK_TXFAIL;
+			break;
+		case DBUS_ERR_TXDROP:
+			dbus_info->pub.stats.tx_dropped++;
+			mask |= ERR_CBMASK_TXFAIL;
+			break;
+		case DBUS_ERR_RXFAIL:
+			dbus_info->pub.stats.rx_errors++;
+			mask |= ERR_CBMASK_RXFAIL;
+			break;
+		case DBUS_ERR_RXDROP:
+			dbus_info->pub.stats.rx_dropped++;
+			mask |= ERR_CBMASK_RXFAIL;
+			break;
+		default:
+			break;
+	}
+
+	if (dbus_info->cbs && dbus_info->cbs->errhandler && (dbus_info->errmask & mask))
+		dbus_info->cbs->errhandler(dbus_info->cbarg, err);
+}
+
+/**
+ * When lower DBUS level signals control IRB completed, higher level (e.g. dhd_linux.c) has to be
+ * notified.
+ */
+static void
+dbus_if_ctl_complete(void *handle, int type, int status)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) handle;
+
+	if (dbus_info == NULL)
+		return;
+
+	if (dbus_info->pub.busstate != DBUS_STATE_DOWN) {
+		if (dbus_info->cbs && dbus_info->cbs->ctl_complete)
+			dbus_info->cbs->ctl_complete(dbus_info->cbarg, type, status);
+	}
+}
+
+/**
+ * Rx related functionality (flow control, posting of free IRBs to rx queue) is dependent upon the
+ * bus state. When lower DBUS level signals a change in the interface state, take appropriate action
+ * and forward the signaling to the higher (e.g. dhd_linux.c) level.
+ */
+static void
+dbus_if_state_change(void *handle, int state)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) handle;
+	int old_state;
+
+	if (dbus_info == NULL)
+		return;
+
+	if (dbus_info->pub.busstate == state)
+		return;
+	old_state = dbus_info->pub.busstate;
+	if (state == DBUS_STATE_DISCONNECT) {
+		DBUSERR(("DBUS disconnected\n"));
+	}
+
+	/* Ignore USB SUSPEND while not up yet */
+	if (state == DBUS_STATE_SLEEP && old_state != DBUS_STATE_UP)
+		return;
+
+	DBUSTRACE(("dbus state change from %d to to %d\n", old_state, state));
+
+	/* Don't update state if it's PnP firmware re-download */
+	if (state != DBUS_STATE_PNP_FWDL)
+		dbus_info->pub.busstate = state;
+	else
+		dbus_flowctrl_rx(handle, FALSE);
+	if (state == DBUS_STATE_SLEEP)
+		dbus_flowctrl_rx(handle, TRUE);
+	if (state == DBUS_STATE_UP) {
+		dbus_rxirbs_fill(dbus_info);
+		dbus_flowctrl_rx(handle, FALSE);
+	}
+
+	if (dbus_info->cbs && dbus_info->cbs->state_change)
+		dbus_info->cbs->state_change(dbus_info->cbarg, state);
+}
+
+/** Forward request for packet from lower DBUS layer to higher layer (e.g. dhd_linux.c) */
+static void *
+dbus_if_pktget(void *handle, uint len, bool send)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) handle;
+	void *p = NULL;
+
+	if (dbus_info == NULL)
+		return NULL;
+
+	if (dbus_info->cbs && dbus_info->cbs->pktget)
+		p = dbus_info->cbs->pktget(dbus_info->cbarg, len, send);
+	else
+		ASSERT(0);
+
+	return p;
+}
+
+/** Forward request to free packet from lower DBUS layer to higher layer (e.g. dhd_linux.c) */
+static void
+dbus_if_pktfree(void *handle, void *p, bool send)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) handle;
+
+	if (dbus_info == NULL)
+		return;
+
+	if (dbus_info->cbs && dbus_info->cbs->pktfree)
+		dbus_info->cbs->pktfree(dbus_info->cbarg, p, send);
+	else
+		ASSERT(0);
+}
+
+/** Lower DBUS level requests either a send or receive IRB */
+static struct dbus_irb*
+dbus_if_getirb(void *cbarg, bool send)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) cbarg;
+	struct exec_parms args;
+	struct dbus_irb *irb;
+
+	if ((dbus_info == NULL) || (dbus_info->pub.busstate != DBUS_STATE_UP))
+		return NULL;
+
+	if (send == TRUE) {
+		args.qdeq.q = dbus_info->tx_q;
+		irb = EXEC_TXLOCK(dbus_info, q_deq_exec, &args);
+	} else {
+		args.qdeq.q = dbus_info->rx_q;
+		irb = EXEC_RXLOCK(dbus_info, q_deq_exec, &args);
+	}
+
+	return irb;
+}
+
+/**
+ * Called as part of DBUS bus registration. Calls back into higher level (e.g. dhd_linux.c) probe
+ * function.
+ */
+static void *
+dbus_probe(void *arg, const char *desc, uint32 bustype, uint32 hdrlen)
+{
+	if (probe_cb) {
+		disc_arg = probe_cb(probe_arg, desc, bustype, hdrlen);
+		return disc_arg;
+	}
+
+	return (void *)DBUS_ERR;
+}
+
+/**
+ * As part of initialization, higher level (e.g. dhd_linux.c) requests DBUS to prepare for
+ * action.
+ */
+int
+dbus_register(int vid, int pid, probe_cb_t prcb,
+	disconnect_cb_t discb, void *prarg, void *param1, void *param2)
+{
+	int err;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	probe_cb = prcb;
+	disconnect_cb = discb;
+	probe_arg = prarg;
+
+	err = dbus_bus_register(vid, pid, dbus_probe, /* call lower DBUS level register function */
+		dbus_disconnect, NULL, &g_busintf, param1, param2);
+
+	return err;
+}
+
+int
+dbus_deregister()
+{
+	int ret;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	probe_cb = NULL;
+	ret = dbus_bus_deregister();
+	disconnect_cb = NULL;
+	probe_arg = NULL;
+
+	return ret;
+
+}
+
+/** As part of initialization, data structures have to be allocated and initialized */
+dbus_pub_t *
+dbus_attach(osl_t *osh, int rxsize, int nrxq, int ntxq, void *cbarg,
+	dbus_callbacks_t *cbs, dbus_extdl_t *extdl, struct shared_info *sh)
+{
+	dbus_info_t *dbus_info;
+	int err;
+
+	if ((g_busintf == NULL) || (g_busintf->attach == NULL) || (cbs == NULL))
+		return NULL;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if ((nrxq <= 0) || (ntxq <= 0))
+		return NULL;
+
+	dbus_info = MALLOC(osh, sizeof(dbus_info_t));
+	if (dbus_info == NULL)
+		return NULL;
+
+	bzero(dbus_info, sizeof(dbus_info_t));
+
+	/* BUS-specific driver interface (at a lower DBUS level) */
+	dbus_info->drvintf = g_busintf;
+	dbus_info->cbarg = cbarg;
+	dbus_info->cbs = cbs;
+
+	dbus_info->pub.sh = sh;
+	dbus_info->pub.osh = osh;
+	dbus_info->pub.rxsize = rxsize;
+
+#ifdef EHCI_FASTPATH_RX
+	atomic_set(&dbus_info->rx_outstanding, 0);
+#endif
+
+	dbus_info->pub.nrxq = nrxq;
+	dbus_info->rx_low_watermark = nrxq / 2;	/* keep enough posted rx urbs */
+	dbus_info->pub.ntxq = ntxq;
+	dbus_info->tx_low_watermark = ntxq / 4;	/* flow control when too many tx urbs posted */
+
+	dbus_info->tx_q = MALLOC(osh, sizeof(dbus_irbq_t));
+	if (dbus_info->tx_q == NULL)
+		goto error;
+	else {
+		bzero(dbus_info->tx_q, sizeof(dbus_irbq_t));
+		err = dbus_irbq_init(dbus_info, dbus_info->tx_q, ntxq, sizeof(dbus_irb_tx_t));
+		if (err != DBUS_OK)
+			goto error;
+	}
+
+	dbus_info->rx_q = MALLOC(osh, sizeof(dbus_irbq_t));
+	if (dbus_info->rx_q == NULL)
+		goto error;
+	else {
+		bzero(dbus_info->rx_q, sizeof(dbus_irbq_t));
+		err = dbus_irbq_init(dbus_info, dbus_info->rx_q, nrxq, sizeof(dbus_irb_rx_t));
+		if (err != DBUS_OK)
+			goto error;
+	}
+
+
+	dbus_info->bus_info = (void *)g_busintf->attach(&dbus_info->pub,
+		dbus_info, &dbus_intf_cbs);
+	if (dbus_info->bus_info == NULL)
+		goto error;
+
+	dbus_tx_timer_init(dbus_info);
+
+#if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
+	/* Need to copy external image for re-download */
+	if (extdl && extdl->fw && (extdl->fwlen > 0)) {
+		dbus_info->extdl.fw = MALLOC(osh, extdl->fwlen);
+		if (dbus_info->extdl.fw) {
+			bcopy(extdl->fw, dbus_info->extdl.fw, extdl->fwlen);
+			dbus_info->extdl.fwlen = extdl->fwlen;
+		}
+	}
+
+	if (extdl && extdl->vars && (extdl->varslen > 0)) {
+		dbus_info->extdl.vars = MALLOC(osh, extdl->varslen);
+		if (dbus_info->extdl.vars) {
+			bcopy(extdl->vars, dbus_info->extdl.vars, extdl->varslen);
+			dbus_info->extdl.varslen = extdl->varslen;
+		}
+	}
+
+	if (dbus_download_firmware(&dbus_info->pub) != DBUS_OK)
+		goto error;
+#endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
+
+	return (dbus_pub_t *)dbus_info;
+
+error:
+	dbus_detach((dbus_pub_t *)dbus_info);
+	return NULL;
+} /* dbus_attach */
+
+void
+dbus_detach(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	osl_t *osh;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return;
+
+	dbus_tx_timer_stop(dbus_info);
+
+	osh = pub->osh;
+
+	if (dbus_info->drvintf && dbus_info->drvintf->detach)
+		 dbus_info->drvintf->detach((dbus_pub_t *)dbus_info, dbus_info->bus_info);
+
+	if (dbus_info->tx_q) {
+		dbus_irbq_deinit(dbus_info, dbus_info->tx_q, sizeof(dbus_irb_tx_t));
+		MFREE(osh, dbus_info->tx_q, sizeof(dbus_irbq_t));
+		dbus_info->tx_q = NULL;
+	}
+
+	if (dbus_info->rx_q) {
+		dbus_irbq_deinit(dbus_info, dbus_info->rx_q, sizeof(dbus_irb_rx_t));
+		MFREE(osh, dbus_info->rx_q, sizeof(dbus_irbq_t));
+		dbus_info->rx_q = NULL;
+	}
+
+
+	if (dbus_info->extdl.fw && (dbus_info->extdl.fwlen > 0)) {
+		MFREE(osh, dbus_info->extdl.fw, dbus_info->extdl.fwlen);
+		dbus_info->extdl.fw = NULL;
+		dbus_info->extdl.fwlen = 0;
+	}
+
+	if (dbus_info->extdl.vars && (dbus_info->extdl.varslen > 0)) {
+		MFREE(osh, dbus_info->extdl.vars, dbus_info->extdl.varslen);
+		dbus_info->extdl.vars = NULL;
+		dbus_info->extdl.varslen = 0;
+	}
+
+	MFREE(osh, dbus_info, sizeof(dbus_info_t));
+} /* dbus_detach */
+
+#if (defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW))
+
+int dbus_download_firmware(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_OK;
+
+	DBUSTRACE(("%s: state %d\n", __FUNCTION__, dbus_info->pub.busstate));
+
+	if (dbus_info->drvintf->dlneeded) {
+		if (dbus_info->drvintf->dlneeded(dbus_info->bus_info)) {
+			dbus_info->pub.busstate = DBUS_STATE_DL_PENDING;
+			err = dbus_do_download(dbus_info);
+			if (err == DBUS_OK) {
+				dbus_info->pub.busstate = DBUS_STATE_DL_DONE;
+			} else {
+				DBUSERR(("%s: download failed (%d)\n", __FUNCTION__, err));
+			}
+		}
+	}
+
+	return err;
+}
+
+#endif /* BCM_DNGL_EMBEDIMAGE || BCM_REQUEST_FW */
+
+/**
+ * higher layer requests us to 'up' the interface to the dongle. Prerequisite is that firmware (not
+ * bootloader) must be active in the dongle.
+ */
+int
+dbus_up(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_OK;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if ((dbus_info->pub.busstate == DBUS_STATE_DL_DONE) ||
+		(dbus_info->pub.busstate == DBUS_STATE_DOWN) ||
+		(dbus_info->pub.busstate == DBUS_STATE_SLEEP)) {
+		if (dbus_info->drvintf && dbus_info->drvintf->up) {
+			err = dbus_info->drvintf->up(dbus_info->bus_info);
+
+			if (err == DBUS_OK) {
+				dbus_rxirbs_fill(dbus_info);
+			}
+		}
+	} else
+		err = DBUS_ERR;
+
+	return err;
+}
+
+/** higher layer requests us to 'down' the interface to the dongle. */
+int
+dbus_down(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	dbus_tx_timer_stop(dbus_info);
+
+	if (dbus_info->pub.busstate == DBUS_STATE_UP ||
+		dbus_info->pub.busstate == DBUS_STATE_SLEEP) {
+		if (dbus_info->drvintf && dbus_info->drvintf->down)
+			return dbus_info->drvintf->down(dbus_info->bus_info);
+	}
+
+	return DBUS_ERR;
+}
+
+int
+dbus_shutdown(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if (dbus_info->drvintf && dbus_info->drvintf->shutdown)
+		return dbus_info->drvintf->shutdown(dbus_info->bus_info);
+
+	return DBUS_OK;
+}
+
+int
+dbus_stop(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if (dbus_info->pub.busstate == DBUS_STATE_UP ||
+		dbus_info->pub.busstate == DBUS_STATE_SLEEP) {
+		if (dbus_info->drvintf && dbus_info->drvintf->stop)
+			return dbus_info->drvintf->stop(dbus_info->bus_info);
+	}
+
+	return DBUS_ERR;
+}
+
+int dbus_send_txdata(dbus_pub_t *dbus, void *pktbuf)
+{
+#ifdef BCMSDIO
+	return dbus_send_pkt(dbus, pktbuf, NULL /* pktinfo */);
+#else
+	return dbus_send_pkt(dbus, pktbuf, pktbuf /* pktinfo */);
+#endif
+}
+
+int
+dbus_send_buf(dbus_pub_t *pub, uint8 *buf, int len, void *info)
+{
+	return dbus_send_irb(pub, buf, len, NULL, info);
+}
+
+int
+dbus_send_pkt(dbus_pub_t *pub, void *pkt, void *info)
+{
+	return dbus_send_irb(pub, NULL, 0, pkt, info);
+}
+
+int
+dbus_send_ctl(dbus_pub_t *pub, uint8 *buf, int len)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if (dbus_info->pub.busstate == DBUS_STATE_UP ||
+		dbus_info->pub.busstate == DBUS_STATE_SLEEP) {
+		if (dbus_info->drvintf && dbus_info->drvintf->send_ctl)
+			return dbus_info->drvintf->send_ctl(dbus_info->bus_info, buf, len);
+	}
+
+	return DBUS_ERR;
+}
+
+int
+dbus_recv_ctl(dbus_pub_t *pub, uint8 *buf, int len)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	if ((dbus_info == NULL) || (buf == NULL))
+		return DBUS_ERR;
+
+	if (dbus_info->pub.busstate == DBUS_STATE_UP ||
+		dbus_info->pub.busstate == DBUS_STATE_SLEEP) {
+		if (dbus_info->drvintf && dbus_info->drvintf->recv_ctl)
+			return dbus_info->drvintf->recv_ctl(dbus_info->bus_info, buf, len);
+	}
+
+	return DBUS_ERR;
+}
+
+/** Only called via RPC (Dec 2012) */
+int
+dbus_recv_bulk(dbus_pub_t *pub, uint32 ep_idx)
+{
+#ifdef EHCI_FASTPATH_RX
+	/* 2nd bulk in not supported for EHCI_FASTPATH_RX */
+	ASSERT(0);
+#else
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	dbus_irb_rx_t *rxirb;
+	struct exec_parms args;
+	int status;
+
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	args.qdeq.q = dbus_info->rx_q;
+	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
+		if (dbus_info->drvintf && dbus_info->drvintf->recv_irb_from_ep) {
+			if ((rxirb = (EXEC_RXLOCK(dbus_info, q_deq_exec, &args))) != NULL) {
+				status = dbus_info->drvintf->recv_irb_from_ep(dbus_info->bus_info,
+					rxirb, ep_idx);
+				if (status == DBUS_ERR_RXDROP) {
+					bzero(rxirb, sizeof(dbus_irb_rx_t));
+					args.qenq.q = dbus_info->rx_q;
+					args.qenq.b = (dbus_irb_t *) rxirb;
+					EXEC_RXLOCK(dbus_info, q_enq_exec, &args);
+				}
+			}
+		}
+	}
+#endif /* EHCI_FASTPATH_RX */
+
+	return DBUS_ERR;
+}
+
+/** only called by dhd_cdc.c (Dec 2012) */
+int
+dbus_poll_intr(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	int status = DBUS_ERR;
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
+		if (dbus_info->drvintf && dbus_info->drvintf->recv_irb_from_ep) {
+			status = dbus_info->drvintf->recv_irb_from_ep(dbus_info->bus_info,
+				NULL, 0xff);
+		}
+	}
+	return status;
+}
+
+/** called by nobody (Dec 2012) */
+void *
+dbus_pktget(dbus_pub_t *pub, int len)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	if ((dbus_info == NULL) || (len < 0))
+		return NULL;
+
+	return PKTGET(dbus_info->pub.osh, len, TRUE);
+}
+
+/** called by nobody (Dec 2012) */
+void
+dbus_pktfree(dbus_pub_t *pub, void* pkt)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	if ((dbus_info == NULL) || (pkt == NULL))
+		return;
+
+	PKTFREE(dbus_info->pub.osh, pkt, TRUE);
+}
+
+/** called by nobody (Dec 2012) */
+int
+dbus_get_stats(dbus_pub_t *pub, dbus_stats_t *stats)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	if ((dbus_info == NULL) || (stats == NULL))
+		return DBUS_ERR;
+
+	bcopy(&dbus_info->pub.stats, stats, sizeof(dbus_stats_t));
+
+	return DBUS_OK;
+}
+
+int
+dbus_get_attrib(dbus_pub_t *pub, dbus_attrib_t *attrib)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_ERR;
+
+	if ((dbus_info == NULL) || (attrib == NULL))
+		return DBUS_ERR;
+
+	if (dbus_info->drvintf && dbus_info->drvintf->get_attrib) {
+		err = dbus_info->drvintf->get_attrib(dbus_info->bus_info,
+		&dbus_info->pub.attrib);
+	}
+
+	bcopy(&dbus_info->pub.attrib, attrib, sizeof(dbus_attrib_t));
+	return err;
+}
+
+int
+dbus_get_device_speed(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+
+	if (dbus_info == NULL)
+		return INVALID_SPEED;
+
+	return (dbus_info->pub.device_speed);
+}
+
+int
+dbus_set_config(dbus_pub_t *pub, dbus_config_t *config)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_ERR;
+
+	if ((dbus_info == NULL) || (config == NULL))
+		return DBUS_ERR;
+
+	if (dbus_info->drvintf && dbus_info->drvintf->set_config) {
+		err = dbus_info->drvintf->set_config(dbus_info->bus_info,
+			config);
+
+		if ((config->config_id == DBUS_CONFIG_ID_AGGR_LIMIT) &&
+			(!err) &&
+			(dbus_info->pub.busstate == DBUS_STATE_UP)) {
+			dbus_rxirbs_fill(dbus_info);
+		}
+	}
+
+	return err;
+}
+
+int
+dbus_get_config(dbus_pub_t *pub, dbus_config_t *config)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_ERR;
+
+	if ((dbus_info == NULL) || (config == NULL))
+		return DBUS_ERR;
+
+	if (dbus_info->drvintf && dbus_info->drvintf->get_config) {
+		err = dbus_info->drvintf->get_config(dbus_info->bus_info,
+		config);
+	}
+
+	return err;
+}
+
+int
+dbus_set_errmask(dbus_pub_t *pub, uint32 mask)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_OK;
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	dbus_info->errmask = mask;
+	return err;
+}
+
+int
+dbus_pnp_resume(dbus_pub_t *pub, int *fw_reload)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_ERR;
+	bool fwdl = FALSE;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
+		return DBUS_OK;
+	}
+
+
+#if defined(BCM_DNGL_EMBEDIMAGE)
+	if (dbus_info->drvintf->device_exists &&
+		dbus_info->drvintf->device_exists(dbus_info->bus_info)) {
+		if (dbus_info->drvintf->dlneeded) {
+			if (dbus_info->drvintf->dlneeded(dbus_info->bus_info)) {
+				err = dbus_do_download(dbus_info);
+				if (err == DBUS_OK) {
+					fwdl = TRUE;
+				}
+				if (dbus_info->pub.busstate == DBUS_STATE_DL_DONE)
+					dbus_up(&dbus_info->pub);
+			}
+		}
+	} else {
+		return DBUS_ERR;
+	}
+#endif /* BCM_DNGL_EMBEDIMAGE */
+
+	if (dbus_info->drvintf->pnp) {
+		err = dbus_info->drvintf->pnp(dbus_info->bus_info,
+			DBUS_PNP_RESUME);
+	}
+
+	if (dbus_info->drvintf->recv_needed) {
+		if (dbus_info->drvintf->recv_needed(dbus_info->bus_info)) {
+			/* Refill after sleep/hibernate */
+			dbus_rxirbs_fill(dbus_info);
+		}
+	}
+
+#if defined(BCM_DNGL_EMBEDIMAGE)
+	if (fwdl == TRUE) {
+		dbus_if_state_change(dbus_info, DBUS_STATE_PNP_FWDL);
+	}
+#endif /* BCM_DNGL_EMBEDIMAGE */
+
+	if (fw_reload)
+		*fw_reload = fwdl;
+
+	return err;
+} /* dbus_pnp_resume */
+
+int
+dbus_pnp_sleep(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_ERR;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	dbus_tx_timer_stop(dbus_info);
+
+	if (dbus_info->drvintf && dbus_info->drvintf->pnp) {
+		err = dbus_info->drvintf->pnp(dbus_info->bus_info,
+			DBUS_PNP_SLEEP);
+	}
+
+	return err;
+}
+
+int
+dbus_pnp_disconnect(dbus_pub_t *pub)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_ERR;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	dbus_tx_timer_stop(dbus_info);
+
+	if (dbus_info->drvintf && dbus_info->drvintf->pnp) {
+		err = dbus_info->drvintf->pnp(dbus_info->bus_info,
+			DBUS_PNP_DISCONNECT);
+	}
+
+	return err;
+}
+
+int
+dbus_iovar_op(dbus_pub_t *pub, const char *name,
+	void *params, int plen, void *arg, int len, bool set)
+{
+	dbus_info_t *dbus_info = (dbus_info_t *) pub;
+	int err = DBUS_ERR;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (dbus_info == NULL)
+		return DBUS_ERR;
+
+	if (dbus_info->drvintf && dbus_info->drvintf->iovar_op) {
+		err = dbus_info->drvintf->iovar_op(dbus_info->bus_info,
+			name, params, plen, arg, len, set);
+	}
+
+	return err;
+}
+
+
+void *
+dhd_dbus_txq(const dbus_pub_t *pub)
+{
+	return NULL;
+}
+
+uint
+dhd_dbus_hdrlen(const dbus_pub_t *pub)
+{
+	return 0;
+}
+
+void *
+dbus_get_devinfo(dbus_pub_t *pub)
+{
+	return pub->dev_info;
+}
+
+#if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
+
+static int
+dbus_otp(dbus_info_t *dbus_info, uint16 *boardtype, uint16 *boardrev)
+{
+	uint32 value = 0;
+	uint8 *cis;
+	uint16 *otpinfo;
+	uint32 i;
+	bool standard_cis = TRUE;
+	uint8 tup, tlen;
+	bool btype_present = FALSE;
+	bool brev_present = FALSE;
+	int ret;
+	int devid;
+	uint16 btype = 0;
+	uint16 brev = 0;
+	uint32 otp_size = 0, otp_addr = 0, otp_sw_rgn = 0;
+
+	if (dbus_info == NULL || dbus_info->drvintf == NULL ||
+		dbus_info->drvintf->readreg == NULL)
+		return DBUS_ERR;
+
+	devid = dbus_info->pub.attrib.devid;
+
+	if ((devid == BCM43234_CHIP_ID) || (devid == BCM43235_CHIP_ID) ||
+		(devid == BCM43236_CHIP_ID)) {
+
+		otp_size = BCM_OTP_SIZE_43236;
+		otp_sw_rgn = BCM_OTP_SW_RGN_43236;
+		otp_addr = BCM_OTP_ADDR_43236;
+
+	} else {
+		return DBUS_ERR_NVRAM;
+	}
+
+	cis = MALLOC(dbus_info->pub.osh, otp_size * 2);
+	if (cis == NULL)
+		return DBUS_ERR;
+
+	otpinfo = (uint16 *) cis;
+
+	for (i = 0; i < otp_size; i++) {
+
+		ret = dbus_info->drvintf->readreg(dbus_info->bus_info,
+			otp_addr + ((otp_sw_rgn + i) << 1), 2, &value);
+
+		if (ret != DBUS_OK) {
+			MFREE(dbus_info->pub.osh, cis, otp_size * 2);
+			return ret;
+		}
+		otpinfo[i] = (uint16) value;
+	}
+
+	for (i = 0; i < (otp_size << 1); ) {
+
+		if (standard_cis) {
+			tup = cis[i++];
+			if (tup == CISTPL_NULL || tup == CISTPL_END)
+				tlen = 0;
+			else
+				tlen = cis[i++];
+		} else {
+			if (cis[i] == CISTPL_NULL || cis[i] == CISTPL_END) {
+				tlen = 0;
+				tup = cis[i];
+			} else {
+				tlen = cis[i];
+				tup = CISTPL_BRCM_HNBU;
+			}
+			++i;
+		}
+
+		if (tup == CISTPL_END || (i + tlen) >= (otp_size << 1)) {
+			break;
+		}
+
+		switch (tup) {
+
+		case CISTPL_BRCM_HNBU:
+
+			switch (cis[i]) {
+
+			case HNBU_BOARDTYPE:
+
+				btype = (uint16) ((cis[i + 2] << 8) + cis[i + 1]);
+				btype_present = TRUE;
+				DBUSTRACE(("%s: HNBU_BOARDTYPE = 0x%2x\n", __FUNCTION__,
+					(uint32)btype));
+				break;
+
+			case HNBU_BOARDREV:
+
+				if (tlen == 2)
+					brev = (uint16) cis[i + 1];
+				else
+					brev = (uint16) ((cis[i + 2] << 8) + cis[i + 1]);
+				brev_present = TRUE;
+				DBUSTRACE(("%s: HNBU_BOARDREV =  0x%2x\n", __FUNCTION__,
+					(uint32)*boardrev));
+				break;
+
+			case HNBU_HNBUCIS:
+				DBUSTRACE(("%s: HNBU_HNBUCIS\n", __FUNCTION__));
+				tlen++;
+				standard_cis = FALSE;
+				break;
+			}
+			break;
+		}
+
+		i += tlen;
+	}
+
+	MFREE(dbus_info->pub.osh, cis, otp_size * 2);
+
+	if (btype_present == TRUE && brev_present == TRUE) {
+		*boardtype = btype;
+		*boardrev = brev;
+		DBUSERR(("otp boardtype = 0x%2x boardrev = 0x%2x\n",
+			*boardtype, *boardrev));
+
+		return DBUS_OK;
+	}
+	else
+		return DBUS_ERR;
+} /* dbus_otp */
+
+static int
+dbus_select_nvram(dbus_info_t *dbus_info, int8 *jumbonvram, int jumbolen,
+uint16 boardtype, uint16 boardrev, int8 **nvram, int *nvram_len)
+{
+	/* Multi board nvram file format is contenation of nvram info with \r
+	*  The file format for two contatenated set is
+	*  \nBroadcom Jumbo Nvram file\nfirst_set\nsecond_set\nthird_set\n
+	*/
+	uint8 *nvram_start = NULL, *nvram_end = NULL;
+	uint8 *nvram_start_prev = NULL, *nvram_end_prev = NULL;
+	uint16 btype = 0, brev = 0;
+	int len  = 0;
+	char *field;
+
+	*nvram = NULL;
+	*nvram_len = 0;
+
+	if (strncmp(BCM_JUMBO_START, jumbonvram, strlen(BCM_JUMBO_START))) {
+		/* single nvram file in the native format */
+		DBUSTRACE(("%s: Non-Jumbo NVRAM File \n", __FUNCTION__));
+		*nvram = jumbonvram;
+		*nvram_len = jumbolen;
+		return DBUS_OK;
+	} else {
+		DBUSTRACE(("%s: Jumbo NVRAM File \n", __FUNCTION__));
+	}
+
+	/* sanity test the end of the config sets for proper ending */
+	if (jumbonvram[jumbolen - 1] != BCM_JUMBO_NVRAM_DELIMIT ||
+		jumbonvram[jumbolen - 2] != '\0') {
+		DBUSERR(("%s: Bad Jumbo NVRAM file format\n", __FUNCTION__));
+		return DBUS_JUMBO_BAD_FORMAT;
+	}
+
+	dbus_info->nvram_nontxt = DBUS_NVRAM_NONTXT;
+
+	nvram_start = jumbonvram;
+
+	while (*nvram_start != BCM_JUMBO_NVRAM_DELIMIT && len < jumbolen) {
+
+		/* consume the  first file info line
+		* \nBroadcom Jumbo Nvram file\nfile1\n ...
+		*/
+		len ++;
+		nvram_start ++;
+	}
+
+	nvram_end = nvram_start;
+
+	/* search for "boardrev=0xabcd" and "boardtype=0x1234" information in
+	* the concatenated nvram config files /sets
+	*/
+
+	while (len < jumbolen) {
+
+		if (*nvram_end == '\0') {
+			/* end of a config set is marked by multiple null characters */
+			len ++;
+			nvram_end ++;
+			DBUSTRACE(("%s: NULL chr len = %d char = 0x%x\n", __FUNCTION__,
+				len, *nvram_end));
+			continue;
+
+		} else if (*nvram_end == BCM_JUMBO_NVRAM_DELIMIT) {
+
+			/* config set delimiter is reached */
+			/* check if next config set is present or not
+			*  return  if next config is not present
+			*/
+
+			/* start search the next config set */
+			nvram_start_prev = nvram_start;
+			nvram_end_prev = nvram_end;
+
+			nvram_end ++;
+			nvram_start = nvram_end;
+			btype = brev = 0;
+			DBUSTRACE(("%s: going to next record len = %d "
+					"char = 0x%x \n", __FUNCTION__, len, *nvram_end));
+			len ++;
+			if (len >= jumbolen) {
+
+				*nvram = nvram_start_prev;
+				*nvram_len = (int)(nvram_end_prev - nvram_start_prev);
+
+				DBUSTRACE(("%s: no more len = %d nvram_end = 0x%p",
+					__FUNCTION__, len, nvram_end));
+
+				return DBUS_JUMBO_NOMATCH;
+
+			} else {
+				continue;
+			}
+
+		} else {
+
+			DBUSTRACE(("%s: config str = %s\n", __FUNCTION__, nvram_end));
+
+			if (bcmp(nvram_end, "boardtype", strlen("boardtype")) == 0) {
+
+				field = strchr(nvram_end, '=');
+				field++;
+				btype = (uint16)bcm_strtoul(field, NULL, 0);
+
+				DBUSTRACE(("%s: btype = 0x%x boardtype = 0x%x \n", __FUNCTION__,
+					btype, boardtype));
+			}
+
+			if (bcmp(nvram_end, "boardrev", strlen("boardrev")) == 0) {
+
+				field = strchr(nvram_end, '=');
+				field++;
+				brev = (uint16)bcm_strtoul(field, NULL, 0);
+
+				DBUSTRACE(("%s: brev = 0x%x boardrev = 0x%x \n", __FUNCTION__,
+					brev, boardrev));
+			}
+			if (btype == boardtype && brev == boardrev) {
+				/* locate nvram config set end - ie.find '\r' char */
+				while (*nvram_end != BCM_JUMBO_NVRAM_DELIMIT)
+					nvram_end ++;
+				*nvram = nvram_start;
+				*nvram_len = (int) (nvram_end - nvram_start);
+				DBUSTRACE(("found len = %d nvram_start = 0x%p "
+					"nvram_end = 0x%p\n", *nvram_len, nvram_start, nvram_end));
+				return DBUS_OK;
+			}
+
+			len += (strlen(nvram_end) + 1);
+			nvram_end += (strlen(nvram_end) + 1);
+		}
+	}
+	return DBUS_JUMBO_NOMATCH;
+} /* dbus_select_nvram */
+
+#if defined(BCM_DNGL_EMBEDIMAGE)
+
+/* store the global osh handle */
+static osl_t *osl_handle = NULL;
+
+/** this function is a combination of trx.c and bcmdl.c plus dbus adaptation */
+static int
+dbus_zlib_decomp(dbus_info_t *dbus_info)
+{
+
+	int method, flags, len, status;
+	unsigned int uncmp_len, uncmp_crc, dec_crc, crc_init;
+	struct trx_header *trx, *newtrx;
+	unsigned char *file = NULL;
+	unsigned char gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
+	z_stream d_stream;
+	unsigned char unused;
+	int actual_len = -1;
+	unsigned char *headers;
+	unsigned int trxhdrsize, nvramsize, decomp_memsize, i;
+
+	(void)actual_len;
+	(void)unused;
+	(void)crc_init;
+
+	osl_handle = dbus_info->pub.osh;
+	dbus_info->orig_fw = NULL;
+
+	headers = dbus_info->fw;
+	/* Extract trx header */
+	trx = (struct trx_header *)headers;
+	trxhdrsize = sizeof(struct trx_header);
+
+	if (ltoh32(trx->magic) != TRX_MAGIC) {
+		DBUSERR(("%s: Error: trx bad hdr %x\n", __FUNCTION__,
+			ltoh32(trx->magic)));
+		return -1;
+	}
+
+	headers += sizeof(struct trx_header);
+
+	if (ltoh32(trx->flag_version) & TRX_UNCOMP_IMAGE) {
+		actual_len = ltoh32(trx->offsets[TRX_OFFSETS_DLFWLEN_IDX]) +
+		                     sizeof(struct trx_header);
+		DBUSERR(("%s: not a compressed image\n", __FUNCTION__));
+		return 0;
+	} else {
+		/* Extract the gzip header info */
+		if ((*headers++ != gz_magic[0]) || (*headers++ != gz_magic[1])) {
+			DBUSERR(("%s: Error: gzip bad hdr\n", __FUNCTION__));
+			return -1;
+		}
+
+		method = (int) *headers++;
+		flags = (int) *headers++;
+
+		if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
+			DBUSERR(("%s: Error: gzip bad hdr not a Z_DEFLATED file\n", __FUNCTION__));
+			return -1;
+		}
+	}
+
+	/* Discard time, xflags and OS code: */
+	for (len = 0; len < 6; len++)
+		unused = *headers++;
+
+	if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
+		len = (uint32) *headers++;
+		len += ((uint32)*headers++)<<8;
+		/* len is garbage if EOF but the loop below will quit anyway */
+		while (len-- != 0) unused = *headers++;
+	}
+
+	if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
+		while (*headers++ && (*headers != 0));
+	}
+
+	if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
+		while (*headers++ && (*headers != 0));
+	}
+
+	if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
+		for (len = 0; len < 2; len++) unused = *headers++;
+	}
+
+	headers++;
+
+
+	/* create space for the uncompressed file */
+	/* the space is for trx header, uncompressed image  and nvram file */
+	/* with typical compression of 0.6, space double of firmware should be ok */
+
+	decomp_memsize = dbus_info->fwlen * 2;
+	dbus_info->decomp_memsize = decomp_memsize;
+	if (!(file = MALLOC(osl_handle, decomp_memsize))) {
+		DBUSERR(("%s: check_file : failed malloc\n", __FUNCTION__));
+		goto err;
+	}
+
+	bzero(file, decomp_memsize);
+
+	/* Initialise the decompression struct */
+	d_stream.next_in = NULL;
+	d_stream.avail_in = 0;
+	d_stream.next_out = NULL;
+	d_stream.avail_out = decomp_memsize - trxhdrsize;
+	d_stream.zalloc = (alloc_func)0;
+	d_stream.zfree = (free_func)0;
+	if (inflateInit2(&d_stream, -15) != Z_OK) {
+		DBUSERR(("%s: Err: inflateInit2\n", __FUNCTION__));
+		goto err;
+	}
+
+	/* Inflate the code */
+	d_stream.next_in = headers;
+	d_stream.avail_in = ltoh32(trx->len);
+	d_stream.next_out = (unsigned char*)(file + trxhdrsize);
+
+	status = inflate(&d_stream, Z_SYNC_FLUSH);
+
+	if (status != Z_STREAM_END)	{
+		DBUSERR(("%s: Error: decompression failed\n", __FUNCTION__));
+		goto err;
+	}
+
+	uncmp_crc = *d_stream.next_in++;
+	uncmp_crc |= *d_stream.next_in++<<8;
+	uncmp_crc |= *d_stream.next_in++<<16;
+	uncmp_crc |= *d_stream.next_in++<<24;
+
+	uncmp_len = *d_stream.next_in++;
+	uncmp_len |= *d_stream.next_in++<<8;
+	uncmp_len |= *d_stream.next_in++<<16;
+	uncmp_len |= *d_stream.next_in++<<24;
+
+	actual_len = (int) (d_stream.next_in - (unsigned char *)trx);
+
+	inflateEnd(&d_stream);
+
+	/* Do a CRC32 on the uncompressed data */
+	crc_init = crc32(0L, Z_NULL, 0);
+	dec_crc = crc32(crc_init, file + trxhdrsize, uncmp_len);
+
+	if (dec_crc != uncmp_crc) {
+		DBUSERR(("%s: decompression: bad crc check \n", __FUNCTION__));
+		goto err;
+	}
+	else {
+		DBUSTRACE(("%s: decompression: good crc check \n", __FUNCTION__));
+	}
+
+	/* rebuild the new trx header and calculate crc */
+	newtrx = (struct trx_header *)file;
+	newtrx->magic = trx->magic;
+	/* add the uncompressed image flag */
+	newtrx->flag_version = trx->flag_version;
+	newtrx->flag_version  |= htol32(TRX_UNCOMP_IMAGE);
+	newtrx->offsets[TRX_OFFSETS_DLFWLEN_IDX] = htol32(uncmp_len);
+	newtrx->offsets[TRX_OFFSETS_JUMPTO_IDX] = trx->offsets[TRX_OFFSETS_JUMPTO_IDX];
+	newtrx->offsets[TRX_OFFSETS_NVM_LEN_IDX] = trx->offsets[TRX_OFFSETS_NVM_LEN_IDX];
+
+	nvramsize = ltoh32(trx->offsets[TRX_OFFSETS_NVM_LEN_IDX]);
+
+	/* the original firmware has nvram file appended */
+	/* copy the nvram file to uncompressed firmware */
+
+	if (nvramsize) {
+		if (nvramsize + uncmp_len > decomp_memsize) {
+			DBUSERR(("%s: nvram cannot be accomodated\n", __FUNCTION__));
+			goto err;
+		}
+		bcopy(d_stream.next_in, &file[uncmp_len], nvramsize);
+		uncmp_len += nvramsize;
+	}
+
+	/* add trx header size to uncmp_len */
+	uncmp_len += trxhdrsize;
+	uncmp_len = ROUNDUP(uncmp_len, 4096);
+	newtrx->len	= htol32(uncmp_len);
+
+	/* Calculate CRC over header */
+	newtrx->crc32 = hndcrc32((uint8 *)&newtrx->flag_version,
+	sizeof(struct trx_header) - OFFSETOF(struct trx_header, flag_version),
+	CRC32_INIT_VALUE);
+
+	/* Calculate CRC over data */
+	for (i = trxhdrsize; i < (uncmp_len); ++i)
+				newtrx->crc32 = hndcrc32((uint8 *)&file[i], 1, newtrx->crc32);
+	newtrx->crc32 = htol32(newtrx->crc32);
+
+	dbus_info->orig_fw = dbus_info->fw;
+	dbus_info->origfw_len = dbus_info->fwlen;
+	dbus_info->image = dbus_info->fw = file;
+	dbus_info->image_len = dbus_info->fwlen = uncmp_len;
+
+	return 0;
+
+err:
+	if (file)
+		free(file);
+	return -1;
+} /* dbus_zlib_decomp */
+
+void *
+dbus_zlib_calloc(int num, int size)
+{
+	uint *ptr;
+	uint totalsize;
+
+	if (osl_handle == NULL)
+		return NULL;
+
+	totalsize = (num * (size + 1));
+
+	ptr  = MALLOC(osl_handle, totalsize);
+
+	if (ptr == NULL)
+		return NULL;
+	bzero(ptr, totalsize);
+
+	/* store the size in the first integer space */
+
+	ptr[0] = totalsize;
+
+	return ((void *) &ptr[1]);
+}
+
+void
+dbus_zlib_free(void *ptr)
+{
+	uint totalsize;
+	uchar *memptr = (uchar *)ptr;
+
+	if (ptr && osl_handle) {
+		memptr -= sizeof(uint);
+		totalsize = *(uint *) memptr;
+		MFREE(osl_handle, memptr, totalsize);
+	}
+}
+
+#endif /* #if defined(BCM_DNGL_EMBEDIMAGE) */
+#endif /* #if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
+
+
+#ifdef LINUX_EXTERNAL_MODULE_DBUS
+
+static int __init
+bcm_dbus_module_init(void)
+{
+	printf("Inserting bcm_dbus module \n");
+	return 0;
+}
+
+static void __exit
+bcm_dbus_module_exit(void)
+{
+	printf("Removing bcm_dbus module \n");
+	return;
+}
+
+EXPORT_SYMBOL(dbus_pnp_sleep);
+EXPORT_SYMBOL(dbus_register);
+EXPORT_SYMBOL(dbus_get_devinfo);
+EXPORT_SYMBOL(dbus_detach);
+EXPORT_SYMBOL(dbus_get_attrib);
+EXPORT_SYMBOL(dbus_down);
+EXPORT_SYMBOL(dbus_pnp_resume);
+EXPORT_SYMBOL(dbus_set_config);
+EXPORT_SYMBOL(dbus_flowctrl_rx);
+EXPORT_SYMBOL(dbus_up);
+EXPORT_SYMBOL(dbus_get_device_speed);
+EXPORT_SYMBOL(dbus_send_pkt);
+EXPORT_SYMBOL(dbus_recv_ctl);
+EXPORT_SYMBOL(dbus_attach);
+EXPORT_SYMBOL(dbus_deregister);
+
+MODULE_LICENSE("GPL");
+
+module_init(bcm_dbus_module_init);
+module_exit(bcm_dbus_module_exit);
+
+#endif  /* #ifdef LINUX_EXTERNAL_MODULE_DBUS */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus_usb.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus_usb.c
new file mode 100644
index 000000000000..f9106e8d0493
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus_usb.c
@@ -0,0 +1,1228 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Dongle BUS interface for USB, OS independent
+ *
+ * Copyright (C) 1999-2019, Broadcom Corporation
+ * 
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ * 
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ * 
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * $Id: dbus_usb.c 565557 2015-06-22 19:29:44Z $
+ */
+
+/**
+ * @file @brief
+ * This file contains DBUS code that is USB, but not OS specific. DBUS is a Broadcom proprietary
+ * host specific abstraction layer.
+ */
+
+#include <osl.h>
+#include <bcmdefs.h>
+#include <bcmutils.h>
+#include <dbus.h>
+#include <usbrdl.h>
+#include <bcmdevs.h>
+#include <bcmendian.h>
+
+#if defined(BCM_DNGL_EMBEDIMAGE)
+#ifdef EMBED_IMAGE_43236b
+#include "rtecdc_43236b.h"
+#endif /* EMBED_IMAGE_43236b */
+#ifdef EMBED_IMAGE_43526a
+#include "rtecdc_43526a.h"
+#endif /* EMBED_IMAGE_43526a */
+#ifdef EMBED_IMAGE_43526b
+#include "rtecdc_43526b.h"
+#endif /* EMBED_IMAGE_43526b */
+#ifdef EMBED_IMAGE_43242a0
+#include "rtecdc_43242a0.h"
+#endif /* EMBED_IMAGE_43242a0 */
+#ifdef EMBED_IMAGE_43143a0
+#include "rtecdc_43143a0.h"
+#endif /* EMBED_IMAGE_43143a0 */
+#ifdef EMBED_IMAGE_43143b0
+#include "rtecdc_43143b0.h"
+#endif /* EMBED_IMAGE_43143b0 */
+#ifdef EMBED_IMAGE_4350a0
+#include "rtecdc_4350a0.h"
+#endif /* EMBED_IMAGE_4350a0 */
+#ifdef EMBED_IMAGE_4350b0
+#include "rtecdc_4350b0.h"
+#endif /* EMBED_IMAGE_4350b0 */
+#ifdef EMBED_IMAGE_4350b1
+#include "rtecdc_4350b1.h"
+#endif /* EMBED_IMAGE_4350b1 */
+#ifdef EMBED_IMAGE_4350c0
+#include "rtecdc_4350c0.h"
+#endif /* EMBED_IMAGE_4350c0 */
+#ifdef EMBED_IMAGE_4350c1
+#include "rtecdc_4350c1.h"
+#endif /* EMBED_IMAGE_4350c1 */
+#ifdef EMBED_IMAGE_43556b1
+#include "rtecdc_43556b1.h"
+#endif /* EMBED_IMAGE_43556b1 */
+#ifdef EMBED_IMAGE_43569a0
+#include "rtecdc_43569a0.h"
+#endif /* EMBED_IMAGE_43569a0 */
+#ifdef EMBED_IMAGE_GENERIC
+#include "rtecdc.h"
+#endif
+#endif /* BCM_DNGL_EMBEDIMAGE */
+
+
+#define USB_DLIMAGE_RETRY_TIMEOUT    3000    /* retry Timeout */
+#define USB_SFLASH_DLIMAGE_SPINWAIT  150     /* in unit of ms */
+#define USB_SFLASH_DLIMAGE_LIMIT     2000    /* spinwait limit (ms) */
+#define POSTBOOT_ID                  0xA123  /* ID to detect if dongle has boot up */
+#define USB_RESETCFG_SPINWAIT        1       /* wait after resetcfg (ms) */
+#define USB_DEV_ISBAD(u)             (u->pub->attrib.devid == 0xDEAD)
+#define USB_DLGO_SPINWAIT            100     /* wait after DL_GO (ms) */
+#define TEST_CHIP                    0x4328
+
+typedef struct {
+	dbus_pub_t  *pub;
+
+	void        *cbarg;
+	dbus_intf_callbacks_t *cbs;  /** callbacks into higher DBUS level (dbus.c) */
+	dbus_intf_t *drvintf;
+	void        *usbosl_info;
+	uint32      rdlram_base_addr;
+	uint32      rdlram_size;
+} usb_info_t;
+
+/*
+ * Callbacks common to all USB
+ */
+static void dbus_usb_disconnect(void *handle);
+static void dbus_usb_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb);
+static void dbus_usb_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status);
+static void dbus_usb_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status);
+static void dbus_usb_errhandler(void *handle, int err);
+static void dbus_usb_ctl_complete(void *handle, int type, int status);
+static void dbus_usb_state_change(void *handle, int state);
+static struct dbus_irb* dbus_usb_getirb(void *handle, bool send);
+static void dbus_usb_rxerr_indicate(void *handle, bool on);
+static int dbus_usb_resetcfg(usb_info_t *usbinfo);
+static int dbus_usb_iovar_op(void *bus, const char *name,
+	void *params, int plen, void *arg, int len, bool set);
+static int dbus_iovar_process(usb_info_t* usbinfo, const char *name,
+                 void *params, int plen, void *arg, int len, bool set);
+static int dbus_usb_doiovar(usb_info_t *bus, const bcm_iovar_t *vi, uint32 actionid,
+	const char *name, void *params, int plen, void *arg, int len, int val_size);
+static int dhdusb_downloadvars(usb_info_t *bus, void *arg, int len);
+
+static int dbus_usb_dl_writeimage(usb_info_t *usbinfo, uint8 *fw, int fwlen);
+static int dbus_usb_dlstart(void *bus, uint8 *fw, int len);
+static bool dbus_usb_dlneeded(void *bus);
+static int dbus_usb_dlrun(void *bus);
+static int dbus_usb_rdl_dwnld_state(usb_info_t *usbinfo);
+
+#ifdef BCM_DNGL_EMBEDIMAGE
+static bool dbus_usb_device_exists(void *bus);
+#endif
+
+/* OS specific */
+extern bool dbus_usbos_dl_cmd(void *info, uint8 cmd, void *buffer, int buflen);
+extern int dbus_usbos_wait(void *info, uint16 ms);
+extern int dbus_write_membytes(usb_info_t *usbinfo, bool set, uint32 address,
+	uint8 *data, uint size);
+extern bool dbus_usbos_dl_send_bulk(void *info, void *buffer, int len);
+extern int dbus_usbos_loopback_tx(void *usbos_info_ptr, int cnt, int size);
+
+/**
+ * These functions are called by the lower DBUS level (dbus_usb_os.c) to notify this DBUS level
+ * (dbus_usb.c) of an event.
+ */
+static dbus_intf_callbacks_t dbus_usb_intf_cbs = {
+	dbus_usb_send_irb_timeout,
+	dbus_usb_send_irb_complete,
+	dbus_usb_recv_irb_complete,
+	dbus_usb_errhandler,
+	dbus_usb_ctl_complete,
+	dbus_usb_state_change,
+	NULL,			/* isr */
+	NULL,			/* dpc */
+	NULL,			/* watchdog */
+	NULL,			/* dbus_if_pktget */
+	NULL, 			/* dbus_if_pktfree */
+	dbus_usb_getirb,
+	dbus_usb_rxerr_indicate
+};
+
+/* IOVar table */
+enum {
+	IOV_SET_DOWNLOAD_STATE = 1,
+	IOV_MEMBYTES,
+	IOV_VARS,
+	IOV_LOOPBACK_TX
+};
+
+const bcm_iovar_t dhdusb_iovars[] = {
+	{"vars",	IOV_VARS,	0,	IOVT_BUFFER,	0 },
+	{"dwnldstate",	IOV_SET_DOWNLOAD_STATE,	0,	IOVT_BOOL,	0 },
+	{"membytes",	IOV_MEMBYTES,	0,	IOVT_BUFFER,	2 * sizeof(int) },
+	{"usb_lb_txfer", IOV_LOOPBACK_TX, 0,    IOVT_BUFFER,    2 * sizeof(int) },
+	{NULL, 0, 0, 0, 0 }
+};
+
+/*
+ * Need global for probe() and disconnect() since
+ * attach() is not called at probe and detach()
+ * can be called inside disconnect()
+ */
+static probe_cb_t	probe_cb = NULL;
+static disconnect_cb_t	disconnect_cb = NULL;
+static void		*probe_arg = NULL;
+static void		*disc_arg = NULL;
+static dbus_intf_t	*g_dbusintf = NULL;
+static dbus_intf_t	dbus_usb_intf; /** functions called by higher layer DBUS into lower layer */
+
+/*
+ * dbus_intf_t common to all USB
+ * These functions override dbus_usb_<os>.c.
+ */
+static void *dbus_usb_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs);
+static void dbus_usb_detach(dbus_pub_t *pub, void *info);
+static void * dbus_usb_probe(void *arg, const char *desc, uint32 bustype, uint32 hdrlen);
+
+/* functions */
+
+/**
+ * As part of DBUS initialization/registration, the higher level DBUS (dbus.c) needs to know what
+ * lower level DBUS functions to call (in both dbus_usb.c and dbus_usb_os.c).
+ */
+static void *
+dbus_usb_probe(void *arg, const char *desc, uint32 bustype, uint32 hdrlen)
+{
+	DBUSTRACE(("%s(): \n", __FUNCTION__));
+	if (probe_cb) {
+
+		if (g_dbusintf != NULL) {
+			/* First, initialize all lower-level functions as default
+			 * so that dbus.c simply calls directly to dbus_usb_os.c.
+			 */
+			bcopy(g_dbusintf, &dbus_usb_intf, sizeof(dbus_intf_t));
+
+			/* Second, selectively override functions we need, if any. */
+			dbus_usb_intf.attach = dbus_usb_attach;
+			dbus_usb_intf.detach = dbus_usb_detach;
+			dbus_usb_intf.iovar_op = dbus_usb_iovar_op;
+			dbus_usb_intf.dlstart = dbus_usb_dlstart;
+			dbus_usb_intf.dlneeded = dbus_usb_dlneeded;
+			dbus_usb_intf.dlrun = dbus_usb_dlrun;
+#ifdef BCM_DNGL_EMBEDIMAGE
+			dbus_usb_intf.device_exists = dbus_usb_device_exists;
+#endif
+		}
+
+		disc_arg = probe_cb(probe_arg, "DBUS USB", USB_BUS, hdrlen);
+		return disc_arg;
+	}
+
+	return NULL;
+}
+
+/**
+ * On return, *intf contains this or lower-level DBUS functions to be called by higher
+ * level (dbus.c)
+ */
+int
+dbus_bus_register(int vid, int pid, probe_cb_t prcb,
+	disconnect_cb_t discb, void *prarg, dbus_intf_t **intf, void *param1, void *param2)
+{
+	int err;
+
+	DBUSTRACE(("%s(): \n", __FUNCTION__));
+	probe_cb = prcb;
+	disconnect_cb = discb;
+	probe_arg = prarg;
+
+	*intf = &dbus_usb_intf;
+
+	err = dbus_bus_osl_register(vid, pid, dbus_usb_probe,
+		dbus_usb_disconnect, NULL, &g_dbusintf, param1, param2);
+
+	ASSERT(g_dbusintf);
+	return err;
+}
+
+int
+dbus_bus_deregister()
+{
+	DBUSTRACE(("%s(): \n", __FUNCTION__));
+	return dbus_bus_osl_deregister();
+}
+
+/** initialization consists of registration followed by 'attach'. */
+void *
+dbus_usb_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs)
+{
+	usb_info_t *usb_info;
+
+	DBUSTRACE(("%s(): \n", __FUNCTION__));
+
+	if ((g_dbusintf == NULL) || (g_dbusintf->attach == NULL))
+		return NULL;
+
+	/* Sanity check for BUS_INFO() */
+	ASSERT(OFFSETOF(usb_info_t, pub) == 0);
+
+	usb_info = MALLOC(pub->osh, sizeof(usb_info_t));
+	if (usb_info == NULL)
+		return NULL;
+
+	bzero(usb_info, sizeof(usb_info_t));
+
+	usb_info->pub = pub;
+	usb_info->cbarg = cbarg;
+	usb_info->cbs = cbs;
+
+	usb_info->usbosl_info = (dbus_pub_t *)g_dbusintf->attach(pub,
+		usb_info, &dbus_usb_intf_cbs);
+	if (usb_info->usbosl_info == NULL) {
+		MFREE(pub->osh, usb_info, sizeof(usb_info_t));
+		return NULL;
+	}
+
+	/* Save USB OS-specific driver entry points */
+	usb_info->drvintf = g_dbusintf;
+
+	pub->bus = usb_info;
+#if  !defined(BCM_DNGL_EMBEDIMAGE) && !defined(BCM_REQUEST_FW)
+
+	if (!dbus_usb_resetcfg(usb_info)) {
+	usb_info->pub->busstate = DBUS_STATE_DL_DONE;
+	}
+#endif
+	/* Return Lower layer info */
+	return (void *) usb_info->usbosl_info;
+}
+
+void
+dbus_usb_detach(dbus_pub_t *pub, void *info)
+{
+	usb_info_t *usb_info = (usb_info_t *) pub->bus;
+	osl_t *osh = pub->osh;
+
+	if (usb_info == NULL)
+		return;
+
+	if (usb_info->drvintf && usb_info->drvintf->detach)
+		usb_info->drvintf->detach(pub, usb_info->usbosl_info);
+
+	MFREE(osh, usb_info, sizeof(usb_info_t));
+}
+
+void
+dbus_usb_disconnect(void *handle)
+{
+	DBUSTRACE(("%s(): \n", __FUNCTION__));
+	if (disconnect_cb)
+		disconnect_cb(disc_arg);
+}
+
+/**
+ * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
+ * notified.
+ */
+static void
+dbus_usb_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb)
+{
+	usb_info_t *usb_info = (usb_info_t *) handle;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (usb_info == NULL)
+		return;
+
+	if (usb_info->cbs && usb_info->cbs->send_irb_timeout)
+		usb_info->cbs->send_irb_timeout(usb_info->cbarg, txirb);
+}
+
+/**
+ * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
+ * notified.
+ */
+static void
+dbus_usb_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status)
+{
+	usb_info_t *usb_info = (usb_info_t *) handle;
+
+	if (usb_info == NULL)
+		return;
+
+	if (usb_info->cbs && usb_info->cbs->send_irb_complete)
+		usb_info->cbs->send_irb_complete(usb_info->cbarg, txirb, status);
+}
+
+/**
+ * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
+ * notified.
+ */
+static void
+dbus_usb_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status)
+{
+	usb_info_t *usb_info = (usb_info_t *) handle;
+
+	if (usb_info == NULL)
+		return;
+
+	if (usb_info->cbs && usb_info->cbs->recv_irb_complete)
+		usb_info->cbs->recv_irb_complete(usb_info->cbarg, rxirb, status);
+}
+
+/** Lower DBUS level (dbus_usb_os.c) requests a free IRB. Pass this on to the higher DBUS level. */
+static struct dbus_irb*
+dbus_usb_getirb(void *handle, bool send)
+{
+	usb_info_t *usb_info = (usb_info_t *) handle;
+
+	if (usb_info == NULL)
+		return NULL;
+
+	if (usb_info->cbs && usb_info->cbs->getirb)
+		return usb_info->cbs->getirb(usb_info->cbarg, send);
+
+	return NULL;
+}
+
+/**
+ * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
+ * notified.
+ */
+static void
+dbus_usb_rxerr_indicate(void *handle, bool on)
+{
+	usb_info_t *usb_info = (usb_info_t *) handle;
+
+	if (usb_info == NULL)
+		return;
+
+	if (usb_info->cbs && usb_info->cbs->rxerr_indicate)
+		usb_info->cbs->rxerr_indicate(usb_info->cbarg, on);
+}
+
+/**
+ * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
+ * notified.
+ */
+static void
+dbus_usb_errhandler(void *handle, int err)
+{
+	usb_info_t *usb_info = (usb_info_t *) handle;
+
+	if (usb_info == NULL)
+		return;
+
+	if (usb_info->cbs && usb_info->cbs->errhandler)
+		usb_info->cbs->errhandler(usb_info->cbarg, err);
+}
+
+/**
+ * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
+ * notified.
+ */
+static void
+dbus_usb_ctl_complete(void *handle, int type, int status)
+{
+	usb_info_t *usb_info = (usb_info_t *) handle;
+
+	if (usb_info == NULL)
+		return;
+
+	if (usb_info->cbs && usb_info->cbs->ctl_complete)
+		usb_info->cbs->ctl_complete(usb_info->cbarg, type, status);
+}
+
+/**
+ * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
+ * notified.
+ */
+static void
+dbus_usb_state_change(void *handle, int state)
+{
+	usb_info_t *usb_info = (usb_info_t *) handle;
+
+	if (usb_info == NULL)
+		return;
+
+	if (usb_info->cbs && usb_info->cbs->state_change)
+		usb_info->cbs->state_change(usb_info->cbarg, state);
+}
+
+/** called by higher DBUS level (dbus.c) */
+static int
+dbus_usb_iovar_op(void *bus, const char *name,
+	void *params, int plen, void *arg, int len, bool set)
+{
+	int err = DBUS_OK;
+
+	err = dbus_iovar_process((usb_info_t*)bus, name, params, plen, arg, len, set);
+	return err;
+}
+
+/** process iovar request from higher DBUS level */
+static int
+dbus_iovar_process(usb_info_t* usbinfo, const char *name,
+                 void *params, int plen, void *arg, int len, bool set)
+{
+	const bcm_iovar_t *vi = NULL;
+	int bcmerror = 0;
+	int val_size;
+	uint32 actionid;
+
+	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
+
+	ASSERT(name);
+	ASSERT(len >= 0);
+
+	/* Get MUST have return space */
+	ASSERT(set || (arg && len));
+
+	/* Set does NOT take qualifiers */
+	ASSERT(!set || (!params && !plen));
+
+	/* Look up var locally; if not found pass to host driver */
+	if ((vi = bcm_iovar_lookup(dhdusb_iovars, name)) == NULL) {
+		/* Not Supported */
+		bcmerror = BCME_UNSUPPORTED;
+		DBUSTRACE(("%s: IOVAR %s is not supported\n", name, __FUNCTION__));
+		goto exit;
+
+	}
+
+	DBUSTRACE(("%s: %s %s, len %d plen %d\n", __FUNCTION__,
+	         name, (set ? "set" : "get"), len, plen));
+
+	/* set up 'params' pointer in case this is a set command so that
+	 * the convenience int and bool code can be common to set and get
+	 */
+	if (params == NULL) {
+		params = arg;
+		plen = len;
+	}
+
+	if (vi->type == IOVT_VOID)
+		val_size = 0;
+	else if (vi->type == IOVT_BUFFER)
+		val_size = len;
+	else
+		/* all other types are integer sized */
+		val_size = sizeof(int);
+
+	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
+	bcmerror = dbus_usb_doiovar(usbinfo, vi, actionid,
+		name, params, plen, arg, len, val_size);
+
+exit:
+	return bcmerror;
+} /* dbus_iovar_process */
+
+static int
+dbus_usb_doiovar(usb_info_t *bus, const bcm_iovar_t *vi, uint32 actionid, const char *name,
+                void *params, int plen, void *arg, int len, int val_size)
+{
+	int bcmerror = 0;
+	int32 int_val = 0;
+	int32 int_val2 = 0;
+	bool bool_val = 0;
+
+	DBUSTRACE(("%s: Enter, action %d name %s params %p plen %d arg %p len %d val_size %d\n",
+	           __FUNCTION__, actionid, name, params, plen, arg, len, val_size));
+
+	if ((bcmerror = bcm_iovar_lencheck(vi, arg, len, IOV_ISSET(actionid))) != 0)
+		goto exit;
+
+	if (plen >= (int)sizeof(int_val))
+		bcopy(params, &int_val, sizeof(int_val));
+
+	if (plen >= (int)sizeof(int_val) * 2)
+		bcopy((void*)((uintptr)params + sizeof(int_val)), &int_val2, sizeof(int_val2));
+
+	bool_val = (int_val != 0) ? TRUE : FALSE;
+
+	switch (actionid) {
+
+	case IOV_SVAL(IOV_MEMBYTES):
+	case IOV_GVAL(IOV_MEMBYTES):
+	{
+		uint32 address;
+		uint size, dsize;
+		uint8 *data;
+
+		bool set = (actionid == IOV_SVAL(IOV_MEMBYTES));
+
+		ASSERT(plen >= 2*sizeof(int));
+
+		address = (uint32)int_val;
+		BCM_REFERENCE(address);
+		bcopy((char *)params + sizeof(int_val), &int_val, sizeof(int_val));
+		size = (uint)int_val;
+
+		/* Do some validation */
+		dsize = set ? plen - (2 * sizeof(int)) : len;
+		if (dsize < size) {
+			DBUSTRACE(("%s: error on %s membytes, addr 0x%08x size %d dsize %d\n",
+			           __FUNCTION__, (set ? "set" : "get"), address, size, dsize));
+			bcmerror = BCME_BADARG;
+			break;
+		}
+		DBUSTRACE(("%s: Request to %s %d bytes at address 0x%08x\n", __FUNCTION__,
+		          (set ? "write" : "read"), size, address));
+
+		/* Generate the actual data pointer */
+		data = set ? (uint8*)params + 2 * sizeof(int): (uint8*)arg;
+
+		/* Call to do the transfer */
+		bcmerror = dbus_usb_dl_writeimage(BUS_INFO(bus, usb_info_t), data, size);
+	}
+		break;
+
+
+	case IOV_SVAL(IOV_SET_DOWNLOAD_STATE):
+
+		if (bool_val == TRUE) {
+			bcmerror = dbus_usb_dlneeded(bus);
+			dbus_usb_rdl_dwnld_state(BUS_INFO(bus, usb_info_t));
+		} else {
+			usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
+			bcmerror = dbus_usb_dlrun(bus);
+			usbinfo->pub->busstate = DBUS_STATE_DL_DONE;
+		}
+		break;
+
+	case IOV_SVAL(IOV_VARS):
+		bcmerror = dhdusb_downloadvars(BUS_INFO(bus, usb_info_t), arg, len);
+		break;
+#ifdef DBUS_USB_LOOPBACK
+	case IOV_SVAL(IOV_LOOPBACK_TX):
+			bcmerror = dbus_usbos_loopback_tx(BUS_INFO(bus, usb_info_t), int_val,
+			  int_val2);
+			break;
+#endif
+	default:
+		bcmerror = BCME_UNSUPPORTED;
+		break;
+	}
+
+exit:
+	return bcmerror;
+} /* dbus_usb_doiovar */
+
+/** higher DBUS level (dbus.c) wants to set NVRAM variables in dongle */
+static int
+dhdusb_downloadvars(usb_info_t *bus, void *arg, int len)
+{
+	int bcmerror = 0;
+	uint32 varsize;
+	uint32 varaddr;
+	uint32 varsizew;
+
+	if (!len) {
+		bcmerror = BCME_BUFTOOSHORT;
+		goto err;
+	}
+
+	/* RAM size is not set. Set it at dbus_usb_dlneeded */
+	if (!bus->rdlram_size)
+		bcmerror = BCME_ERROR;
+
+	/* Even if there are no vars are to be written, we still need to set the ramsize. */
+	varsize = len ? ROUNDUP(len, 4) : 0;
+	varaddr = (bus->rdlram_size - 4) - varsize;
+
+	/* Write the vars list */
+	DBUSTRACE(("WriteVars: @%x varsize=%d\n", varaddr, varsize));
+	bcmerror = dbus_write_membytes(bus->usbosl_info, TRUE, (varaddr + bus->rdlram_base_addr),
+		arg, varsize);
+
+	/* adjust to the user specified RAM */
+	DBUSTRACE(("Usable memory size: %d\n", bus->rdlram_size));
+	DBUSTRACE(("Vars are at %d, orig varsize is %d\n", varaddr, varsize));
+
+	varsize = ((bus->rdlram_size - 4) - varaddr);
+
+	/*
+	 * Determine the length token:
+	 * Varsize, converted to words, in lower 16-bits, checksum in upper 16-bits.
+	 */
+	if (bcmerror) {
+		varsizew = 0;
+	} else {
+		varsizew = varsize / 4;
+		varsizew = (~varsizew << 16) | (varsizew & 0x0000FFFF);
+		varsizew = htol32(varsizew);
+	}
+
+	DBUSTRACE(("New varsize is %d, length token=0x%08x\n", varsize, varsizew));
+
+	/* Write the length token to the last word */
+	bcmerror = dbus_write_membytes(bus->usbosl_info, TRUE, ((bus->rdlram_size - 4) +
+		bus->rdlram_base_addr), (uint8*)&varsizew, 4);
+err:
+	return bcmerror;
+} /* dbus_usb_doiovar */
+
+/**
+ * After downloading firmware into dongle and starting it, we need to know if the firmware is
+ * indeed up and running.
+ */
+static int
+dbus_usb_resetcfg(usb_info_t *usbinfo)
+{
+	void *osinfo;
+	bootrom_id_t id;
+	uint16 waittime = 0;
+
+	uint32 starttime = 0;
+	uint32 endtime = 0;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (usbinfo == NULL)
+		return DBUS_ERR;
+
+	osinfo = usbinfo->usbosl_info;
+	ASSERT(osinfo);
+
+	/* Give dongle chance to boot */
+	dbus_usbos_wait(osinfo, USB_SFLASH_DLIMAGE_SPINWAIT);
+	waittime = USB_SFLASH_DLIMAGE_SPINWAIT;
+	while (waittime < USB_DLIMAGE_RETRY_TIMEOUT) {
+
+		starttime = OSL_SYSUPTIME();
+
+		id.chip = 0xDEAD;       /* Get the ID */
+		dbus_usbos_dl_cmd(osinfo, DL_GETVER, &id, sizeof(bootrom_id_t));
+		id.chip = ltoh32(id.chip);
+
+		endtime = OSL_SYSUPTIME();
+		waittime += (endtime - starttime);
+
+		if (id.chip == POSTBOOT_ID)
+			break;
+	}
+
+	if (id.chip == POSTBOOT_ID) {
+		DBUSERR(("%s: download done. Bootup time = %d ms postboot chip 0x%x/rev 0x%x\n",
+			__FUNCTION__, waittime, id.chip, id.chiprev));
+
+		dbus_usbos_dl_cmd(osinfo, DL_RESETCFG, &id, sizeof(bootrom_id_t));
+
+		dbus_usbos_wait(osinfo, USB_RESETCFG_SPINWAIT);
+		return DBUS_OK;
+	} else {
+		DBUSERR(("%s: Cannot talk to Dongle. Wait time = %d ms. Firmware is not UP \n",
+			__FUNCTION__, waittime));
+		return DBUS_ERR;
+	}
+
+	return DBUS_OK;
+}
+
+/** before firmware download, the dongle has to be prepared to receive the fw image */
+static int
+dbus_usb_rdl_dwnld_state(usb_info_t *usbinfo)
+{
+	void *osinfo = usbinfo->usbosl_info;
+	rdl_state_t state;
+	int err = DBUS_OK;
+
+	/* 1) Prepare USB boot loader for runtime image */
+	dbus_usbos_dl_cmd(osinfo, DL_START, &state, sizeof(rdl_state_t));
+
+	state.state = ltoh32(state.state);
+	state.bytes = ltoh32(state.bytes);
+
+	/* 2) Check we are in the Waiting state */
+	if (state.state != DL_WAITING) {
+		DBUSERR(("%s: Failed to DL_START\n", __FUNCTION__));
+		err = DBUS_ERR;
+		goto fail;
+	}
+
+fail:
+	return err;
+}
+
+/**
+ * Dongle contains bootcode in ROM but firmware is (partially) contained in dongle RAM. Therefore,
+ * firmware has to be downloaded into dongle RAM.
+ */
+static int
+dbus_usb_dl_writeimage(usb_info_t *usbinfo, uint8 *fw, int fwlen)
+{
+	osl_t *osh = usbinfo->pub->osh;
+	void *osinfo = usbinfo->usbosl_info;
+	unsigned int sendlen, sent, dllen;
+	char *bulkchunk = NULL, *dlpos;
+	rdl_state_t state;
+	int err = DBUS_OK;
+	bootrom_id_t id;
+	uint16 wait, wait_time;
+	uint32 dl_trunk_size = RDL_CHUNK;
+
+	if (BCM4350_CHIP(usbinfo->pub->attrib.devid))
+		dl_trunk_size = RDL_CHUNK_MAX;
+
+	while (!bulkchunk) {
+		bulkchunk = MALLOC(osh, dl_trunk_size);
+		if (dl_trunk_size == RDL_CHUNK)
+			break;
+		if (!bulkchunk) {
+			dl_trunk_size /= 2;
+			if (dl_trunk_size < RDL_CHUNK)
+				dl_trunk_size = RDL_CHUNK;
+		}
+	}
+
+	if (bulkchunk == NULL) {
+		err = DBUS_ERR;
+		goto fail;
+	}
+
+	sent = 0;
+	dlpos = fw;
+	dllen = fwlen;
+
+	/* Get chip id and rev */
+	id.chip = usbinfo->pub->attrib.devid;
+	id.chiprev = usbinfo->pub->attrib.chiprev;
+
+	DBUSTRACE(("enter %s: fwlen=%d\n", __FUNCTION__, fwlen));
+
+	dbus_usbos_dl_cmd(osinfo, DL_GETSTATE, &state, sizeof(rdl_state_t));
+
+	/* 3) Load the image */
+	while ((sent < dllen)) {
+		/* Wait until the usb device reports it received all the bytes we sent */
+
+		if (sent < dllen) {
+			if ((dllen-sent) < dl_trunk_size)
+				sendlen = dllen-sent;
+			else
+				sendlen = dl_trunk_size;
+
+			/* simply avoid having to send a ZLP by ensuring we never have an even
+			 * multiple of 64
+			 */
+			if (!(sendlen % 64))
+				sendlen -= 4;
+
+			/* send data */
+			memcpy(bulkchunk, dlpos, sendlen);
+			if (!dbus_usbos_dl_send_bulk(osinfo, bulkchunk, sendlen)) {
+				err = DBUS_ERR;
+				goto fail;
+			}
+
+			dlpos += sendlen;
+			sent += sendlen;
+			DBUSTRACE(("%s: sendlen %d\n", __FUNCTION__, sendlen));
+		}
+
+		wait = 0;
+		wait_time = USB_SFLASH_DLIMAGE_SPINWAIT;
+		while (!dbus_usbos_dl_cmd(osinfo, DL_GETSTATE, &state,
+			sizeof(rdl_state_t))) {
+			if ((id.chip == 43236) && (id.chiprev == 0)) {
+				DBUSERR(("%s: 43236a0 SFlash delay, waiting for dongle crc check "
+					 "completion!!!\n", __FUNCTION__));
+				dbus_usbos_wait(osinfo, wait_time);
+				wait += wait_time;
+				if (wait >= USB_SFLASH_DLIMAGE_LIMIT) {
+					DBUSERR(("%s: DL_GETSTATE Failed xxxx\n", __FUNCTION__));
+					err = DBUS_ERR;
+					goto fail;
+					break;
+				}
+			} else {
+				DBUSERR(("%s: DL_GETSTATE Failed xxxx\n", __FUNCTION__));
+				err = DBUS_ERR;
+				goto fail;
+			}
+		}
+
+		state.state = ltoh32(state.state);
+		state.bytes = ltoh32(state.bytes);
+
+		/* restart if an error is reported */
+		if ((state.state == DL_BAD_HDR) || (state.state == DL_BAD_CRC)) {
+			DBUSERR(("%s: Bad Hdr or Bad CRC\n", __FUNCTION__));
+			err = DBUS_ERR;
+			goto fail;
+		}
+
+	}
+fail:
+	if (bulkchunk)
+		MFREE(osh, bulkchunk, dl_trunk_size);
+
+	return err;
+} /* dbus_usb_dl_writeimage */
+
+/** Higher level DBUS layer (dbus.c) requests this layer to download image into dongle */
+static int
+dbus_usb_dlstart(void *bus, uint8 *fw, int len)
+{
+	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
+	int err;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (usbinfo == NULL)
+		return DBUS_ERR;
+
+	if (USB_DEV_ISBAD(usbinfo))
+		return DBUS_ERR;
+
+	err = dbus_usb_rdl_dwnld_state(usbinfo);
+
+	if (DBUS_OK == err) {
+	err = dbus_usb_dl_writeimage(usbinfo, fw, len);
+	if (err == DBUS_OK)
+		usbinfo->pub->busstate = DBUS_STATE_DL_DONE;
+	else
+		usbinfo->pub->busstate = DBUS_STATE_DL_PENDING;
+	} else
+		usbinfo->pub->busstate = DBUS_STATE_DL_PENDING;
+
+	return err;
+}
+
+static bool
+dbus_usb_update_chipinfo(usb_info_t *usbinfo, uint32 chip)
+{
+	bool retval = TRUE;
+	/* based on the CHIP Id, store the ram size which is needed for NVRAM download. */
+	switch (chip) {
+
+		case 0x4319:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_4319;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4319;
+			break;
+
+		case 0x4329:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_4329;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4329;
+			break;
+
+		case 43234:
+		case 43235:
+		case 43236:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_43236;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_43236;
+			break;
+
+		case 0x4328:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_4328;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4328;
+			break;
+
+		case 0x4322:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_4322;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4322;
+			break;
+
+		case 0x4360:
+		case 0xAA06:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_4360;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4360;
+			break;
+
+		case 43242:
+		case 43243:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_43242;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_43242;
+			break;
+
+		case 43143:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_43143;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_43143;
+			break;
+
+		case 0x4350:
+		case 43556:
+		case 43558:
+		case 43569:
+			usbinfo->rdlram_size = RDL_RAM_SIZE_4350;
+			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4350;
+			break;
+
+		case POSTBOOT_ID:
+			break;
+
+		default:
+			DBUSERR(("%s: Chip 0x%x Ram size is not known\n", __FUNCTION__, chip));
+			retval = FALSE;
+			break;
+
+	}
+
+	return retval;
+} /* dbus_usb_update_chipinfo */
+
+/** higher DBUS level (dbus.c) wants to know if firmware download is required. */
+static bool
+dbus_usb_dlneeded(void *bus)
+{
+	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
+	void *osinfo;
+	bootrom_id_t id;
+	bool dl_needed = TRUE;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (usbinfo == NULL)
+		return FALSE;
+
+	osinfo = usbinfo->usbosl_info;
+	ASSERT(osinfo);
+
+	/* Check if firmware downloaded already by querying runtime ID */
+	id.chip = 0xDEAD;
+	dbus_usbos_dl_cmd(osinfo, DL_GETVER, &id, sizeof(bootrom_id_t));
+
+	id.chip = ltoh32(id.chip);
+	id.chiprev = ltoh32(id.chiprev);
+
+	if (FALSE == dbus_usb_update_chipinfo(usbinfo, id.chip)) {
+		dl_needed = FALSE;
+		goto exit;
+	}
+
+	DBUSERR(("%s: chip 0x%x rev 0x%x\n", __FUNCTION__, id.chip, id.chiprev));
+	if (id.chip == POSTBOOT_ID) {
+		/* This code is  needed to support two enumerations on USB1.1 scenario */
+		DBUSERR(("%s: Firmware already downloaded\n", __FUNCTION__));
+
+		dbus_usbos_dl_cmd(osinfo, DL_RESETCFG, &id, sizeof(bootrom_id_t));
+		dl_needed = FALSE;
+		if (usbinfo->pub->busstate == DBUS_STATE_DL_PENDING)
+			usbinfo->pub->busstate = DBUS_STATE_DL_DONE;
+	} else {
+		usbinfo->pub->attrib.devid = id.chip;
+		usbinfo->pub->attrib.chiprev = id.chiprev;
+	}
+
+exit:
+	return dl_needed;
+}
+
+/** After issuing firmware download, higher DBUS level (dbus.c) wants to start the firmware. */
+static int
+dbus_usb_dlrun(void *bus)
+{
+	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
+	void *osinfo;
+	rdl_state_t state;
+	int err = DBUS_OK;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (usbinfo == NULL)
+		return DBUS_ERR;
+
+	if (USB_DEV_ISBAD(usbinfo))
+		return DBUS_ERR;
+
+	osinfo = usbinfo->usbosl_info;
+	ASSERT(osinfo);
+
+	/* Check we are runnable */
+	dbus_usbos_dl_cmd(osinfo, DL_GETSTATE, &state, sizeof(rdl_state_t));
+
+	state.state = ltoh32(state.state);
+	state.bytes = ltoh32(state.bytes);
+
+	/* Start the image */
+	if (state.state == DL_RUNNABLE) {
+		DBUSTRACE(("%s: Issue DL_GO\n", __FUNCTION__));
+		dbus_usbos_dl_cmd(osinfo, DL_GO, &state, sizeof(rdl_state_t));
+
+		if (usbinfo->pub->attrib.devid == TEST_CHIP)
+			dbus_usbos_wait(osinfo, USB_DLGO_SPINWAIT);
+
+		dbus_usb_resetcfg(usbinfo);
+		/* The Donlge may go for re-enumeration. */
+	} else {
+		DBUSERR(("%s: Dongle not runnable\n", __FUNCTION__));
+		err = DBUS_ERR;
+	}
+
+	return err;
+}
+
+/**
+ * As preparation for firmware download, higher DBUS level (dbus.c) requests the firmware image
+ * to be used for the type of dongle detected. Directly called by dbus.c (so not via a callback
+ * construction)
+ */
+void
+dbus_bus_fw_get(void *bus, uint8 **fw, int *fwlen, int *decomp)
+{
+	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
+	unsigned int devid;
+	unsigned int crev;
+
+	devid = usbinfo->pub->attrib.devid;
+	crev = usbinfo->pub->attrib.chiprev;
+
+	*fw = NULL;
+	*fwlen = 0;
+
+	switch (devid) {
+	case BCM43236_CHIP_ID:
+	case BCM43235_CHIP_ID:
+	case BCM43234_CHIP_ID:
+	case BCM43238_CHIP_ID: {
+		if (crev == 3 || crev == 2 || crev == 1) {
+#ifdef EMBED_IMAGE_43236b
+			*fw = (uint8 *)dlarray_43236b;
+			*fwlen = sizeof(dlarray_43236b);
+
+#endif
+		}
+		} break;
+	case BCM4360_CHIP_ID:
+	case BCM4352_CHIP_ID:
+	case BCM43526_CHIP_ID:
+#ifdef EMBED_IMAGE_43526a
+		if (crev <= 2) {
+			*fw = (uint8 *)dlarray_43526a;
+			*fwlen = sizeof(dlarray_43526a);
+		}
+#endif
+#ifdef EMBED_IMAGE_43526b
+		if (crev > 2) {
+			*fw = (uint8 *)dlarray_43526b;
+			*fwlen = sizeof(dlarray_43526b);
+		}
+#endif
+		break;
+
+	case BCM43242_CHIP_ID:
+#ifdef EMBED_IMAGE_43242a0
+		*fw = (uint8 *)dlarray_43242a0;
+		*fwlen = sizeof(dlarray_43242a0);
+#endif
+		break;
+
+	case BCM43143_CHIP_ID:
+#ifdef EMBED_IMAGE_43143a0
+		*fw = (uint8 *)dlarray_43143a0;
+		*fwlen = sizeof(dlarray_43143a0);
+#endif
+#ifdef EMBED_IMAGE_43143b0
+		*fw = (uint8 *)dlarray_43143b0;
+		*fwlen = sizeof(dlarray_43143b0);
+#endif
+		break;
+
+	case BCM4350_CHIP_ID:
+	case BCM4354_CHIP_ID:
+	case BCM43556_CHIP_ID:
+	case BCM43558_CHIP_ID:
+	case BCM43566_CHIP_ID:
+	case BCM43568_CHIP_ID:
+	case BCM43570_CHIP_ID:
+	case BCM4358_CHIP_ID:
+#ifdef EMBED_IMAGE_4350a0
+		if (crev == 0) {
+			*fw = (uint8 *)dlarray_4350a0;
+			*fwlen = sizeof(dlarray_4350a0);
+		}
+#endif
+#ifdef EMBED_IMAGE_4350b0
+		if (crev == 1) {
+			*fw = (uint8 *)dlarray_4350b0;
+			*fwlen = sizeof(dlarray_4350b0);
+		}
+#endif
+#ifdef EMBED_IMAGE_4350b1
+		if (crev == 2) {
+			*fw = (uint8 *)dlarray_4350b1;
+			*fwlen = sizeof(dlarray_4350b1);
+		}
+#endif
+#ifdef EMBED_IMAGE_43556b1
+		if (crev == 2) {
+			*fw = (uint8 *)dlarray_43556b1;
+			*fwlen = sizeof(dlarray_43556b1);
+		}
+#endif
+#ifdef EMBED_IMAGE_4350c0
+		if (crev == 3) {
+			*fw = (uint8 *)dlarray_4350c0;
+			*fwlen = sizeof(dlarray_4350c0);
+		}
+#endif /* EMBED_IMAGE_4350c0 */
+#ifdef EMBED_IMAGE_4350c1
+		if (crev == 4) {
+			*fw = (uint8 *)dlarray_4350c1;
+			*fwlen = sizeof(dlarray_4350c1);
+		}
+#endif /* EMBED_IMAGE_4350c1 */
+		break;
+	case BCM43569_CHIP_ID:
+#ifdef EMBED_IMAGE_43569a0
+		if (crev == 0) {
+			*fw = (uint8 *)dlarray_43569a0;
+			*fwlen = sizeof(dlarray_43569a0);
+		}
+#endif /* EMBED_IMAGE_43569a0 */
+		break;
+	default:
+#ifdef EMBED_IMAGE_GENERIC
+		*fw = (uint8 *)dlarray;
+		*fwlen = sizeof(dlarray);
+#endif
+		break;
+	}
+} /* dbus_bus_fw_get */
+
+#ifdef BCM_DNGL_EMBEDIMAGE
+static bool
+dbus_usb_device_exists(void *bus)
+{
+	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
+	void *osinfo;
+	bootrom_id_t id;
+
+	DBUSTRACE(("%s\n", __FUNCTION__));
+
+	if (usbinfo == NULL)
+		return FALSE;
+
+	osinfo = usbinfo->usbosl_info;
+	ASSERT(osinfo);
+
+	id.chip = 0xDEAD;
+	/* Query device to see if we get a response */
+	dbus_usbos_dl_cmd(osinfo, DL_GETVER, &id, sizeof(bootrom_id_t));
+
+	usbinfo->pub->attrib.devid = id.chip;
+	if (id.chip == 0xDEAD)
+		return FALSE;
+	else
+		return TRUE;
+}
+#endif /* BCM_DNGL_EMBEDIMAGE */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus_usb_linux.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus_usb_linux.c
new file mode 100644
index 000000000000..6d269718a429
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dbus_usb_linux.c
@@ -0,0 +1,4601 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Dongle BUS interface
+ * USB Linux Implementation
+ *
+ * Copyright (C) 1999-2019, Broadcom Corporation
+ * 
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ * 
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ * 
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * $Id: dbus_usb_linux.c 708808 2018-11-27 03:12:35Z $
+ */
+
+/**
+ * @file @brief
+ * This file contains DBUS code that is USB *and* OS (Linux) specific. DBUS is a Broadcom
+ * proprietary host specific abstraction layer.
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+
+/**
+ * DBUS_LINUX_RXDPC is created for router platform performance tuning. A separate thread is created
+ * to handle USB RX and avoid the call chain getting too long and enhance cache hit rate.
+ *
+ * DBUS_LINUX_RXDPC setting is in wlconfig file.
+ */
+
+/*
+ * If DBUS_LINUX_RXDPC is off, spin_lock_bh() for CTFPOOL in
+ * linux_osl.c has to be changed to spin_lock_irqsave() because
+ * PKTGET/PKTFREE are no longer in bottom half.
+ *
+ * Right now we have another queue rpcq in wl_linux.c. Maybe we
+ * can eliminate that one to reduce the overhead.
+ *
+ * Enabling 2nd EP and DBUS_LINUX_RXDPC causing traffic from
+ * both EP's to be queued in the same rx queue. If we want
+ * RXDPC to work with 2nd EP. The EP for RPC call return
+ * should bypass the dpc and go directly up.
+ */
+
+/* #define DBUS_LINUX_RXDPC */
+
+/* Dbus histogram for ntxq, nrxq, dpc parameter tuning */
+/* #define DBUS_LINUX_HIST */
+
+#include <usbrdl.h>
+#include <bcmendian.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <asm/uaccess.h>
+#include <asm/unaligned.h>
+#include <dbus.h>
+#include <bcmutils.h>
+#include <bcmdevs.h>
+#include <linux/usb.h>
+#include <usbrdl.h>
+#include <linux/firmware.h>
+#ifdef DBUS_LINUX_RXDPC
+#include <linux/sched.h>
+#endif
+
+#if defined(USBOS_THREAD) || defined(USBOS_TX_THREAD)
+
+/**
+ * The usb-thread is designed to provide currency on multiprocessors and SMP linux kernels. On the
+ * dual cores platform, the WLAN driver, without threads, executed only on CPU0. The driver consumed
+ * almost of 100% on CPU0, while CPU1 remained idle. The behavior was observed on Broadcom's STB.
+ *
+ * The WLAN driver consumed most of CPU0 and not CPU1 because tasklets/queues, software irq, and
+ * hardware irq are executing from CPU0, only. CPU0 became the system's bottle-neck. TPUT is lower
+ * and system's responsiveness is slower.
+ *
+ * To improve system responsiveness and TPUT usb-thread was implemented. The system's threads could
+ * be scheduled to run on any core. One core could be processing data in the usb-layer and the other
+ * core could be processing data in the wl-layer.
+ *
+ * For further info see [WlThreadAndUsbThread] Twiki.
+ */
+
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/hardirq.h>
+#include <linux/list.h>
+#include <linux_osl.h>
+#endif /* USBOS_THREAD || USBOS_TX_THREAD */
+
+
+#ifdef DBUS_LINUX_RXDPC
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+#define RESCHED()   _cond_resched()
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+#define RESCHED()   cond_resched()
+#else
+#define RESCHED()   __cond_resched()
+#endif /* LINUX_VERSION_CODE  */
+#endif	/* DBUS_LINUX_RXDPC */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+#define KERNEL26
+#endif
+
+/**
+ * Starting with the 3.10 kernel release, dynamic PM support for USB is present whenever
+ * the kernel was built with CONFIG_PM_RUNTIME enabled. The CONFIG_USB_SUSPEND option has
+ * been eliminated.
+ */
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND)) \
+	|| ((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)) && defined(CONFIG_PM_RUNTIME))
+/* For USB power management support, see Linux kernel: Documentation/usb/power-management.txt */
+#define USB_SUSPEND_AVAILABLE
+#endif
+
+/* Define alternate fw/nvram paths used in Android */
+#define CONFIG_ANDROID_BCMDHD_FW_PATH "broadcom/dhd/firmware/fw.bin.trx"
+#define CONFIG_ANDROID_BCMDHD_NVRAM_PATH "broadcom/dhd/nvrams/nvm.txt"
+
+static inline int usb_submit_urb_linux(struct urb *urb)
+{
+
+#ifdef BCM_MAX_URB_LEN
+	if (urb && (urb->transfer_buffer_length > BCM_MAX_URB_LEN)) {
+		DBUSERR(("URB transfer length=%d exceeded %d ra=%p\n", urb->transfer_buffer_length,
+		BCM_MAX_URB_LEN, __builtin_return_address(0)));
+		return DBUS_ERR;
+	}
+#endif
+
+#ifdef KERNEL26
+	return usb_submit_urb(urb, GFP_ATOMIC);
+#else
+	return usb_submit_urb(urb);
+#endif
+
+}
+
+#define USB_SUBMIT_URB(urb) usb_submit_urb_linux(urb)
+
+#ifdef KERNEL26
+
+#define USB_ALLOC_URB()				usb_alloc_urb(0, GFP_ATOMIC)
+#define USB_UNLINK_URB(urb)			(usb_kill_urb(urb))
+#define USB_FREE_URB(urb)			(usb_free_urb(urb))
+#define USB_REGISTER()				usb_register(&dbus_usbdev)
+#define USB_DEREGISTER()			usb_deregister(&dbus_usbdev)
+
+#ifdef USB_SUSPEND_AVAILABLE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33))
+#define USB_AUTOPM_SET_INTERFACE(intf)		usb_autopm_set_interface(intf)
+#else
+#define USB_ENABLE_AUTOSUSPEND(udev)		usb_enable_autosuspend(udev)
+#define USB_DISABLE_AUTOSUSPEND(udev)       usb_disable_autosuspend(udev)
+#endif  /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33))  */
+
+#define USB_AUTOPM_GET_INTERFACE(intf)		usb_autopm_get_interface(intf)
+#define USB_AUTOPM_PUT_INTERFACE(intf)		usb_autopm_put_interface(intf)
+#define USB_AUTOPM_GET_INTERFACE_ASYNC(intf)	usb_autopm_get_interface_async(intf)
+#define USB_AUTOPM_PUT_INTERFACE_ASYNC(intf)	usb_autopm_put_interface_async(intf)
+#define USB_MARK_LAST_BUSY(dev)			usb_mark_last_busy(dev)
+
+#else /* USB_SUSPEND_AVAILABLE */
+
+#define USB_AUTOPM_GET_INTERFACE(intf)		do {} while (0)
+#define USB_AUTOPM_PUT_INTERFACE(intf)		do {} while (0)
+#define USB_AUTOPM_GET_INTERFACE_ASYNC(intf)	do {} while (0)
+#define USB_AUTOPM_PUT_INTERFACE_ASYNC(intf)	do {} while (0)
+#define USB_MARK_LAST_BUSY(dev)			do {} while (0)
+#endif /* USB_SUSPEND_AVAILABLE */
+
+#define USB_CONTROL_MSG(dev, pipe, request, requesttype, value, index, data, size, timeout) \
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), \
+	(data), (size), (timeout))
+#define USB_BULK_MSG(dev, pipe, data, len, actual_length, timeout) \
+	usb_bulk_msg((dev), (pipe), (data), (len), (actual_length), (timeout))
+#define USB_BUFFER_ALLOC(dev, size, mem, dma)	usb_buffer_alloc(dev, size, mem, dma)
+#define USB_BUFFER_FREE(dev, size, data, dma)	usb_buffer_free(dev, size, data, dma)
+
+#ifdef WL_URB_ZPKT
+#define URB_QUEUE_BULK   URB_ZERO_PACKET
+#else
+#define URB_QUEUE_BULK   0
+#endif /* WL_URB_ZPKT */
+
+#define CALLBACK_ARGS		struct urb *urb, struct pt_regs *regs
+#define CALLBACK_ARGS_DATA	urb, regs
+#define CONFIGDESC(usb)		(&((usb)->actconfig)->desc)
+#define IFPTR(usb, idx)		((usb)->actconfig->interface[idx])
+#define IFALTS(usb, idx)	(IFPTR((usb), (idx))->altsetting[0])
+#define IFDESC(usb, idx)	IFALTS((usb), (idx)).desc
+#define IFEPDESC(usb, idx, ep)	(IFALTS((usb), (idx)).endpoint[ep]).desc
+#ifdef DBUS_LINUX_RXDPC
+#define DAEMONIZE(a)		daemonize(a); allow_signal(SIGKILL); allow_signal(SIGTERM);
+#define SET_NICE(n)		set_user_nice(current, n)
+#endif
+
+#else /* KERNEL26 */
+
+#define USB_ALLOC_URB()				usb_alloc_urb(0)
+#define USB_UNLINK_URB(urb)			usb_unlink_urb(urb)
+#define USB_FREE_URB(urb)			(usb_free_urb(urb))
+#define USB_REGISTER()				usb_register(&dbus_usbdev)
+#define USB_DEREGISTER()			usb_deregister(&dbus_usbdev)
+#define USB_AUTOPM_GET_INTERFACE(intf)		do {} while (0)
+#define USB_AUTOPM_GET_INTERFACE_ASYNC(intf)	do {} while (0)
+#define USB_AUTOPM_PUT_INTERFACE_ASYNC(intf)	do {} while (0)
+#define USB_MARK_LAST_BUSY(dev)			do {} while (0)
+
+#define USB_CONTROL_MSG(dev, pipe, request, requesttype, value, index, data, size, timeout) \
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), \
+	(data), (size), (timeout))
+#define USB_BUFFER_ALLOC(dev, size, mem, dma)  kmalloc(size, mem)
+#define USB_BUFFER_FREE(dev, size, data, dma)  kfree(data)
+
+#ifdef WL_URB_ZPKT
+#define URB_QUEUE_BULK   USB_QUEUE_BULK|URB_ZERO_PACKET
+#else
+#define URB_QUEUE_BULK   0
+#endif /*  WL_URB_ZPKT */
+
+#define CALLBACK_ARGS		struct urb *urb
+#define CALLBACK_ARGS_DATA	urb
+#define CONFIGDESC(usb)		((usb)->actconfig)
+#define IFPTR(usb, idx)		(&(usb)->actconfig->interface[idx])
+#define IFALTS(usb, idx)	((usb)->actconfig->interface[idx].altsetting[0])
+#define IFDESC(usb, idx)	IFALTS((usb), (idx))
+#define IFEPDESC(usb, idx, ep)	(IFALTS((usb), (idx)).endpoint[ep])
+
+#ifdef DBUS_LINUX_RXDPC
+#define DAEMONIZE(a)    daemonize();
+#define SET_NICE(n)     do {current->nice = (n);} while (0)
+#endif /* DBUS_LINUX_RXDPC */
+
+#endif /* KERNEL26 */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))
+#define USB_SPEED_SUPER		5
+#endif  /* #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)) */
+
+#define CONTROL_IF   0
+#define BULK_IF      0
+
+#ifdef BCMUSBDEV_COMPOSITE
+#define USB_COMPIF_MAX       4
+
+#define USB_CLASS_WIRELESS	0xe0
+#define USB_CLASS_MISC		0xef
+#define USB_SUBCLASS_COMMON	0x02
+#define USB_PROTO_IAD		0x01
+#define USB_PROTO_VENDOR	0xff
+
+#define USB_QUIRK_NO_SET_INTF   0x04 /* device does not support set_interface */
+#endif /* BCMUSBDEV_COMPOSITE */
+
+#define USB_SYNC_WAIT_TIMEOUT  300  /* ms */
+
+/* Private data kept in skb */
+#define SKB_PRIV(skb, idx)  (&((void **)skb->cb)[idx])
+#define SKB_PRIV_URB(skb)   (*(struct urb **)SKB_PRIV(skb, 0))
+
+#ifndef DBUS_USB_RXQUEUE_BATCH_ADD
+/* items to add each time within limit */
+#define DBUS_USB_RXQUEUE_BATCH_ADD            8
+#endif
+
+#ifndef DBUS_USB_RXQUEUE_LOWER_WATERMARK
+/* add a new batch req to rx queue when waiting item count reduce to this number */
+#define DBUS_USB_RXQUEUE_LOWER_WATERMARK      4
+#endif
+
+enum usbos_suspend_state {
+	USBOS_SUSPEND_STATE_DEVICE_ACTIVE = 0, /* Device is busy, won't allow suspend */
+	USBOS_SUSPEND_STATE_SUSPEND_PENDING,   /* Device is idle, can be suspended */
+	                                       /* Wating PM to suspend */
+	USBOS_SUSPEND_STATE_SUSPENDED          /* Device suspended */
+};
+
+enum usbos_request_state {
+	USBOS_REQUEST_STATE_UNSCHEDULED = 0,	/* USB TX request not scheduled */
+	USBOS_REQUEST_STATE_SCHEDULED,		/* USB TX request given to TX thread */
+	USBOS_REQUEST_STATE_SUBMITTED		/* USB TX request submitted */
+};
+
+typedef struct {
+	uint32 notification;
+	uint32 reserved;
+} intr_t;
+
+typedef struct {
+	dbus_pub_t *pub;
+
+	void *cbarg;
+	dbus_intf_callbacks_t *cbs;
+
+	/* Imported */
+	struct usb_device *usb;	/* USB device pointer from OS */
+	struct urb *intr_urb; /* URB for interrupt endpoint */
+	struct list_head req_rxfreeq;
+	struct list_head req_txfreeq;
+	struct list_head req_rxpostedq;	/* Posted down to USB driver for RX */
+	struct list_head req_txpostedq;	/* Posted down to USB driver for TX */
+	spinlock_t rxfree_lock; /* Lock for rx free list */
+	spinlock_t txfree_lock; /* Lock for tx free list */
+	spinlock_t rxposted_lock; /* Lock for rx posted list */
+	spinlock_t txposted_lock; /* Lock for tx posted list */
+	uint rx_pipe, tx_pipe, intr_pipe, rx_pipe2; /* Pipe numbers for USB I/O */
+	uint rxbuf_len;
+
+	struct list_head req_rxpendingq; /* RXDPC: Pending for dpc to send up */
+	spinlock_t rxpending_lock;	/* RXDPC: Lock for rx pending list */
+	long dpc_pid;
+	struct semaphore dpc_sem;
+	struct completion dpc_exited;
+	int rxpending;
+#if defined(DBUS_LINUX_HIST)
+	int	dpc_cnt, dpc_pktcnt, dpc_maxpktcnt;
+#endif
+
+	struct urb               *ctl_urb;
+	int                      ctl_in_pipe, ctl_out_pipe;
+	struct usb_ctrlrequest   ctl_write;
+	struct usb_ctrlrequest   ctl_read;
+	struct semaphore         ctl_lock;     /* Lock for CTRL transfers via tx_thread */
+#ifdef USBOS_TX_THREAD
+	enum usbos_request_state ctl_state;
+#endif /* USBOS_TX_THREAD */
+
+	spinlock_t rxlock;      /* Lock for rxq management */
+	spinlock_t txlock;      /* Lock for txq management */
+
+	int intr_size;          /* Size of interrupt message */
+	int interval;           /* Interrupt polling interval */
+	intr_t intr;            /* Data buffer for interrupt endpoint */
+
+	int maxps;
+	atomic_t txposted;
+	atomic_t rxposted;
+	atomic_t txallocated;
+	atomic_t rxallocated;
+	bool rxctl_deferrespok;	/* Get a response for setup from dongle */
+
+	wait_queue_head_t wait;
+	bool waitdone;
+	int sync_urb_status;
+
+	struct urb *blk_urb; /* Used for downloading embedded image */
+
+#if defined(DBUS_LINUX_HIST)
+	int *txposted_hist;
+	int *rxposted_hist;
+#endif
+#ifdef USBOS_THREAD
+	spinlock_t              ctrl_lock;
+	spinlock_t              usbos_list_lock;
+	struct list_head        usbos_list;
+	struct list_head        usbos_free_list;
+	atomic_t                usbos_list_cnt;
+	wait_queue_head_t       usbos_queue_head;
+	struct task_struct      *usbos_kt;
+#endif /* USBOS_THREAD */
+
+#ifdef USBOS_TX_THREAD
+	spinlock_t              usbos_tx_list_lock;
+	struct list_head	usbos_tx_list;
+	wait_queue_head_t	usbos_tx_queue_head;
+	struct task_struct      *usbos_tx_kt;
+#endif /* USBOS_TX_THREAD */
+
+	struct dma_pool *qtd_pool; /* QTD pool for USB optimization only */
+	int tx_ep, rx_ep, rx2_ep;  /* EPs for USB optimization */
+	struct usb_device *usb_device; /* USB device for optimization */
+#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX) /** Linux USB AP related */
+	spinlock_t fastpath_lock;
+#endif
+} usbos_info_t;
+
+typedef struct urb_req {
+	void         *pkt;
+	int          buf_len;
+	struct urb   *urb;
+	void         *arg;
+	usbos_info_t *usbinfo;
+	struct list_head urb_list;
+} urb_req_t;
+
+#ifdef USBOS_THREAD
+typedef struct usbos_list_entry {
+	struct list_head    list;   /* must be first */
+	void               *urb_context;
+	int                 urb_length;
+	int                 urb_status;
+} usbos_list_entry_t;
+
+static void* dbus_usbos_thread_init(usbos_info_t *usbos_info);
+static void  dbus_usbos_thread_deinit(usbos_info_t *usbos_info);
+static void  dbus_usbos_dispatch_schedule(CALLBACK_ARGS);
+static int   dbus_usbos_thread_func(void *data);
+#endif /* USBOS_THREAD */
+
+#ifdef USBOS_TX_THREAD
+void* dbus_usbos_tx_thread_init(usbos_info_t *usbos_info);
+void  dbus_usbos_tx_thread_deinit(usbos_info_t *usbos_info);
+int   dbus_usbos_tx_thread_func(void *data);
+#endif /* USBOS_TX_THREAD */
+
+/* Shared Function prototypes */
+bool dbus_usbos_dl_cmd(usbos_info_t *usbinfo, uint8 cmd, void *buffer, int buflen);
+int dbus_usbos_wait(usbos_info_t *usbinfo, uint16 ms);
+bool dbus_usbos_dl_send_bulk(usbos_info_t *usbinfo, void *buffer, int len);
+int dbus_write_membytes(usbos_info_t *usbinfo, bool set, uint32 address, uint8 *data, uint size);
+
+/* Local function prototypes */
+static void dbus_usbos_send_complete(CALLBACK_ARGS);
+#ifdef DBUS_LINUX_RXDPC
+static void dbus_usbos_recv_dpc(usbos_info_t *usbos_info);
+static int dbus_usbos_dpc_thread(void *data);
+#endif /* DBUS_LINUX_RXDPC */
+static void dbus_usbos_recv_complete(CALLBACK_ARGS);
+static int  dbus_usbos_errhandler(void *bus, int err);
+static int  dbus_usbos_state_change(void *bus, int state);
+static void dbusos_stop(usbos_info_t *usbos_info);
+
+#ifdef KERNEL26
+static int dbus_usbos_probe(struct usb_interface *intf, const struct usb_device_id *id);
+static void dbus_usbos_disconnect(struct usb_interface *intf);
+#if defined(USB_SUSPEND_AVAILABLE)
+static int dbus_usbos_resume(struct usb_interface *intf);
+static int dbus_usbos_suspend(struct usb_interface *intf, pm_message_t message);
+/* at the moment, used for full dongle host driver only */
+static int dbus_usbos_reset_resume(struct usb_interface *intf);
+#endif /* USB_SUSPEND_AVAILABLE */
+#else /* KERNEL26 */
+static void *dbus_usbos_probe(struct usb_device *usb, unsigned int ifnum,
+	const struct usb_device_id *id);
+static void dbus_usbos_disconnect(struct usb_device *usb, void *ptr);
+#endif /* KERNEL26 */
+
+#ifdef USB_TRIGGER_DEBUG
+static bool dbus_usbos_ctl_send_debugtrig(usbos_info_t *usbinfo);
+#endif /* USB_TRIGGER_DEBUG */
+
+#ifdef KEEPIF_ON_DEVICE_RESET
+enum usb_dev_status {
+	USB_DEVICE_INIT = 0,
+	USB_DEVICE_RESETTED = 1,
+	USB_DEVICE_DISCONNECTED = 2,
+	USB_DEVICE_PROBED
+};
+static int dbus_usbos_usbreset_func(void *data);
+#endif /* KEEPIF_ON_DEVICE_RESET */
+
+/**
+ * have to disable missing-field-initializers warning as last element {} triggers it
+ * and different versions of kernel have different number of members so it is impossible
+ * to specify the initializer. BTW issuing the warning here is bug og GCC as  universal
+ * zero {0} specified in C99 standard as correct way of initialization of struct to all zeros
+ */
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
+	4 && __GNUC_MINOR__ >= 6))
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
+#endif
+
+static struct usb_device_id devid_table[] = {
+	{ USB_DEVICE(BCM_DNGL_VID, 0x0000) }, /* Configurable via register() */
+#if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4328) },
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4322) },
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4319) },
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_43236) },
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_43143) },
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_43242) },
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4360) },
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4350) },
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_43569) },
+#endif
+#ifdef EXTENDED_VID_PID
+	EXTENDED_VID_PID,
+#endif /* EXTENDED_VID_PID */
+	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BDC_PID) }, /* Default BDC */
+	{ USB_DEVICE(CY_DNGL_VID, BCM_DNGL_BDC_PID) },  /* CY Default BDC */
+	{ }
+};
+
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
+	4 && __GNUC_MINOR__ >= 6))
+#pragma GCC diagnostic pop
+#endif
+
+MODULE_DEVICE_TABLE(usb, devid_table);
+
+/** functions called by the Linux kernel USB subsystem */
+static struct usb_driver dbus_usbdev = {
+	name:           "dbus_usbdev",
+	probe:          dbus_usbos_probe,
+	disconnect:     dbus_usbos_disconnect,
+	id_table:       devid_table,
+#if defined(USB_SUSPEND_AVAILABLE)
+	suspend:        dbus_usbos_suspend,
+	resume:         dbus_usbos_resume,
+	reset_resume:	dbus_usbos_reset_resume,
+	/* Linux USB core will allow autosuspend for devices bound to this driver */
+	supports_autosuspend: 1
+#endif /* USB_SUSPEND_AVAILABLE */
+};
+
+/**
+ * This stores USB info during Linux probe callback since attach() is not called yet at this point
+ */
+typedef struct {
+	void    *usbos_info;
+	struct usb_device *usb; /* USB device pointer from OS */
+	uint    rx_pipe;   /* Pipe numbers for USB I/O */
+	uint    tx_pipe;   /* Pipe numbers for USB I/O */
+	uint    intr_pipe; /* Pipe numbers for USB I/O */
+	uint    rx_pipe2;  /* Pipe numbers for USB I/O */
+	int     intr_size; /* Size of interrupt message */
+	int     interval;  /* Interrupt polling interval */
+	bool    dldone;
+	int     vid;
+	int     pid;
+	bool    dereged;
+	bool    disc_cb_done;
+	DEVICE_SPEED    device_speed;
+	enum usbos_suspend_state suspend_state;
+	struct usb_interface     *intf;
+#ifdef KEEPIF_ON_DEVICE_RESET
+	bool                  keepif_on_devreset; /* if need keep network interface on dev reset */
+	bool                  dev_resetted; /* if dev reset event occured */
+	enum dbus_state       busstate_bf_devreset; /* busstate before devreset */
+	atomic_t              usbdev_stat; /* device status: resetted? disconnected? re-probed? */
+	wait_queue_head_t     usbreset_queue_head; /* kernel thread waiting queue */
+	struct task_struct    *usbreset_kt; /* kernel thread handle dev reset/probe event */
+#endif /* KEEPIF_ON_DEVICE_RESET */
+} probe_info_t;
+
+/*
+ * USB Linux dbus_intf_t
+ */
+static void dbus_usbos_init_info(void);
+static void *dbus_usbos_intf_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs);
+static void dbus_usbos_intf_detach(dbus_pub_t *pub, void *info);
+static int  dbus_usbos_intf_send_irb(void *bus, dbus_irb_tx_t *txirb);
+static int  dbus_usbos_intf_recv_irb(void *bus, dbus_irb_rx_t *rxirb);
+static int  dbus_usbos_intf_recv_irb_from_ep(void *bus, dbus_irb_rx_t *rxirb, uint32 ep_idx);
+static int  dbus_usbos_intf_cancel_irb(void *bus, dbus_irb_tx_t *txirb);
+static int  dbus_usbos_intf_send_ctl(void *bus, uint8 *buf, int len);
+static int  dbus_usbos_intf_recv_ctl(void *bus, uint8 *buf, int len);
+static int  dbus_usbos_intf_get_attrib(void *bus, dbus_attrib_t *attrib);
+static int  dbus_usbos_intf_up(void *bus);
+static int  dbus_usbos_intf_down(void *bus);
+static int  dbus_usbos_intf_stop(void *bus);
+static int  dbus_usbos_readreg(void *bus, uint32 regaddr, int datalen, uint32 *value);
+extern int dbus_usbos_loopback_tx(void *usbos_info_ptr, int cnt, int size);
+int dbus_usbos_writereg(void *bus, uint32 regaddr, int datalen, uint32 data);
+#if defined(DBUS_LINUX_HIST)
+static void dbus_usbos_intf_dump(void *bus, struct bcmstrbuf *b);
+#endif 
+static int  dbus_usbos_intf_set_config(void *bus, dbus_config_t *config);
+static bool dbus_usbos_intf_recv_needed(void *bus);
+static void *dbus_usbos_intf_exec_rxlock(void *bus, exec_cb_t cb, struct exec_parms *args);
+static void *dbus_usbos_intf_exec_txlock(void *bus, exec_cb_t cb, struct exec_parms *args);
+#ifdef BCMUSBDEV_COMPOSITE
+static int dbus_usbos_intf_wlan(struct usb_device *usb);
+#endif /* BCMUSBDEV_COMPOSITE */
+
+/** functions called by dbus_usb.c */
+static dbus_intf_t dbus_usbos_intf = {
+	.attach = dbus_usbos_intf_attach,
+	.detach = dbus_usbos_intf_detach,
+	.up = dbus_usbos_intf_up,
+	.down = dbus_usbos_intf_down,
+	.send_irb = dbus_usbos_intf_send_irb,
+	.recv_irb = dbus_usbos_intf_recv_irb,
+	.cancel_irb = dbus_usbos_intf_cancel_irb,
+	.send_ctl = dbus_usbos_intf_send_ctl,
+	.recv_ctl = dbus_usbos_intf_recv_ctl,
+	.get_stats = NULL,
+	.get_attrib = dbus_usbos_intf_get_attrib,
+	.remove = NULL,
+	.resume = NULL,
+	.suspend = NULL,
+	.stop = dbus_usbos_intf_stop,
+	.reset = NULL,
+	.pktget = NULL,
+	.pktfree = NULL,
+	.iovar_op = NULL,
+#if defined(DBUS_LINUX_HIST)
+	.dump = dbus_usbos_intf_dump,
+#else
+	.dump = NULL,
+#endif 
+	.set_config = dbus_usbos_intf_set_config,
+	.get_config = NULL,
+	.device_exists = NULL,
+	.dlneeded = NULL,
+	.dlstart = NULL,
+	.dlrun = NULL,
+	.recv_needed = dbus_usbos_intf_recv_needed,
+	.exec_rxlock = dbus_usbos_intf_exec_rxlock,
+	.exec_txlock = dbus_usbos_intf_exec_txlock,
+
+	.tx_timer_init = NULL,
+	.tx_timer_start = NULL,
+	.tx_timer_stop = NULL,
+
+	.sched_dpc = NULL,
+	.lock = NULL,
+	.unlock = NULL,
+	.sched_probe_cb = NULL,
+
+	.shutdown = NULL,
+
+	.recv_stop = NULL,
+	.recv_resume = NULL,
+
+	.recv_irb_from_ep = dbus_usbos_intf_recv_irb_from_ep,
+	.readreg = dbus_usbos_readreg
+};
+
+static probe_info_t    g_probe_info;
+static probe_cb_t      probe_cb = NULL;
+static disconnect_cb_t disconnect_cb = NULL;
+static void            *probe_arg = NULL;
+static void            *disc_arg = NULL;
+
+#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
+
+#define EHCI_PAGE_SIZE    4096
+
+/* Copies of structures located elsewhere. */
+
+typedef struct {
+	dbus_pub_t *pub;
+
+	void *cbarg;
+	dbus_intf_callbacks_t *cbs;
+	dbus_intf_t *drvintf;
+	void *usbosl_info;
+} usb_info_t;
+
+/** General info for all BUS */
+typedef struct dbus_irbq {
+	dbus_irb_t *head;
+	dbus_irb_t *tail;
+	int cnt;
+} dbus_irbq_t;
+
+/**
+ * This private structure dbus_info_t is also declared in dbus.c.
+ * All the fields must be consistent in both declarations.
+ */
+typedef struct dbus_info {
+	dbus_pub_t pub; /* MUST BE FIRST */
+
+	void *cbarg;
+	dbus_callbacks_t *cbs;
+	void *bus_info;
+	dbus_intf_t *drvintf;
+	uint8 *fw;
+	int fwlen;
+	uint32 errmask;
+	int rx_low_watermark;
+	int tx_low_watermark;
+	bool txoff;
+	bool txoverride;
+	bool rxoff;
+	bool tx_timer_ticking;
+	dbus_irbq_t *rx_q;
+	dbus_irbq_t *tx_q;
+
+#ifdef EHCI_FASTPATH_RX
+	atomic_t rx_outstanding;
+#endif
+	uint8 *nvram;
+	int	nvram_len;
+	uint8 *image;	/* buffer for combine fw and nvram */
+	int image_len;
+	uint8 *orig_fw;
+	int origfw_len;
+	int decomp_memsize;
+	dbus_extdl_t extdl;
+	int nvram_nontxt;
+} dbus_info_t;
+
+static atomic_t s_tx_pending;
+
+static int optimize_init(usbos_info_t *usbos_info, struct usb_device *usb, int out,
+	int in, int in2);
+static int optimize_deinit(usbos_info_t *usbos_info, struct usb_device *usb);
+#endif  /* #if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX) */
+
+
+static volatile int loopback_rx_cnt, loopback_tx_cnt;
+int loopback_size;
+bool is_loopback_pkt(void *buf);
+int matches_loopback_pkt(void *buf);
+
+/**
+ * multiple code paths in this file dequeue a URB request, this function makes sure that it happens
+ * in a concurrency save manner. Don't call this from a sleepable process context.
+ */
+static urb_req_t * BCMFASTPATH
+dbus_usbos_qdeq(struct list_head *urbreq_q, spinlock_t *lock)
+{
+	unsigned long flags;
+	urb_req_t *req;
+
+	ASSERT(urbreq_q != NULL);
+
+	spin_lock_irqsave(lock, flags);
+
+	if (list_empty(urbreq_q)) {
+		req = NULL;
+	} else {
+		ASSERT(urbreq_q->next != NULL);
+		ASSERT(urbreq_q->next != urbreq_q);
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-qual"
+#endif
+		req = list_entry(urbreq_q->next, urb_req_t, urb_list);
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
+#pragma GCC diagnostic pop
+#endif
+		list_del_init(&req->urb_list);
+	}
+
+	spin_unlock_irqrestore(lock, flags);
+
+	return req;
+}
+
+static void BCMFASTPATH
+dbus_usbos_qenq(struct list_head *urbreq_q, urb_req_t *req, spinlock_t *lock)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(lock, flags);
+
+	list_add_tail(&req->urb_list, urbreq_q);
+
+	spin_unlock_irqrestore(lock, flags);
+}
+
+/**
+ * multiple code paths in this file remove a URB request from a list, this function makes sure that
+ * it happens in a concurrency save manner. Don't call this from a sleepable process context.
+ * Is quite similar to dbus_usbos_qdeq(), I wonder why this function is needed.
+ */
+static void
+dbus_usbos_req_del(urb_req_t *req, spinlock_t *lock)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(lock, flags);
+
+	list_del_init(&req->urb_list);
+
+	spin_unlock_irqrestore(lock, flags);
+}
+
+
+/**
+ * Driver requires a pool of URBs to operate. This function is called during
+ * initialization (attach phase), allocates a number of URBs, and puts them
+ * on the free (req_rxfreeq and req_txfreeq) queue
+ */
+static int
+dbus_usbos_urbreqs_alloc(usbos_info_t *usbos_info, uint32 count, bool is_rx)
+{
+	int i;
+	int allocated = 0;
+	int err = DBUS_OK;
+
+	for (i = 0; i < count; i++) {
+		urb_req_t *req;
+
+		req = MALLOC(usbos_info->pub->osh, sizeof(urb_req_t));
+		if (req == NULL) {
+			DBUSERR(("%s: MALLOC req failed\n", __FUNCTION__));
+			err = DBUS_ERR_NOMEM;
+			goto fail;
+		}
+		bzero(req, sizeof(urb_req_t));
+
+		req->urb = USB_ALLOC_URB();
+		if (req->urb == NULL) {
+			DBUSERR(("%s: USB_ALLOC_URB req->urb failed\n", __FUNCTION__));
+			err = DBUS_ERR_NOMEM;
+			goto fail;
+		}
+
+		INIT_LIST_HEAD(&req->urb_list);
+
+		if (is_rx) {
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+			/* don't allocate now. Do it on demand */
+			req->pkt = NULL;
+#else
+			/* pre-allocate  buffers never to be released */
+			req->pkt = MALLOC(usbos_info->pub->osh, usbos_info->rxbuf_len);
+			if (req->pkt == NULL) {
+				DBUSERR(("%s: MALLOC req->pkt failed\n", __FUNCTION__));
+				err = DBUS_ERR_NOMEM;
+				goto fail;
+			}
+#endif
+			req->buf_len = usbos_info->rxbuf_len;
+			dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
+		} else {
+			req->buf_len = 0;
+			dbus_usbos_qenq(&usbos_info->req_txfreeq, req, &usbos_info->txfree_lock);
+		}
+		allocated++;
+		continue;
+
+fail:
+		if (req) {
+			if (is_rx && req->pkt) {
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+				/* req->pkt is NULL in "NOCOPY" mode */
+#else
+				MFREE(usbos_info->pub->osh, req->pkt, req->buf_len);
+#endif
+			}
+			if (req->urb) {
+				USB_FREE_URB(req->urb);
+			}
+			MFREE(usbos_info->pub->osh, req, sizeof(urb_req_t));
+		}
+		break;
+	}
+
+	atomic_add(allocated, is_rx ? &usbos_info->rxallocated : &usbos_info->txallocated);
+
+	if (is_rx) {
+		DBUSTRACE(("%s: add %d (total %d) rx buf, each has %d bytes\n", __FUNCTION__,
+			allocated, atomic_read(&usbos_info->rxallocated), usbos_info->rxbuf_len));
+	} else {
+		DBUSTRACE(("%s: add %d (total %d) tx req\n", __FUNCTION__,
+			allocated, atomic_read(&usbos_info->txallocated)));
+	}
+
+	return err;
+} /* dbus_usbos_urbreqs_alloc */
+
+/** Typically called during detach or when attach failed. Don't call until all URBs unlinked */
+static int
+dbus_usbos_urbreqs_free(usbos_info_t *usbos_info, bool is_rx)
+{
+	int rtn = 0;
+	urb_req_t *req;
+	struct list_head *req_q;
+	spinlock_t *lock;
+
+	if (is_rx) {
+		req_q = &usbos_info->req_rxfreeq;
+		lock = &usbos_info->rxfree_lock;
+	} else {
+		req_q = &usbos_info->req_txfreeq;
+		lock = &usbos_info->txfree_lock;
+	}
+	while ((req = dbus_usbos_qdeq(req_q, lock)) != NULL) {
+
+		if (is_rx) {
+			if (req->pkt) {
+				/* We do MFREE instead of PKTFREE because the pkt has been
+				 * converted to native already
+				 */
+				MFREE(usbos_info->pub->osh, req->pkt, req->buf_len);
+				req->pkt = NULL;
+				req->buf_len = 0;
+			}
+		} else {
+			/* sending req should not be assigned pkt buffer */
+			ASSERT(req->pkt == NULL);
+		}
+
+		if (req->urb) {
+			USB_FREE_URB(req->urb);
+			req->urb = NULL;
+		}
+		MFREE(usbos_info->pub->osh, req, sizeof(urb_req_t));
+
+		rtn++;
+	}
+	return rtn;
+} /* dbus_usbos_urbreqs_free */
+
+/**
+ * called by Linux kernel on URB completion. Upper DBUS layer (dbus_usb.c) has to be notified of
+ * send completion.
+ */
+void
+dbus_usbos_send_complete(CALLBACK_ARGS)
+{
+	urb_req_t *req = urb->context;
+	dbus_irb_tx_t *txirb = req->arg;
+	usbos_info_t *usbos_info = req->usbinfo;
+	unsigned long flags;
+	int status = DBUS_OK;
+	int txposted;
+
+	USB_AUTOPM_PUT_INTERFACE_ASYNC(g_probe_info.intf);
+
+	spin_lock_irqsave(&usbos_info->txlock, flags);
+
+	dbus_usbos_req_del(req, &usbos_info->txposted_lock);
+	txposted = atomic_dec_return(&usbos_info->txposted);
+#if defined(DBUS_LINUX_HIST)
+	if (usbos_info->txposted_hist) {
+		usbos_info->txposted_hist[txposted]++;
+	}
+#endif 
+	if (unlikely (txposted < 0)) {
+		DBUSERR(("%s ERROR: txposted is negative (%d)!!\n", __FUNCTION__, txposted));
+	}
+	spin_unlock_irqrestore(&usbos_info->txlock, flags);
+
+	if (unlikely (urb->status)) {
+		status = DBUS_ERR_TXFAIL;
+		DBUSTRACE(("txfail status %d\n", urb->status));
+	}
+
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+	/* sending req should not be assigned pkt buffer */
+	ASSERT(req->pkt == NULL);
+#endif
+	/*  txirb should always be set, except for ZLP. ZLP is reusing this callback function. */
+	if (txirb != NULL) {
+		if (txirb->send_buf != NULL) {
+			MFREE(usbos_info->pub->osh, txirb->send_buf, req->buf_len);
+			txirb->send_buf = NULL;
+			req->buf_len = 0;
+		}
+		if (likely (usbos_info->cbarg && usbos_info->cbs)) {
+			if (likely (usbos_info->cbs->send_irb_complete != NULL))
+			    usbos_info->cbs->send_irb_complete(usbos_info->cbarg, txirb, status);
+		}
+	}
+
+	dbus_usbos_qenq(&usbos_info->req_txfreeq, req, &usbos_info->txfree_lock);
+} /* dbus_usbos_send_complete */
+
+/**
+ * In order to receive USB traffic from the dongle, we need to supply the Linux kernel with a free
+ * URB that is going to contain received data.
+ */
+static int BCMFASTPATH
+dbus_usbos_recv_urb_submit(usbos_info_t *usbos_info, dbus_irb_rx_t *rxirb, uint32 ep_idx)
+{
+	urb_req_t *req;
+	int ret = DBUS_OK;
+	unsigned long flags;
+	void *p;
+	uint rx_pipe;
+	int rxposted;
+
+	BCM_REFERENCE(rxposted);
+
+	if (!(req = dbus_usbos_qdeq(&usbos_info->req_rxfreeq, &usbos_info->rxfree_lock))) {
+		DBUSTRACE(("%s No free URB!\n", __FUNCTION__));
+		return DBUS_ERR_RXDROP;
+	}
+
+	spin_lock_irqsave(&usbos_info->rxlock, flags);
+
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+	req->pkt = rxirb->pkt = PKTGET(usbos_info->pub->osh, req->buf_len, FALSE);
+	if (!rxirb->pkt) {
+		DBUSERR(("%s: PKTGET failed\n", __FUNCTION__));
+		dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
+		ret = DBUS_ERR_RXDROP;
+		goto fail;
+	}
+	/* consider the packet "native" so we don't count it as MALLOCED in the osl */
+	PKTTONATIVE(usbos_info->pub->osh, req->pkt);
+	rxirb->buf = NULL;
+	p = PKTDATA(usbos_info->pub->osh, req->pkt);
+#else
+	if (req->buf_len != usbos_info->rxbuf_len) {
+		ASSERT(req->pkt);
+		MFREE(usbos_info->pub->osh, req->pkt, req->buf_len);
+		DBUSTRACE(("%s: replace rx buff: old len %d, new len %d\n", __FUNCTION__,
+			req->buf_len, usbos_info->rxbuf_len));
+		req->buf_len = 0;
+		req->pkt = MALLOC(usbos_info->pub->osh, usbos_info->rxbuf_len);
+		if (req->pkt == NULL) {
+			DBUSERR(("%s: MALLOC req->pkt failed\n", __FUNCTION__));
+			ret = DBUS_ERR_NOMEM;
+			goto fail;
+		}
+		req->buf_len = usbos_info->rxbuf_len;
+	}
+	rxirb->buf = req->pkt;
+	p = rxirb->buf;
+#endif /* defined(BCM_RPC_NOCOPY) */
+	rxirb->buf_len = req->buf_len;
+	req->usbinfo = usbos_info;
+	req->arg = rxirb;
+	if (ep_idx == 0) {
+		rx_pipe = usbos_info->rx_pipe;
+	} else {
+		rx_pipe = usbos_info->rx_pipe2;
+		ASSERT(usbos_info->rx_pipe2);
+	}
+	/* Prepare the URB */
+	usb_fill_bulk_urb(req->urb, usbos_info->usb, rx_pipe,
+		p,
+		rxirb->buf_len,
+		(usb_complete_t)dbus_usbos_recv_complete, req);
+		req->urb->transfer_flags |= URB_QUEUE_BULK;
+
+	if ((ret = USB_SUBMIT_URB(req->urb))) {
+		DBUSERR(("%s USB_SUBMIT_URB failed. status %d\n", __FUNCTION__, ret));
+		dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
+		ret = DBUS_ERR_RXFAIL;
+		goto fail;
+	}
+	rxposted = atomic_inc_return(&usbos_info->rxposted);
+#if defined(DBUS_LINUX_HIST)
+	if (usbos_info->rxposted_hist) {
+		usbos_info->rxposted_hist[rxposted]++;
+	}
+#endif 
+
+	dbus_usbos_qenq(&usbos_info->req_rxpostedq, req, &usbos_info->rxposted_lock);
+fail:
+	spin_unlock_irqrestore(&usbos_info->rxlock, flags);
+	return ret;
+} /* dbus_usbos_recv_urb_submit */
+
+#ifdef DBUS_LINUX_RXDPC
+
+static void BCMFASTPATH
+dbus_usbos_recv_dpc(usbos_info_t *usbos_info)
+{
+	urb_req_t *req = NULL;
+	dbus_irb_rx_t *rxirb = NULL;
+	int dbus_status = DBUS_OK;
+	bool killed = (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPEND_PENDING) ? 1 : 0;
+
+#if defined(DBUS_LINUX_HIST)
+	int cnt = 0;
+
+	usbos_info->dpc_cnt++;
+#endif 
+
+	while ((req = dbus_usbos_qdeq(&usbos_info->req_rxpendingq,
+		&usbos_info->rxpending_lock)) != NULL) {
+		struct urb *urb = req->urb;
+		rxirb = req->arg;
+
+		/* Handle errors */
+		if (urb->status) {
+			/*
+			 * Linux 2.4 disconnect: -ENOENT or -EILSEQ for CRC error; rmmod: -ENOENT
+			 * Linux 2.6 disconnect: -EPROTO, rmmod: -ESHUTDOWN
+			 */
+			if ((urb->status == -ENOENT && (!killed)) || urb->status == -ESHUTDOWN) {
+				/* NOTE: unlink() can not be called from URB callback().
+				 * Do not call dbusos_stop() here.
+				 */
+				dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
+			} else if (urb->status == -EPROTO) {
+			} else {
+				DBUSERR(("%s rx error %d\n", __FUNCTION__, urb->status));
+				dbus_usbos_errhandler(usbos_info, DBUS_ERR_RXFAIL);
+			}
+
+			/* On error, don't submit more URBs yet */
+			DBUSERR(("%s %d rx error %d\n", __FUNCTION__, __LINE__, urb->status));
+			rxirb->buf = NULL;
+			rxirb->actual_len = 0;
+			dbus_status = DBUS_ERR_RXFAIL;
+			goto fail;
+		}
+
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+		/* detach the packet from the req */
+		req->pkt = NULL;
+#endif
+		/* Make the skb represent the received urb */
+		rxirb->actual_len = urb->actual_length;
+
+fail:
+		usbos_info->rxpending--;
+#if defined(DBUS_LINUX_HIST)
+		cnt++;
+#endif 
+		if (usbos_info->cbarg && usbos_info->cbs &&
+			usbos_info->cbs->recv_irb_complete) {
+			usbos_info->cbs->recv_irb_complete(usbos_info->cbarg, rxirb, dbus_status);
+		}
+		dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
+	}
+
+#if defined(DBUS_LINUX_HIST)
+	usbos_info->dpc_pktcnt += cnt;
+	usbos_info->dpc_maxpktcnt = MAX(cnt, usbos_info->dpc_maxpktcnt);
+#endif 
+#ifdef DBUS_LINUX_HIST
+	{
+		static unsigned long last_dump = 0;
+
+		/* dump every 20 sec */
+		if (jiffies > (last_dump + 20*HZ)) {
+			dbus_usbos_intf_dump(usbos_info, NULL);
+			last_dump = jiffies;
+		}
+	}
+#endif /* DBUS_LINUX_HIST */
+} /* dbus_usbos_recv_dpc */
+
+static int BCMFASTPATH
+dbus_usbos_dpc_thread(void *data)
+{
+	usbos_info_t *usbos_info = (usbos_info_t*)data;
+
+	DAEMONIZE("dbus_rx_dpc");
+	/* High priority for short response time. We will yield by ourselves. */
+	/* SET_NICE(-10); */
+
+	/* Run until signal received */
+	while (1) {
+		if (down_interruptible(&usbos_info->dpc_sem) == 0) {
+			dbus_usbos_recv_dpc(usbos_info);
+			RESCHED();
+		} else
+			break;
+	}
+
+	complete_and_exit(&usbos_info->dpc_exited, 0);
+	return 0;
+}
+
+#endif /* DBUS_LINUX_RXDPC */
+
+/**
+ * Called by worked thread when a 'receive URB' completed or Linux kernel when it returns a URB to
+ * this driver.
+ */
+static void BCMFASTPATH
+dbus_usbos_recv_complete_handle(urb_req_t *req, int len, int status)
+{
+#ifdef DBUS_LINUX_RXDPC
+	usbos_info_t *usbos_info = req->usbinfo;
+	unsigned long flags;
+	int rxallocated, rxposted;
+
+	spin_lock_irqsave(&usbos_info->rxlock, flags);
+	/* detach the packet from the queue */
+	dbus_usbos_req_del(req, &usbos_info->rxposted_lock);
+	rxposted = atomic_dec_return(&usbos_info->rxposted);
+	rxallocated = atomic_read(&usbos_info->rxallocated);
+
+	/* Enqueue to rxpending queue */
+	usbos_info->rxpending++;
+	dbus_usbos_qenq(&usbos_info->req_rxpendingq, req, &usbos_info->rxpending_lock);
+	spin_unlock_irqrestore(&usbos_info->rxlock, flags);
+
+#error "RX req/buf appending-mode not verified for DBUS_LINUX_RXDPC because it was disabled"
+	if ((rxallocated < usbos_info->pub->nrxq) && (!status) &&
+		(rxposted == DBUS_USB_RXQUEUE_LOWER_WATERMARK)) {
+			DBUSTRACE(("%s: need more rx buf: rxallocated %d rxposted %d!\n",
+				__FUNCTION__, rxallocated, rxposted));
+			dbus_usbos_urbreqs_alloc(usbos_info,
+				MIN(DBUS_USB_RXQUEUE_BATCH_ADD,
+				usbos_info->pub->nrxq - rxallocated), TRUE);
+	}
+#error "Please verify above code works if you happened to enable DBUS_LINUX_RXDPC!!"
+
+	/* Wake up dpc for further processing */
+	ASSERT(usbos_info->dpc_pid >= 0);
+	up(&usbos_info->dpc_sem);
+#else
+	dbus_irb_rx_t *rxirb = req->arg;
+	usbos_info_t *usbos_info = req->usbinfo;
+	unsigned long flags;
+	int rxallocated, rxposted;
+	int dbus_status = DBUS_OK;
+	bool killed = (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPEND_PENDING) ? 1 : 0;
+
+	spin_lock_irqsave(&usbos_info->rxlock, flags);
+	dbus_usbos_req_del(req, &usbos_info->rxposted_lock);
+	rxposted = atomic_dec_return(&usbos_info->rxposted);
+	rxallocated = atomic_read(&usbos_info->rxallocated);
+	spin_unlock_irqrestore(&usbos_info->rxlock, flags);
+
+	if ((rxallocated < usbos_info->pub->nrxq) && (!status) &&
+		(rxposted == DBUS_USB_RXQUEUE_LOWER_WATERMARK)) {
+			DBUSTRACE(("%s: need more rx buf: rxallocated %d rxposted %d!\n",
+				__FUNCTION__, rxallocated, rxposted));
+			dbus_usbos_urbreqs_alloc(usbos_info,
+				MIN(DBUS_USB_RXQUEUE_BATCH_ADD,
+				usbos_info->pub->nrxq - rxallocated), TRUE);
+	}
+
+	/* Handle errors */
+	if (status) {
+		/*
+		 * Linux 2.4 disconnect: -ENOENT or -EILSEQ for CRC error; rmmod: -ENOENT
+		 * Linux 2.6 disconnect: -EPROTO, rmmod: -ESHUTDOWN
+		 */
+		if ((status == -ENOENT && (!killed))|| status == -ESHUTDOWN) {
+			/* NOTE: unlink() can not be called from URB callback().
+			 * Do not call dbusos_stop() here.
+			 */
+			DBUSTRACE(("%s rx error %d\n", __FUNCTION__, status));
+			dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
+		} else if (status == -EPROTO) {
+			DBUSTRACE(("%s rx error %d\n", __FUNCTION__, status));
+		} else if (killed && (status == -EHOSTUNREACH || status == -ENOENT)) {
+			/* Device is suspended */
+		} else {
+			DBUSTRACE(("%s rx error %d\n", __FUNCTION__, status));
+			dbus_usbos_errhandler(usbos_info, DBUS_ERR_RXFAIL);
+		}
+
+		/* On error, don't submit more URBs yet */
+		rxirb->buf = NULL;
+		rxirb->actual_len = 0;
+		dbus_status = DBUS_ERR_RXFAIL;
+		goto fail;
+	}
+
+	/* Make the skb represent the received urb */
+	rxirb->actual_len = len;
+
+	if (rxirb->actual_len < sizeof(uint32)) {
+		DBUSTRACE(("small pkt len %d, process as ZLP\n", rxirb->actual_len));
+		dbus_status = DBUS_ERR_RXZLP;
+	}
+
+fail:
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+	/* detach the packet from the queue */
+	req->pkt = NULL;
+#endif /* BCM_RPC_NOCOPY || BCM_RPC_RXNOCOPY */
+
+	if (usbos_info->cbarg && usbos_info->cbs) {
+		if (usbos_info->cbs->recv_irb_complete) {
+			usbos_info->cbs->recv_irb_complete(usbos_info->cbarg, rxirb, dbus_status);
+		}
+	}
+
+	dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
+#endif /* DBUS_LINUX_RXDPC */
+
+	/* Mark the interface as busy to reset USB autosuspend timer */
+	USB_MARK_LAST_BUSY(usbos_info->usb);
+} /* dbus_usbos_recv_complete_handle */
+
+/** called by Linux kernel when it returns a URB to this driver */
+static void
+dbus_usbos_recv_complete(CALLBACK_ARGS)
+{
+#ifdef USBOS_THREAD
+	dbus_usbos_dispatch_schedule(CALLBACK_ARGS_DATA);
+#else /*  !USBOS_THREAD */
+	dbus_usbos_recv_complete_handle(urb->context, urb->actual_length, urb->status);
+#endif /*  USBOS_THREAD */
+}
+
+
+/**
+ * If Linux notifies our driver that a control read or write URB has completed, we should notify
+ * the DBUS layer above us (dbus_usb.c in this case).
+ */
+static void
+dbus_usbos_ctl_complete(usbos_info_t *usbos_info, int type, int urbstatus)
+{
+	int status = DBUS_ERR;
+
+	if (usbos_info == NULL)
+		return;
+
+	switch (urbstatus) {
+		case 0:
+			status = DBUS_OK;
+		break;
+		case -EINPROGRESS:
+		case -ENOENT:
+		default:
+#ifdef INTR_EP_ENABLE
+			DBUSERR(("%s:%d fail status %d bus:%d susp:%d intr:%d ctli:%d ctlo:%d\n",
+				__FUNCTION__, type, urbstatus,
+				usbos_info->pub->busstate, g_probe_info.suspend_state,
+				usbos_info->intr_urb_submitted, usbos_info->ctlin_urb_submitted,
+				usbos_info->ctlout_urb_submitted));
+#else
+			DBUSERR(("%s: failed with status %d\n", __FUNCTION__, urbstatus));
+			status = DBUS_ERR;
+		break;
+#endif /* INTR_EP_ENABLE */
+	}
+
+	if (usbos_info->cbarg && usbos_info->cbs) {
+		if (usbos_info->cbs->ctl_complete)
+			usbos_info->cbs->ctl_complete(usbos_info->cbarg, type, status);
+	}
+}
+
+/** called by Linux */
+static void
+dbus_usbos_ctlread_complete(CALLBACK_ARGS)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *)urb->context;
+
+	ASSERT(urb);
+	usbos_info = (usbos_info_t *)urb->context;
+
+	dbus_usbos_ctl_complete(usbos_info, DBUS_CBCTL_READ, urb->status);
+
+#ifdef USBOS_THREAD
+	if (usbos_info->rxctl_deferrespok) {
+		usbos_info->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_CLASS |
+		USB_RECIP_INTERFACE;
+		usbos_info->ctl_read.bRequest = 1;
+	}
+#endif
+
+	up(&usbos_info->ctl_lock);
+
+	USB_AUTOPM_PUT_INTERFACE_ASYNC(g_probe_info.intf);
+}
+
+/** called by Linux */
+static void
+dbus_usbos_ctlwrite_complete(CALLBACK_ARGS)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *)urb->context;
+
+	ASSERT(urb);
+	usbos_info = (usbos_info_t *)urb->context;
+
+	dbus_usbos_ctl_complete(usbos_info, DBUS_CBCTL_WRITE, urb->status);
+
+#ifdef USBOS_TX_THREAD
+	usbos_info->ctl_state = USBOS_REQUEST_STATE_UNSCHEDULED;
+#endif /* USBOS_TX_THREAD */
+
+	up(&usbos_info->ctl_lock);
+
+	USB_AUTOPM_PUT_INTERFACE_ASYNC(g_probe_info.intf);
+}
+
+#ifdef INTR_EP_ENABLE
+/** called by Linux */
+static void
+dbus_usbos_intr_complete(CALLBACK_ARGS)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *)urb->context;
+	bool killed = (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPEND_PENDING) ? 1 : 0;
+
+	if (usbos_info == NULL || usbos_info->pub == NULL)
+		return;
+	if ((urb->status == -ENOENT && (!killed)) || urb->status == -ESHUTDOWN ||
+		urb->status == -ENODEV) {
+		dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
+	}
+
+	if (usbos_info->pub->busstate == DBUS_STATE_DOWN) {
+		DBUSERR(("%s: intr cb when DBUS down, ignoring\n", __FUNCTION__));
+		return;
+	}
+	dbus_usbos_ctl_complete(usbos_info, DBUS_CBINTR_POLL, urb->status);
+}
+#endif	/* INTR_EP_ENABLE */
+
+/**
+ * when the bus is going to sleep or halt, the Linux kernel requires us to take ownership of our
+ * URBs again. Multiple code paths in this file require a list of URBs to be cancelled in a
+ * concurrency save manner.
+ */
+static void
+dbus_usbos_unlink(struct list_head *urbreq_q, spinlock_t *lock)
+{
+	urb_req_t *req;
+
+	/* dbus_usbos_recv_complete() adds req back to req_freeq */
+	while ((req = dbus_usbos_qdeq(urbreq_q, lock)) != NULL) {
+		ASSERT(req->urb != NULL);
+		USB_UNLINK_URB(req->urb);
+	}
+}
+
+/** multiple code paths in this file require the bus to stop */
+static void
+dbus_usbos_cancel_all_urbs(usbos_info_t *usbos_info)
+{
+	int rxposted, txposted;
+
+	DBUSTRACE(("%s: unlink all URBs\n", __FUNCTION__));
+
+#ifdef USBOS_TX_THREAD
+	usbos_info->ctl_state = USBOS_REQUEST_STATE_UNSCHEDULED;
+
+	/* Yield the CPU to TX thread so all pending requests are submitted */
+	while (!list_empty(&usbos_info->usbos_tx_list)) {
+		wake_up_interruptible(&usbos_info->usbos_tx_queue_head);
+		OSL_SLEEP(10);
+	}
+#endif /* USBOS_TX_THREAD */
+
+	/* tell Linux kernel to cancel a single intr, ctl and blk URB */
+	if (usbos_info->intr_urb)
+		USB_UNLINK_URB(usbos_info->intr_urb);
+	if (usbos_info->ctl_urb)
+		USB_UNLINK_URB(usbos_info->ctl_urb);
+	if (usbos_info->blk_urb)
+		USB_UNLINK_URB(usbos_info->blk_urb);
+
+	dbus_usbos_unlink(&usbos_info->req_txpostedq, &usbos_info->txposted_lock);
+	dbus_usbos_unlink(&usbos_info->req_rxpostedq, &usbos_info->rxposted_lock);
+
+	/* Wait until the callbacks for all submitted URBs have been called, because the
+	 * handler needs to know is an USB suspend is in progress.
+	 */
+	SPINWAIT((atomic_read(&usbos_info->txposted) != 0 ||
+		atomic_read(&usbos_info->rxposted) != 0), 10000);
+
+	txposted = atomic_read(&usbos_info->txposted);
+	rxposted = atomic_read(&usbos_info->rxposted);
+	if (txposted != 0 || rxposted != 0) {
+		DBUSERR(("%s ERROR: REQs posted, rx=%d tx=%d!\n",
+			__FUNCTION__, rxposted, txposted));
+	}
+} /* dbus_usbos_cancel_all_urbs */
+
+/** multiple code paths require the bus to stop */
+static void
+dbusos_stop(usbos_info_t *usbos_info)
+{
+	urb_req_t *req;
+	int rxposted;
+	req = NULL;
+	BCM_REFERENCE(req);
+
+	ASSERT(usbos_info);
+
+#ifdef USB_TRIGGER_DEBUG
+	dbus_usbos_ctl_send_debugtrig(usbos_info);
+#endif /* USB_TRIGGER_DEBUG */
+	dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
+
+	dbus_usbos_cancel_all_urbs(usbos_info);
+
+#ifdef USBOS_THREAD
+	/* yield the CPU to rx packet thread */
+	while (1) {
+		if (atomic_read(&usbos_info->usbos_list_cnt) <= 0)	break;
+		wake_up_interruptible(&usbos_info->usbos_queue_head);
+		OSL_SLEEP(3);
+	}
+#endif /* USBOS_THREAD */
+
+	rxposted = atomic_read(&usbos_info->rxposted);
+	if (rxposted > 0) {
+		DBUSERR(("%s ERROR: rx REQs posted=%d in stop!\n", __FUNCTION__,
+			rxposted));
+	}
+
+	ASSERT(atomic_read(&usbos_info->txposted) == 0 && rxposted == 0);
+
+#ifdef DBUS_LINUX_RXDPC
+	/* Stop the dpc thread */
+	if (usbos_info->dpc_pid >= 0) {
+		KILL_PROC(usbos_info->dpc_pid, SIGTERM);
+		wait_for_completion(&usbos_info->dpc_exited);
+	}
+
+	/* Move pending reqs to free queue so they can be freed */
+	while ((req = dbus_usbos_qdeq(&usbos_info->req_rxpendingq,
+		&usbos_info->rxpending_lock)) != NULL) {
+		dbus_usbos_qenq(&usbos_info->req_rxfreeq, req,
+			&usbos_info->rxfree_lock);
+	}
+#endif /* DBUS_LINUX_RXDPC */
+} /* dbusos_stop */
+
+#if defined(USB_SUSPEND_AVAILABLE)
+
+/**
+ * Linux kernel sports a 'USB auto suspend' feature. See: http://lwn.net/Articles/373550/
+ * The suspend method is called by the Linux kernel to warn the driver that the device is going to
+ * be suspended.  If the driver returns a negative error code, the suspend will be aborted. If the
+ * driver returns 0, it must cancel all outstanding URBs (usb_kill_urb()) and not submit any more.
+ */
+static int
+dbus_usbos_suspend(struct usb_interface *intf,
+            pm_message_t message)
+{
+	DBUSERR(("%s suspend state: %d\n", __FUNCTION__, g_probe_info.suspend_state));
+	/* DHD for full dongle model */
+	g_probe_info.suspend_state = USBOS_SUSPEND_STATE_SUSPEND_PENDING;
+	dbus_usbos_state_change((usbos_info_t*)g_probe_info.usbos_info, DBUS_STATE_SLEEP);
+	dbus_usbos_cancel_all_urbs((usbos_info_t*)g_probe_info.usbos_info);
+	g_probe_info.suspend_state = USBOS_SUSPEND_STATE_SUSPENDED;
+
+	return 0;
+}
+
+/**
+ * The resume method is called to tell the driver that the device has been resumed and the driver
+ * can return to normal operation.  URBs may once more be submitted.
+ */
+static int dbus_usbos_resume(struct usb_interface *intf)
+{
+	DBUSERR(("%s Device resumed\n", __FUNCTION__));
+
+	dbus_usbos_state_change((usbos_info_t*)g_probe_info.usbos_info, DBUS_STATE_UP);
+	g_probe_info.suspend_state = USBOS_SUSPEND_STATE_DEVICE_ACTIVE;
+	return 0;
+}
+
+/**
+* This function is directly called by the Linux kernel, when the suspended device has been reset
+* instead of being resumed
+*/
+static int dbus_usbos_reset_resume(struct usb_interface *intf)
+{
+	DBUSERR(("%s Device reset resumed\n", __FUNCTION__));
+
+#ifdef KEEPIF_ON_DEVICE_RESET
+	if (g_probe_info.keepif_on_devreset) {
+		atomic_set(&g_probe_info.usbdev_stat, USB_DEVICE_RESETTED);
+		wake_up_interruptible(&g_probe_info.usbreset_queue_head);
+	} else
+#endif /* KEEPIF_ON_DEVICE_RESET */
+	{
+		/* The device may have lost power, so a firmware download may be required */
+		dbus_usbos_state_change((usbos_info_t*)g_probe_info.usbos_info,
+			DBUS_STATE_DL_NEEDED);
+		g_probe_info.suspend_state = USBOS_SUSPEND_STATE_DEVICE_ACTIVE;
+	}
+
+	return 0;
+}
+
+#endif /* USB_SUSPEND_AVAILABLE */
+
+/**
+ * Called by Linux kernel at initialization time, kernel wants to know if our driver will accept the
+ * caller supplied USB interface. Note that USB drivers are bound to interfaces, and not to USB
+ * devices.
+ */
+#ifdef KERNEL26
+static int
+dbus_usbos_probe(struct usb_interface *intf, const struct usb_device_id *id)
+#else
+static void *
+dbus_usbos_probe(struct usb_device *usb, unsigned int ifnum, const struct usb_device_id *id)
+#endif /* KERNEL26 */
+{
+	int ep;
+	struct usb_endpoint_descriptor *endpoint;
+	int ret = 0;
+#ifdef KERNEL26
+	struct usb_device *usb = interface_to_usbdev(intf);
+#else
+	int claimed = 0;
+#endif
+	int num_of_eps;
+#ifdef BCMUSBDEV_COMPOSITE
+	int wlan_if = -1;
+	bool intr_ep = FALSE;
+#endif /* BCMUSBDEV_COMPOSITE */
+
+#ifdef BCMUSBDEV_COMPOSITE
+	wlan_if = dbus_usbos_intf_wlan(usb);
+#ifdef KERNEL26
+	if ((wlan_if >= 0) && (IFPTR(usb, wlan_if) == intf)) {
+#else
+	if (wlan_if == ifnum) {
+#endif /* KERNEL26 */
+#endif /* BCMUSBDEV_COMPOSITE */
+		g_probe_info.usb = usb;
+		g_probe_info.dldone = TRUE;
+#ifdef BCMUSBDEV_COMPOSITE
+	} else {
+		DBUSTRACE(("dbus_usbos_probe: skip probe for non WLAN interface\n"));
+		ret = BCME_UNSUPPORTED;
+		goto fail;
+	}
+#endif /* BCMUSBDEV_COMPOSITE */
+
+#ifdef KERNEL26
+	g_probe_info.intf = intf;
+#endif /* KERNEL26 */
+
+#ifdef BCMUSBDEV_COMPOSITE
+	if (IFDESC(usb, wlan_if).bInterfaceNumber > USB_COMPIF_MAX) {
+#else
+	if (IFDESC(usb, CONTROL_IF).bInterfaceNumber) {
+#endif /* BCMUSBDEV_COMPOSITE */
+		ret = -1;
+		goto fail;
+	}
+	if (id != NULL) {
+		g_probe_info.vid = id->idVendor;
+		g_probe_info.pid = id->idProduct;
+	}
+
+#ifdef KERNEL26
+	usb_set_intfdata(intf, &g_probe_info);
+#endif
+
+	/* Check that the device supports only one configuration */
+	if (usb->descriptor.bNumConfigurations != 1) {
+		ret = -1;
+		goto fail;
+	}
+
+	if (usb->descriptor.bDeviceClass != USB_CLASS_VENDOR_SPEC) {
+#ifdef BCMUSBDEV_COMPOSITE
+		if ((usb->descriptor.bDeviceClass != USB_CLASS_MISC) &&
+			(usb->descriptor.bDeviceClass != USB_CLASS_WIRELESS)) {
+#endif /* BCMUSBDEV_COMPOSITE */
+			ret = -1;
+			goto fail;
+#ifdef BCMUSBDEV_COMPOSITE
+		}
+#endif /* BCMUSBDEV_COMPOSITE */
+	}
+
+	/*
+	 * Only the BDC interface configuration is supported:
+	 *	Device class: USB_CLASS_VENDOR_SPEC
+	 *	if0 class: USB_CLASS_VENDOR_SPEC
+	 *	if0/ep0: control
+	 *	if0/ep1: bulk in
+	 *	if0/ep2: bulk out (ok if swapped with bulk in)
+	 */
+	if (CONFIGDESC(usb)->bNumInterfaces != 1) {
+#ifdef BCMUSBDEV_COMPOSITE
+		if (CONFIGDESC(usb)->bNumInterfaces > USB_COMPIF_MAX) {
+#endif /* BCMUSBDEV_COMPOSITE */
+			ret = -1;
+			goto fail;
+#ifdef BCMUSBDEV_COMPOSITE
+		}
+#endif /* BCMUSBDEV_COMPOSITE */
+	}
+
+	/* Check interface */
+#ifndef KERNEL26
+#ifdef BCMUSBDEV_COMPOSITE
+	if (usb_interface_claimed(IFPTR(usb, wlan_if))) {
+#else
+	if (usb_interface_claimed(IFPTR(usb, CONTROL_IF))) {
+#endif /* BCMUSBDEV_COMPOSITE */
+		ret = -1;
+		goto fail;
+	}
+#endif /* !KERNEL26 */
+
+#ifdef BCMUSBDEV_COMPOSITE
+	if ((IFDESC(usb, wlan_if).bInterfaceClass != USB_CLASS_VENDOR_SPEC ||
+		IFDESC(usb, wlan_if).bInterfaceSubClass != 2 ||
+		IFDESC(usb, wlan_if).bInterfaceProtocol != 0xff) &&
+		(IFDESC(usb, wlan_if).bInterfaceClass != USB_CLASS_MISC ||
+		IFDESC(usb, wlan_if).bInterfaceSubClass != USB_SUBCLASS_COMMON ||
+		IFDESC(usb, wlan_if).bInterfaceProtocol != USB_PROTO_IAD)) {
+			DBUSERR(("%s: invalid control interface: class %d, subclass %d, proto %d\n",
+				__FUNCTION__,
+				IFDESC(usb, wlan_if).bInterfaceClass,
+				IFDESC(usb, wlan_if).bInterfaceSubClass,
+				IFDESC(usb, wlan_if).bInterfaceProtocol));
+#else
+	if (IFDESC(usb, CONTROL_IF).bInterfaceClass != USB_CLASS_VENDOR_SPEC ||
+		IFDESC(usb, CONTROL_IF).bInterfaceSubClass != 2 ||
+		IFDESC(usb, CONTROL_IF).bInterfaceProtocol != 0xff) {
+			DBUSERR(("%s: invalid control interface: class %d, subclass %d, proto %d\n",
+				__FUNCTION__,
+				IFDESC(usb, CONTROL_IF).bInterfaceClass,
+				IFDESC(usb, CONTROL_IF).bInterfaceSubClass,
+				IFDESC(usb, CONTROL_IF).bInterfaceProtocol));
+#endif /* BCMUSBDEV_COMPOSITE */
+			ret = -1;
+			goto fail;
+	}
+
+	/* Check control endpoint */
+#ifdef BCMUSBDEV_COMPOSITE
+	endpoint = &IFEPDESC(usb, wlan_if, 0);
+#else
+	endpoint = &IFEPDESC(usb, CONTROL_IF, 0);
+#endif /* BCMUSBDEV_COMPOSITE */
+	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT) {
+#ifdef BCMUSBDEV_COMPOSITE
+		if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=
+			USB_ENDPOINT_XFER_BULK) {
+#endif /* BCMUSBDEV_COMPOSITE */
+			DBUSERR(("%s: invalid control endpoint %d\n",
+				__FUNCTION__, endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK));
+			ret = -1;
+			goto fail;
+#ifdef BCMUSBDEV_COMPOSITE
+		}
+#endif /* BCMUSBDEV_COMPOSITE */
+	}
+
+#ifdef BCMUSBDEV_COMPOSITE
+	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT) {
+#endif /* BCMUSBDEV_COMPOSITE */
+		g_probe_info.intr_pipe =
+			usb_rcvintpipe(usb, endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+#ifdef BCMUSBDEV_COMPOSITE
+		intr_ep = TRUE;
+	}
+#endif /* BCMUSBDEV_COMPOSITE */
+
+#ifndef KERNEL26
+	/* Claim interface */
+#ifdef BCMUSBDEV_COMPOSITE
+	usb_driver_claim_interface(&dbus_usbdev, IFPTR(usb, wlan_if), &g_probe_info);
+#else
+	usb_driver_claim_interface(&dbus_usbdev, IFPTR(usb, CONTROL_IF), &g_probe_info);
+#endif /* BCMUSBDEV_COMPOSITE */
+	claimed = 1;
+#endif /* !KERNEL26 */
+	g_probe_info.rx_pipe = 0;
+	g_probe_info.rx_pipe2 = 0;
+	g_probe_info.tx_pipe = 0;
+#ifdef BCMUSBDEV_COMPOSITE
+	if (intr_ep)
+		ep = 1;
+	else
+		ep = 0;
+	num_of_eps = IFDESC(usb, wlan_if).bNumEndpoints - 1;
+#else
+	num_of_eps = IFDESC(usb, BULK_IF).bNumEndpoints - 1;
+#endif /* BCMUSBDEV_COMPOSITE */
+
+	if ((num_of_eps != 2) && (num_of_eps != 3)) {
+#ifdef BCMUSBDEV_COMPOSITE
+		if (num_of_eps > 7)
+#endif /* BCMUSBDEV_COMPOSITE */
+			ASSERT(0);
+	}
+	/* Check data endpoints and get pipes */
+#ifdef BCMUSBDEV_COMPOSITE
+	for (; ep <= num_of_eps; ep++) {
+		endpoint = &IFEPDESC(usb, wlan_if, ep);
+#else
+	for (ep = 1; ep <= num_of_eps; ep++) {
+		endpoint = &IFEPDESC(usb, BULK_IF, ep);
+#endif /* BCMUSBDEV_COMPOSITE */
+		if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=
+		    USB_ENDPOINT_XFER_BULK) {
+			DBUSERR(("%s: invalid data endpoint %d\n",
+			           __FUNCTION__, ep));
+			ret = -1;
+			goto fail;
+		}
+
+		if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) {
+			/* direction: dongle->host */
+			if (!g_probe_info.rx_pipe) {
+				g_probe_info.rx_pipe = usb_rcvbulkpipe(usb,
+					(endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK));
+			} else {
+				g_probe_info.rx_pipe2 = usb_rcvbulkpipe(usb,
+					(endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK));
+			}
+
+		} else
+			g_probe_info.tx_pipe = usb_sndbulkpipe(usb, (endpoint->bEndpointAddress &
+			     USB_ENDPOINT_NUMBER_MASK));
+	}
+
+	/* Allocate interrupt URB and data buffer */
+	/* RNDIS says 8-byte intr, our old drivers used 4-byte */
+#ifdef BCMUSBDEV_COMPOSITE
+	g_probe_info.intr_size = (IFEPDESC(usb, wlan_if, 0).wMaxPacketSize == 16) ? 8 : 4;
+	g_probe_info.interval = IFEPDESC(usb, wlan_if, 0).bInterval;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21))
+	usb->quirks |= USB_QUIRK_NO_SET_INTF;
+#endif
+#else
+	g_probe_info.intr_size = (IFEPDESC(usb, CONTROL_IF, 0).wMaxPacketSize == 16) ? 8 : 4;
+	g_probe_info.interval = IFEPDESC(usb, CONTROL_IF, 0).bInterval;
+#endif /* BCMUSBDEV_COMPOSITE */
+
+#ifndef KERNEL26
+	/* usb_fill_int_urb does the interval decoding in 2.6 */
+	if (usb->speed == USB_SPEED_HIGH)
+		g_probe_info.interval = 1 << (g_probe_info.interval - 1);
+#endif
+	if (usb->speed == USB_SPEED_SUPER) {
+		g_probe_info.device_speed = SUPER_SPEED;
+		DBUSERR(("super speed device detected\n"));
+	} else if (usb->speed == USB_SPEED_HIGH) {
+		g_probe_info.device_speed = HIGH_SPEED;
+		DBUSERR(("high speed device detected\n"));
+	} else {
+		g_probe_info.device_speed = FULL_SPEED;
+		DBUSERR(("full speed device detected\n"));
+	}
+#ifdef KEEPIF_ON_DEVICE_RESET
+	if (g_probe_info.keepif_on_devreset && g_probe_info.dev_resetted) {
+		atomic_set(&g_probe_info.usbdev_stat, USB_DEVICE_PROBED);
+		wake_up_interruptible(&g_probe_info.usbreset_queue_head);
+	} else
+#endif /* KEEPIF_ON_DEVICE_RESET */
+	if (g_probe_info.dereged == FALSE && probe_cb) {
+		disc_arg = probe_cb(probe_arg, "", USB_BUS, 0);
+	}
+
+	g_probe_info.disc_cb_done = FALSE;
+
+#ifdef KERNEL26
+	intf->needs_remote_wakeup = 1;
+#endif /* KERNEL26 */
+
+	/* Success */
+#ifdef KERNEL26
+	return DBUS_OK;
+#else
+	usb_inc_dev_use(usb);
+	return &g_probe_info;
+#endif
+
+fail:
+#ifdef BCMUSBDEV_COMPOSITE
+	if (ret != BCME_UNSUPPORTED)
+#endif /* BCMUSBDEV_COMPOSITE */
+		DBUSERR(("%s: failed with errno %d\n", __FUNCTION__, ret));
+#ifndef KERNEL26
+	if (claimed)
+#ifdef BCMUSBDEV_COMPOSITE
+		usb_driver_release_interface(&dbus_usbdev, IFPTR(usb, wlan_if));
+#else
+		usb_driver_release_interface(&dbus_usbdev, IFPTR(usb, CONTROL_IF));
+#endif /* BCMUSBDEV_COMPOSITE */
+#endif /* !KERNEL26 */
+
+#ifdef KERNEL26
+	usb_set_intfdata(intf, NULL);
+	return ret;
+#else
+	return NULL;
+#endif
+} /* dbus_usbos_probe */
+
+/** Called by Linux kernel, is the counter part of dbus_usbos_probe() */
+#ifdef KERNEL26
+static void
+dbus_usbos_disconnect(struct usb_interface *intf)
+#else
+static void
+dbus_usbos_disconnect(struct usb_device *usb, void *ptr)
+#endif
+{
+#ifdef KERNEL26
+	struct usb_device *usb = interface_to_usbdev(intf);
+	probe_info_t *probe_usb_init_data = usb_get_intfdata(intf);
+#else
+	probe_info_t *probe_usb_init_data = (probe_info_t *) ptr;
+#endif
+	usbos_info_t *usbos_info;
+
+	if (probe_usb_init_data) {
+		usbos_info = (usbos_info_t *) probe_usb_init_data->usbos_info;
+		if (usbos_info) {
+			if ((probe_usb_init_data->dereged == FALSE) && disconnect_cb && disc_arg) {
+				bool remove_if = TRUE;
+#ifdef KEEPIF_ON_DEVICE_RESET
+				if (g_probe_info.keepif_on_devreset)
+					remove_if = FALSE;
+#endif /* KEEPIF_ON_DEVICE_RESET */
+				if (remove_if) {
+					disconnect_cb(disc_arg);
+					disc_arg = NULL;
+					probe_usb_init_data->disc_cb_done = TRUE;
+				}
+			}
+		}
+	}
+
+	if (usb) {
+#ifndef KERNEL26
+#ifdef BCMUSBDEV_COMPOSITE
+		usb_driver_release_interface(&dbus_usbdev, IFPTR(usb, wlan_if));
+#else
+		usb_driver_release_interface(&dbus_usbdev, IFPTR(usb, CONTROL_IF));
+#endif /* BCMUSBDEV_COMPOSITE */
+		usb_dec_dev_use(usb);
+#endif /* !KERNEL26 */
+	}
+
+#ifdef KEEPIF_ON_DEVICE_RESET
+	if (g_probe_info.keepif_on_devreset && (!g_probe_info.dev_resetted)) {
+		atomic_set(&g_probe_info.usbdev_stat, USB_DEVICE_DISCONNECTED);
+		wake_up_interruptible(&g_probe_info.usbreset_queue_head);
+	}
+#endif /* KEEPIF_ON_DEVICE_RESET */
+} /* dbus_usbos_disconnect */
+
+#define LOOPBACK_PKT_START 0xBABE1234
+
+bool is_loopback_pkt(void *buf)
+{
+
+	uint32 *buf_ptr = (uint32 *) buf;
+
+	if (*buf_ptr == LOOPBACK_PKT_START)
+		return TRUE;
+	return FALSE;
+
+}
+
+int matches_loopback_pkt(void *buf)
+{
+	int i, j;
+	unsigned char *cbuf = (unsigned char *) buf;
+
+	for (i = 4; i < loopback_size; i++) {
+		if (cbuf[i] != (i % 256)) {
+			printf("%s: mismatch at i=%d %d : ", __FUNCTION__, i, cbuf[i]);
+			for (j = i; ((j < i+ 16) && (j < loopback_size)); j++) {
+				printf("%d ", cbuf[j]);
+			}
+			printf("\n");
+			return 0;
+		}
+	}
+	loopback_rx_cnt++;
+	return 1;
+}
+
+int dbus_usbos_loopback_tx(void *usbos_info_ptr, int cnt, int size)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) usbos_info_ptr;
+	unsigned char *buf;
+	int j;
+	void* p = NULL;
+	int rc, last_rx_cnt;
+	int tx_failed_cnt;
+	int max_size = 1650;
+	int usb_packet_size = 512;
+	int min_packet_size = 10;
+
+	if (size % usb_packet_size == 0) {
+		size = size - 1;
+		DBUSERR(("%s: overriding size=%d \n", __FUNCTION__, size));
+	}
+
+	if (size < min_packet_size) {
+		size = min_packet_size;
+		DBUSERR(("%s: overriding size=%d\n", __FUNCTION__, min_packet_size));
+	}
+	if (size > max_size) {
+		size = max_size;
+		DBUSERR(("%s: overriding size=%d\n", __FUNCTION__, max_size));
+	}
+
+	loopback_tx_cnt = 0;
+	loopback_rx_cnt = 0;
+	tx_failed_cnt = 0;
+	loopback_size   = size;
+
+	while (loopback_tx_cnt < cnt) {
+		uint32 *x;
+		int pkt_size = loopback_size;
+
+		p = PKTGET(usbos_info->pub->osh, pkt_size, TRUE);
+		if (p == NULL) {
+			DBUSERR(("%s:%d Failed to allocate packet sz=%d\n",
+			       __FUNCTION__, __LINE__, pkt_size));
+			return BCME_ERROR;
+		}
+		x = (uint32*) PKTDATA(usbos_info->pub->osh, p);
+		*x = LOOPBACK_PKT_START;
+		buf = (unsigned char*) x;
+		for (j = 4; j < pkt_size; j++) {
+			buf[j] = j % 256;
+		}
+		rc = dbus_send_buf(usbos_info->pub, buf, pkt_size, p);
+		if (rc != BCME_OK) {
+			DBUSERR(("%s:%d Freeing packet \n", __FUNCTION__, __LINE__));
+			PKTFREE(usbos_info->pub->osh, p, TRUE);
+			dbus_usbos_wait(usbos_info, 1);
+			tx_failed_cnt++;
+		} else {
+			loopback_tx_cnt++;
+			tx_failed_cnt = 0;
+		}
+		if (tx_failed_cnt == 5) {
+			DBUSERR(("%s : Failed to send loopback packets cnt=%d loopback_tx_cnt=%d\n",
+			 __FUNCTION__, cnt, loopback_tx_cnt));
+			break;
+		}
+	}
+	printf("Transmitted %d loopback packets of size %d\n", loopback_tx_cnt, loopback_size);
+
+	last_rx_cnt = loopback_rx_cnt;
+	while (loopback_rx_cnt < loopback_tx_cnt) {
+		dbus_usbos_wait(usbos_info, 1);
+		if (loopback_rx_cnt <= last_rx_cnt) {
+			DBUSERR(("%s: Matched rx cnt stuck at %d \n", __FUNCTION__, last_rx_cnt));
+			return BCME_ERROR;
+		}
+		last_rx_cnt = loopback_rx_cnt;
+	}
+	printf("Received %d loopback packets of size %d\n", loopback_tx_cnt, loopback_size);
+
+	return BCME_OK;
+} /* dbus_usbos_loopback_tx */
+
+/**
+ * Higher layer (dbus_usb.c) wants to transmit an I/O Request Block
+ *     @param[in] txirb txirb->pkt, if non-zero, contains a single or a chain of packets
+ */
+static int
+dbus_usbos_intf_send_irb(void *bus, dbus_irb_tx_t *txirb)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	urb_req_t *req, *req_zlp = NULL;
+	int ret = DBUS_OK;
+	unsigned long flags;
+	void *pkt;
+	uint32 buffer_length;
+	uint8 *buf;
+
+	if ((usbos_info == NULL) || !usbos_info->tx_pipe) {
+		return DBUS_ERR;
+	}
+
+	if (txirb->pkt != NULL) {
+		buffer_length = pkttotlen(usbos_info->pub->osh, txirb->pkt);
+		/* In case of multiple packets the values below may be overwritten */
+		txirb->send_buf = NULL;
+		buf = PKTDATA(usbos_info->pub->osh, txirb->pkt);
+	} else { /* txirb->buf != NULL */
+		ASSERT(txirb->buf != NULL);
+		ASSERT(txirb->send_buf == NULL);
+		buffer_length = txirb->len;
+		buf = txirb->buf;
+	}
+
+	if (!(req = dbus_usbos_qdeq(&usbos_info->req_txfreeq, &usbos_info->txfree_lock))) {
+		DBUSERR(("%s No free URB!\n", __FUNCTION__));
+		return DBUS_ERR_TXDROP;
+	}
+
+	/* If not using standard Linux kernel functionality for handling Zero Length Packet(ZLP),
+	 * the dbus needs to generate ZLP when length is multiple of MaxPacketSize.
+	 */
+#ifndef WL_URB_ZPKT
+	if (!(buffer_length % usbos_info->maxps)) {
+		if (!(req_zlp =
+			dbus_usbos_qdeq(&usbos_info->req_txfreeq, &usbos_info->txfree_lock))) {
+			DBUSERR(("%s No free URB for ZLP!\n", __FUNCTION__));
+			dbus_usbos_qenq(&usbos_info->req_txfreeq, req, &usbos_info->txfree_lock);
+			return DBUS_ERR_TXDROP;
+		}
+
+		/* No txirb, so that dbus_usbos_send_complete can differentiate between
+		 * DATA and ZLP.
+		 */
+		req_zlp->arg = NULL;
+		req_zlp->usbinfo = usbos_info;
+		req_zlp->buf_len = 0;
+
+		usb_fill_bulk_urb(req_zlp->urb, usbos_info->usb, usbos_info->tx_pipe, NULL,
+			0, (usb_complete_t)dbus_usbos_send_complete, req_zlp);
+
+		req_zlp->urb->transfer_flags |= URB_QUEUE_BULK;
+	}
+#endif /* !WL_URB_ZPKT */
+
+#ifndef USBOS_TX_THREAD
+	/* Disable USB autosuspend until this request completes, request USB resume if needed.
+	 * Because this call runs asynchronously, there is no guarantee the bus is resumed before
+	 * the URB is submitted, and the URB might be dropped. Use USBOS_TX_THREAD to avoid
+	 * this.
+	 */
+	USB_AUTOPM_GET_INTERFACE_ASYNC(g_probe_info.intf);
+#endif /* !USBOS_TX_THREAD */
+
+	spin_lock_irqsave(&usbos_info->txlock, flags);
+
+	req->arg = txirb;
+	req->usbinfo = usbos_info;
+	req->buf_len = 0;
+
+	/* Prepare the URB */
+	if (txirb->pkt != NULL) {
+		uint32 pktlen;
+		uint8 *transfer_buf;
+
+		/* For multiple packets, allocate contiguous buffer and copy packet data to it */
+		if (PKTNEXT(usbos_info->pub->osh, txirb->pkt)) {
+			transfer_buf = MALLOC(usbos_info->pub->osh, buffer_length);
+			if (!transfer_buf) {
+				ret = DBUS_ERR_TXDROP;
+				DBUSERR(("fail to alloc to usb buffer\n"));
+				goto fail;
+			}
+
+			pkt = txirb->pkt;
+			txirb->send_buf = transfer_buf;
+			req->buf_len = buffer_length;
+
+			while (pkt) {
+				pktlen = PKTLEN(usbos_info->pub->osh, pkt);
+				bcopy(PKTDATA(usbos_info->pub->osh, pkt), transfer_buf, pktlen);
+				transfer_buf += pktlen;
+				pkt = PKTNEXT(usbos_info->pub->osh, pkt);
+			}
+
+			ASSERT(((uint8 *) txirb->send_buf + buffer_length) == transfer_buf);
+
+			/* Overwrite buf pointer with pointer to allocated contiguous transfer_buf
+			 */
+			buf = txirb->send_buf;
+		}
+	}
+
+	usb_fill_bulk_urb(req->urb, usbos_info->usb, usbos_info->tx_pipe, buf,
+		buffer_length, (usb_complete_t)dbus_usbos_send_complete, req);
+
+	req->urb->transfer_flags |= URB_QUEUE_BULK;
+
+#ifdef USBOS_TX_THREAD
+	/* Enqueue TX request, the TX thread will resume the bus if needed and submit
+	 * it asynchronously
+	 */
+	dbus_usbos_qenq(&usbos_info->usbos_tx_list, req, &usbos_info->usbos_tx_list_lock);
+	if (req_zlp != NULL) {
+		dbus_usbos_qenq(&usbos_info->usbos_tx_list, req_zlp,
+			&usbos_info->usbos_tx_list_lock);
+	}
+	spin_unlock_irqrestore(&usbos_info->txlock, flags);
+
+	wake_up_interruptible(&usbos_info->usbos_tx_queue_head);
+	return DBUS_OK;
+#else
+	if ((ret = USB_SUBMIT_URB(req->urb))) {
+		ret = DBUS_ERR_TXDROP;
+		goto fail;
+	}
+
+	dbus_usbos_qenq(&usbos_info->req_txpostedq, req, &usbos_info->txposted_lock);
+	atomic_inc(&usbos_info->txposted);
+
+	if (req_zlp != NULL) {
+		if ((ret = USB_SUBMIT_URB(req_zlp->urb))) {
+			DBUSERR(("failed to submit ZLP URB!\n"));
+			ASSERT(0);
+			ret = DBUS_ERR_TXDROP;
+			goto fail2;
+		}
+
+		dbus_usbos_qenq(&usbos_info->req_txpostedq, req_zlp, &usbos_info->txposted_lock);
+		/* Also increment txposted for zlp packet, as it will be decremented in
+		 * dbus_usbos_send_complete()
+		 */
+		atomic_inc(&usbos_info->txposted);
+	}
+
+	spin_unlock_irqrestore(&usbos_info->txlock, flags);
+	return DBUS_OK;
+#endif /* USBOS_TX_THREAD */
+
+fail:
+	if (txirb->send_buf != NULL) {
+		MFREE(usbos_info->pub->osh, txirb->send_buf, req->buf_len);
+		txirb->send_buf = NULL;
+		req->buf_len = 0;
+	}
+	dbus_usbos_qenq(&usbos_info->req_txfreeq, req, &usbos_info->txfree_lock);
+#ifndef USBOS_TX_THREAD
+fail2:
+#endif
+	if (req_zlp != NULL) {
+		dbus_usbos_qenq(&usbos_info->req_txfreeq, req_zlp, &usbos_info->txfree_lock);
+	}
+
+	spin_unlock_irqrestore(&usbos_info->txlock, flags);
+
+#ifndef USBOS_TX_THREAD
+	USB_AUTOPM_PUT_INTERFACE_ASYNC(g_probe_info.intf);
+#endif /* !USBOS_TX_THREAD */
+
+	return ret;
+} /* dbus_usbos_intf_send_irb */
+
+/** Higher layer (dbus_usb.c) recycles a received (and used) packet. */
+static int
+dbus_usbos_intf_recv_irb(void *bus, dbus_irb_rx_t *rxirb)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	int ret = DBUS_OK;
+
+	if (usbos_info == NULL)
+		return DBUS_ERR;
+
+	ret = dbus_usbos_recv_urb_submit(usbos_info, rxirb, 0);
+	return ret;
+}
+
+static int
+dbus_usbos_intf_recv_irb_from_ep(void *bus, dbus_irb_rx_t *rxirb, uint32 ep_idx)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	int ret = DBUS_OK;
+
+	if (usbos_info == NULL)
+		return DBUS_ERR;
+
+#ifdef INTR_EP_ENABLE
+		/* By specifying the ep_idx value of 0xff, the cdc layer is asking to
+		* submit an interrupt URB
+		*/
+		if (rxirb == NULL && ep_idx == 0xff) {
+			/* submit intr URB */
+			if ((ret = USB_SUBMIT_URB(usbos_info->intr_urb)) < 0) {
+				DBUSERR(("%s intr USB_SUBMIT_URB failed, status %d\n",
+					__FUNCTION__, ret));
+			}
+			return ret;
+		}
+#else
+		if (rxirb == NULL) {
+			return DBUS_ERR;
+		}
+#endif /* INTR_EP_ENABLE */
+
+	ret = dbus_usbos_recv_urb_submit(usbos_info, rxirb, ep_idx);
+	return ret;
+}
+
+/** Higher layer (dbus_usb.c) want to cancel an IRB */
+static int
+dbus_usbos_intf_cancel_irb(void *bus, dbus_irb_tx_t *txirb)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+
+	if (usbos_info == NULL)
+		return DBUS_ERR;
+
+	return DBUS_ERR;
+}
+
+/** Only one CTL transfer can be pending at any time. This function may block. */
+static int
+dbus_usbos_intf_send_ctl(void *bus, uint8 *buf, int len)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	uint16 size;
+#ifndef USBOS_TX_THREAD
+	int status;
+#endif /* USBOS_TX_THREAD */
+
+	if ((usbos_info == NULL) || (buf == NULL) || (len == 0))
+		return DBUS_ERR;
+
+	if (usbos_info->ctl_urb == NULL)
+		return DBUS_ERR;
+
+	/* Block until a pending CTL transfer has completed */
+	if (down_interruptible(&usbos_info->ctl_lock) != 0) {
+		return DBUS_ERR_TXCTLFAIL;
+	}
+
+#ifdef USBOS_TX_THREAD
+	ASSERT(usbos_info->ctl_state == USBOS_REQUEST_STATE_UNSCHEDULED);
+#else
+	/* Disable USB autosuspend until this request completes, request USB resume if needed.
+	 * Because this call runs asynchronously, there is no guarantee the bus is resumed before
+	 * the URB is submitted, and the URB might be dropped. Use USBOS_TX_THREAD to avoid
+	 * this.
+	 */
+	USB_AUTOPM_GET_INTERFACE_ASYNC(g_probe_info.intf);
+#endif /* USBOS_TX_THREAD */
+
+	size = len;
+	usbos_info->ctl_write.wLength = cpu_to_le16p(&size);
+	usbos_info->ctl_urb->transfer_buffer_length = size;
+
+	usb_fill_control_urb(usbos_info->ctl_urb,
+		usbos_info->usb,
+		usb_sndctrlpipe(usbos_info->usb, 0),
+		(unsigned char *) &usbos_info->ctl_write,
+		buf, size, (usb_complete_t)dbus_usbos_ctlwrite_complete, usbos_info);
+
+#ifdef USBOS_TX_THREAD
+	/* Enqueue CTRL request for transmission by the TX thread. The
+	 * USB bus will first be resumed if needed.
+	 */
+	usbos_info->ctl_state = USBOS_REQUEST_STATE_SCHEDULED;
+	wake_up_interruptible(&usbos_info->usbos_tx_queue_head);
+#else
+	status = USB_SUBMIT_URB(usbos_info->ctl_urb);
+	if (status < 0) {
+		DBUSERR(("%s: usb_submit_urb failed %d\n", __FUNCTION__, status));
+		up(&usbos_info->ctl_lock);
+
+		USB_AUTOPM_PUT_INTERFACE_ASYNC(g_probe_info.intf);
+
+		return DBUS_ERR_TXCTLFAIL;
+	}
+#endif /* USBOS_TX_THREAD */
+
+	return DBUS_OK;
+} /* dbus_usbos_intf_send_ctl */
+
+/** This function does not seem to be called by anyone, including dbus_usb.c */
+static int
+dbus_usbos_intf_recv_ctl(void *bus, uint8 *buf, int len)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	int status;
+	uint16 size;
+
+	if ((usbos_info == NULL) || (buf == NULL) || (len == 0))
+		return DBUS_ERR;
+
+	if (usbos_info->ctl_urb == NULL)
+		return DBUS_ERR;
+
+	/* Block until a pending CTRL transfer has completed */
+	if (down_interruptible(&usbos_info->ctl_lock) != 0) {
+		return DBUS_ERR_TXCTLFAIL;
+	}
+
+	/* Disable USB autosuspend until this request completes, request USB resume if needed. */
+	USB_AUTOPM_GET_INTERFACE_ASYNC(g_probe_info.intf);
+
+	size = len;
+	usbos_info->ctl_read.wLength = cpu_to_le16p(&size);
+	usbos_info->ctl_urb->transfer_buffer_length = size;
+
+	if (usbos_info->rxctl_deferrespok) {
+		/* BMAC model */
+		usbos_info->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_VENDOR |
+			USB_RECIP_INTERFACE;
+		usbos_info->ctl_read.bRequest = DL_DEFER_RESP_OK;
+	} else {
+		/* full dongle model */
+		usbos_info->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_CLASS |
+			USB_RECIP_INTERFACE;
+		usbos_info->ctl_read.bRequest = 1;
+	}
+
+	usb_fill_control_urb(usbos_info->ctl_urb,
+		usbos_info->usb,
+		usb_rcvctrlpipe(usbos_info->usb, 0),
+		(unsigned char *) &usbos_info->ctl_read,
+		buf, size, (usb_complete_t)dbus_usbos_ctlread_complete, usbos_info);
+
+	status = USB_SUBMIT_URB(usbos_info->ctl_urb);
+	if (status < 0) {
+		DBUSERR(("%s: usb_submit_urb failed %d\n", __FUNCTION__, status));
+		up(&usbos_info->ctl_lock);
+
+		USB_AUTOPM_PUT_INTERFACE_ASYNC(g_probe_info.intf);
+
+		return DBUS_ERR_RXCTLFAIL;
+	}
+
+	return DBUS_OK;
+}
+
+static int
+dbus_usbos_intf_get_attrib(void *bus, dbus_attrib_t *attrib)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+
+	if ((usbos_info == NULL) || (attrib == NULL))
+		return DBUS_ERR;
+
+	attrib->bustype = DBUS_USB;
+	attrib->vid = g_probe_info.vid;
+	attrib->pid = g_probe_info.pid;
+
+	attrib->devid = g_probe_info.pid;
+
+	attrib->nchan = 1;
+
+	/* MaxPacketSize for USB hi-speed bulk out is 512 bytes
+	 * and 64-bytes for full-speed.
+	 * When sending pkt > MaxPacketSize, Host SW breaks it
+	 * up into multiple packets.
+	 */
+	attrib->mtu = usbos_info->maxps;
+
+	return DBUS_OK;
+}
+
+/** Called by higher layer (dbus_usb.c) when it wants to 'up' the USB interface to the dongle */
+static int
+dbus_usbos_intf_up(void *bus)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	uint16 ifnum;
+#ifdef BCMUSBDEV_COMPOSITE
+	int wlan_if = 0;
+#endif
+	if (usbos_info == NULL)
+		return DBUS_ERR;
+
+	if (usbos_info->usb == NULL)
+		return DBUS_ERR;
+
+#if defined(INTR_EP_ENABLE)
+	/* full dongle use intr EP, bmac doesn't use it */
+	if (usbos_info->intr_urb) {
+		int ret;
+
+		usb_fill_int_urb(usbos_info->intr_urb, usbos_info->usb,
+			usbos_info->intr_pipe, &usbos_info->intr,
+			usbos_info->intr_size, (usb_complete_t)dbus_usbos_intr_complete,
+			usbos_info, usbos_info->interval);
+
+		if ((ret = USB_SUBMIT_URB(usbos_info->intr_urb))) {
+			DBUSERR(("%s USB_SUBMIT_URB failed with status %d\n", __FUNCTION__, ret));
+			return DBUS_ERR;
+		}
+	}
+#endif	
+
+	if (usbos_info->ctl_urb) {
+		usbos_info->ctl_in_pipe = usb_rcvctrlpipe(usbos_info->usb, 0);
+		usbos_info->ctl_out_pipe = usb_sndctrlpipe(usbos_info->usb, 0);
+
+#ifdef BCMUSBDEV_COMPOSITE
+		wlan_if = dbus_usbos_intf_wlan(usbos_info->usb);
+		ifnum = cpu_to_le16(IFDESC(usbos_info->usb, wlan_if).bInterfaceNumber);
+#else
+		ifnum = cpu_to_le16(IFDESC(usbos_info->usb, CONTROL_IF).bInterfaceNumber);
+#endif /* BCMUSBDEV_COMPOSITE */
+		/* CTL Write */
+		usbos_info->ctl_write.bRequestType =
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE;
+		usbos_info->ctl_write.bRequest = 0;
+		usbos_info->ctl_write.wValue = cpu_to_le16(0);
+		usbos_info->ctl_write.wIndex = cpu_to_le16p(&ifnum);
+
+		/* CTL Read */
+		usbos_info->ctl_read.bRequestType =
+			USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;
+		usbos_info->ctl_read.bRequest = 1;
+		usbos_info->ctl_read.wValue = cpu_to_le16(0);
+		usbos_info->ctl_read.wIndex = cpu_to_le16p(&ifnum);
+	}
+
+	/* Success, indicate usbos_info is fully up */
+	dbus_usbos_state_change(usbos_info, DBUS_STATE_UP);
+
+	return DBUS_OK;
+} /* dbus_usbos_intf_up */
+
+static int
+dbus_usbos_intf_down(void *bus)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+
+	if (usbos_info == NULL)
+		return DBUS_ERR;
+
+	dbusos_stop(usbos_info);
+	return DBUS_OK;
+}
+
+static int
+dbus_usbos_intf_stop(void *bus)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+
+	if (usbos_info == NULL)
+		return DBUS_ERR;
+
+	dbusos_stop(usbos_info);
+	return DBUS_OK;
+}
+
+#if defined(DBUS_LINUX_HIST)
+static void
+dbus_usbos_intf_dump(void *bus, struct bcmstrbuf *b)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	int i = 0, j = 0, rxposted, txposted;
+
+	rxposted = atomic_read(&usbos_info->rxposted);
+	txposted = atomic_read(&usbos_info->txposted);
+	if (b) {
+		bcm_bprintf(b, "\ndbus linux dump\n");
+		bcm_bprintf(b, "txposted %d rxposted %d\n",
+			txposted, rxposted);
+
+		bcm_bprintf(b, "RXDPC: dpc_cnt %d dpc_pktcnt %d dpc_maxpktcnt %d avg_dpc_pktcnt\n",
+			usbos_info->dpc_cnt, usbos_info->dpc_pktcnt,
+			usbos_info->dpc_maxpktcnt, usbos_info->dpc_cnt ?
+			(usbos_info->dpc_pktcnt/usbos_info->dpc_cnt):1);
+
+		/* Histogram */
+		bcm_bprintf(b, "txposted\n");
+	} else {
+		printf("\ndbus linux dump\n");
+		printf("txposted %d rxposted %d\n",
+			txposted, rxposted);
+		printf("RXDPC: dpc_cnt %d dpc_pktcnt %d dpc_maxpktcnt %d avg_dpc_pktcnt %d\n",
+			usbos_info->dpc_cnt, usbos_info->dpc_pktcnt,
+			usbos_info->dpc_maxpktcnt, usbos_info->dpc_cnt ?
+			(usbos_info->dpc_pktcnt/usbos_info->dpc_cnt):1);
+
+		/* Histogram */
+		printf("txposted\n");
+	}
+
+	for (i = 0; i < usbos_info->pub->ntxq; i++) {
+		if (usbos_info->txposted_hist == NULL) {
+			break;
+		}
+		if (usbos_info->txposted_hist[i]) {
+			if (b)
+				bcm_bprintf(b, "%d: %d ", i, usbos_info->txposted_hist[i]);
+			else
+				printf("%d: %d ", i, usbos_info->txposted_hist[i]);
+			j++;
+			if (j % 10 == 0) {
+				if (b)
+					bcm_bprintf(b, "\n");
+				else
+					printf("\n");
+			}
+		}
+	}
+
+	j = 0;
+	if (b)
+		bcm_bprintf(b, "\nrxposted\n");
+	else
+		printf("\nrxposted\n");
+	for (i = 0; i < usbos_info->pub->nrxq; i++) {
+		if (usbos_info->rxposted_hist == NULL) {
+			break;
+		}
+		if (usbos_info->rxposted_hist[i]) {
+			if (b)
+				bcm_bprintf(b, "%d: %d ", i, usbos_info->rxposted_hist[i]);
+			else
+				printf("%d: %d ", i, usbos_info->rxposted_hist[i]);
+			j++;
+			if (j % 10 == 0) {
+				if (b)
+					bcm_bprintf(b, "\n");
+				else
+					printf("\n");
+			}
+		}
+	}
+	if (b)
+		bcm_bprintf(b, "\n");
+	else
+		printf("\n");
+
+	return;
+}
+#endif 
+
+/** Called by higher layer (dbus_usb.c) */
+static int
+dbus_usbos_intf_set_config(void *bus, dbus_config_t *config)
+{
+	int err = DBUS_ERR;
+	usbos_info_t* usbos_info = bus;
+
+	if (config->config_id == DBUS_CONFIG_ID_RXCTL_DEFERRES) {
+		usbos_info->rxctl_deferrespok = config->rxctl_deferrespok;
+		err = DBUS_OK;
+	}
+#ifdef KEEPIF_ON_DEVICE_RESET
+	else if (config->config_id == DBUS_CONFIG_ID_KEEPIF_ON_DEVRESET) {
+		g_probe_info.keepif_on_devreset = config->general_param ? TRUE : FALSE;
+		err = DBUS_OK;
+	}
+#endif /* KEEPIF_ON_DEVICE_RESET */
+	else if (config->config_id == DBUS_CONFIG_ID_AGGR_LIMIT) {
+#ifndef BCM_FD_AGGR
+		/* DBUS_CONFIG_ID_AGGR_LIMIT shouldn't be called after probe stage */
+		ASSERT(disc_arg == NULL);
+#endif /* BCM_FD_AGGR */
+		ASSERT(config->aggr_param.maxrxsf > 0);
+		ASSERT(config->aggr_param.maxrxsize > 0);
+		if (config->aggr_param.maxrxsize > usbos_info->rxbuf_len) {
+			int state = usbos_info->pub->busstate;
+			dbus_usbos_unlink(&usbos_info->req_rxpostedq, &usbos_info->rxposted_lock);
+			while (atomic_read(&usbos_info->rxposted)) {
+				DBUSTRACE(("%s rxposted is %d, delay 1 ms\n", __FUNCTION__,
+					atomic_read(&usbos_info->rxposted)));
+				dbus_usbos_wait(usbos_info, 1);
+			}
+			usbos_info->rxbuf_len = config->aggr_param.maxrxsize;
+			dbus_usbos_state_change(usbos_info, state);
+		}
+		err = DBUS_OK;
+	}
+
+	return err;
+}
+
+#ifdef EHCI_FASTPATH_TX
+
+/**
+ * In some cases, the code must submit an URB and wait for its completion.
+ * Related: dbus_usbos_sync_complete()
+ */
+static int
+dbus_usbos_sync_wait(usbos_info_t *usbinfo, uint16 time)
+{
+	int ret;
+	int err = DBUS_OK;
+	int ms = time;
+
+	ret = wait_event_interruptible_timeout(usbinfo->wait,
+		usbinfo->waitdone == TRUE, (ms * HZ / 1000));
+
+	if ((usbinfo->waitdone == FALSE) || (usbinfo->sync_urb_status)) {
+		DBUSERR(("%s: timeout(%d) or urb err=0x%x\n",
+			__FUNCTION__, ret, usbinfo->sync_urb_status));
+		err = DBUS_ERR;
+		BCM_REFERENCE(ret);
+	}
+	usbinfo->waitdone = FALSE;
+	return err;
+}
+
+
+#endif /* EHCI_FASTPATH_TX */
+
+/** Called by dbus_usb.c when it wants to download firmware into the dongle */
+bool
+dbus_usbos_dl_cmd(usbos_info_t *usbinfo, uint8 cmd, void *buffer, int buflen)
+{
+	int transferred;
+	int index = 0;
+	char *tmpbuf;
+
+	if ((usbinfo == NULL) || (buffer == NULL) || (buflen == 0))
+		return FALSE;
+
+	tmpbuf = (char *) MALLOC(usbinfo->pub->osh, buflen);
+	if (!tmpbuf) {
+		DBUSERR(("%s: Unable to allocate memory \n", __FUNCTION__));
+		return FALSE;
+	}
+
+#ifdef BCM_REQUEST_FW
+	if (cmd == DL_GO) {
+		index = 1;
+	}
+#endif
+
+	/* Disable USB autosuspend until this request completes, request USB resume if needed. */
+	USB_AUTOPM_GET_INTERFACE(g_probe_info.intf);
+
+	transferred = USB_CONTROL_MSG(usbinfo->usb, usb_rcvctrlpipe(usbinfo->usb, 0),
+		cmd, (USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE),
+		0, index,
+		(void*) tmpbuf, buflen, USB_CTRL_EP_TIMEOUT);
+	if (transferred == buflen) {
+		memcpy(buffer, tmpbuf, buflen);
+	} else {
+		DBUSERR(("%s: usb_control_msg failed %d\n", __FUNCTION__, transferred));
+	}
+
+	USB_AUTOPM_PUT_INTERFACE(g_probe_info.intf);
+
+	MFREE(usbinfo->pub->osh, tmpbuf, buflen);
+	return (transferred == buflen);
+}
+
+/**
+ * Called by dbus_usb.c when it wants to download a buffer into the dongle (e.g. as part of the
+ * download process, when writing nvram variables).
+ */
+int
+dbus_write_membytes(usbos_info_t* usbinfo, bool set, uint32 address, uint8 *data, uint size)
+{
+	hwacc_t hwacc;
+	int write_bytes = 4;
+	int status;
+	int retval = 0;
+
+	DBUSTRACE(("Enter:%s\n", __FUNCTION__));
+
+	/* Read is not supported */
+	if (set == 0) {
+		DBUSERR(("Currently read is not supported!!\n"));
+		return -1;
+	}
+
+	USB_AUTOPM_GET_INTERFACE(g_probe_info.intf);
+
+	hwacc.cmd = DL_CMD_WRHW;
+	hwacc.addr = address;
+
+	DBUSTRACE(("Address:%x size:%d", hwacc.addr, size));
+	do {
+		if (size >= 4) {
+			write_bytes = 4;
+		} else if (size >= 2) {
+			write_bytes = 2;
+		} else {
+			write_bytes = 1;
+		}
+
+		hwacc.len = write_bytes;
+
+		while (size >= write_bytes) {
+			hwacc.data = *((unsigned int*)data);
+
+			status = USB_CONTROL_MSG(usbinfo->usb, usb_sndctrlpipe(usbinfo->usb, 0),
+				DL_WRHW, (USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE),
+				1, 0, (char *)&hwacc, sizeof(hwacc_t), USB_CTRL_EP_TIMEOUT);
+
+			if (status < 0) {
+				retval = -1;
+				DBUSERR((" Ctrl write hwacc failed w/status %d @ address:%x \n",
+					status, hwacc.addr));
+				goto err;
+			}
+
+			hwacc.addr += write_bytes;
+			data += write_bytes;
+			size -= write_bytes;
+		}
+	} while (size > 0);
+
+err:
+	USB_AUTOPM_PUT_INTERFACE(g_probe_info.intf);
+
+	return retval;
+}
+
+int
+dbus_usbos_readreg(void *bus, uint32 regaddr, int datalen, uint32 *value)
+{
+	usbos_info_t *usbinfo = (usbos_info_t *) bus;
+	int ret = DBUS_OK;
+	int transferred;
+	uint32 cmd;
+	hwacc_t	hwacc;
+
+	if (usbinfo == NULL)
+		return DBUS_ERR;
+
+	if (datalen == 1)
+		cmd = DL_RDHW8;
+	else if (datalen == 2)
+		cmd = DL_RDHW16;
+	else
+		cmd = DL_RDHW32;
+
+	USB_AUTOPM_GET_INTERFACE(g_probe_info.intf);
+
+	transferred = USB_CONTROL_MSG(usbinfo->usb, usb_rcvctrlpipe(usbinfo->usb, 0),
+		cmd, (USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE),
+		(uint16)(regaddr), (uint16)(regaddr >> 16),
+		(void *) &hwacc, sizeof(hwacc_t), USB_CTRL_EP_TIMEOUT);
+
+	if (transferred >= sizeof(hwacc_t)) {
+		*value = hwacc.data;
+	} else {
+		DBUSERR(("%s: usb_control_msg failed %d\n", __FUNCTION__, transferred));
+		ret = DBUS_ERR;
+	}
+
+	USB_AUTOPM_PUT_INTERFACE(g_probe_info.intf);
+
+	return ret;
+}
+
+int
+dbus_usbos_writereg(void *bus, uint32 regaddr, int datalen, uint32 data)
+{
+	usbos_info_t *usbinfo = (usbos_info_t *) bus;
+	int ret = DBUS_OK;
+	int transferred;
+	uint32 cmd = DL_WRHW;
+	hwacc_t	hwacc;
+
+	if (usbinfo == NULL)
+		return DBUS_ERR;
+
+	USB_AUTOPM_GET_INTERFACE(g_probe_info.intf);
+
+	hwacc.cmd = DL_WRHW;
+	hwacc.addr = regaddr;
+	hwacc.data = data;
+	hwacc.len = datalen;
+
+	transferred = USB_CONTROL_MSG(usbinfo->usb, usb_sndctrlpipe(usbinfo->usb, 0),
+		cmd, (USB_DIR_OUT| USB_TYPE_VENDOR | USB_RECIP_INTERFACE),
+		1, 0,
+		(void *) &hwacc, sizeof(hwacc_t), USB_CTRL_EP_TIMEOUT);
+
+	if (transferred != sizeof(hwacc_t)) {
+		DBUSERR(("%s: usb_control_msg failed %d\n", __FUNCTION__, transferred));
+		ret = DBUS_ERR;
+	}
+
+	USB_AUTOPM_PUT_INTERFACE(g_probe_info.intf);
+
+	return ret;
+}
+
+int
+dbus_usbos_wait(usbos_info_t *usbinfo, uint16 ms)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+	if (in_interrupt())
+		mdelay(ms);
+	else
+		msleep_interruptible(ms);
+#else
+	wait_ms(ms);
+#endif
+	return DBUS_OK;
+}
+
+/** Called by dbus_usb.c as part of the firmware download process */
+bool
+dbus_usbos_dl_send_bulk(usbos_info_t *usbinfo, void *buffer, int len)
+{
+#ifdef EHCI_FASTPATH_TX
+	int ret = DBUS_ERR;
+
+	struct ehci_qtd *qtd = optimize_ehci_qtd_alloc(GFP_KERNEL);
+	int token = EHCI_QTD_SET_CERR(3);
+
+	if (qtd == NULL)
+		goto fail;
+
+	optimize_qtd_fill_with_data(usbinfo->pub, 0, qtd, buffer, token, len);
+	optimize_submit_async(qtd, 0);
+
+	ret = dbus_usbos_sync_wait(usbinfo, USB_SYNC_WAIT_TIMEOUT);
+
+	return (ret == DBUS_OK);
+fail:
+	return FALSE;
+#else
+	bool ret = TRUE;
+	int status;
+	int transferred = 0;
+
+	if (usbinfo == NULL)
+		return DBUS_ERR;
+
+	USB_AUTOPM_GET_INTERFACE(g_probe_info.intf);
+
+	status = USB_BULK_MSG(usbinfo->usb, usbinfo->tx_pipe,
+		buffer, len,
+		&transferred, USB_BULK_EP_TIMEOUT);
+
+	if (status < 0) {
+		DBUSERR(("%s: usb_bulk_msg failed %d\n", __FUNCTION__, status));
+		ret = FALSE;
+	}
+
+	USB_AUTOPM_PUT_INTERFACE(g_probe_info.intf);
+
+	return ret;
+#endif /* EHCI_FASTPATH_TX */
+}
+
+static bool
+dbus_usbos_intf_recv_needed(void *bus)
+{
+	return FALSE;
+}
+
+/**
+ * Higher layer (dbus_usb.c) wants to execute a function on the condition that the rx spin lock has
+ * been acquired.
+ */
+static void*
+dbus_usbos_intf_exec_rxlock(void *bus, exec_cb_t cb, struct exec_parms *args)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	void *ret;
+	unsigned long flags;
+
+	if (usbos_info == NULL)
+		return NULL;
+
+	spin_lock_irqsave(&usbos_info->rxlock, flags);
+	ret = cb(args);
+	spin_unlock_irqrestore(&usbos_info->rxlock, flags);
+
+	return ret;
+}
+
+static void*
+dbus_usbos_intf_exec_txlock(void *bus, exec_cb_t cb, struct exec_parms *args)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+	void *ret;
+	unsigned long flags;
+
+	if (usbos_info == NULL)
+		return NULL;
+
+	spin_lock_irqsave(&usbos_info->txlock, flags);
+	ret = cb(args);
+	spin_unlock_irqrestore(&usbos_info->txlock, flags);
+
+	return ret;
+}
+
+/**
+ * if an error condition was detected in this module, the higher DBUS layer (dbus_usb.c) has to
+ * be notified.
+ */
+int
+dbus_usbos_errhandler(void *bus, int err)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+
+	if (usbos_info == NULL)
+		return DBUS_ERR;
+
+	if (usbos_info->cbarg && usbos_info->cbs) {
+		if (usbos_info->cbs->errhandler)
+			usbos_info->cbs->errhandler(usbos_info->cbarg, err);
+	}
+
+	return DBUS_OK;
+}
+
+/**
+ * if a change in bus state was detected in this module, the higher DBUS layer (dbus_usb.c) has to
+ * be notified.
+ */
+int
+dbus_usbos_state_change(void *bus, int state)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) bus;
+
+	if (usbos_info == NULL)
+		return DBUS_ERR;
+
+	if (usbos_info->cbarg && usbos_info->cbs) {
+		if (usbos_info->cbs->state_change)
+			usbos_info->cbs->state_change(usbos_info->cbarg, state);
+	}
+
+	usbos_info->pub->busstate = state;
+	return DBUS_OK;
+}
+
+int
+dbus_bus_osl_register(int vid, int pid, probe_cb_t prcb,
+	disconnect_cb_t discb, void *prarg, dbus_intf_t **intf, void *param1, void *param2)
+{
+	bzero(&g_probe_info, sizeof(probe_info_t));
+
+	probe_cb = prcb;
+	disconnect_cb = discb;
+	probe_arg = prarg;
+
+	devid_table[0].idVendor = vid;
+	devid_table[0].idProduct = pid;
+
+	*intf = &dbus_usbos_intf;
+
+	USB_REGISTER();
+
+#ifdef KEEPIF_ON_DEVICE_RESET
+	init_waitqueue_head(&g_probe_info.usbreset_queue_head);
+	atomic_set(&g_probe_info.usbdev_stat, USB_DEVICE_INIT);
+	g_probe_info.usbreset_kt = kthread_create(dbus_usbos_usbreset_func,
+		&g_probe_info, "usbreset-thread");
+	ASSERT(!IS_ERR(g_probe_info.usbreset_kt));
+	wake_up_process(g_probe_info.usbreset_kt);
+#endif /* KEEPIF_ON_DEVICE_RESET */
+
+	return DBUS_ERR_NODEVICE;
+}
+
+int
+dbus_bus_osl_deregister()
+{
+	g_probe_info.dereged = TRUE;
+
+#ifdef KEEPIF_ON_DEVICE_RESET
+	wake_up_interruptible(&g_probe_info.usbreset_queue_head);
+	kthread_stop(g_probe_info.usbreset_kt);
+#endif /* KEEPIF_ON_DEVICE_RESET */
+
+	if (disconnect_cb && disc_arg && (g_probe_info.disc_cb_done == FALSE)) {
+		disconnect_cb(disc_arg);
+		disc_arg = NULL;
+	}
+
+	USB_DEREGISTER();
+
+	return DBUS_OK;
+}
+
+static void
+dbus_usbos_init_info(void)
+{
+	usbos_info_t *usbos_info = g_probe_info.usbos_info;
+
+	if (!usbos_info) {
+		return;
+	}
+
+	/* Update USB Info */
+	usbos_info->usb = g_probe_info.usb;
+	usbos_info->rx_pipe = g_probe_info.rx_pipe;
+	usbos_info->rx_pipe2 = g_probe_info.rx_pipe2;
+	usbos_info->tx_pipe = g_probe_info.tx_pipe;
+	usbos_info->intr_pipe = g_probe_info.intr_pipe;
+	usbos_info->intr_size = g_probe_info.intr_size;
+	usbos_info->interval = g_probe_info.interval;
+	usbos_info->pub->device_speed = g_probe_info.device_speed;
+	usbos_info->pub->dev_info = g_probe_info.usb;
+	if (usbos_info->rx_pipe2) {
+		usbos_info->pub->attrib.has_2nd_bulk_in_ep = 1;
+	} else {
+		usbos_info->pub->attrib.has_2nd_bulk_in_ep = 0;
+	}
+
+	if (usbos_info->tx_pipe)
+		usbos_info->maxps = usb_maxpacket(usbos_info->usb,
+			usbos_info->tx_pipe, usb_pipeout(usbos_info->tx_pipe));
+}
+
+void *
+dbus_usbos_intf_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs)
+{
+	usbos_info_t *usbos_info;
+
+	if (g_probe_info.dldone == FALSE) {
+		DBUSERR(("%s: err device not downloaded!\n", __FUNCTION__));
+		return NULL;
+	}
+
+	/* Sanity check for BUS_INFO() */
+	ASSERT(OFFSETOF(usbos_info_t, pub) == 0);
+
+	usbos_info = MALLOC(pub->osh, sizeof(usbos_info_t));
+	if (usbos_info == NULL)
+		return NULL;
+
+	bzero(usbos_info, sizeof(usbos_info_t));
+
+	usbos_info->pub = pub;
+	usbos_info->cbarg = cbarg;
+	usbos_info->cbs = cbs;
+
+	/* Needed for disconnect() */
+	g_probe_info.usbos_info = usbos_info;
+	dbus_usbos_init_info();
+
+	INIT_LIST_HEAD(&usbos_info->req_rxfreeq);
+	INIT_LIST_HEAD(&usbos_info->req_txfreeq);
+	INIT_LIST_HEAD(&usbos_info->req_rxpostedq);
+	INIT_LIST_HEAD(&usbos_info->req_txpostedq);
+	spin_lock_init(&usbos_info->rxfree_lock);
+	spin_lock_init(&usbos_info->txfree_lock);
+	spin_lock_init(&usbos_info->rxposted_lock);
+	spin_lock_init(&usbos_info->txposted_lock);
+	spin_lock_init(&usbos_info->rxlock);
+	spin_lock_init(&usbos_info->txlock);
+
+	atomic_set(&usbos_info->rxposted, 0);
+	atomic_set(&usbos_info->txposted, 0);
+
+#ifdef DBUS_LINUX_RXDPC
+	INIT_LIST_HEAD(&usbos_info->req_rxpendingq);
+	spin_lock_init(&usbos_info->rxpending_lock);
+#endif /* DBUS_LINUX_RXDPC */
+
+#if defined(DBUS_LINUX_HIST)
+	usbos_info->txposted_hist = MALLOC(pub->osh, (usbos_info->pub->ntxq+1) * sizeof(int));
+	if (usbos_info->txposted_hist) {
+		bzero(usbos_info->txposted_hist, (usbos_info->pub->ntxq+1) * sizeof(int));
+	}
+	usbos_info->rxposted_hist = MALLOC(pub->osh, (usbos_info->pub->nrxq+1) * sizeof(int));
+	if (usbos_info->rxposted_hist) {
+		bzero(usbos_info->rxposted_hist, (usbos_info->pub->nrxq+1) * sizeof(int));
+	}
+#endif
+#ifdef USB_DISABLE_INT_EP
+	usbos_info->intr_urb = NULL;
+#else
+	if (!(usbos_info->intr_urb = USB_ALLOC_URB())) {
+		DBUSERR(("%s: usb_alloc_urb (tx) failed\n", __FUNCTION__));
+		goto fail;
+	}
+#endif
+
+	if (!(usbos_info->ctl_urb = USB_ALLOC_URB())) {
+		DBUSERR(("%s: usb_alloc_urb (tx) failed\n", __FUNCTION__));
+		goto fail;
+	}
+
+	init_waitqueue_head(&usbos_info->wait);
+
+	if (!(usbos_info->blk_urb = USB_ALLOC_URB())) {	/* for embedded image downloading */
+		DBUSERR(("%s: usb_alloc_urb (tx) failed\n", __FUNCTION__));
+		goto fail;
+	}
+
+	usbos_info->rxbuf_len = (uint)usbos_info->pub->rxsize;
+
+
+#ifdef DBUS_LINUX_RXDPC		/* Initialize DPC thread */
+	sema_init(&usbos_info->dpc_sem, 0);
+	init_completion(&usbos_info->dpc_exited);
+	usbos_info->dpc_pid = kernel_thread(dbus_usbos_dpc_thread, usbos_info, 0);
+	if (usbos_info->dpc_pid < 0) {
+		DBUSERR(("%s: failed to create dpc thread\n", __FUNCTION__));
+		goto fail;
+	}
+#endif /* DBUS_LINUX_RXDPC */
+
+	atomic_set(&usbos_info->txallocated, 0);
+	if (DBUS_OK != dbus_usbos_urbreqs_alloc(usbos_info,
+		usbos_info->pub->ntxq, FALSE)) {
+		goto fail;
+	}
+
+	atomic_set(&usbos_info->rxallocated, 0);
+	if (DBUS_OK != dbus_usbos_urbreqs_alloc(usbos_info,
+#ifdef CTFPOOL
+		usbos_info->pub->nrxq,
+#else
+		MIN(DBUS_USB_RXQUEUE_BATCH_ADD, usbos_info->pub->nrxq),
+#endif
+		TRUE)) {
+		goto fail;
+	}
+
+	sema_init(&usbos_info->ctl_lock, 1);
+
+#ifdef USBOS_THREAD
+	if (dbus_usbos_thread_init(usbos_info) == NULL)
+		goto fail;
+#endif /* USBOS_THREAD */
+
+#ifdef USBOS_TX_THREAD
+	if (dbus_usbos_tx_thread_init(usbos_info) == NULL)
+		goto fail;
+#endif /* USBOS_TX_THREAD */
+
+#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
+	spin_lock_init(&usbos_info->fastpath_lock);
+	if (optimize_init(usbos_info, usbos_info->usb, usbos_info->tx_pipe,
+		usbos_info->rx_pipe, usbos_info->rx_pipe2) != 0) {
+		DBUSERR(("%s: optimize_init failed!\n", __FUNCTION__));
+		goto fail;
+	}
+
+#endif /* EHCI_FASTPATH_TX || EHCI_FASTPATH_RX */
+
+	return (void *) usbos_info;
+fail:
+#ifdef DBUS_LINUX_RXDPC
+	if (usbos_info->dpc_pid >= 0) {
+		KILL_PROC(usbos_info->dpc_pid, SIGTERM);
+		wait_for_completion(&usbos_info->dpc_exited);
+	}
+#endif /* DBUS_LINUX_RXDPC */
+	if (usbos_info->intr_urb) {
+		USB_FREE_URB(usbos_info->intr_urb);
+		usbos_info->intr_urb = NULL;
+	}
+
+	if (usbos_info->ctl_urb) {
+		USB_FREE_URB(usbos_info->ctl_urb);
+		usbos_info->ctl_urb = NULL;
+	}
+
+#if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
+	if (usbos_info->blk_urb) {
+		USB_FREE_URB(usbos_info->blk_urb);
+		usbos_info->blk_urb = NULL;
+	}
+#endif
+
+	dbus_usbos_urbreqs_free(usbos_info, TRUE);
+	atomic_set(&usbos_info->rxallocated, 0);
+	dbus_usbos_urbreqs_free(usbos_info, FALSE);
+	atomic_set(&usbos_info->txallocated, 0);
+
+	g_probe_info.usbos_info = NULL;
+
+	MFREE(pub->osh, usbos_info, sizeof(usbos_info_t));
+	return NULL;
+} /* dbus_usbos_intf_attach */
+
+void
+dbus_usbos_intf_detach(dbus_pub_t *pub, void *info)
+{
+	usbos_info_t *usbos_info = (usbos_info_t *) info;
+	osl_t *osh = pub->osh;
+
+	if (usbos_info == NULL) {
+		return;
+	}
+
+#ifdef USBOS_TX_THREAD
+	dbus_usbos_tx_thread_deinit(usbos_info);
+#endif /* USBOS_TX_THREAD */
+
+#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
+	optimize_deinit(usbos_info, usbos_info->usb);
+#endif
+	/* Must unlink all URBs prior to driver unload;
+	 * otherwise an URB callback can occur after driver
+	 * has been de-allocated and rmmod'd
+	 */
+	dbusos_stop(usbos_info);
+
+	if (usbos_info->intr_urb) {
+		USB_FREE_URB(usbos_info->intr_urb);
+		usbos_info->intr_urb = NULL;
+	}
+
+	if (usbos_info->ctl_urb) {
+		USB_FREE_URB(usbos_info->ctl_urb);
+		usbos_info->ctl_urb = NULL;
+	}
+
+	if (usbos_info->blk_urb) {
+		USB_FREE_URB(usbos_info->blk_urb);
+		usbos_info->blk_urb = NULL;
+	}
+
+	dbus_usbos_urbreqs_free(usbos_info, TRUE);
+	atomic_set(&usbos_info->rxallocated, 0);
+	dbus_usbos_urbreqs_free(usbos_info, FALSE);
+	atomic_set(&usbos_info->txallocated, 0);
+
+#if defined(DBUS_LINUX_HIST)
+	if (usbos_info->txposted_hist) {
+		MFREE(osh, usbos_info->txposted_hist, (usbos_info->pub->ntxq+1) * sizeof(int));
+	}
+	if (usbos_info->rxposted_hist) {
+		MFREE(osh, usbos_info->rxposted_hist, (usbos_info->pub->nrxq+1) * sizeof(int));
+	}
+#endif 
+#ifdef USBOS_THREAD
+	dbus_usbos_thread_deinit(usbos_info);
+#endif /* USBOS_THREAD */
+
+	g_probe_info.usbos_info = NULL;
+	MFREE(osh, usbos_info, sizeof(usbos_info_t));
+} /* dbus_usbos_intf_detach */
+
+
+#ifdef USBOS_TX_THREAD
+
+void*
+dbus_usbos_tx_thread_init(usbos_info_t *usbos_info)
+{
+	spin_lock_init(&usbos_info->usbos_tx_list_lock);
+	INIT_LIST_HEAD(&usbos_info->usbos_tx_list);
+	init_waitqueue_head(&usbos_info->usbos_tx_queue_head);
+
+	usbos_info->usbos_tx_kt = kthread_create(dbus_usbos_tx_thread_func,
+		usbos_info, "usb-tx-thread");
+
+	if (IS_ERR(usbos_info->usbos_tx_kt)) {
+		DBUSERR(("Thread Creation failed\n"));
+		return (NULL);
+	}
+
+	usbos_info->ctl_state = USBOS_REQUEST_STATE_UNSCHEDULED;
+	wake_up_process(usbos_info->usbos_tx_kt);
+
+	return (usbos_info->usbos_tx_kt);
+}
+
+void
+dbus_usbos_tx_thread_deinit(usbos_info_t *usbos_info)
+{
+	urb_req_t *req;
+
+	if (usbos_info->usbos_tx_kt) {
+		wake_up_interruptible(&usbos_info->usbos_tx_queue_head);
+		kthread_stop(usbos_info->usbos_tx_kt);
+	}
+
+	/* Move pending requests to free queue so they can be freed */
+	while ((req = dbus_usbos_qdeq(
+		&usbos_info->usbos_tx_list, &usbos_info->usbos_tx_list_lock)) != NULL) {
+		dbus_usbos_qenq(&usbos_info->req_txfreeq, req, &usbos_info->txfree_lock);
+	}
+}
+
+/**
+ * Allow USB in-band resume to block by submitting CTRL and DATA URBs on a separate thread.
+ */
+int
+dbus_usbos_tx_thread_func(void *data)
+{
+	usbos_info_t  *usbos_info = (usbos_info_t *)data;
+	urb_req_t     *req;
+	dbus_irb_tx_t *txirb;
+	int           ret;
+	unsigned long flags;
+
+#ifdef WL_THREADNICE
+	set_user_nice(current, WL_THREADNICE);
+#endif
+
+	while (1) {
+		/* Wait until there are URBs to submit */
+		wait_event_interruptible_timeout(
+			usbos_info->usbos_tx_queue_head,
+			!list_empty(&usbos_info->usbos_tx_list) ||
+			usbos_info->ctl_state == USBOS_REQUEST_STATE_SCHEDULED,
+			100);
+
+		if (kthread_should_stop())
+			break;
+
+		/* Submit CTRL URB if needed */
+		if (usbos_info->ctl_state == USBOS_REQUEST_STATE_SCHEDULED) {
+
+			/* Disable USB autosuspend until this request completes. If the
+			 * interface was suspended, this call blocks until it has been resumed.
+			 */
+			USB_AUTOPM_GET_INTERFACE(g_probe_info.intf);
+
+			usbos_info->ctl_state = USBOS_REQUEST_STATE_SUBMITTED;
+
+			ret = USB_SUBMIT_URB(usbos_info->ctl_urb);
+			if (ret != 0) {
+				DBUSERR(("%s CTRL USB_SUBMIT_URB failed, status %d\n",
+					__FUNCTION__, ret));
+
+				usbos_info->ctl_state = USBOS_REQUEST_STATE_UNSCHEDULED;
+				up(&usbos_info->ctl_lock);
+
+				USB_AUTOPM_PUT_INTERFACE_ASYNC(g_probe_info.intf);
+			}
+		}
+
+		/* Submit all available TX URBs */
+		while ((req = dbus_usbos_qdeq(&usbos_info->usbos_tx_list,
+			&usbos_info->usbos_tx_list_lock)) != NULL) {
+
+			/* Disable USB autosuspend until this request completes. If the
+			 * interface was suspended, this call blocks until it has been resumed.
+			 */
+			USB_AUTOPM_GET_INTERFACE(g_probe_info.intf);
+
+			spin_lock_irqsave(&usbos_info->txlock, flags);
+
+			ret = USB_SUBMIT_URB(req->urb);
+			if (ret == 0) {
+				/* URB submitted successfully */
+				dbus_usbos_qenq(&usbos_info->req_txpostedq, req,
+					&usbos_info->txposted_lock);
+				atomic_inc(&usbos_info->txposted);
+			} else {
+				/* Submitting the URB failed. */
+				DBUSERR(("%s TX USB_SUBMIT_URB failed, status %d\n",
+					__FUNCTION__, ret));
+
+				USB_AUTOPM_PUT_INTERFACE_ASYNC(g_probe_info.intf);
+			}
+
+			spin_unlock_irqrestore(&usbos_info->txlock, flags);
+
+			if (ret != 0) {
+				/* Cleanup and notify higher layers */
+				dbus_usbos_qenq(&usbos_info->req_txfreeq, req,
+					&usbos_info->txfree_lock);
+
+				txirb = req->arg;
+				if (txirb->send_buf) {
+					MFREE(usbos_info->pub->osh, txirb->send_buf, req->buf_len);
+					txirb->send_buf = NULL;
+					req->buf_len = 0;
+				}
+
+				if (likely (usbos_info->cbarg && usbos_info->cbs)) {
+					if (likely (usbos_info->cbs->send_irb_complete != NULL))
+						usbos_info->cbs->send_irb_complete(
+							usbos_info->cbarg, txirb, DBUS_ERR_TXDROP);
+				}
+			}
+		}
+	}
+
+	return 0;
+} /* dbus_usbos_tx_thread_func */
+
+#endif /* USBOS_TX_THREAD */
+
+#ifdef USBOS_THREAD
+
+/**
+ * Increase system performance by creating a USB thread that runs parallel to other system
+ * activity.
+ */
+static void*
+dbus_usbos_thread_init(usbos_info_t *usbos_info)
+{
+	usbos_list_entry_t  *entry;
+	unsigned long       flags, ii;
+
+	spin_lock_init(&usbos_info->usbos_list_lock);
+	spin_lock_init(&usbos_info->ctrl_lock);
+	INIT_LIST_HEAD(&usbos_info->usbos_list);
+	INIT_LIST_HEAD(&usbos_info->usbos_free_list);
+	init_waitqueue_head(&usbos_info->usbos_queue_head);
+	atomic_set(&usbos_info->usbos_list_cnt, 0);
+
+
+	for (ii = 0; ii < (usbos_info->pub->nrxq + usbos_info->pub->ntxq); ii++) {
+		entry = MALLOC(usbos_info->pub->osh, sizeof(usbos_list_entry_t));
+		if (entry) {
+			spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
+			list_add_tail((struct list_head*) entry, &usbos_info->usbos_free_list);
+			spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
+		} else {
+			DBUSERR(("Failed to create list\n"));
+		}
+	}
+
+	usbos_info->usbos_kt = kthread_create(dbus_usbos_thread_func,
+		usbos_info, "usb-thread");
+
+	if (IS_ERR(usbos_info->usbos_kt)) {
+		DBUSERR(("Thread Creation failed\n"));
+		return (NULL);
+	}
+
+	wake_up_process(usbos_info->usbos_kt);
+
+	return (usbos_info->usbos_kt);
+}
+
+static void
+dbus_usbos_thread_deinit(usbos_info_t *usbos_info)
+{
+	struct list_head    *cur, *next;
+	usbos_list_entry_t  *entry;
+	unsigned long       flags;
+
+	if (usbos_info->usbos_kt) {
+		wake_up_interruptible(&usbos_info->usbos_queue_head);
+		kthread_stop(usbos_info->usbos_kt);
+	}
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-qual"
+#endif
+	list_for_each_safe(cur, next, &usbos_info->usbos_list)
+	{
+		entry = list_entry(cur, struct usbos_list_entry, list);
+		/* detach this entry from the list and then free the entry */
+		spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
+		list_del(cur);
+		MFREE(usbos_info->pub->osh, entry, sizeof(usbos_list_entry_t));
+		spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
+	}
+
+	list_for_each_safe(cur, next, &usbos_info->usbos_free_list)
+	{
+		entry = list_entry(cur, struct usbos_list_entry, list);
+		/* detach this entry from the list and then free the entry */
+		spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
+		list_del(cur);
+		MFREE(usbos_info->pub->osh, entry, sizeof(usbos_list_entry_t));
+		spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
+	}
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
+#pragma GCC diagnostic pop
+#endif
+}
+
+/** Process completed URBs in a worker thread */
+static int
+dbus_usbos_thread_func(void *data)
+{
+	usbos_info_t        *usbos_info = (usbos_info_t *)data;
+	usbos_list_entry_t  *entry;
+	struct list_head    *cur, *next;
+	unsigned long       flags;
+
+#ifdef WL_THREADNICE
+	set_user_nice(current, WL_THREADNICE);
+#endif
+
+	while (1) {
+		/* If the list is empty, then go to sleep */
+		wait_event_interruptible_timeout
+		(usbos_info->usbos_queue_head,
+			atomic_read(&usbos_info->usbos_list_cnt) > 0,
+			100);
+
+		if (kthread_should_stop())
+			break;
+
+		spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
+
+		/* For each entry on the list, process it.  Remove the entry from
+		* the list when done.
+		*/
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-qual"
+#endif
+		list_for_each_safe(cur, next, &usbos_info->usbos_list)
+		{
+			urb_req_t           *req;
+			int                 len;
+			int                 stat;
+			usbos_info_t        *usbos_info_local;
+
+			entry = list_entry(cur, struct usbos_list_entry, list);
+			if (entry == NULL)
+				break;
+
+			req = entry->urb_context;
+			len = entry->urb_length;
+			stat = entry->urb_status;
+			usbos_info_local = req->usbinfo;
+
+			/* detach this entry from the list and attach it to the free list */
+			list_del_init(cur);
+			spin_unlock_irqrestore(&usbos_info_local->usbos_list_lock, flags);
+
+			dbus_usbos_recv_complete_handle(req, len, stat);
+
+			spin_lock_irqsave(&usbos_info_local->usbos_list_lock, flags);
+
+			list_add_tail(cur, &usbos_info_local->usbos_free_list);
+
+			atomic_dec(&usbos_info_local->usbos_list_cnt);
+		}
+
+		spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
+
+	}
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
+#pragma GCC diagnostic pop
+#endif
+
+	return 0;
+} /* dbus_usbos_thread_func */
+
+/** Called on Linux calling URB callback, see dbus_usbos_recv_complete() */
+static void
+dbus_usbos_dispatch_schedule(CALLBACK_ARGS)
+{
+	urb_req_t           *req = urb->context;
+	usbos_info_t        *usbos_info = req->usbinfo;
+	usbos_list_entry_t  *entry;
+	unsigned long       flags;
+	struct list_head    *cur;
+
+	spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
+
+	cur   = usbos_info->usbos_free_list.next;
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-qual"
+#endif
+	entry = list_entry(cur, struct usbos_list_entry, list);
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
+#pragma GCC diagnostic pop
+#endif
+
+	/* detach this entry from the free list and prepare it insert it to use list */
+	list_del_init(cur);
+
+	if (entry) {
+		entry->urb_context = urb->context;
+		entry->urb_length  = urb->actual_length;
+		entry->urb_status  = urb->status;
+
+		atomic_inc(&usbos_info->usbos_list_cnt);
+		list_add_tail(cur, &usbos_info->usbos_list);
+	} else {
+		DBUSERR(("!!!!!!OUT OF MEMORY!!!!!!!\n"));
+	}
+
+	spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
+
+	/* thread */
+	wake_up_interruptible(&usbos_info->usbos_queue_head);
+} /* dbus_usbos_dispatch_schedule */
+
+#endif /* USBOS_THREAD */
+
+#ifdef USB_TRIGGER_DEBUG
+static bool
+dbus_usbos_ctl_send_debugtrig(usbos_info_t* usbinfo)
+{
+	bootrom_id_t id;
+
+	if (usbinfo == NULL)
+		return FALSE;
+
+	id.chip = 0xDEAD;
+
+	dbus_usbos_dl_cmd(usbinfo, DL_DBGTRIG, &id, sizeof(bootrom_id_t));
+
+	/* ignore the result for now */
+	return TRUE;
+}
+#endif /* USB_TRIGGER_DEBUG */
+
+
+#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
+
+/** New optimized code for USB AP. EHCI fastpath specific function. */
+void inline optimize_ehci_qtd_init(struct ehci_qtd *qtd, dma_addr_t dma)
+{
+	memset(qtd, 0, sizeof(*qtd));
+	wmb();
+	qtd->qtd_self = dma;
+	qtd->qtd_status = cpu_to_le32(EHCI_QTD_HALTED);
+	qtd->qtd_next = EHCI_NULL;
+	qtd->qtd_altnext = EHCI_NULL;
+	qtd->obj_next = NULL;
+	qtd->rpc = NULL;
+	/* qtd->buff = NULL; */
+	qtd->xacterrs = EHCI_QTD_XACTERR_MAX;
+	wmb();
+}
+
+/** EHCI fastpath specific function */
+struct ehci_qtd *optimize_ehci_qtd_alloc(gfp_t flags)
+{
+	struct ehci_qtd		*qtd;
+	dma_addr_t		dma;
+
+	usbos_info_t *usbos_info = g_probe_info.usbos_info;
+
+	struct dma_pool *pool = usbos_info->qtd_pool;
+
+	qtd = dma_pool_alloc(pool, flags, &dma);
+	if (qtd != NULL) {
+		optimize_ehci_qtd_init(qtd, dma);
+	}
+
+	return qtd;
+}
+
+/** EHCI fastpath specific function */
+void optimize_ehci_qtd_free(struct ehci_qtd *qtd)
+{
+	usbos_info_t *usbos_info = g_probe_info.usbos_info;
+	struct dma_pool *pool = usbos_info->qtd_pool;
+	dma_pool_free(pool, qtd, qtd->qtd_self);
+}
+
+/**
+ * EHCI fastpath specific function. Loosely follows qtd_copy_status
+ * Greatly simplified as there are only three options: normal, short read, and disaster
+ */
+static int BCMFASTPATH get_qtd_status(struct ehci_qtd *qtd, int token, int *actual_length)
+{
+	int	status = -EINPROGRESS;
+
+	*actual_length += qtd->length - EHCI_QTD_GET_BYTES(token);
+
+	/* Short read is not an error */
+	if (unlikely (SHORT_READ_Q (token)))
+		status = -EREMOTEIO;
+
+	/* Check for serious problems */
+	if (token & EHCI_QTD_HALTED) {
+		status = -EPROTO;
+		if (token & (EHCI_QTD_BABBLE | EHCI_QTD_MISSEDMICRO | EHCI_QTD_BUFERR |
+			EHCI_QTD_XACTERR))
+			printk("EHCI Fastpath: Serious USB issue qtd %p token %08x --> status %d\n",
+				qtd, token, status);
+	}
+
+	return status;
+}
+
+static void dump_qtd(struct ehci_qtd *qtd)
+{
+	printk("qtd_next %08x qtd_altnext %08x qtd_status %08x\n", qtd->qtd_next,
+		qtd->qtd_altnext, qtd->qtd_status);
+}
+
+static void dump_qh(struct ehci_qh *qh)
+{
+	struct ehci_qtd *qtd = (struct ehci_qtd *)(qh->qh_curqtd | 0xa0000000);
+	printk("EHCI Fastpath: QH %p Dump\n", qh);
+	printk("qtd_next %08x info1 %08x info2 %08x current %08x\n", qh->qh_link, qh->qh_endp,
+		qh->qh_endphub, qh->qh_curqtd);
+	printk("overlay\n");
+	dump_qtd((struct ehci_qtd *)&qh->ow_next);
+	while ((((int)qtd)&EHCI_NULL) == 0)
+	{
+		printk("QTD %p\n", qtd);
+		dump_qtd((struct ehci_qtd *)qtd);
+		qtd = (struct ehci_qtd *)(qtd->qtd_next | 0xa0000000);
+	}
+}
+
+
+/**
+ * EHCI fastpath specific function.
+ * This code assumes the caller holding a lock
+ * It is currently called from scan_async that should have the lock
+ * Lock shall be dropped around the actual completion, then reacquired
+ * This is a clean implementation of the qh_completions()
+ */
+static void BCMFASTPATH ehci_bypass_callback(int pipeindex, struct ehci_qh *qh, spinlock_t *lock)
+{
+							/* Loop variables */
+	struct ehci_qtd		*qtd, 			/* current QTD */
+				*end = qh->dummy, 	/* "afterend" */
+				*next;
+	int			stopped;
+
+	usbos_info_t *usbos_info = g_probe_info.usbos_info;
+
+	/* printk("EHCI Fastpath: callback pipe %d QH %p lock %p\n", pipeindex, qh, lock); */
+
+	/*
+	 * This code should not require any interlocking with QTD additions
+	 * The additions never touch QH, we should never touch 'end'
+	 * Note that QTD additions will keep 'end' in place
+	 */
+	for (qtd = qh->first_qtd; qtd != end; qtd = next)
+	{
+		u32		status;		/* Status bits from QTD */
+
+		/* Get the status bits from the QTD */
+		rmb();
+		status = hc32_to_cpu(qtd->qtd_status);
+
+		if ((status & EHCI_QTD_ACTIVE) == 0) {
+			if (unlikely((status & EHCI_QTD_HALTED) != 0)) {
+				/* Retry transaction errors until we
+				 * reach the software xacterr limit
+				 */
+				if ((status & EHCI_QTD_XACTERR) &&
+					EHCI_QTD_GET_CERR(status) == 0 &&
+					--qtd->xacterrs > 0) {
+					/* Reset the token in the qtd and the
+					 * qh overlay (which still contains
+					 * the qtd) so that we pick up from
+					 * where we left off
+					 */
+					printk("EHCI Fastpath: detected XactErr "
+						"qtd %p len %d/%d retry %d\n",
+						qtd, qtd->length - EHCI_QTD_GET_BYTES(status),
+						qtd->length,
+						EHCI_QTD_XACTERR_MAX - qtd->xacterrs);
+
+					status &= ~EHCI_QTD_HALTED;
+					status |= EHCI_QTD_ACTIVE | EHCI_QTD_SET_CERR(3);
+					qtd->qtd_status = cpu_to_le32(status);
+					wmb();
+					qh->ow_status = cpu_to_le32(status);
+
+					break;
+				}
+
+				/* QTD processing was aborted - highly unlikely (never seen, so not
+				 * tested). In very new 2.6, we can retry. In 2.4 and older 2.6,
+				 * life sucks (the USB stack does the same)
+				 */
+				printk("EHCI Fastpath: QTD halted\n");
+				dump_qh(qh);
+				stopped = 1;
+			}
+		} else {
+			/* Inactive QTD is an afterend, finished the list */
+			break;
+		}
+
+		/* Remove the QTD from software QH. This should be done before dropping the lock
+		 * in for upper layer
+		 */
+		next = qtd->obj_next;
+		qh->first_qtd = next;
+
+		/* Upper layer processing. */
+		if (EHCI_QTD_GET_PID(status) == 0)  /* OUT (host->dongle) pipe */
+		{
+			if (qtd->rpc == NULL)
+			{
+				usbos_info->waitdone = TRUE;
+				wake_up_interruptible(&usbos_info->wait);
+				usbos_info->sync_urb_status = 0;
+			} else {
+
+
+
+				/* usb_info_t *usb_info = (usb_info_t *) handle; */
+				usb_info_t *usb_info = (usb_info_t *) usbos_info->cbarg;
+				/* if(usb_info && usb_info->cbs && usb_info->cbs->send_irb_complete)
+				 * usb_info->cbs->send_irb_complete(usb_info->cbarg, txirb, status);
+				 */
+
+				dbus_info_t *dbus_info = (dbus_info_t *)usb_info->cbarg;
+
+				/* Free the coalesce buffer, if multi-buffer packet only. Do not
+				 * rely on buff, as it might not even exist
+				 */
+				if (PKTNEXT(usbos_info->pub->osh, qtd->rpc)) {
+					/* printk("k-Freeing %p\n", qtd->buff); */
+					kfree(qtd->buff);
+				}
+
+				if (dbus_info->cbs && dbus_info->cbs->send_complete)
+				{
+					atomic_dec(&s_tx_pending);
+					spin_unlock(lock);
+					/* printk("Sending to RPC qtd %p\n", qtd); */
+#if !(defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) || defined(BCM_RPC_TOC))
+	#error Configuration not supported; read dbus_if_send_irb_complete for guidelines
+#endif
+					dbus_info->cbs->send_complete(dbus_info->cbarg, qtd->rpc,
+						0);
+					if ((atomic_read(&s_tx_pending) < 16) &&
+						dbus_info->txoff && !dbus_info->txoverride) {
+						dbus_flowctrl_tx(dbus_info, OFF);
+					}
+					spin_lock(lock);
+
+					/* Things could have happened while the lock was gone,
+					 * resync to the hardware
+					 */
+					next = qh->first_qtd;
+					end = qh->dummy;
+				}
+			}
+
+			optimize_ehci_qtd_free(qtd);
+		} else {   /* IN (dongle->host) pipe */
+			/* Simulates the upstream travel */
+			usb_info_t *usb_info = (usb_info_t *) usbos_info->cbarg;
+			dbus_info_t *dbus_info = (dbus_info_t *)usb_info->cbarg;
+			/* unsigned long       flags; */
+			int actual_length = 0;
+
+			/* All our reads must be short */
+			if (!SHORT_READ_Q (status)) ASSERT(0);
+
+			/* Done with hardware, convert status to error codes */
+			status = get_qtd_status(qtd, status, &actual_length);
+
+			switch (status) {
+			/* success */
+			case 0:
+			case -EINPROGRESS:
+			case -EREMOTEIO:
+				status = 0;
+				break;
+
+			case -ECONNRESET:		/* canceled */
+			case -ENOENT:
+			case -EPROTO:
+				DBUSERR(("%s: ehci unlink. status %x\n", __FUNCTION__, status));
+				break;
+			}
+
+			if (g_probe_info.dereged) {
+				printk("%s: DBUS deregistering, ignoring recv callback\n",
+					__FUNCTION__);
+				return;
+			}
+
+			dma_unmap_single(
+				usbos_info->usb->bus->controller,
+				(dma_addr_t)qtd->qtd_buffer_hi[0],
+				actual_length,
+				DMA_FROM_DEVICE);
+
+
+			if (dbus_info->pub.busstate != DBUS_STATE_DOWN) {
+				if (status == 0) {
+					void *buf = qtd->rpc;
+
+					ASSERT(buf != NULL);
+					spin_unlock(lock);
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+					/* Note that these ifdefs are indirectly coming from
+					 * dbus_usbos_recv_urb_submit The code itself is from
+					 * dbus_if_recv_irb_complete that makes the decision
+					 * at runtime, yet it is only pkt or buf depending on
+					 * the NOCOPY setup, never both :-)
+					 */
+					if (dbus_info->cbs && dbus_info->cbs->recv_pkt)
+						dbus_info->cbs->recv_pkt(dbus_info->cbarg, buf);
+#else
+					if (actual_length > 0) {
+						if (dbus_info->cbs && dbus_info->cbs->recv_buf)
+							dbus_info->cbs->recv_buf(dbus_info->cbarg,
+							buf, actual_length);
+					}
+#endif
+					spin_lock(lock);
+
+					/* Things could have happened while the lock was gone,
+					 * resync to the hardware
+					 */
+					next = qh->first_qtd;
+					end = qh->dummy;
+
+					/* Reinitialize this qtd since it will be reused. */
+					optimize_ehci_qtd_init(qtd, qtd->qtd_self);
+
+#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
+					/* Note that these ifdefs are coming from
+					 * dbus_usbos_recv_urb_submit. In the NOCOPY configuration,
+					 * force an allocation of a new packet
+					 */
+					optimize_submit_rx_request(&dbus_info->pub, 1, qtd, NULL);
+
+#else
+					/* In the copy mode, simply reuse the buffer; upper level
+					 * had already consumed the data
+					 */
+					optimize_submit_rx_request(&dbus_info->pub, 1, qtd, buf);
+#endif
+					/* Not to free this qtd because it will be reused. */
+					continue;
+				}
+			} else {
+				printk("%s: DBUS down, ignoring recv callback\n", __FUNCTION__);
+			}
+			optimize_ehci_qtd_free(qtd);
+		}
+	}
+} /* ehci_bypass_callback */
+
+/** EHCI fastpath specific function */
+static void optimize_urb_callback(struct urb *urb)
+{
+	struct usb_ctrlrequest *req = urb->context;
+
+	kfree(req);
+	USB_FREE_URB(urb);
+}
+
+/**
+ * EHCI fastpath specific function. Shall be called under an external lock (currently RPC_TP_LOCK)
+ */
+static int optimize_submit_urb(struct usb_device *usb, void *ptr, int request)
+{
+	struct usb_ctrlrequest *req;
+	struct urb *urb;
+
+	if ((urb = USB_ALLOC_URB()) == NULL) {
+		printk("EHCI Fastpath: Error allocating URB in optimize_EP!");
+		return -ENOMEM;
+	}
+
+	if ((req = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC)) == NULL) {
+		printk("EHCI Fastpath: Failed to allocate memory for control request in"
+			" optimize_EP!");
+		USB_FREE_URB(urb);
+		return -ENOMEM;
+	}
+
+	req->bRequestType = (USB_TYPE_VENDOR | USB_RECIP_OTHER);
+	req->bRequest = request;
+
+	/* Use this instead of a buffer */
+	req->wValue = ((int)ptr & 0xffff);
+	req->wIndex = ((((int)ptr)>>16) & 0xffff);
+	req->wLength = 0;
+
+	printk("EHCI Fastpath: usb_dev %p\n", usb);
+	printk("EHCI Fastpath: bus %p\n", usb->bus);
+	printk("EHCI Fastpath: Hub %p\n", usb->bus->root_hub);
+
+	usb_fill_control_urb(
+		urb,
+		usb->bus->root_hub,
+		usb_sndctrlpipe(usb->bus->root_hub, 0),
+		(void *)req,
+		NULL,
+		0,
+		optimize_urb_callback,
+		req);
+
+	USB_SUBMIT_URB(urb);
+
+	if (urb->status != 0) {
+		printk("EHCI Fastpath: Cannot submit URB in optimize_EP: %d\n", urb->status);
+	}
+
+	return urb->status;
+} /* optimize_submit_urb */
+
+/** EHCI fastpath specific function */
+static int epnum(int pipe)
+{
+	int epn = usb_pipeendpoint(pipe);
+	if (usb_pipein (pipe))
+		epn |= 0x10;
+	return epn;
+}
+
+/** EHCI fastpath specific function */
+static int optimize_init(usbos_info_t *usbos_info, struct usb_device *usb, int out, int in, int in2)
+{
+	int retval = -EPIPE;
+
+	atomic_set(&s_tx_pending, 0);
+	/* atomic_set(&s_rx_pending, 0); */
+
+	usbos_info->tx_ep = epnum(out);
+	usbos_info->rx_ep = epnum(in);
+	usbos_info->rx2_ep = epnum(in2);
+	usbos_info->usb_device = usb;
+
+	/* printk("EHCI Fastpath: Create pool %p %p %p\n", usb, usb->bus, usb->bus->controller); */
+
+	/* QTDs for bulk transfers - separate pool */
+	usbos_info->qtd_pool = dma_pool_create("usbnet_qtd",
+		usb->bus->controller,
+		sizeof(struct ehci_qtd),
+		EHCI_QTD_ALIGN /* byte alignment (for hw parts) */,
+		4096 /* can't cross 4K */);
+	if (!usbos_info->qtd_pool) {
+		printk("EHCI Fastpath: Cannot create the QTD pool\n");
+		goto fail;
+	}
+
+	/* detaching the EP */
+	if (optimize_submit_urb(usb, usb, EHCI_SET_BYPASS_DEV) != 0)
+		goto fail;
+	optimize_submit_urb(usb, ehci_bypass_callback, EHCI_SET_BYPASS_CB);
+	optimize_submit_urb(usb, usbos_info->qtd_pool, EHCI_SET_BYPASS_POOL);
+#ifdef EHCI_FASTPATH_TX
+	optimize_submit_urb(usb, (void*)((0<<16)|usbos_info->tx_ep), EHCI_FASTPATH);
+#endif
+#ifdef EHCI_FASTPATH_RX
+	optimize_submit_urb(usb, (void*)((1<<16)|usbos_info->rx_ep),   EHCI_FASTPATH);
+#endif
+
+	/* getting the QH */
+	printk("EHCI Fastpath: EP in %d EP in2 %d EP out %d\n", usbos_info->rx_ep,
+		usbos_info->rx2_ep, usbos_info->tx_ep);
+
+	return 0;
+
+fail:
+	return retval;
+} /* optimize_submit_urb */
+
+/** EHCI fastpath specific function */
+static int optimize_deinit_qtds(struct ehci_qh *qh, int coalesce_buf)
+{
+	usbos_info_t *usbos_info = g_probe_info.usbos_info;
+	struct ehci_qtd *qtd, *end, *next;
+	unsigned long	flags;
+
+	if (qh == NULL)
+		return 0;
+
+	end = qh->dummy;
+
+	printk("%s %d. qh = %p\n", __func__, __LINE__, qh);
+
+	spin_lock_irqsave(&usbos_info->fastpath_lock, flags);
+	for (qtd = qh->first_qtd; qtd != end; qtd = next) {
+		next = qtd->obj_next;
+		qh->first_qtd = next;
+
+		/* Free the coalesce buffer, if multi-buffer packet only. Do not
+		 * rely on buff, as it might not even exist
+		 */
+		if (coalesce_buf && PKTNEXT(usbos_info->pub->osh, qtd->rpc)) {
+			printk("k-Freeing %p, ", qtd->buff);
+			kfree(qtd->buff);
+		}
+		printk("freeing qtd %p\n", qtd);
+
+		optimize_ehci_qtd_free(qtd);
+	}
+	spin_unlock_irqrestore(&usbos_info->fastpath_lock, flags);
+
+	return 0;
+}
+
+static BCMFASTPATH struct ehci_qh *get_ep(usbos_info_t *usbos_info, int ep)
+{
+#ifdef KERNEL26
+	struct usb_host_endpoint *epp = NULL;
+	switch (ep)
+	{
+	case 0: epp = usbos_info->usb_device->ep_out[usbos_info->tx_ep&0xf]; break;
+	case 1: epp = usbos_info->usb_device->ep_in[usbos_info->rx_ep&0xf]; break;
+	case 2: epp = usbos_info->usb_device->ep_in[usbos_info->rx2_ep&0xf]; break;
+	default: ASSERT(0);
+	}
+	if (epp != NULL)
+		return (struct ehci_qh *)epp->hcpriv;
+	else return NULL;
+#else
+	switch (ep)
+	{
+	case 0: return (struct ehci_qh *)(((struct hcd_dev*)(usbos_info->
+		usb_device->hcpriv))->ep[usbos_info->tx_ep]);
+	case 1: return (struct ehci_qh *)(((struct hcd_dev*)(usbos_info->
+		usb_device->hcpriv))->ep[usbos_info->rx_ep]);
+	case 2: return (struct ehci_qh *)(((struct hcd_dev*)(usbos_info->
+		usb_device->hcpriv))->ep[usbos_info->rx2_ep]);
+	default: ASSERT(0);
+	}
+	return NULL;
+#endif /* KERNEL26 */
+}
+
+/** EHCI fastpath specific function */
+int optimize_deinit(usbos_info_t *usbos_info, struct usb_device *usb)
+{
+	optimize_deinit_qtds(get_ep(usbos_info, 0), 1);
+	optimize_deinit_qtds(get_ep(usbos_info, 1), 0);
+#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
+	optimize_submit_urb(usb, (void *)0, EHCI_CLR_EP_BYPASS);
+#endif
+	dma_pool_destroy(usbos_info->qtd_pool);
+	return 0;
+}
+
+/** EHCI fastpath specific function. Reassemble the segmented packet */
+static int BCMFASTPATH optimize_gather(const dbus_pub_t *pub, void *pkt, void **buf)
+{
+	int len = 0;
+
+	void *transfer_buf = kmalloc(pkttotlen(pub->osh, pkt),
+		GFP_ATOMIC);
+	*buf = transfer_buf;
+
+	if (!transfer_buf) {
+		printk("fail to alloc to usb buffer\n");
+		return 0;
+	}
+
+	while (pkt) {
+		int pktlen = PKTLEN(pub->osh, pkt);
+		bcopy(PKTDATA(pub->osh, pkt), transfer_buf, pktlen);
+		transfer_buf += pktlen;
+		len += pktlen;
+		pkt = PKTNEXT(pub->osh, pkt);
+	}
+
+	/* printk("Coalesced a %d-byte buffer\n", len); */
+
+	return len;
+}
+
+/** EHCI fastpath specific function */
+int BCMFASTPATH optimize_qtd_fill_with_rpc(const dbus_pub_t *pub, int epn,
+	struct ehci_qtd *qtd, void *rpc, int token, int len)
+{
+	void *data = NULL;
+
+	if (len == 0)
+		return optimize_qtd_fill_with_data(pub, epn, qtd, data, token, len);
+
+	ASSERT(rpc != NULL);
+	data = PKTDATA(pub->osh, rpc);
+	qtd->rpc = rpc;
+
+	if (PKTNEXT(pub->osh, rpc)) {
+		len = optimize_gather(pub, rpc, &data);
+		qtd->buff = data;
+	}
+
+	return optimize_qtd_fill_with_data(pub, epn, qtd, data, token, len);
+}
+
+/** EHCI fastpath specific function. Fill the QTD from the data buffer */
+int BCMFASTPATH optimize_qtd_fill_with_data(const dbus_pub_t *pub, int epn,
+	struct ehci_qtd *qtd, void *data, int token, int len)
+{
+	int		i, bytes_fit, page_offset;
+	dma_addr_t	addr = 0;
+
+	/* struct usb_host_endpoint *ep = get_ep(epn); */
+	usbos_info_t *usbos_info = g_probe_info.usbos_info;
+
+	token |= (EHCI_QTD_ACTIVE | EHCI_QTD_IOC); /* Allow execution, force interrupt */
+
+	if (len > 0) {
+		addr = dma_map_single(
+			usbos_info->usb->bus->controller,
+			data,
+			len,
+			EHCI_QTD_GET_PID(token) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+	}
+
+	qtd->qtd_buffer[0] = cpu_to_hc32((u32)addr);
+	/* Here qtd->qtd_buffer_hi[0] is leveraged to store addr value, which
+	 * is needed when invoking dma_unmap_single() in ehci_bypass_callback().
+	 * This is valid for EHCI 32bit only.
+	 */
+	qtd->qtd_buffer_hi[0] = cpu_to_hc32((u32)addr);
+	page_offset = (addr & (EHCI_PAGE_SIZE-1));
+	bytes_fit = EHCI_PAGE_SIZE - page_offset;
+	addr -= page_offset;
+	if (len < bytes_fit)
+		bytes_fit = len;
+	else {
+		addr +=  EHCI_PAGE_SIZE;
+
+		for (i = 1; bytes_fit < len && i < EHCI_QTD_NBUFFERS; i++) {
+			qtd->qtd_buffer[i] = cpu_to_hc32((u32)addr);
+			qtd->qtd_buffer_hi[i] = 0;
+			addr += EHCI_PAGE_SIZE;
+			if ((bytes_fit + EHCI_PAGE_SIZE) < len)
+				bytes_fit += EHCI_PAGE_SIZE;
+			else
+				bytes_fit = len;
+		}
+
+		if (bytes_fit != len)
+		{
+			ASSERT(0);
+		}
+	}
+	qtd->qtd_status = cpu_to_hc32((bytes_fit << 16) | token);
+	qtd->length = bytes_fit;
+
+	return bytes_fit;
+} /* optimize_qtd_fill_with_data */
+
+
+/**
+ * EHCI fastpath specific function. Reimplementation of qh_append_tds(). Returns nonzero if too many
+ * requests pending.
+ */
+int BCMFASTPATH optimize_submit_async(struct ehci_qtd *qtd, int epn)
+{
+	/* Clean implementation along the lines of qh_append_tds() */
+
+	struct ehci_qtd		*afterend; /* Element at the end of the QTD chain (after the
+					    * last useful one, "after-end")
+					    */
+	dma_addr_t		hw_addr;
+	__hc32			status;
+	unsigned long	flags;
+
+	usbos_info_t *usbos_info = g_probe_info.usbos_info;
+	struct ehci_qh *qh = get_ep(usbos_info, epn);
+	usb_info_t *usb_info = (usb_info_t *) usbos_info->cbarg;
+	dbus_info_t *dbus_info = (dbus_info_t *)usb_info->cbarg;
+
+	/* printk("Submit qtd %p to pipe %d (%p)\n", qtd, epn, qh); */
+	if (qh == NULL)
+	{
+		printk("EHCI Fastpath: Attempt of optimized submit to a non-optimized pipe\n");
+		return -1;
+	}
+
+	spin_lock_irqsave(&usbos_info->fastpath_lock, flags);
+
+	/* Limit outstanding - for rpc behavior only */
+	/* printk("QH qtd_status %08x\n", qh->hw->qtd_status); */
+
+	if ((qtd->qtd_status & (1<<8)) == 0)
+	{
+		atomic_inc(&s_tx_pending);
+		if (atomic_read(&s_tx_pending) > 16*2) /* (dbus_info->tx_low_watermark * 3)) */
+			dbus_flowctrl_tx(dbus_info, TRUE);
+	}
+
+	ASSERT(qh != NULL);
+
+
+	/*
+	 * Standard list processing trick:
+	 *   * old "afterend" is filled with the incoming data while still HALTed
+	 *   * new element is appended and prepared to serve as new afterend
+	 *   * now old afterend is activated
+	 * This way, HW never races the SW - no semaphores are necessary, as long as this function
+	 * is not reentered for the same QH
+	 */
+
+	/* Make new QTD to be HALTed, wait for it to actually happen */
+	status = qtd->qtd_status;
+	qtd->qtd_status = cpu_to_le32(EHCI_QTD_HALTED);
+	wmb();
+
+	/* Now copy all information from the new QTD to the old afterend,
+	 * except the own HW address
+	 */
+	afterend = qh->dummy;
+	hw_addr = afterend->qtd_self;
+	*afterend = *qtd;
+	afterend->qtd_self = hw_addr;
+
+	/* The new QTD is ready to serve as a new afterend, append it */
+	qh->dummy = qtd;
+	afterend->qtd_next = qtd->qtd_self;
+	afterend->qtd_altnext = qtd->qtd_self;  /* Always assume short read. Harmless in our case */
+	afterend->obj_next = qtd;
+
+	/* Wait for writes to happen and enable the old afterend (now containing the QTD data) */
+	wmb();
+	afterend->qtd_status = status;
+	wmb();
+
+	spin_unlock_irqrestore(&usbos_info->fastpath_lock, flags);
+
+	return 0;
+} /* optimize_submit_async */
+
+void BCMFASTPATH optimize_submit_rx_request(const dbus_pub_t *pub, int epn, struct ehci_qtd *qtd_in,
+                                            void *buf)
+{
+	usbos_info_t *usbos_info = g_probe_info.usbos_info;
+	int len = usbos_info->rxbuf_len;
+	void *pkt;
+	struct ehci_qtd *qtd;
+	int token = EHCI_QTD_SET_CERR(3) | EHCI_QTD_SET_PID(1);
+
+	if (qtd_in == NULL) {
+		qtd = optimize_ehci_qtd_alloc(GFP_KERNEL);
+		if (!qtd) {
+			printk("EHCI Fastpath: Out of QTDs\n");
+			return;
+		}
+	} else {
+		qtd = qtd_in;
+	}
+
+	if (buf == NULL)
+	{
+		/* NOCOPY, allocate own packet */
+		/* Follow dbus_usbos_recv_urb_submit */
+		pkt = PKTGET(usbos_info->pub->osh, len, FALSE);
+		if (pkt == NULL) {
+			printk("%s: PKTGET failed\n", __FUNCTION__);
+			optimize_ehci_qtd_free(qtd);
+			return;
+		}
+		/* consider the packet "native" so we don't count it as MALLOCED in the osl */
+		PKTTONATIVE(usbos_info->pub->osh, pkt);
+		qtd->rpc = pkt;
+		buf = PKTDATA(usbos_info->pub->osh, pkt);
+
+	} else {
+		qtd->rpc = buf;
+	}
+
+	optimize_qtd_fill_with_data(pub, epn, qtd, buf, token, len);
+	optimize_submit_async(qtd, epn);
+} /* optimize_submit_rx_request */
+
+#endif /* EHCI_FASTPATH_TX || EHCI_FASTPATH_RX */
+
+#ifdef BCM_REQUEST_FW
+
+struct request_fw_context {
+	const struct firmware *firmware;
+	struct semaphore lock;
+};
+
+/*
+ * Callback for dbus_request_firmware().
+ */
+static void
+dbus_request_firmware_done(const struct firmware *firmware, void *ctx)
+{
+	struct request_fw_context *context = (struct request_fw_context*)ctx;
+
+	/* Store the received firmware handle in the context and wake requester */
+	context->firmware = firmware;
+	up(&context->lock);
+}
+
+/*
+ * Send a firmware request and wait for completion.
+ *
+ * The use of the asynchronous version of request_firmware() is needed to avoid
+ * kernel oopses when we just come out of system hibernate.
+ */
+static int
+dbus_request_firmware(const char *name, const struct firmware **firmware)
+{
+	struct request_fw_context *context;
+	int ret;
+
+	context = kzalloc(sizeof(*context), GFP_KERNEL);
+	if (!context)
+		return -ENOMEM;
+
+	sema_init(&context->lock, 0);
+
+	ret = request_firmware_nowait(THIS_MODULE, true, name, &g_probe_info.usb->dev,
+	                              GFP_KERNEL, context, dbus_request_firmware_done);
+	if (ret) {
+		kfree(context);
+		return ret;
+	}
+
+	/* Wait for completion */
+	if (down_interruptible(&context->lock) != 0) {
+		kfree(context);
+		return -ERESTARTSYS;
+	}
+
+	*firmware = context->firmware;
+	kfree(context);
+
+	return *firmware != NULL ? 0 : -ENOENT;
+}
+
+static void *
+dbus_get_fwfile(int devid, int chiprev, uint8 **fw, int *fwlen, uint16 boardtype, uint16 boardrev)
+{
+	const struct firmware *firmware = NULL;
+	s8 file_name[64];
+	int ret;
+
+	snprintf(file_name, sizeof(file_name), "%s", CONFIG_ANDROID_BCMDHD_FW_PATH);
+
+	ret = dbus_request_firmware(file_name, &firmware);
+	if (ret) {
+		DBUSERR(("fail to request firmware %s\n", file_name));
+		return NULL;
+	}
+
+	*fwlen = firmware->size;
+	*fw = (uint8 *)firmware->data;
+	return (void *)firmware;
+
+}
+
+static void *
+dbus_get_nvfile(int devid, int chiprev, uint8 **fw, int *fwlen, uint16 boardtype, uint16 boardrev)
+{
+	const struct firmware *firmware = NULL;
+	s8 file_name[64];
+	int ret;
+
+	snprintf(file_name, sizeof(file_name), "%s", CONFIG_ANDROID_BCMDHD_NVRAM_PATH);
+
+	ret = dbus_request_firmware(file_name, &firmware);
+	if (ret) {
+		DBUSERR(("fail to request nvram %s\n", file_name));
+
+
+		if (ret) {
+			DBUSERR(("fail to request nvram %s\n", file_name));
+			return NULL;
+		}
+	}
+
+	*fwlen = firmware->size;
+	*fw = (uint8 *)firmware->data;
+	return (void *)firmware;
+}
+
+void *
+dbus_get_fw_nvfile(int devid, int chiprev, uint8 **fw, int *fwlen, int type, uint16 boardtype,
+	uint16 boardrev)
+{
+	switch (type) {
+		case DBUS_FIRMWARE:
+			return dbus_get_fwfile(devid, chiprev, fw, fwlen, boardtype, boardrev);
+		case DBUS_NVFILE:
+			return dbus_get_nvfile(devid, chiprev, fw, fwlen, boardtype, boardrev);
+		default:
+			return NULL;
+	}
+}
+
+void
+dbus_release_fw_nvfile(void *firmware)
+{
+	release_firmware((struct firmware *)firmware);
+}
+#endif /* BCM_REQUEST_FW */
+
+#ifdef BCMUSBDEV_COMPOSITE
+/**
+ * For a composite device the interface order is not guaranteed, scan the device struct for the WLAN
+ * interface.
+ */
+static int
+dbus_usbos_intf_wlan(struct usb_device *usb)
+{
+	int i, num_of_eps, ep, intf_wlan = -1;
+	int num_intf = CONFIGDESC(usb)->bNumInterfaces;
+	struct usb_endpoint_descriptor *endpoint;
+
+	for (i = 0; i < num_intf; i++) {
+		if (IFDESC(usb, i).bInterfaceClass != USB_CLASS_VENDOR_SPEC)
+			continue;
+		num_of_eps = IFDESC(usb, i).bNumEndpoints;
+
+		for (ep = 0; ep < num_of_eps; ep++) {
+			endpoint = &IFEPDESC(usb, i, ep);
+			if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+				USB_ENDPOINT_XFER_BULK) {
+				intf_wlan = i;
+				break;
+			}
+		}
+		if (ep < num_of_eps)
+			break;
+	}
+
+	return intf_wlan;
+}
+#endif /* BCMUSBDEV_COMPOSITE */
+
+#ifdef KEEPIF_ON_DEVICE_RESET
+/* if keepif_on_devreset is set, and reset_resume or disconnect got called, we need de-register or
+ * register the usb driver to OS again; but this operation can't be called inside the reset_resume
+ * or disconnect callback, so introduce a kernel thread to do these work
+ */
+static int
+dbus_usbos_usbreset_func(void *data)
+{
+	enum usb_dev_status flag = USB_DEVICE_INIT;
+	usbos_info_t *usbos_info;
+
+	while (1) {
+		wait_event_interruptible_timeout(g_probe_info.usbreset_queue_head,
+			atomic_read(&g_probe_info.usbdev_stat), 100); /* 100 ms */
+
+		if (kthread_should_stop())
+			break;
+		if (!(usbos_info = g_probe_info.usbos_info))
+			continue;
+		if (!(flag = atomic_read(&g_probe_info.usbdev_stat)))
+			continue;
+
+		usbos_info = g_probe_info.usbos_info;
+		flag = atomic_read(&g_probe_info.usbdev_stat);
+		atomic_set(&g_probe_info.usbdev_stat, USB_DEVICE_INIT);
+
+		if ((flag == USB_DEVICE_RESETTED) || (flag == USB_DEVICE_DISCONNECTED)) {
+			DBUSERR(("Device reset, re-register USB driver\n"));
+			g_probe_info.dev_resetted = TRUE;
+			g_probe_info.busstate_bf_devreset = usbos_info->pub->busstate;
+			dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
+
+			g_probe_info.dereged = TRUE;
+			USB_DEREGISTER();
+			USB_REGISTER();
+			g_probe_info.dereged = FALSE;
+		} else if (flag == USB_DEVICE_PROBED) {
+			DBUSERR(("Device probed, but no need to initialize higher layer\n"));
+			g_probe_info.dev_resetted = FALSE;
+			dbus_usbos_init_info();
+			/* The device may have lost power, so a firmware download may be required */
+			dbus_usbos_state_change(usbos_info,
+				DBUS_STATE_DL_NEEDED);
+			g_probe_info.suspend_state = USBOS_SUSPEND_STATE_DEVICE_ACTIVE;
+			dbus_usbos_state_change(usbos_info,
+				g_probe_info.busstate_bf_devreset);
+		}
+	}
+	return 0;
+}
+#endif /* KEEPIF_ON_DEVICE_RESET */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd.h
index 67d3134e5573..b784beff2acb 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd.h
@@ -1,10 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Header file describing the internal (inter-module) DHD interfaces.
  *
  * Provides type definitions and function prototypes used to link the
  * DHD OS, bus, and protocol modules.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -27,7 +28,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: dhd.h 674559 2017-10-27 03:07:31Z $
+ * $Id: dhd.h 715966 2019-05-30 02:36:59Z $
  */
 
 /****************
@@ -74,10 +75,10 @@ int get_scheduler_policy(struct task_struct *p);
 #define MAX_RESCHED_CNT 600
 #endif 
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) && LINUX_VERSION_CODE < \
-	KERNEL_VERSION(3, 18, 0) || defined(CONFIG_BCMDHD_VENDOR_EXT))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) || \
+	defined(CONFIG_BCMDHD_VENDOR_EXT))
 #define WL_VENDOR_EXT_SUPPORT
-#endif /* 3.14.0 <= LINUX_KERNEL_VERSION < 3.18.0 || CONFIG_BCMDHD_VENDOR_EXT */
+#endif /* 3.14.0 <= LINUX_KERNEL_VERSION || CONFIG_BCMDHD_VENDOR_EXT */
 
 #if defined(KEEP_ALIVE)
 /* Default KEEP_ALIVE Period is 55 sec to prevent AP from sending Keep Alive probe frame */
@@ -393,6 +394,9 @@ typedef struct dhd_pub {
 	 * please do NOT merge it back from other branches !!!
 	 */
 
+#ifdef BCMDBUS
+	struct dbus_pub *dbus;
+#endif
 
 	/* Internal dhd items */
 	bool up;		/* Driver up/down (to OS) */
@@ -758,6 +762,12 @@ extern int dhd_os_wd_wake_lock(dhd_pub_t *pub);
 extern int dhd_os_wd_wake_unlock(dhd_pub_t *pub);
 extern int dhd_os_wake_lock_waive(dhd_pub_t *pub);
 extern int dhd_os_wake_lock_restore(dhd_pub_t *pub);
+extern void dhd_event_wake_lock(dhd_pub_t *pub);
+extern void dhd_event_wake_unlock(dhd_pub_t *pub);
+extern void dhd_txfl_wake_lock_timeout(dhd_pub_t *pub, int val);
+extern void dhd_txfl_wake_unlock(dhd_pub_t *pub);
+extern void dhd_os_wake_lock_init(struct dhd_info *dhd);
+extern void dhd_os_wake_lock_destroy(struct dhd_info *dhd);
 #ifdef BCMPCIE_OOB_HOST_WAKE
 extern void dhd_os_oob_irq_wake_lock_timeout(dhd_pub_t *pub, int val);
 extern void dhd_os_oob_irq_wake_unlock(dhd_pub_t *pub);
@@ -803,6 +813,13 @@ inline static void MUTEX_UNLOCK_SOFTAP_SET(dhd_pub_t * dhdp)
 #define DHD_OS_WD_WAKE_LOCK(pub)		dhd_os_wd_wake_lock(pub)
 #define DHD_OS_WD_WAKE_UNLOCK(pub)		dhd_os_wd_wake_unlock(pub)
 
+#define DHD_EVENT_WAKE_LOCK(pub)		dhd_event_wake_lock(pub)
+#define DHD_EVENT_WAKE_UNLOCK(pub)		dhd_event_wake_unlock(pub)
+#define DHD_TXFL_WAKE_LOCK_TIMEOUT(pub, val)	dhd_txfl_wake_lock_timeout(pub, val)
+#define DHD_TXFL_WAKE_UNLOCK(pub)		dhd_txfl_wake_unlock(pub)
+#define DHD_OS_WAKE_LOCK_INIT(dhd) 		dhd_os_wake_lock_init(dhd)
+#define DHD_OS_WAKE_LOCK_DESTROY(dhd)		dhd_os_wake_lock_destroy(dhd)
+
 #ifdef BCMPCIE_OOB_HOST_WAKE
 #define OOB_WAKE_LOCK_TIMEOUT 500
 #define DHD_OS_OOB_IRQ_WAKE_LOCK_TIMEOUT(pub, val)	dhd_os_oob_irq_wake_lock_timeout(pub, val)
@@ -833,6 +850,7 @@ inline static void MUTEX_UNLOCK_SOFTAP_SET(dhd_pub_t * dhdp)
 #define DHD_PACKET_TIMEOUT_MS	500
 #define DHD_EVENT_TIMEOUT_MS	1500
 #define SCAN_WAKE_LOCK_TIMEOUT	10000
+#define MAX_TX_TIMEOUT		500
 
 /* Enum for IOCTL recieved status */
 typedef enum dhd_ioctl_recieved_status
@@ -1090,11 +1108,13 @@ extern int dhd_net2idx(struct dhd_info *dhd, struct net_device *net);
 extern struct net_device * dhd_idx2net(void *pub, int ifidx);
 extern int net_os_send_hang_message(struct net_device *dev);
 extern bool dhd_wowl_cap(void *bus);
+extern int wl_host_event(dhd_pub_t *dhd_pub, int *idx, void *pktdata, uint pktlen,
+	wl_event_msg_t *, void **data_ptr,  void *);
 
-extern int wl_host_event(dhd_pub_t *dhd_pub, int *idx, void *pktdata,
-                         wl_event_msg_t *, void **data_ptr,  void *);
 extern void wl_event_to_host_order(wl_event_msg_t * evt);
-extern int wl_host_event_get_data(void *pktdata, wl_event_msg_t *event, void **data_ptr);
+extern int wl_host_event_get_data(void *pktdata, uint pktlen, bcm_event_msg_u_t *evu);
+extern int wl_process_host_event(dhd_pub_t *dhd_pub, int *idx, void *pktdata, uint pktlen,
+	wl_event_msg_t *, void **data_ptr,  void *);
 
 extern int dhd_wl_ioctl(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf, int len);
 extern int dhd_wl_ioctl_cmd(dhd_pub_t *dhd_pub, int cmd, void *arg, int len, uint8 set,
@@ -1364,7 +1384,9 @@ extern char fw_path2[MOD_PARAM_PATHLEN];
 
 /* Flag to indicate if we should download firmware on driver load */
 extern uint dhd_download_fw_on_driverload;
+#ifndef BCMDBUS
 extern int allow_delay_fwdl;
+#endif /* !BCMDBUS */
 
 
 extern void dhd_wait_for_event(dhd_pub_t *dhd, bool *lockvar);
@@ -1470,6 +1492,10 @@ extern void dhd_os_general_spin_unlock(dhd_pub_t *pub, unsigned long flags);
 
 extern void dhd_dump_to_kernelog(dhd_pub_t *dhdp);
 
+#ifdef BCMDBUS
+extern void dhd_bus_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf);
+extern void dhd_bus_clearcounts(dhd_pub_t *dhdp);
+#endif /* BCMDBUS */
 
 #ifdef DHD_L2_FILTER
 extern int dhd_get_parp_status(dhd_pub_t *dhdp, uint32 idx);
@@ -1492,6 +1518,7 @@ typedef struct wl_evt_pport {
 	dhd_pub_t *dhd_pub;
 	int *ifidx;
 	void *pktdata;
+	uint data_len;
 	void **data_ptr;
 	void *raw_event;
 } wl_evt_pport_t;
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bta.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bta.c
index 1c2be05d93ae..b0ff7651a812 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bta.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bta.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BT-AMP support routines
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -38,7 +39,11 @@
 #include <proto/bt_amp_hci.h>
 #include <dngl_stats.h>
 #include <dhd.h>
+#ifdef BCMDBUS
+#include <dbus.h>
+#else
 #include <dhd_bus.h>
+#endif
 #include <dhd_proto.h>
 #include <dhdioctl.h>
 #include <dhd_dbg.h>
@@ -86,7 +91,11 @@ dhd_bta_flush_hcidata(dhd_pub_t *pub, uint16 llh)
 	struct pktq *q;
 	uint count = 0;
 
+#ifdef BCMDBUS
+	q = dhd_dbus_txq(pub->dbus);
+#else
 	q = dhd_bus_txq(pub->bus);
+#endif /* BCMDBUS */
 	if (q == NULL)
 		return;
 
@@ -102,6 +111,9 @@ dhd_bta_flush_hcidata(dhd_pub_t *pub, uint16 llh)
 			void *pkt = pktq_pdeq(q, prec);
 			int ifidx;
 
+#ifdef BCMDBUS
+			PKTPULL(pub->osh, pkt, dhd_dbus_hdrlen(pub->dbus));
+#endif /* BCMDBUS */
 			dhd_prot_hdrpull(pub, &ifidx, pkt, NULL, NULL);
 
 			if (PKTLEN(pub->osh, pkt) >= RFC1042_HDR_LEN) {
@@ -129,6 +141,9 @@ dhd_bta_flush_hcidata(dhd_pub_t *pub, uint16 llh)
 			}
 
 			dhd_prot_hdrpush(pub, ifidx, pkt);
+#ifdef BCMDBUS
+			PKTPUSH(pub->osh, pkt, dhd_dbus_hdrlen(pub->dbus));
+#endif /* BCMDBUS */
 
 			if (head_pkt == NULL)
 				head_pkt = pkt;
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bta.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bta.h
index dcb5e658c45c..3ade6ef801f1 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bta.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bta.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BT-AMP support routines
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bus.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bus.h
index 8eccbaea235c..ae32cce0ef36 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bus.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_bus.h
@@ -1,10 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Header file describing the internal (inter-module) DHD interfaces.
  *
  * Provides type definitions and function prototypes used to link the
  * DHD OS, bus, and protocol modules.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_buzzz.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_buzzz.h
index e349a3f451dd..c4e04507b4f6 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_buzzz.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_buzzz.h
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _DHD_BUZZZ_H_INCLUDED_
 #define _DHD_BUZZZ_H_INCLUDED_
 
 /*
  * Broadcom logging system - Empty implementaiton
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cdc.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cdc.c
index ad20e0776456..926300da354b 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cdc.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cdc.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * DHD Protocol Module for CDC and BDC.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: dhd_cdc.c 581085 2015-08-21 09:04:22Z $
+ * $Id: dhd_cdc.c 708487 2018-10-31 05:33:14Z $
  *
  * BDC is like CDC, except it includes a header for data packets to convey
  * packet priority over the bus, and flags (e.g. to indicate checksum status
@@ -41,7 +42,11 @@
 #include <dngl_stats.h>
 #include <dhd.h>
 #include <dhd_proto.h>
+#ifdef BCMDBUS
+#include <dbus.h>
+#else
 #include <dhd_bus.h>
+#endif /* BCMDBUS */
 #include <dhd_dbg.h>
 
 
@@ -50,6 +55,10 @@
 #include <dhd_wlfc.h>
 #endif
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+#include <dhd_chip_info.h>
+#endif
+
 #ifdef DHD_ULP
 #include <dhd_ulp.h>
 #endif /* DHD_ULP */
@@ -68,15 +77,24 @@ typedef struct dhd_prot {
 	uint16 reqid;
 	uint8 pending;
 	uint32 lastcmd;
+#ifdef BCMDBUS
+	uint ctl_completed;
+#endif
 	uint8 bus_header[BUS_HEADER_LEN];
 	cdc_ioctl_t msg;
 	unsigned char buf[WLC_IOCTL_MAXLEN + ROUND_UP_MARGIN];
 } dhd_prot_t;
 
+#if defined(BCMDBUS)
+extern int dhd_dbus_txdata(dhd_pub_t *dhdp, void *pktbuf);
+#endif
 
 static int
 dhdcdc_msg(dhd_pub_t *dhd)
 {
+#ifdef BCMDBUS
+	int timeout = 0;
+#endif /* BCMDBUS */
 	int err = 0;
 	dhd_prot_t *prot = dhd->prot;
 	int len = ltoh32(prot->msg.len) + sizeof(cdc_ioctl_t);
@@ -93,8 +111,51 @@ dhdcdc_msg(dhd_pub_t *dhd)
 		len = CDC_MAX_MSG_SIZE;
 
 	/* Send request */
+#ifdef BCMDBUS
+	DHD_OS_IOCTL_RESP_LOCK(dhd);
+	prot->ctl_completed = FALSE;
+	err = dbus_send_ctl(dhd->dbus, (void *)&prot->msg, len);
+	if (err) {
+		DHD_ERROR(("dbus_send_ctl error=0x%x\n", err));
+		DHD_OS_IOCTL_RESP_UNLOCK(dhd);
+		DHD_OS_WAKE_UNLOCK(dhd);
+		return err;
+	}
+#else
 	err = dhd_bus_txctl(dhd->bus, (uchar*)&prot->msg, len);
+#endif
 
+#ifdef BCMDBUS
+	timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed);
+	if ((!timeout) || (!prot->ctl_completed)) {
+		DHD_ERROR(("Txctl timeout %d ctl_completed %d\n",
+			timeout, prot->ctl_completed));
+		DHD_ERROR(("Txctl wait timed out\n"));
+		err = -1;
+	}
+	DHD_OS_IOCTL_RESP_UNLOCK(dhd);
+#endif
+#if defined(BCMDBUS) && defined(INTR_EP_ENABLE)
+	/* If the ctl write is successfully completed, wait for an acknowledgement
+	* that indicates that it is now ok to do ctl read from the dongle
+	*/
+	if (err != -1) {
+		DHD_OS_IOCTL_RESP_LOCK(dhd);
+		prot->ctl_completed = FALSE;
+		if (dbus_poll_intr(dhd->dbus)) {
+			DHD_ERROR(("dbus_poll_intr not submitted\n"));
+		} else {
+			/* interrupt polling is sucessfully submitted. Wait for dongle to send
+			* interrupt
+			*/
+			timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed);
+			if (!timeout) {
+				DHD_ERROR(("intr poll wait timed out\n"));
+			}
+		}
+		DHD_OS_IOCTL_RESP_UNLOCK(dhd);
+	}
+#endif /* defined(BCMDBUS) && defined(INTR_EP_ENABLE) */
 	DHD_OS_WAKE_UNLOCK(dhd);
 	return err;
 }
@@ -102,6 +163,9 @@ dhdcdc_msg(dhd_pub_t *dhd)
 static int
 dhdcdc_cmplt(dhd_pub_t *dhd, uint32 id, uint32 len)
 {
+#ifdef BCMDBUS
+	int timeout = 0;
+#endif /* BCMDBUS */
 	int ret;
 	int cdc_len = len + sizeof(cdc_ioctl_t);
 	dhd_prot_t *prot = dhd->prot;
@@ -110,12 +174,38 @@ dhdcdc_cmplt(dhd_pub_t *dhd, uint32 id, uint32 len)
 
 
 	do {
+#ifdef BCMDBUS
+		DHD_OS_IOCTL_RESP_LOCK(dhd);
+		prot->ctl_completed = FALSE;
+		ret = dbus_recv_ctl(dhd->dbus, (uchar*)&prot->msg, cdc_len);
+		if (ret) {
+			DHD_ERROR(("dbus_recv_ctl error=0x%x(%d)\n", ret, ret));
+			DHD_OS_IOCTL_RESP_UNLOCK(dhd);
+			goto done;
+		}
+		timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed);
+		if ((!timeout) || (!prot->ctl_completed)) {
+			DHD_ERROR(("Rxctl timeout %d ctl_completed %d\n",
+				timeout, prot->ctl_completed));
+			ret = -1;
+			DHD_OS_IOCTL_RESP_UNLOCK(dhd);
+
+			goto done;
+		}
+		DHD_OS_IOCTL_RESP_UNLOCK(dhd);
+
+		ret = cdc_len;
+#else
 		ret = dhd_bus_rxctl(dhd->bus, (uchar*)&prot->msg, cdc_len);
+#endif /* BCMDBUS */
 		if (ret < 0)
 			break;
 	} while (CDC_IOC_ID(ltoh32(prot->msg.flags)) != id);
 
 
+#ifdef BCMDBUS
+done:
+#endif /* BCMDBUS */
 	return ret;
 }
 
@@ -285,6 +375,25 @@ dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len, uint8
 	return ret;
 }
 
+#ifdef BCMDBUS
+int
+dhd_prot_ctl_complete(dhd_pub_t *dhd)
+{
+	dhd_prot_t *prot;
+
+	if (dhd == NULL)
+		return BCME_ERROR;
+
+	prot = dhd->prot;
+
+	ASSERT(prot);
+	DHD_OS_IOCTL_RESP_LOCK(dhd);
+	prot->ctl_completed = TRUE;
+	dhd_os_ioctl_resp_wake(dhd);
+	DHD_OS_IOCTL_RESP_UNLOCK(dhd);
+	return 0;
+}
+#endif /* BCMDBUS */
 
 int
 dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t * ioc, void * buf, int len)
@@ -477,6 +586,12 @@ dhd_prot_hdrpull(dhd_pub_t *dhd, int *ifidx, void *pktbuf, uchar *reorder_buf_in
 		dhd_wlfc_parse_header_info(dhd, pktbuf, (data_offset << 2),
 			reorder_buf_info, reorder_info_len);
 
+#ifdef BCMDBUS
+#ifndef DHD_WLFC_THREAD
+		dhd_wlfc_commit_packets(dhd,
+			(f_commitpkt_t)dhd_dbus_txdata, (void *)dhd, NULL, FALSE);
+#endif /* DHD_WLFC_THREAD */
+#endif /* BCMDBUS */
 	}
 #endif /* PROP_TXSTATUS */
 
@@ -548,20 +663,28 @@ dhd_sync_with_dongle(dhd_pub_t *dhd)
 	wlc_rev_info_t revinfo;
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	if(alive == FW_ALIVE_MAGIC) {
+		ret = dhd_preinit_ioctls_alive(dhd);
+	} else
+#endif /* LOAD_DHD_WITH_FW_ALIVE */
+	{
+		/* Get the device rev info */
+		memset(&revinfo, 0, sizeof(revinfo));
+		ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_REVINFO, &revinfo, sizeof(revinfo), FALSE, 0);
+		if (ret < 0)
+			goto done;
 
-	/* Get the device rev info */
-	memset(&revinfo, 0, sizeof(revinfo));
-	ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_REVINFO, &revinfo, sizeof(revinfo), FALSE, 0);
-	if (ret < 0)
-		goto done;
-
-
-	dhd_process_cid_mac(dhd, TRUE);
+#if defined(BCMDBUS) && defined(BCMDHDUSB)
+		/* dbus_set_revinfo(dhd->dbus, revinfo.chipnum, revinfo.chiprev); */
+#endif /* BCMDBUS && BCMDHDUSB */
 
-	ret = dhd_preinit_ioctls(dhd);
+		dhd_process_cid_mac(dhd, TRUE);
 
-	if (!ret)
-		dhd_process_cid_mac(dhd, FALSE);
+		ret = dhd_preinit_ioctls(dhd);
+		if (!ret)
+			dhd_process_cid_mac(dhd, FALSE);
+	}
 
 	/* Always assumes wl for now */
 	dhd->iswl = TRUE;
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg80211.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg80211.c
index 339bd276289d..931e6a8c09cc 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg80211.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver - Dongle Host Driver (DHD) related
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -149,6 +150,7 @@ struct net_device * dhd_cfg80211_netdev_free(struct net_device *ndev)
 			kfree(ndev->ieee80211_ptr);
 			ndev->ieee80211_ptr = NULL;
 		}
+		free_netdev(ndev);
 		return NULL;
 	}
 
@@ -160,6 +162,8 @@ void dhd_netdev_free(struct net_device *ndev)
 #ifdef WL_CFG80211
 	ndev = dhd_cfg80211_netdev_free(ndev);
 #endif
+	if (ndev)
+		free_netdev(ndev);
 }
 
 static s32
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg80211.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg80211.h
index 260ff0cefc7d..53a52b62521d 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg80211.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg80211.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver - Dongle Host Driver (DHD) related
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg_vendor.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg_vendor.c
index 4ba3827d421a..8d95b8531b1b 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg_vendor.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_cfg_vendor.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 vendor command/event handlers of DHD
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_chip_info.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_chip_info.c
new file mode 100644
index 000000000000..e0d78282ee80
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_chip_info.c
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include "dhd_chip_info.h"
+
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+int alive = 0;
+int card_dev = 0;
+int card_rev = 0;
+
+uint32	bcm43430_coreid[] = {
+0x00000800,0x00000812,0x00000829,0x0000082a,0x0000080e,0x00000240};
+uint32  bcm43430_coresba[] = {
+0x18000000,0x18001000,0x18002000,0x18003000,0x18004000,0x19000000};
+uint32  bcm43430_coresba_size[] = {
+0x00001000,0x00001000,0x00001000,0x00001000,0x00001000,0x01000000};
+uint32  bcm43430_wrapba[] = {
+0x18100000,0x18101000,0x18102000,0x18103000,0x18104000,0x18106000};
+uint32  bcm43430_cia[] = {
+0x4bf80001,0x4bf81201,0x4bf82901,0x4bf82a01,0x4bf80e01,0x43b24001};
+uint32  bcm43430_cib[] = {
+0x31004211,0x27004211,0x15004211,0x09004211,0x16080401,0x00080201};
+
+uint32  bcm43436_cib[] = {
+0x31004211,0x27004211,0x18004211,0x0b004211,0x19080401,0x00080201};
+
+
+int sii_pub_43430[] = {
+0x00000001,0x00000003,0x00000829,0x00000015,0x00000002,0x00000031,0x10400000,0x0000001e,
+0x00000018,0x39d25f18,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000a9a6,
+0x00000000,0x00000003,0x30c21b01,0x00000000,0x00000000,0x00000000,
+};
+
+int sii_pub_43436[] = {
+0x00000001,0x00000003,0x00000829,0x00000018,0x00000002,0x00000031,0x10400000,0x0000001e,
+0x00000018,0x39d25f18,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000a9a6,
+0x00000002,0x00000004,0x40c01b01,0x00000000,0x00000000,0x00000000,
+};
+
+uint32 bcm43012_coreid[] = { 
+			0x00000800, 0x00000812, 0x00000829, 0x0000082a,
+			0x0000080e, 0x00000844, 0x00000840, 0x00000827 };
+uint32 bcm43012_coresba[] = {
+			0x18000000, 0x18001000, 0x18002000, 0x18003000,
+			0x18004000, 0x18005000, 0x18010000, 0x18012000 };
+uint32 bcm43012_coresba_size[] = {
+			0x00001000, 0x00001000, 0x00001000, 0x00001000,
+			0x00001000, 0x00001000, 0x00002000, 0x00001000 };
+uint32 bcm43012_wrapba[] = {
+			0x18100000, 0x18101000, 0x18102000, 0x18103000,
+			0x18107000, 0x18104000, 0x00000000, 0x00000000 };
+uint32 bcm43012_cia[] = {
+			0x4bf80001, 0x4bf81201, 0x4bf82901, 0x4bf82a01,
+			0x4bf80e01, 0x4bf84401, 0x4bf84001, 0x4bf82701 };
+uint32 bcm43012_cib[] = {
+			0x38084411, 0x3e084411, 0x1b004211, 0x0a004211,
+			0x17080401, 0x01004211, 0x09000201, 0x1e000201 };
+int sii_pub_43012[] = {
+			0x00000001, 0x00000003, 0x00000829, 0x0000001b,
+			0x00000002, 0x00000038, 0x10400109, 0x0000105c,
+			0x0000001e, 0x8a8c5f1e, 0x00000000, 0x00000000,
+			0x00000000, 0x00000000, 0x00000000, 0x0000a804,
+			0x00000002, 0x00000000, 0x00c18854, 0x00000000,
+			0x00000000, 0x00000000 };
+#endif /* LOAD_DHD_WITH_FW_ALIVE */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_chip_info.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_chip_info.h
new file mode 100644
index 000000000000..b830259a4f3c
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_chip_info.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __dhd_chip_info_h__
+#define __dhd_chip_info_h__
+
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+
+#include <typedefs.h>
+
+#define chip_info_dump 0
+
+#define ai_core_43341 7
+#define oob_router_43341 0x18108000
+
+#define ai_core_43430 6
+#define oob_router_43430 0x18107000
+
+#define ai_core_43012 8
+#define oob_router_43012 0x1810c000
+
+#define FW_ALIVE_MAGIC 0x151515
+
+extern int alive;
+extern int card_dev;
+extern int card_rev;
+
+extern uint32	bcm43341_coreid[];
+extern uint32	bcm43341_coresba[];
+extern uint32	bcm43341_coresba_size[];
+extern uint32	bcm43341_coresba2_size[];
+extern uint32	bcm43341_wrapba[];
+extern uint32	bcm43341_cia[];
+extern uint32	bcm43341_cib[];
+
+extern uint32	bcm43430_coreid[];
+extern uint32	bcm43430_coresba[];
+extern uint32	bcm43430_coresba_size[];
+extern uint32	bcm43430_wrapba[];
+extern uint32	bcm43430_cia[];
+extern uint32	bcm43430_cib[];
+extern uint32	bcm43436_cib[];
+
+extern int	sii_pub_43341[];
+extern int	sii_pub_43430[];
+extern int	sii_pub_43436[];
+
+extern uint32 bcm43012_coreid[];
+extern uint32 bcm43012_coresba[];
+extern uint32 bcm43012_coresba_size[];
+extern uint32 bcm43012_wrapba[];
+extern uint32 bcm43012_cia[];
+extern uint32 bcm43012_cib[];
+extern int sii_pub_43012[];
+
+#endif	//LOAD_DHD_WITH_FW_ALIVE
+
+#endif	//__dhd_chip_info_h__
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_common.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_common.c
index abf812b19a67..9e5aa7ef9763 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_common.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_common.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Dongle Host Driver (DHD), common DHD core.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: dhd_common.c 674559 2017-10-27 03:07:31Z $
+ * $Id: dhd_common.c 715966 2019-05-30 02:36:59Z $
  */
 #include <typedefs.h>
 #include <osl.h>
@@ -47,7 +48,11 @@
 #include <dhd_flowring.h>
 #endif
 
+#ifdef BCMDBUS
+#include <dbus.h>
+#else
 #include <dhd_bus.h>
+#endif /* BCMDBUS */
 #include <dhd_proto.h>
 #include <dhd_dbg.h>
 #include <dhd_debug.h>
@@ -89,7 +94,7 @@
 extern void htsf_update(struct dhd_info *dhd, void *data);
 #endif
 
-int dhd_msg_level = DHD_ERROR_VAL | DHD_MSGTRACE_VAL | DHD_FWLOG_VAL;
+int dhd_msg_level = DHD_ERROR_VAL | DHD_MSGTRACE_VAL | DHD_EVENT_VAL;
 
 
 #if defined(WL_WLC_SHIM)
@@ -160,6 +165,9 @@ static int traffic_mgmt_add_dwm_filter(dhd_pub_t *dhd,
 	trf_mgmt_filter_list_t * trf_mgmt_filter_list, int len);
 #endif
 
+#ifdef HOST_FLAG
+extern int hostsleep;
+#endif
 
 /* IOVar table */
 enum {
@@ -504,6 +512,11 @@ dhd_wl_ioctl(dhd_pub_t *dhd_pub, int ifidx, wl_ioctl_t *ioc, void *buf, int len)
 	int ret = BCME_ERROR;
 	unsigned long flags;
 
+#ifdef HOST_FLAG
+	int hostsleep_set = 0;
+	int hostsleep_val = 0;
+	char *psleep = NULL;
+#endif
 #ifdef KEEPIF_ON_DEVICE_RESET
 		if (ioc->cmd == WLC_GET_VAR) {
 			dbus_config_t config;
@@ -550,9 +563,42 @@ dhd_wl_ioctl(dhd_pub_t *dhd_pub, int ifidx, wl_ioctl_t *ioc, void *buf, int len)
 			}
 		}
 #else
+#ifdef HOST_FLAG
+		/*save hostsleep val first, if ioctl success, set hostsleep to val*/
+		if (ioc->cmd == WLC_SET_VAR) {
+			psleep = strstr(buf, "hostsleep");
+			if (psleep) {
+				hostsleep_set = 1;
+				memcpy(&hostsleep_val, psleep + strlen("hostsleep") + 1, sizeof(hostsleep_val));
+				printf("###hostsleep: cmd = %d, hostsleep_val = %d, buf = %s\n",
+					ioc->cmd, hostsleep_val, (char *)buf);
+			}
+		}
+		/* block all cmd, expect hostsleep remove */
+		if (hostsleep && (!hostsleep_set || hostsleep_val)) {
+			printf("%s: block all none hostsleep clr cmd\n", __FUNCTION__);
+			dhd_os_proto_unblock(dhd_pub);
+			return BCME_EPERM;
+		} else if (hostsleep_set && hostsleep_val) {
+			printf("%s: set dhd hostsleep 1\n", __FUNCTION__);
+			hostsleep = 1;
+		}
+#endif
 		ret = dhd_prot_ioctl(dhd_pub, ifidx, ioc, buf, len);
 #endif /* defined(WL_WLC_SHIM) */
 
+#ifdef HOST_FLAG
+		if (hostsleep_set) {
+			if (hostsleep_val && ret) { // reset hostsleep if host_sleep 1 set failed
+				printf("%s: reset hostsleep\n", __FUNCTION__);
+				hostsleep = 0;
+			} else if (!hostsleep_val && !ret) { // clear hostsleep if host_sleep 0 set successfully
+				printf("%s: clear hostsleep\n", __FUNCTION__);
+				hostsleep = 0;
+			}
+		}
+#endif
+
 		if (ret && dhd_pub->up) {
 			/* Send hang event only if dhd_open() was success */
 			dhd_os_check_hang(dhd_pub, ifidx, ret);
@@ -683,10 +729,12 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 		bcopy(&int_val, arg, val_size);
 		break;
 
+#ifndef BCMDBUS
 	case IOV_GVAL(IOV_WDTICK):
 		int_val = (int32)dhd_watchdog_ms;
 		bcopy(&int_val, arg, val_size);
 		break;
+#endif
 
 	case IOV_SVAL(IOV_WDTICK):
 		if (!dhd_pub->up) {
@@ -705,6 +753,7 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 		bcmerror = dhd_dump(dhd_pub, arg, len);
 		break;
 
+#ifndef BCMDBUS
 #ifdef DHD_DEBUG
 	case IOV_GVAL(IOV_DCONSOLE_POLL):
 		int_val = (int32)dhd_console_ms;
@@ -720,6 +769,7 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 			bcmerror = dhd_bus_console_in(dhd_pub, arg, len - 1);
 		break;
 #endif /* DHD_DEBUG */
+#endif /* BCMDBUS */
 
 	case IOV_SVAL(IOV_CLEARCOUNTS):
 		dhd_pub->tx_packets = dhd_pub->rx_packets = 0;
@@ -1598,11 +1648,21 @@ dhd_ioctl(dhd_pub_t * dhd_pub, dhd_ioctl_t *ioc, void * buf, uint buflen)
 
 		/* if still not found, try bus module */
 		if (ioc->cmd == DHD_GET_VAR) {
+#ifdef BCMDBUS
+			bcmerror = dbus_iovar_op(dhd_pub->dbus, buf,
+				arg, arglen, buf, buflen, IOV_GET);
+#else
 			bcmerror = dhd_bus_iovar_op(dhd_pub, buf,
 				arg, arglen, buf, buflen, IOV_GET);
+#endif
 		} else {
+#ifdef BCMDBUS
+			bcmerror = dbus_iovar_op(dhd_pub->dbus, buf,
+				NULL, 0, arg, arglen, IOV_SET);
+#else
 			bcmerror = dhd_bus_iovar_op(dhd_pub, buf,
 				NULL, 0, arg, arglen, IOV_SET);
+#endif
 		}
 
 		break;
@@ -1840,8 +1900,8 @@ wl_show_host_event(dhd_pub_t *dhd_pub, wl_event_msg_t *event, void *event_data,
 		break;
 	case WLC_E_ESCAN_RESULT:
 	{
-		DHD_EVENT(("MACEVENT: %s %d, MAC %s, status %d \n",
-		       event_name, event_type, eabuf, (int)status));
+		//DHD_EVENT(("MACEVENT: %s %d, MAC %s, status %d \n",
+		//       event_name, event_type, eabuf, (int)status));
 	}
 		break;
 	default:
@@ -1874,16 +1934,19 @@ wl_event_process_default(wl_event_msg_t *event, struct wl_evt_pport *evt_pport)
 }
 
 int
-wl_event_process(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata, void **data_ptr, void *raw_event)
+wl_event_process(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata, uint pktlen, void **data_ptr,
+	void *raw_event)
 {
 	wl_evt_pport_t evt_pport;
 	wl_event_msg_t event;
+	bcm_event_msg_u_t evu;
 
 	/* make sure it is a BRCM event pkt and record event data */
-	int ret = wl_host_event_get_data(pktdata, &event, data_ptr);
+	int ret = wl_host_event_get_data(pktdata, pktlen, &evu);
 	if (ret != BCME_OK) {
 		return ret;
 	}
+	memcpy(&event, &evu.event, sizeof(wl_event_msg_t));
 
 	/* convert event from network order to host order */
 	wl_event_to_host_order(&event);
@@ -1894,6 +1957,7 @@ wl_event_process(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata, void **data_ptr,
 	evt_pport.pktdata = pktdata;
 	evt_pport.data_ptr = data_ptr;
 	evt_pport.raw_event = raw_event;
+	evt_pport.data_len = pktlen;
 
 #if defined(WL_WLC_SHIM) && defined(WL_WLC_SHIM_EVENTS)
 	{
@@ -1910,46 +1974,57 @@ wl_event_process(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata, void **data_ptr,
 
 /* Check whether packet is a BRCM event pkt. If it is, record event data. */
 int
-wl_host_event_get_data(void *pktdata, wl_event_msg_t *event, void **data_ptr)
+wl_host_event_get_data(void *pktdata, uint pktlen, bcm_event_msg_u_t *evu)
 {
-	bcm_event_t *pvt_data = (bcm_event_t *)pktdata;
-
-	if (bcmp(BRCM_OUI, &pvt_data->bcm_hdr.oui[0], DOT11_OUI_LEN)) {
-		DHD_ERROR(("%s: mismatched OUI, bailing\n", __FUNCTION__));
-		return BCME_ERROR;
-	}
+	int ret;
 
-	/* BRCM event pkt may be unaligned - use xxx_ua to load user_subtype. */
-	if (ntoh16_ua((void *)&pvt_data->bcm_hdr.usr_subtype) != BCMILCP_BCM_SUBTYPE_EVENT) {
-		DHD_ERROR(("%s: mismatched subtype, bailing\n", __FUNCTION__));
-		return BCME_ERROR;
+	ret = is_wlc_event_frame(pktdata, pktlen, 0, evu);
+	if (ret != BCME_OK) {
+		DHD_ERROR(("%s: Invalid event frame, err = %d\n",
+			__FUNCTION__, ret));
 	}
-
-	*data_ptr = &pvt_data[1];
-
-	/* memcpy since BRCM event pkt may be unaligned. */
-	memcpy(event, &pvt_data->event, sizeof(wl_event_msg_t));
-
-	return BCME_OK;
+	return ret;
 }
 
 int
-wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
+wl_process_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata, uint pktlen,
 	wl_event_msg_t *event, void **data_ptr, void *raw_event)
 {
-	bcm_event_t *pvt_data;
+	bcm_event_t *pvt_data = (bcm_event_t *)pktdata;
+	bcm_event_msg_u_t evu;
 	uint8 *event_data;
 	uint32 type, status, datalen, reason;
 	uint16 flags;
-	int evlen;
-
-	/* make sure it is a BRCM event pkt and record event data */
-	int ret = wl_host_event_get_data(pktdata, event, data_ptr);
+	uint evlen;
+	int ret;
+	uint16 usr_subtype;
+	ret = wl_host_event_get_data(pktdata, pktlen, &evu);
 	if (ret != BCME_OK) {
 		return ret;
 	}
+	usr_subtype = ntoh16_ua((void *)&pvt_data->bcm_hdr.usr_subtype);
+	switch (usr_subtype) {
+	case BCMILCP_BCM_SUBTYPE_EVENT:
+		memcpy(event, &evu.event, sizeof(wl_event_msg_t));
+		*data_ptr = &pvt_data[1];
+		break;
+	case BCMILCP_BCM_SUBTYPE_DNGLEVENT:
+#ifdef HEALTH_CHECK
+	/* If it is a DNGL event process it first */
+	if (dngl_host_event(dhd_pub, pktdata, &evu.dngl_event, pktlen) == BCME_OK) {
+			/*
+			* Return error purposely to prevent DNGL event being processed
+			* as BRCM event
+			*/
+			return BCME_ERROR;
+	}
+#endif /* HEALTH_CHECK */
+		return BCME_NOTFOUND;
+	default:
+		return BCME_NOTFOUND;
+	}
 
-	pvt_data = (bcm_event_t *)pktdata;
+	/* start wl_event_msg process */
 	event_data = *data_ptr;
 
 	type = ntoh32_ua((void *)&event->event_type);
@@ -1957,8 +2032,8 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 	status = ntoh32_ua((void *)&event->status);
 	reason = ntoh32_ua((void *)&event->reason);
 	datalen = ntoh32_ua((void *)&event->datalen);
-	evlen = datalen + sizeof(bcm_event_t);
 
+	evlen = datalen + sizeof(bcm_event_t);
 	switch (type) {
 #ifdef PROP_TXSTATUS
 	case WLC_E_FIFO_CREDIT_MAP:
@@ -2096,7 +2171,7 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 			dhd_ifname2idx(dhd_pub->info, event->ifname),
 			&event->addr.octet);
 		break;
-#if defined(DHD_FW_COREDUMP)
+#if !defined(BCMDBUS) && defined(DHD_FW_COREDUMP)
 	case WLC_E_PSM_WATCHDOG:
 		DHD_ERROR(("%s: WLC_E_PSM_WATCHDOG event received : \n", __FUNCTION__));
 		if (dhd_socram_dump(dhd_pub->bus) != BCME_OK) {
@@ -2183,6 +2258,14 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 	return (BCME_OK);
 }
 
+int
+wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata, uint pktlen,
+	wl_event_msg_t *event, void **data_ptr, void *raw_event)
+{
+	return wl_process_host_event(dhd_pub, ifidx, pktdata, pktlen, event, data_ptr,
+		raw_event);
+}
+
 void
 dhd_print_buf(void *pbuf, int len, int bytes_per_line)
 {
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_custom_gpio.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_custom_gpio.c
index ca3c51197d6d..a5f98f6c0d7e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_custom_gpio.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_custom_gpio.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Customer code to add GPIO control during WLAN start/stop
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_dbg.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_dbg.h
index 77b64aa7f614..410bbc62b067 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_dbg.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_dbg.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Debug/trace/assert driver definitions for Dongle Host Driver.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug.c
index daa0c4deb44c..1c08830dfe33 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * DHD debugability support
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug.h
index f2e191c4ff33..0d0e860fda19 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * DHD debugability header file
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug_linux.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug_linux.c
index 11f0c4ad4ba5..3940f7080a9d 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_debug_linux.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * DHD debugability Linux os layer
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_flowring.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_flowring.c
index 5fb587d2b176..24d41890ac34 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_flowring.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_flowring.c
@@ -1,10 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /**
  * @file Broadcom Dongle Host Driver (DHD), Flow ring specific code at top level
  *
  * Flow rings are transmit traffic (=propagating towards antenna) related entities
  *
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_flowring.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_flowring.h
index b17dbbe69473..24e4b88a87b0 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_flowring.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_flowring.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /**
  * @file Header file describing the flow rings DHD interfaces.
  *
@@ -6,7 +7,7 @@
  * Provides type definitions and function prototypes used to create, delete and manage flow rings at
  * high level.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_gpio.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_gpio.c
index f7c1bbd66197..32f0321dd840 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_gpio.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_gpio.c
@@ -1,4 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
+/* SPDX-License-Identifier: GPL-2.0 */
 
 #include <osl.h>
 #include <dhd_linux.h>
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_ip.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_ip.c
index d0b0b1f2c5bb..96b1a2fbca01 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_ip.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_ip.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * IP Packet Parser Module.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: dhd_ip.c 575241 2015-07-29 09:17:04Z $
+ * $Id: dhd_ip.c 709309 2019-01-17 09:04:00Z $
  */
 #include <typedefs.h>
 #include <osl.h>
@@ -289,10 +290,16 @@ static void _tdata_psh_info_pool_deinit(dhd_pub_t *dhdp,
 }
 #endif /* BCMSDIO */
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 static void dhd_tcpack_send(struct timer_list *t)
 {
-	tcpack_sup_module_t *tcpack_sup_mod;
 	tcpack_info_t *cur_tbl = from_timer(cur_tbl, t, timer);
+#else
+static void dhd_tcpack_send(ulong data)
+{
+	tcpack_info_t *cur_tbl = (tcpack_info_t *)data;
+#endif
+	tcpack_sup_module_t *tcpack_sup_mod;
 	dhd_pub_t *dhdp;
 	int ifidx;
 	void* pkt;
@@ -418,9 +425,14 @@ int dhd_tcpack_suppress_set(dhd_pub_t *dhdp, uint8 mode)
 		for (i = 0; i < TCPACK_INFO_MAXNUM; i++)
 		{
 			tcpack_sup_mod->tcpack_info_tbl[i].dhdp = dhdp;
-			timer_setup(&tcpack_sup_mod->tcpack_info_tbl[i].timer,
-				    dhd_tcpack_send,
-				    0);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
+			timer_setup((struct timer_list *)&tcpack_sup_mod->tcpack_info_tbl[i].timer, dhd_tcpack_send, 0);
+#else
+			init_timer(&tcpack_sup_mod->tcpack_info_tbl[i].timer);
+			tcpack_sup_mod->tcpack_info_tbl[i].timer.data =
+				(ulong)&tcpack_sup_mod->tcpack_info_tbl[i];
+			tcpack_sup_mod->tcpack_info_tbl[i].timer.function = dhd_tcpack_send;
+#endif
 		}
 	}
 
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_ip.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_ip.h
index 9a22c8ca1a7b..0e79bdb0ac9a 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_ip.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_ip.h
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Header file describing the common ip parser function.
  *
  * Provides type definitions and function prototypes used to parse ip packet.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux.c
index 961b93333e50..86d1f8c06333 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux.c
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Dongle Host Driver (DHD), Linux-specific network interface
  * Basically selected code segments from usb-cdc.c and usb-rndis.c
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -25,7 +26,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: dhd_linux.c 674559 2017-10-27 03:07:31Z $
+ * $Id: dhd_linux.c 715966 2019-05-30 02:36:59Z $
  */
 
 #include <typedefs.h>
@@ -53,12 +54,15 @@
 #include <linux/ip.h>
 #include <linux/reboot.h>
 #include <linux/notifier.h>
-#include <uapi/linux/sched/types.h>
 #include <net/addrconf.h>
 #ifdef ENABLE_ADAPTIVE_SCHED
 #include <linux/cpufreq.h>
 #endif /* ENABLE_ADAPTIVE_SCHED */
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
+#include <uapi/linux/sched/types.h>
+#include <linux/sched/signal.h>
+#endif
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
 
@@ -128,6 +132,7 @@ void dhd_page_corrupt_cb(void *handle, void *addr_corrupt, size_t len);
 extern void register_page_corrupt_cb(page_corrupt_cb_t cb, void* handle);
 #endif /* DHD_DEBUG_PAGEALLOC */
 
+static void dhd_tcp_dump(char *ifname, uint8 *pktdata, bool tx);
 
 #if defined(DHD_LB)
 /* Dynamic CPU selection for load balancing */
@@ -136,6 +141,9 @@ extern void register_page_corrupt_cb(page_corrupt_cb_t cb, void* handle);
 #include <linux/notifier.h>
 #include <linux/workqueue.h>
 #include <asm/atomic.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+#include <linux/cpuhotplug.h>
+#endif
 
 #if !defined(DHD_LB_PRIMARY_CPUS)
 #define DHD_LB_PRIMARY_CPUS     0x0 /* Big CPU coreids mask */
@@ -145,6 +153,10 @@ extern void register_page_corrupt_cb(page_corrupt_cb_t cb, void* handle);
 #define DHD_LB_SECONDARY_CPUS   0xFE /* Little CPU coreids mask */
 #endif
 
+#if (NR_CPUS > 8)
+#undef NR_CPUS
+#define NR_CPUS 8
+#endif
 #define HIST_BIN_SIZE	8
 
 #if defined(DHD_LB_RXP)
@@ -232,6 +244,10 @@ static u32 vendor_oui = CONFIG_DHD_SET_RANDOM_MAC_VAL;
 
 
 
+#ifdef HOST_FLAG
+int hostsleep = 0;
+#endif
+
 const uint8 wme_fifo2ac[] = { 0, 1, 2, 3, 1, 1 };
 const uint8 prio2fifo[8] = { 1, 0, 0, 1, 2, 2, 3, 3 };
 #define WME_PRIO2AC(prio)  wme_fifo2ac[prio2fifo[(prio)]]
@@ -277,7 +293,18 @@ static void dhd_hang_process(void *dhd_info, void *event_data, u8 event);
 MODULE_LICENSE("GPL and additional rights");
 #endif /* LinuxVer */
 
+#ifdef BCMDBUS
+#include <dbus.h>
+extern int dhd_bus_init(dhd_pub_t *dhdp, bool enforce_mutex);
+extern void dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex);
+extern void dhd_bus_unregister(void);
+
+#ifdef BCMSDIO
+extern bool dhd_bus_dpc(struct dhd_bus *bus);
+#endif /* BCMSDIO */
+#else
 #include <dhd_bus.h>
+#endif /* BCMDBUS */
 
 #ifdef DHD_ULP
 #include <dhd_ulp.h>
@@ -480,6 +507,10 @@ typedef struct dhd_info {
 #ifdef PROP_TXSTATUS
 	spinlock_t	wlfc_spinlock;
 
+#ifdef BCMDBUS
+	ulong		wlfc_lock_flags;
+	ulong		wlfc_pub_lock_flags;
+#endif
 #endif /* PROP_TXSTATUS */
 #ifdef WLMEDIA_HTSF
 	htsf_t  htsf;
@@ -495,10 +526,14 @@ typedef struct dhd_info {
 	spinlock_t	sdlock;
 	spinlock_t	txqlock;
 	spinlock_t	dhd_lock;
+#ifdef BCMDBUS
+	ulong		txqlock_flags;
+#else
 
 	struct semaphore sdsem;
 	tsk_ctl_t	thr_dpc_ctl;
 	tsk_ctl_t	thr_wdt_ctl;
+#endif /* BCMDBUS */
 
 	tsk_ctl_t	thr_rxf_ctl;
 	spinlock_t	rxf_lock;
@@ -510,6 +545,8 @@ typedef struct dhd_info {
 	struct wake_lock wl_rxwake; /* Wifi rx wakelock */
 	struct wake_lock wl_ctrlwake; /* Wifi ctrl wakelock */
 	struct wake_lock wl_wdwake; /* Wifi wd wakelock */
+	struct wake_lock wl_evtwake; /* Wifi event wakelock */
+	struct wake_lock wl_txflwake; /* Wifi tx flow wakelock*/
 #ifdef BCMPCIE_OOB_HOST_WAKE
 	struct wake_lock wl_intrwake; /* Host wakeup wakelock */
 #endif /* BCMPCIE_OOB_HOST_WAKE */
@@ -591,7 +628,11 @@ typedef struct dhd_info {
 	cpumask_var_t cpumask_primary, cpumask_secondary; /* configuration */
 	cpumask_var_t cpumask_primary_new, cpumask_secondary_new; /* temp */
 
+#if (LINUX_VERSION_CODE  >= KERNEL_VERSION(4, 10, 0))
+	struct hlist_node node_online;
+#else
 	struct notifier_block cpu_notifier;
+#endif
 
 	/* Tasklet to handle Tx Completion packet freeing */
 	struct tasklet_struct tx_compl_tasklet;
@@ -664,6 +705,10 @@ typedef struct dhd_info {
 #endif /* DHD_LB */
 
 #if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
+#if defined(BCMDBUS)
+	struct task_struct *fw_download_task;
+	struct semaphore fw_download_lock;
+#endif /* BCMDBUS */
 #endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
 	struct net_device *monitor_dev; /* monitor pseudo device */
 	uint monitor_type;   /* monitor pseudo device */
@@ -726,7 +771,7 @@ static void dhd_update_rx_pkt_chainable_state(dhd_pub_t* dhdp, uint32 idx);
 #endif /* DHD_WET || DHD_MCAST_REGEN || DHD_L2_FILTER */
 
 /* Error bits */
-module_param(dhd_msg_level, int, 0);
+module_param(dhd_msg_level, int, 0664);
 
 #ifdef ARP_OFFLOAD_SUPPORT
 /* ARP offload enable */
@@ -760,8 +805,7 @@ uint dhd_console_ms = 0;
 module_param(dhd_console_ms, uint, 0644);
 #endif /* defined(DHD_DEBUG) */
 
-//uint dhd_slpauto = TRUE;
-uint dhd_slpauto = FALSE;
+uint dhd_slpauto = TRUE;
 module_param(dhd_slpauto, uint, 0);
 
 #ifdef PKT_FILTER_SUPPORT
@@ -995,6 +1039,31 @@ void dhd_select_cpu_candidacy(dhd_info_t *dhd)
 	return;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+int dhd_cpuhp_online(unsigned int cpu, struct hlist_node *node)
+{
+	dhd_info_t *dhd = hlist_entry_safe(node, dhd_info_t,
+				node_online);
+
+	DHD_INFO(("%s: cpu=%d\n", __func__, cpu));
+	DHD_LB_STATS_INCR(dhd->cpu_online_cnt[cpu]);
+	cpumask_set_cpu(cpu, dhd->cpumask_curr_avail);
+	dhd_select_cpu_candidacy(dhd);
+	return 0;
+}
+
+int dhd_cpuhp_dead(unsigned int cpu, struct hlist_node *node)
+{
+	dhd_info_t *dhd = hlist_entry_safe(node, dhd_info_t,
+				node_online);
+
+	DHD_INFO(("%s: cpu=%d\n", __func__, cpu));
+	DHD_LB_STATS_INCR(dhd->cpu_offline_cnt[cpu]);
+	cpumask_clear_cpu(cpu, dhd->cpumask_curr_avail);
+	dhd_select_cpu_candidacy(dhd);
+	return 0;
+}
+#else
 /*
  * Function to handle CPU Hotplug notifications.
  * One of the task it does is to trigger the CPU Candidacy algorithm
@@ -1027,6 +1096,7 @@ dhd_cpu_callback(struct notifier_block *nfb, unsigned long action, void *hcpu)
 
 	return NOTIFY_OK;
 }
+#endif
 
 #if defined(DHD_LB_STATS)
 void dhd_lb_stats_init(dhd_pub_t *dhdp)
@@ -1343,9 +1413,11 @@ module_param(dhd_pktgen_len, uint, 0);
 
 
 
+#ifndef BCMDBUS
 /* Allow delayed firmware download for debug purpose */
 int allow_delay_fwdl = FALSE;
 module_param(allow_delay_fwdl, int, 0);
+#endif /* !BCMDBUS */
 
 /* Flag to indicate whether FW download has succeeded */
 bool dhd_fw_downloaded = FALSE;
@@ -1379,7 +1451,9 @@ int dhd_monitor_uninit(void);
 struct iw_statistics *dhd_get_wireless_stats(struct net_device *dev);
 #endif /* defined(WL_WIRELESS_EXT) */
 
+#ifndef BCMDBUS
 static void dhd_dpc(ulong data);
+#endif
 /* forward decl */
 extern int dhd_wait_pend8021x(struct net_device *dev);
 void dhd_os_wd_timer_extend(void *bus, bool extend);
@@ -1391,8 +1465,11 @@ void dhd_os_wd_timer_extend(void *bus, bool extend);
 static int dhd_toe_get(dhd_info_t *dhd, int idx, uint32 *toe_ol);
 static int dhd_toe_set(dhd_info_t *dhd, int idx, uint32 toe_ol);
 #endif /* TOE */
+#ifdef BCMDBUS
+int dhd_dbus_txdata(dhd_pub_t *dhdp, void *pktbuf);
+#endif
 
-static int dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
+static int dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata, uint16 pktlen,
                              wl_event_msg_t *event_ptr, void **data_ptr);
 
 #if defined(CONFIG_PM_SLEEP)
@@ -2891,6 +2968,415 @@ dhd_bssidx2bssid(dhd_pub_t *dhdp, int idx)
 	return NULL;
 }
 
+#ifdef BCMDBUS
+#define DBUS_NRXQ	50
+#define DBUS_NTXQ	100
+
+static void
+dhd_dbus_send_complete(void *handle, void *info, int status)
+{
+	dhd_info_t *dhd = (dhd_info_t *)handle;
+	void *pkt = info;
+
+	if ((dhd == NULL) || (pkt == NULL))
+		return;
+
+	if (status == DBUS_OK) {
+		dhd->pub.dstats.tx_packets++;
+	} else {
+		DHD_ERROR(("TX error=%d\n", status));
+		dhd->pub.dstats.tx_errors++;
+	}
+#ifdef PROP_TXSTATUS
+	if (DHD_PKTTAG_WLFCPKT(PKTTAG(pkt)) &&
+		(dhd_wlfc_txcomplete(&dhd->pub, pkt, status == 0) != WLFC_UNSUPPORTED)) {
+		return;
+	}
+#endif /* PROP_TXSTATUS */
+	PKTFREE(dhd->pub.osh, pkt, TRUE);
+}
+
+static void
+dhd_dbus_recv_pkt(void *handle, void *pkt)
+{
+	uchar reorder_info_buf[WLHOST_REORDERDATA_TOTLEN];
+	uint reorder_info_len;
+	uint pkt_count;
+	dhd_info_t *dhd = (dhd_info_t *)handle;
+	int ifidx = 0;
+
+	if (dhd == NULL)
+		return;
+
+	/* If the protocol uses a data header, check and remove it */
+	if (dhd_prot_hdrpull(&dhd->pub, &ifidx, pkt, reorder_info_buf,
+		&reorder_info_len) != 0) {
+		DHD_ERROR(("rx protocol error\n"));
+		PKTFREE(dhd->pub.osh, pkt, FALSE);
+		dhd->pub.rx_errors++;
+		return;
+	}
+
+	if (reorder_info_len) {
+		/* Reordering info from the firmware */
+		dhd_process_pkt_reorder_info(&dhd->pub, reorder_info_buf, reorder_info_len,
+			&pkt, &pkt_count);
+		if (pkt_count == 0)
+			return;
+	}
+	else {
+		pkt_count = 1;
+	}
+	dhd_rx_frame(&dhd->pub, ifidx, pkt, pkt_count, 0);
+}
+
+static void
+dhd_dbus_recv_buf(void *handle, uint8 *buf, int len)
+{
+	dhd_info_t *dhd = (dhd_info_t *)handle;
+	void *pkt;
+
+	if (dhd == NULL)
+		return;
+
+	if ((pkt = PKTGET(dhd->pub.osh, len, FALSE)) == NULL) {
+		DHD_ERROR(("PKTGET (rx) failed=%d\n", len));
+		return;
+	}
+
+	bcopy(buf, PKTDATA(dhd->pub.osh, pkt), len);
+	dhd_dbus_recv_pkt(dhd, pkt);
+}
+
+static void
+dhd_dbus_txflowcontrol(void *handle, bool onoff)
+{
+	dhd_info_t *dhd = (dhd_info_t *)handle;
+	bool wlfc_enabled = FALSE;
+
+	if (dhd == NULL)
+		return;
+
+#ifdef PROP_TXSTATUS
+	wlfc_enabled = (dhd_wlfc_flowcontrol(&dhd->pub, onoff, !onoff) != WLFC_UNSUPPORTED);
+#endif
+
+	if (!wlfc_enabled) {
+		dhd_txflowcontrol(&dhd->pub, ALL_INTERFACES, onoff);
+	}
+}
+
+static void
+dhd_dbus_errhandler(void *handle, int err)
+{
+}
+
+static void
+dhd_dbus_ctl_complete(void *handle, int type, int status)
+{
+	dhd_info_t *dhd = (dhd_info_t *)handle;
+
+	if (dhd == NULL)
+		return;
+
+	if (type == DBUS_CBCTL_READ) {
+		if (status == DBUS_OK)
+			dhd->pub.rx_ctlpkts++;
+		else
+			dhd->pub.rx_ctlerrs++;
+	} else if (type == DBUS_CBCTL_WRITE) {
+		if (status == DBUS_OK)
+			dhd->pub.tx_ctlpkts++;
+		else
+			dhd->pub.tx_ctlerrs++;
+	}
+
+	dhd_prot_ctl_complete(&dhd->pub);
+}
+
+static void
+dhd_dbus_state_change(void *handle, int state)
+{
+	dhd_info_t *dhd = (dhd_info_t *)handle;
+
+	if (dhd == NULL)
+		return;
+
+	switch (state) {
+
+		case DBUS_STATE_DL_NEEDED:
+#if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
+#if defined(BCMDBUS)
+			DHD_TRACE(("%s: firmware request\n", __FUNCTION__));
+			up(&dhd->fw_download_lock);
+#endif /* BCMDBUS */
+#else
+			DHD_ERROR(("%s: firmware request cannot be handled\n", __FUNCTION__));
+#endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
+			break;
+		case DBUS_STATE_DOWN:
+			DHD_TRACE(("%s: DBUS is down\n", __FUNCTION__));
+			dhd->pub.busstate = DHD_BUS_DOWN;
+			break;
+		case DBUS_STATE_UP:
+			DHD_TRACE(("%s: DBUS is up\n", __FUNCTION__));
+			dhd->pub.busstate = DHD_BUS_DATA;
+			break;
+		default:
+			break;
+	}
+
+	DHD_TRACE(("%s: DBUS current state=%d\n", __FUNCTION__, state));
+}
+
+static void *
+dhd_dbus_pktget(void *handle, uint len, bool send)
+{
+	dhd_info_t *dhd = (dhd_info_t *)handle;
+	void *p = NULL;
+
+	if (dhd == NULL)
+		return NULL;
+
+	if (send == TRUE) {
+		dhd_os_sdlock_txq(&dhd->pub);
+		p = PKTGET(dhd->pub.osh, len, TRUE);
+		dhd_os_sdunlock_txq(&dhd->pub);
+	} else {
+		dhd_os_sdlock_rxq(&dhd->pub);
+		p = PKTGET(dhd->pub.osh, len, FALSE);
+		dhd_os_sdunlock_rxq(&dhd->pub);
+	}
+
+	return p;
+}
+
+static void
+dhd_dbus_pktfree(void *handle, void *p, bool send)
+{
+	dhd_info_t *dhd = (dhd_info_t *)handle;
+
+	if (dhd == NULL)
+		return;
+
+	if (send == TRUE) {
+#ifdef PROP_TXSTATUS
+		if (DHD_PKTTAG_WLFCPKT(PKTTAG(p)) &&
+			(dhd_wlfc_txcomplete(&dhd->pub, p, FALSE) != WLFC_UNSUPPORTED)) {
+			return;
+		}
+#endif /* PROP_TXSTATUS */
+
+		dhd_os_sdlock_txq(&dhd->pub);
+		PKTFREE(dhd->pub.osh, p, TRUE);
+		dhd_os_sdunlock_txq(&dhd->pub);
+	} else {
+		dhd_os_sdlock_rxq(&dhd->pub);
+		PKTFREE(dhd->pub.osh, p, FALSE);
+		dhd_os_sdunlock_rxq(&dhd->pub);
+	}
+}
+
+#ifdef BCM_FD_AGGR
+
+static void
+dbus_rpcth_tx_complete(void *ctx, void *pktbuf, int status)
+{
+	dhd_info_t *dhd = (dhd_info_t *)ctx;
+	void *tmp;
+
+	while (pktbuf && dhd) {
+		tmp = PKTNEXT(dhd->pub.osh, pktbuf);
+		PKTSETNEXT(dhd->pub.osh, pktbuf, NULL);
+		dhd_dbus_send_complete(ctx, pktbuf, status);
+		pktbuf = tmp;
+	}
+}
+static void
+dbus_rpcth_rx_pkt(void *context, rpc_buf_t *rpc_buf)
+{
+	dhd_dbus_recv_pkt(context, rpc_buf);
+}
+
+static void
+dbus_rpcth_rx_aggrpkt(void *context, void *rpc_buf)
+{
+	dhd_info_t *dhd = (dhd_info_t *)context;
+
+	if (dhd == NULL)
+		return;
+
+	/* all the de-aggregated packets are delivered back to function dbus_rpcth_rx_pkt()
+	* as cloned packets
+	*/
+	bcm_rpc_dbus_recv_aggrpkt(dhd->rpc_th, rpc_buf,
+		bcm_rpc_buf_len_get(dhd->rpc_th, rpc_buf));
+
+	/* free the original packet */
+	dhd_dbus_pktfree(context, rpc_buf, FALSE);
+}
+
+static void
+dbus_rpcth_rx_aggrbuf(void *context, uint8 *buf, int len)
+{
+	dhd_info_t *dhd = (dhd_info_t *)context;
+
+	if (dhd == NULL)
+		return;
+
+	if (dhd->fdaggr & BCM_FDAGGR_D2H_ENABLED) {
+		bcm_rpc_dbus_recv_aggrbuf(dhd->rpc_th, buf, len);
+	}
+	else {
+		dhd_dbus_recv_buf(context, buf, len);
+	}
+
+}
+
+static void
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
+dhd_rpcth_watchdog(struct timer_list *t)
+{
+	dhd_info_t *dhd = from_timer(dhd, t, rpcth_timer);
+#else
+dhd_rpcth_watchdog(ulong data)
+{
+	dhd_info_t *dhd = (dhd_info_t *)data;
+#endif
+
+	if (dhd->pub.dongle_reset) {
+		return;
+	}
+
+	dhd->rpcth_timer_active = FALSE;
+	/* release packets in the aggregation queue */
+	bcm_rpc_tp_watchdog(dhd->rpc_th);
+}
+
+static int
+dhd_fdaggr_ioctl(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf, int len)
+{
+	int bcmerror = 0;
+	void *rpc_th;
+
+	rpc_th = dhd_pub->info->rpc_th;
+
+	if (!strcmp("rpc_agg", ioc->buf)) {
+		uint32 rpc_agg;
+		uint32 rpc_agg_host;
+		uint32 rpc_agg_dngl;
+
+		if (ioc->set) {
+			memcpy(&rpc_agg, ioc->buf + strlen("rpc_agg") + 1, sizeof(uint32));
+			rpc_agg_host = rpc_agg & BCM_RPC_TP_HOST_AGG_MASK;
+			if (rpc_agg_host)
+				bcm_rpc_tp_agg_set(rpc_th, rpc_agg_host, TRUE);
+			else
+				bcm_rpc_tp_agg_set(rpc_th, BCM_RPC_TP_HOST_AGG_MASK, FALSE);
+			bcmerror = dhd_wl_ioctl(dhd_pub, ifindex, ioc, buf, len);
+			if (bcmerror < 0) {
+				DHD_ERROR(("usb aggregation not supported\n"));
+			} else {
+				dhd_pub->info->fdaggr = 0;
+				if (rpc_agg & BCM_RPC_TP_HOST_AGG_MASK)
+					dhd_pub->info->fdaggr |= BCM_FDAGGR_H2D_ENABLED;
+				if (rpc_agg & BCM_RPC_TP_DNGL_AGG_MASK)
+					dhd_pub->info->fdaggr |= BCM_FDAGGR_D2H_ENABLED;
+			}
+		} else {
+			rpc_agg_host = bcm_rpc_tp_agg_get(rpc_th);
+			bcmerror = dhd_wl_ioctl(dhd_pub, ifindex, ioc, buf, len);
+			if (!bcmerror) {
+				memcpy(&rpc_agg_dngl, buf, sizeof(uint32));
+				rpc_agg = (rpc_agg_host & BCM_RPC_TP_HOST_AGG_MASK) |
+					(rpc_agg_dngl & BCM_RPC_TP_DNGL_AGG_MASK);
+				memcpy(buf, &rpc_agg, sizeof(uint32));
+			}
+		}
+	} else if (!strcmp("rpc_host_agglimit", ioc->buf)) {
+		uint8 sf;
+		uint16 bytes;
+		uint32 agglimit;
+
+		if (ioc->set) {
+			memcpy(&agglimit, ioc->buf + strlen("rpc_host_agglimit") + 1,
+				sizeof(uint32));
+			sf = agglimit >> 16;
+			bytes = agglimit & 0xFFFF;
+			bcm_rpc_tp_agg_limit_set(rpc_th, sf, bytes);
+		} else {
+			bcm_rpc_tp_agg_limit_get(rpc_th, &sf, &bytes);
+			agglimit = (uint32)((sf << 16) + bytes);
+			memcpy(buf, &agglimit, sizeof(uint32));
+		}
+
+	} else {
+		bcmerror = dhd_wl_ioctl(dhd_pub, ifindex, ioc, buf, len);
+	}
+	return bcmerror;
+}
+#endif /* BCM_FD_AGGR */
+
+static dbus_callbacks_t dhd_dbus_cbs = {
+#ifdef BCM_FD_AGGR
+	dbus_rpcth_tx_complete,
+	dbus_rpcth_rx_aggrbuf,
+	dbus_rpcth_rx_aggrpkt,
+#else
+	dhd_dbus_send_complete,
+	dhd_dbus_recv_buf,
+	dhd_dbus_recv_pkt,
+#endif
+	dhd_dbus_txflowcontrol,
+	dhd_dbus_errhandler,
+	dhd_dbus_ctl_complete,
+	dhd_dbus_state_change,
+	dhd_dbus_pktget,
+	dhd_dbus_pktfree
+};
+
+void
+dhd_bus_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
+{
+	bcm_bprintf(strbuf, "Bus USB\n");
+}
+
+void
+dhd_bus_clearcounts(dhd_pub_t *dhdp)
+{
+}
+
+bool
+dhd_bus_dpc(struct dhd_bus *bus)
+{
+	return FALSE;
+}
+
+int
+dhd_dbus_txdata(dhd_pub_t *dhdp, void *pktbuf)
+{
+
+	if (dhdp->txoff)
+		return BCME_EPERM;
+#ifdef BCM_FD_AGGR
+	if (((dhd_info_t *)(dhdp->info))->fdaggr & BCM_FDAGGR_H2D_ENABLED)
+
+	{
+		dhd_info_t *dhd;
+		int ret;
+		dhd = (dhd_info_t *)(dhdp->info);
+		ret = bcm_rpc_tp_buf_send(dhd->rpc_th, pktbuf);
+		if (dhd->rpcth_timer_active == FALSE) {
+			dhd->rpcth_timer_active = TRUE;
+			mod_timer(&dhd->rpcth_timer, jiffies + BCM_RPC_TP_HOST_TMOUT * HZ / 1000);
+		}
+		return ret;
+	} else
+#endif /* BCM_FD_AGGR */
+	return dbus_send_txdata(dhdp->dbus, pktbuf);
+}
+
+#endif /* BCMDBUS */
 
 static void
 _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
@@ -3458,7 +3944,11 @@ dhd_os_wlfc_block(dhd_pub_t *pub)
 {
 	dhd_info_t *di = (dhd_info_t *)(pub->info);
 	ASSERT(di != NULL);
+#ifdef BCMDBUS
+	spin_lock_irqsave(&di->wlfc_spinlock, di->wlfc_lock_flags);
+#else
 	spin_lock_bh(&di->wlfc_spinlock);
+#endif
 	return 1;
 }
 
@@ -3468,7 +3958,11 @@ dhd_os_wlfc_unblock(dhd_pub_t *pub)
 	dhd_info_t *di = (dhd_info_t *)(pub->info);
 
 	ASSERT(di != NULL);
+#ifdef BCMDBUS
+	spin_unlock_irqrestore(&di->wlfc_spinlock, di->wlfc_lock_flags);
+#else
 	spin_unlock_bh(&di->wlfc_spinlock);
+#endif
 	return 1;
 }
 
@@ -3643,6 +4137,7 @@ __dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 #ifdef DHD_DHCP_DUMP
 		if (ntoh16(eh->ether_type) == ETHER_TYPE_IP) {
 			dhd_dhcp_dump(pktdata, TRUE);
+			dhd_tcp_dump(dhd_ifname(dhdp, ifidx), pktdata, TRUE);
 		}
 #endif /* DHD_DHCP_DUMP */
 	} else {
@@ -3714,6 +4209,19 @@ __dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 #if defined(DHD_8021X_DUMP)
 	dhd_tx_dump(dhdp->osh, pktbuf);
 #endif
+#ifdef BCMDBUS
+#ifdef PROP_TXSTATUS
+	if (dhd_wlfc_commit_packets(dhdp, (f_commitpkt_t)dhd_dbus_txdata,
+		dhdp, pktbuf, TRUE) == WLFC_UNSUPPORTED) {
+		/* non-proptxstatus way */
+		ret = dhd_dbus_txdata(dhdp, pktbuf);
+	}
+#else
+	ret = dhd_dbus_txdata(dhdp, pktbuf);
+#endif /* PROP_TXSTATUS */
+	if (ret)
+		PKTCFREE(dhdp->osh, pktbuf, TRUE);
+#else
 #ifdef PROP_TXSTATUS
 	{
 		if (dhd_wlfc_commit_packets(dhdp, (f_commitpkt_t)dhd_bus_txdata,
@@ -3734,6 +4242,8 @@ __dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 #endif /* BCMPCIE */
 #endif /* PROP_TXSTATUS */
 
+#endif /* BCMDBUS */
+
 	return ret;
 }
 
@@ -4028,6 +4538,15 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 		}
 	}
 #endif /* DHDTCPACK_SUPPRESS */
+#ifdef HOST_FLAG
+	if (hostsleep) {
+		printf("%s (%d): hostsleep = %d, tx_dropped = %lu\n",__FUNCTION__, __LINE__,
+			hostsleep, ifp->stats.tx_dropped);
+		PKTFREE(dhd->pub.osh, pktbuf, TRUE);
+		ret = BCME_TXFAIL;
+		goto done;
+	}
+#endif
 
 	ret = __dhd_sendpkt(&dhd->pub, ifidx, pktbuf);
 
@@ -4457,6 +4976,7 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 #ifdef DHD_DHCP_DUMP
 		if (protocol != ETHER_TYPE_BRCM && protocol == ETHER_TYPE_IP) {
 			dhd_dhcp_dump(dump_data, FALSE);
+			dhd_tcp_dump(dhd_ifname(dhdp, ifidx), dump_data, FALSE);
 		}
 #endif /* DHD_DHCP_DUMP */
 #if defined(DHD_RX_DUMP)
@@ -4506,6 +5026,7 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 
 		/* Process special event packets and then discard them */
 		memset(&event, 0, sizeof(event));
+
 		if (ntoh16(skb->protocol) == ETHER_TYPE_BRCM) {
 			dhd_wl_host_event(dhd, &ifidx,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
@@ -4513,8 +5034,7 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 #else
 			skb->mac.raw,
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22) */
-			&event,
-			&data);
+			len, &event, &data);
 
 			wl_event_to_host_order(&event);
 			if (!tout_ctrl)
@@ -4533,7 +5053,7 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 			}
 
 			if (numpkt != 1) {
-				DHD_INFO(("%s: Got BRCM event packet in a chained packet.\n",
+				DHD_ERROR(("%s: Got BRCM event packet in a chained packet.\n",
 				__FUNCTION__));
 			}
 #ifdef DHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT
@@ -4571,6 +5091,12 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 #endif /* PROP_TXSTATUS */
 		}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
+		/* It is useless for network stack any more, and we do not use it */
+		if (ifp->net)
+			ifp->net->last_rx = jiffies;
+#endif
+
 		if (ntoh16(skb->protocol) != ETHER_TYPE_BRCM) {
 			dhdp->dstats.rx_bytes += skb->len;
 			dhdp->rx_packets++; /* Local count */
@@ -4702,6 +5228,7 @@ dhd_get_stats(struct net_device *net)
 	return &ifp->stats;
 }
 
+#ifndef BCMDBUS
 static int
 dhd_watchdog_thread(void *data)
 {
@@ -4759,9 +5286,15 @@ dhd_watchdog_thread(void *data)
 	complete_and_exit(&tsk->completed, 0);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 static void dhd_watchdog(struct timer_list *t)
 {
 	dhd_info_t *dhd = from_timer(dhd, t, timer);
+#else
+static void dhd_watchdog(ulong data)
+{
+	dhd_info_t *dhd = (dhd_info_t *)data;
+#endif
 	unsigned long flags;
 
 	if (dhd->pub.dongle_reset) {
@@ -5096,6 +5629,7 @@ dhd_sched_dpc(dhd_pub_t *dhdp)
 		DHD_OS_WAKE_UNLOCK(dhdp);
 	}
 }
+#endif /* BCMDBUS */
 
 static void
 dhd_sched_rxf(dhd_pub_t *dhdp, void *skb)
@@ -5148,17 +5682,50 @@ dhd_sched_rxf(dhd_pub_t *dhdp, void *skb)
 }
 
 #if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
-#endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
-
-#ifdef TOE
-/* Retrieve current toe component enables, which are kept as a bitmap in toe_ol iovar */
+#if defined(BCMDBUS)
 static int
-dhd_toe_get(dhd_info_t *dhd, int ifidx, uint32 *toe_ol)
+fw_download_thread_func(void *data)
 {
-	char buf[32];
+	dhd_info_t *dhd = (dhd_info_t *)data;
 	int ret;
 
-	ret = dhd_iovar(&dhd->pub, ifidx, "toe_ol", NULL, 0, (char *)&buf, sizeof(buf), FALSE);
+	while (1) {
+		/* Wait for start trigger */
+		if (down_interruptible(&dhd->fw_download_lock) != 0)
+			return -ERESTARTSYS;
+
+		if (kthread_should_stop())
+			break;
+
+		DHD_TRACE(("%s: initiating firmware check and download\n", __FUNCTION__));
+		if (dbus_download_firmware(dhd->pub.dbus) == DBUS_OK) {
+			if ((ret = dbus_up(dhd->pub.dbus)) == 0) {
+#ifdef PROP_TXSTATUS
+				/* Need to deinitialise WLFC to allow re-initialisation later. */
+				dhd_wlfc_deinit(&dhd->pub);
+#endif /* PROP_TXSTATUS */
+				/* Resynchronise with the dongle. This also re-initialises WLFC. */
+				if ((ret = dhd_sync_with_dongle(&dhd->pub)) < 0) {
+					DHD_ERROR(("%s: failed with code %d\n", __FUNCTION__, ret));
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+#endif /* BCMDBUS */
+#endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
+
+#ifdef TOE
+/* Retrieve current toe component enables, which are kept as a bitmap in toe_ol iovar */
+static int
+dhd_toe_get(dhd_info_t *dhd, int ifidx, uint32 *toe_ol)
+{
+	char buf[32];
+	int ret;
+
+	ret = dhd_iovar(&dhd->pub, ifidx, "toe_ol", NULL, 0, (char *)&buf, sizeof(buf), FALSE);
 
 	if (ret < 0) {
 		if (ret == -EIO) {
@@ -5374,12 +5941,12 @@ static bool dhd_check_hang(struct net_device *net, dhd_pub_t *dhdp, int error)
 		return FALSE;
 
 	dhd = (dhd_info_t *)dhdp->info;
-#if !defined(BCMPCIE)
+#if (!defined(BCMDBUS) && !defined(BCMPCIE))
 	if (dhd->thr_dpc_ctl.thr_pid < 0) {
 		DHD_ERROR(("%s : skipped due to negative pid - unloading?\n", __FUNCTION__));
 		return FALSE;
 	}
-#endif 
+#endif /* BCMDBUS */
 #ifdef DHD_FW_COREDUMP
 	if (error == -ETIMEDOUT && dhdp->busstate != DHD_BUS_DOWN) {
 		if (dhd_os_socram_dump(net, &dump_len) == BCME_OK) {
@@ -5426,6 +5993,7 @@ int dhd_ioctl_process(dhd_pub_t *pub, int ifidx, dhd_ioctl_t *ioc, void *data_bu
 		goto done;
 	}
 
+#ifndef BCMDBUS
 	/* send to dongle (must be up, and wl). */
 	if (pub->busstate == DHD_BUS_DOWN || pub->busstate == DHD_BUS_LOAD) {
 		if (allow_delay_fwdl) {
@@ -5445,6 +6013,7 @@ int dhd_ioctl_process(dhd_pub_t *pub, int ifidx, dhd_ioctl_t *ioc, void *data_bu
 		bcmerror = BCME_DONGLE_DOWN;
 		goto done;
 	}
+#endif /* BCMDBUS */
 
 	/*
 	 * Flush the TX queue if required for proper message serialization:
@@ -5755,7 +6324,8 @@ dhd_stop(struct net_device *net)
 #endif /* OEM_ANDROID && CONFIG_IPV6 */
 				dhd_net_if_unlock_local(dhd);
 			}
-			cancel_work_sync(dhd->dhd_deferred_wq);
+			//remove this to prevent dev_close get stuck in dhd_hang_process
+			//cancel_work_sync(dhd->dhd_deferred_wq);
 #if defined(DHD_LB) && defined(DHD_LB_RXP)
 			__skb_queue_purge(&dhd->rx_pend_queue);
 #endif /* DHD_LB && DHD_LB_RXP */
@@ -5805,6 +6375,15 @@ dhd_stop(struct net_device *net)
 
 	DHD_PERIM_UNLOCK(&dhd->pub);
 	DHD_OS_WAKE_UNLOCK(&dhd->pub);
+
+	/* Destroy wakelock */
+	if (!dhd_download_fw_on_driverload &&
+		(dhd->dhd_state & DHD_ATTACH_STATE_WAKELOCKS_INIT)) {
+		DHD_OS_WAKE_LOCK_DESTROY(dhd);
+		dhd->dhd_state &= ~DHD_ATTACH_STATE_WAKELOCKS_INIT;
+	}
+	printf("%s: Exit\n", __FUNCTION__);
+
 	return 0;
 }
 
@@ -5857,7 +6436,12 @@ dhd_open(struct net_device *net)
 		return -1;
 	}
 
-
+	if (!dhd_download_fw_on_driverload) {
+		if (!(dhd->dhd_state & DHD_ATTACH_STATE_WAKELOCKS_INIT)) {
+			DHD_OS_WAKE_LOCK_INIT(dhd);
+			dhd->dhd_state |= DHD_ATTACH_STATE_WAKELOCKS_INIT;
+		}
+	}
 
 	DHD_OS_WAKE_LOCK(&dhd->pub);
 	DHD_PERIM_LOCK(&dhd->pub);
@@ -5916,6 +6500,7 @@ dhd_open(struct net_device *net)
 
 		if (dhd->pub.busstate != DHD_BUS_DATA) {
 
+#ifndef BCMDBUS
 			/* try to bring up bus */
 			DHD_PERIM_UNLOCK(&dhd->pub);
 			ret = dhd_bus_start(&dhd->pub);
@@ -5925,6 +6510,18 @@ dhd_open(struct net_device *net)
 				ret = -1;
 				goto exit;
 			}
+#else /* BCMDBUS */
+			if ((ret = dbus_up(dhd->pub.dbus)) != 0) {
+				goto exit;
+			} else {
+				dhd->pub.busstate = DHD_BUS_DATA;
+			}
+
+			if ((ret = dhd_sync_with_dongle(&dhd->pub)) < 0) {
+				DHD_ERROR(("%s: failed with code %d\n", __FUNCTION__, ret));
+				goto exit;
+			}
+#endif /* BCMDBUS */
 
 		}
 
@@ -6213,11 +6810,25 @@ dhd_allocate_if(dhd_pub_t *dhdpub, int ifidx, char *name,
 		ifp->net->name[IFNAMSIZ - 1] = '\0';
 	}
 
-	ifp->net->needs_free_netdev = true;
 #ifdef WL_CFG80211
-	if (ifidx != 0)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+	if (ifidx == 0) {
+		ifp->net->priv_destructor = free_netdev;
+	} else {
 		ifp->net->priv_destructor = dhd_netdev_free;
+	}
+#else
+	if (ifidx == 0)
+		ifp->net->destructor = free_netdev;
+	else
+		ifp->net->destructor = dhd_netdev_free;
+#endif
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+	ifp->net->priv_destructor = free_netdev;
 #else
+	ifp->net->destructor = free_netdev;
+#endif
 #endif /* WL_CFG80211 */
 	strncpy(ifp->name, ifp->net->name, IFNAMSIZ);
 	ifp->name[IFNAMSIZ - 1] = '\0';
@@ -6730,6 +7341,30 @@ dhd_init_static_strs_array(dhd_event_log_t *temp, char *str_file, char *map_file
 }
 
 #endif /* SHOW_LOGTRACE */
+#ifdef DHD_LB
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+
+static enum cpuhp_state dhd_cpuhp_online_state;
+
+static int
+dhd_cpuhp_init(osl_t *osh, dhd_info_t *dhd)
+{
+	int ret = 0;
+
+	ret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, "net/wireless/dhd:online",
+			dhd_cpuhp_online, dhd_cpuhp_dead);
+	if (ret < 0) {
+		DHD_ERROR(("%s(): cpuhp_setup_state_multi() online failed, ret=%d\n",
+			__FUNCTION__, ret));
+		return ret;
+	}
+	dhd_cpuhp_online_state = ret;
+	cpuhp_state_add_instance_nocalls(dhd_cpuhp_online_state,
+		&dhd->node_online);
+	return ret;
+}
+#endif
+#endif
 
 
 dhd_pub_t *
@@ -6750,9 +7385,9 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	DHD_ERROR(("%s\n", driver_target));
 #endif /* STBLINUX */
 	/* will implement get_ids for DBUS later */
-#if defined(BCMSDIO)
+#if !defined(BCMDBUS) && defined(BCMSDIO)
 	dhd_bus_get_ids(bus, &bus_type, &bus_num, &slot_num);
-#endif 
+#endif /* !defined(BCMDBUS) && defined(BCMSDIO) */
 	adapter = dhd_wifi_platform_get_adapter(bus_type, bus_num, slot_num);
 
 	/* Allocate primary dhd_info */
@@ -6784,6 +7419,7 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 		dhd->pub.dhd_cspec.country_abbrev, &dhd->pub.dhd_cspec,
 		dhd->pub.dhd_cflags);
 #endif /* CUSTOM_COUNTRY_CODE */
+#ifndef BCMDBUS
 	dhd->thr_dpc_ctl.thr_pid = DHD_PID_KT_TL_INVALID;
 	dhd->thr_wdt_ctl.thr_pid = DHD_PID_KT_INVALID;
 
@@ -6799,6 +7435,7 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	 * solution
 	 */
 	dhd_update_fw_nv_path(dhd);
+#endif /* BCMDBUS */
 
 	/* Link to info module */
 	dhd->pub.info = dhd;
@@ -6887,20 +7524,11 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	spin_lock_init(&dhd->wakelock_spinlock);
 	dhd->wakelock_counter = 0;
 	dhd->wakelock_wd_counter = 0;
-	dhd->wakelock_rx_timeout_enable = 0;
-	dhd->wakelock_ctrl_timeout_enable = 0;
 #ifdef CONFIG_HAS_WAKELOCK
 	wake_lock_init(&dhd->wl_wifi, WAKE_LOCK_SUSPEND, "wlan_wake");
-	wake_lock_init(&dhd->wl_rxwake, WAKE_LOCK_SUSPEND, "wlan_rx_wake");
-	wake_lock_init(&dhd->wl_ctrlwake, WAKE_LOCK_SUSPEND, "wlan_ctrl_wake");
 	wake_lock_init(&dhd->wl_wdwake, WAKE_LOCK_SUSPEND, "wlan_wd_wake");
-#ifdef BCMPCIE_OOB_HOST_WAKE
-	wake_lock_init(&dhd->wl_intrwake, WAKE_LOCK_SUSPEND, "wlan_oob_irq_wake");
-#endif /* BCMPCIE_OOB_HOST_WAKE */
-#ifdef DHD_USE_SCAN_WAKELOCK
-	wake_lock_init(&dhd->wl_scanwake, WAKE_LOCK_SUSPEND, "wlan_scan_wake");
-#endif /* DHD_USE_SCAN_WAKELOCK */
-#endif /* CONFIG_HAS_WAKELOCK */
+	DHD_OS_WAKE_LOCK_INIT(dhd);
+#endif
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
 	mutex_init(&dhd->dhd_net_if_mutex);
 	mutex_init(&dhd->dhd_suspend_mutex);
@@ -6953,9 +7581,16 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	}
 
 
+#ifndef BCMDBUS
 
 	/* Set up the watchdog timer */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 	timer_setup(&dhd->timer, dhd_watchdog, 0);
+#else
+	init_timer(&dhd->timer);
+	dhd->timer.data = (ulong)dhd;
+	dhd->timer.function = dhd_watchdog;
+#endif
 	dhd->default_wd_interval = dhd_watchdog_ms;
 
 	if (dhd_watchdog_prio >= 0) {
@@ -6985,6 +7620,7 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 		/* Initialize RXF thread */
 		PROC_START(dhd_rxf_thread, dhd, &dhd->thr_rxf_ctl, 0, "dhd_rxf");
 	}
+#endif /* BCMDBUS */
 
 	dhd_state |= DHD_ATTACH_STATE_THREADS_CREATED;
 
@@ -7037,6 +7673,10 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 #endif /* DHDTCPACK_SUPPRESS */
 
 #if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
+#if defined(BCMDBUS)
+	sema_init(&dhd->fw_download_lock, 0);
+	dhd->fw_download_task = kthread_run(fw_download_thread_func, dhd, "fwdl-thread");
+#endif /* BCMDBUS */
 #endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
 
 	dhd_state |= DHD_ATTACH_STATE_DONE;
@@ -7064,17 +7704,24 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 		 * CPU Hotplug framework to change the CPU for each job dynamically
 		 * using candidacy algorithm.
 		 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+		dhd_cpuhp_init(osh, dhd);
+#else
 		dhd->cpu_notifier.notifier_call = dhd_cpu_callback;
 		register_cpu_notifier(&dhd->cpu_notifier); /* Register a callback */
+#endif
 	} else {
 		/*
 		 * We are unable to initialize CPU masks, so candidacy algorithm
 		 * won't run, but still Load Balancing will be honoured based
 		 * on the CPUs allocated for a given job statically during init
 		 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+#else
 		dhd->cpu_notifier.notifier_call = NULL;
 		DHD_ERROR(("%s(): dhd_cpumasks_init failed CPUs for JOB would be static\n",
 			__FUNCTION__));
+#endif
 	}
 
 
@@ -7133,13 +7780,25 @@ int dhd_get_fw_mode(dhd_info_t *dhdinfo)
 	return DHD_FLAG_STA_MODE;
 }
 
-extern int rkwifi_set_firmware(char *fw, char *nvram);
+#ifndef BCMDBUS
+
 int cis_chipvendor = 0;
 unsigned short cis_device = 0;
-char cis_fw_43455_path[] = "/system/etc/firmware/fw_cyw43455.bin";
-char cis_nv_43455_path[] = "/system/etc/firmware/nvram_cyw43455.txt";
-char cis_fw_4354_path[] = "/system/etc/firmware/fw_cyw4354.bin";
-char cis_nv_4354_path[] = "/system/etc/firmware/nvram_cyw4354.txt";
+char fw_path[1024] = {0};
+char nv_path[1024] = {0};
+
+#define DEFAULT_BCMDHD_FW_PATH "/vendor/etc/firmware/"
+#define DEFAULT_BCMDHD_NVRAM_PATH "/vendor/etc/firmware/"
+
+#define FW_CYW43364 "fw_cyw43364.bin"
+#define FW_CYW43438 "fw_cyw43438.bin"
+#define FW_CYW43455 "fw_cyw43455.bin"
+#define FW_CYW4354 "fw_cyw4354.bin"
+
+#define NVRAM_CYW43364 "nvram_azw432.txt"
+#define NVRAM_CYW43438 "nvram_azw372.txt"
+#define NVRAM_CYW43455 "nvram_azw256.txt"
+#define NVRAM_CYW4354 "nvram_azw235.txt"
 
 bool dhd_update_fw_nv_path(dhd_info_t *dhdinfo)
 {
@@ -7148,10 +7807,7 @@ bool dhd_update_fw_nv_path(dhd_info_t *dhdinfo)
 	const char *fw = NULL;
 	const char *nv = NULL;
 	wifi_adapter_info_t *adapter = dhdinfo->adapter;
-#ifdef CONFIG_PLAT_ROCKCHIP
-	char firmware[100] = {0};
-	char nvram[100] = {0};
-#endif /* CONFIG_PLAT_ROCKCHIP */
+
 
 	/* Update firmware and nvram path. The path may be from adapter info or module parameter
 	 * The path from adapter info is used for initialization only (as it won't change).
@@ -7164,12 +7820,6 @@ bool dhd_update_fw_nv_path(dhd_info_t *dhdinfo)
 	 */
 
 	/* set default firmware and nvram path for built-in type driver */
-
-#ifdef CONFIG_PLAT_ROCKCHIP
-    rkwifi_set_firmware(firmware, nvram);
-    nv = nvram;
-    fw = firmware;
-#else /* CONFIG_PLAT_ROCKCHIP */
 	if (!dhd_download_fw_on_driverload) {
 #ifdef CONFIG_BCMDHD_FW_PATH
 		fw = CONFIG_BCMDHD_FW_PATH;
@@ -7178,7 +7828,6 @@ bool dhd_update_fw_nv_path(dhd_info_t *dhdinfo)
 		nv = CONFIG_BCMDHD_NVRAM_PATH;
 #endif /* CONFIG_BCMDHD_NVRAM_PATH */
 	}
-#endif /* CONFIG_PLAT_ROCKCHIP */
 
 	/* check if we need to initialize the path */
 	if (dhdinfo->fw_path[0] == '\0') {
@@ -7200,18 +7849,41 @@ bool dhd_update_fw_nv_path(dhd_info_t *dhdinfo)
 	if (nvram_path[0] != '\0')
 		nv = nvram_path;
 
-	if (cis_device == BCM43455_CHIP_ID) {
-		DHD_ERROR(("Adding 43455 firmware and NVRAM path by CIS\n"
+	if (cis_device == BCM43455_CHIP_ID && cis_chipvendor == 0x81) {
+		sprintf(fw_path, "%s%s", DEFAULT_BCMDHD_FW_PATH, FW_CYW43455);
+		sprintf(nv_path, "%s%s", DEFAULT_BCMDHD_NVRAM_PATH, NVRAM_CYW43455);
+		DHD_ERROR(("Adding CYW43455 firmware and NVRAM path by CIS\n"
+			"\tfirmware path: %s\n"
+			"\tNVRAM path:    %s\n", fw_path, nv_path));
+		
+		fw = fw_path;
+		nv = nv_path;
+	} else if (cis_device == BCM43430_CHIP_ID) {
+		if (cis_chipvendor == 0x81) {
+			sprintf(fw_path, "%s%s", DEFAULT_BCMDHD_FW_PATH, FW_CYW43438);
+			sprintf(nv_path, "%s%s", DEFAULT_BCMDHD_NVRAM_PATH, NVRAM_CYW43438);
+			DHD_ERROR(("Adding CYW43438 firmware and NVRAM path by CIS\n"
 			"\tfirmware path: %s\n"
-			"\tNVRAM path:    %s\n", cis_fw_43455_path, cis_nv_43455_path));
-		fw = cis_fw_43455_path;
-		nv = cis_nv_43455_path;
+			"\tNVRAM path:    %s\n", fw_path, nv_path));
+			fw = fw_path;
+			nv = nv_path;
+		} else {
+			sprintf(fw_path, "%s%s", DEFAULT_BCMDHD_FW_PATH, FW_CYW43364);
+			sprintf(nv_path, "%s%s", DEFAULT_BCMDHD_NVRAM_PATH, NVRAM_CYW43364);
+			DHD_ERROR(("Adding CYW43364 firmware and NVRAM path by CIS\n"
+			"\tfirmware path: %s\n"
+			"\tNVRAM path:    %s\n", fw_path, nv_path));
+			fw = fw_path;
+			nv = nv_path;
+		}
 	} else if (cis_device == BCM4354_CHIP_ID) {
-		DHD_ERROR(("Adding 4354 firmware and NVRAM path by CIS\n"
+		sprintf(fw_path, "%s%s", DEFAULT_BCMDHD_FW_PATH, FW_CYW4354);
+		sprintf(nv_path, "%s%s", DEFAULT_BCMDHD_NVRAM_PATH, NVRAM_CYW4354);
+		DHD_ERROR(("Adding CYW4354 firmware and NVRAM path by CIS\n"
 			"\tfirmware path: %s\n"
-			"\tNVRAM path:    %s\n", cis_fw_4354_path, cis_nv_4354_path));
-		fw = cis_fw_4354_path;
-		nv = cis_nv_4354_path;
+			"\tNVRAM path:    %s\n", fw_path, nv_path));
+		fw = fw_path;
+		nv = nv_path;
 	}
 
 	if (fw && fw[0] != '\0') {
@@ -7270,7 +7942,7 @@ dhd_bus_start(dhd_pub_t *dhdp)
 
 	/* try to download image and nvram to the dongle */
 	if  (dhd->pub.busstate == DHD_BUS_DOWN && dhd_update_fw_nv_path(dhd)) {
-		DHD_ERROR(("%s download fw %s, nv %s\n", __FUNCTION__, dhd->fw_path, dhd->nv_path));
+		DHD_INFO(("%s download fw %s, nv %s\n", __FUNCTION__, dhd->fw_path, dhd->nv_path));
 		ret = dhd_bus_download_firmware(dhd->pub.bus, dhd->pub.osh,
 		                                dhd->fw_path, dhd->nv_path);
 		if (ret < 0) {
@@ -7375,6 +8047,15 @@ dhd_bus_start(dhd_pub_t *dhdp)
 
 	dhd_os_sdunlock(dhdp);
 
+#ifdef HOST_FLAG
+	{
+		int enable = 0;
+		if (dhd_wl_ioctl_set_intiovar(dhdp, "hostsleep", enable, WLC_SET_VAR, TRUE, 0)) {
+			DHD_ERROR(("%s: Failed to set hostsleep 0\n", __FUNCTION__));
+		}
+	}
+#endif /* HOST_FLAG */
+
 	/* Bus is ready, query any dongle information */
 	if ((ret = dhd_sync_with_dongle(&dhd->pub)) < 0) {
 		DHD_GENERAL_LOCK(&dhd->pub, flags);
@@ -7401,6 +8082,7 @@ dhd_bus_start(dhd_pub_t *dhdp)
 	DHD_PERIM_UNLOCK(dhdp);
 	return 0;
 }
+#endif /* BCMDBUS */
 #ifdef WLTDLS
 int _dhd_tdls_enable(dhd_pub_t *dhd, bool tdls_on, bool auto_on, struct ether_addr *mac)
 {
@@ -7551,7 +8233,7 @@ void dhd_tdls_update_peer_info(struct net_device *dev, bool connect, uint8 *da)
 	}
 }
 #endif /* PCIE_FULL_DONGLE */
-#endif 
+#endif /* BCMDBUS */
 
 bool dhd_is_concurrent_mode(dhd_pub_t *dhd)
 {
@@ -7671,7 +8353,6 @@ int dhd_set_ap_powersave(dhd_pub_t *dhdp, int ifidx, int enable)
 }
 #endif /* SUPPORT_AP_POWERSAVE */
 
-
 int
 dhd_preinit_ioctls(dhd_pub_t *dhd)
 {
@@ -7696,14 +8377,14 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	int32 amsdu_aggsf = 0;
 #endif
 
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 #ifdef PROP_TXSTATUS
 	int wlfc_enable = TRUE;
 #ifndef DISABLE_11N
 	uint32 hostreorder = 1;
 #endif /* DISABLE_11N */
 #endif /* PROP_TXSTATUS */
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #ifndef PCIE_FULL_DONGLE
 	uint32 wl_ap_isolate;
 #endif /* PCIE_FULL_DONGLE */
@@ -8083,12 +8764,10 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	}
 #endif /* defined(KEEP_ALIVE) */
 
-#if (0)
 	if ((ret = dhd_apply_default_clm(dhd, clm_path)) < 0) {
 		DHD_ERROR(("%s: CLM set failed. Abort initialization.\n", __FUNCTION__));
 		goto done;
 	}
-#endif
 
 #ifdef USE_WL_TXBF
 	if ((ret = dhd_iovar(dhd, 0, "txbf", (char *)&txbf, sizeof(txbf), NULL, 0, TRUE)) < 0) {
@@ -8316,6 +8995,8 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 			DHD_ERROR(("%s write event mask ext failed %d\n", __FUNCTION__, ret));
 			goto done;
 		}
+	} else if (ret2 < 0 && ret2 == BCME_VERSION) {
+		DHD_ERROR(("%s Different Event version\n", __FUNCTION__));
 	} else if (ret2 < 0 && ret2 != BCME_UNSUPPORTED) {
 		DHD_ERROR(("%s read event mask ext failed %d\n", __FUNCTION__, ret2));
 		goto done;
@@ -8391,7 +9072,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	dhd_txglom_enable(dhd, TRUE);
 #endif /* defined(BCMSDIO) */
 
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 #ifdef PROP_TXSTATUS
 	if (disable_proptx ||
 #ifdef PROP_TXSTATUS_VSDB
@@ -8465,6 +9146,128 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	return ret;
 }
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+int
+dhd_preinit_ioctls_alive(dhd_pub_t *dhd)
+{
+	int ret = 0;
+	char buf[WLC_IOCTL_SMLEN];
+
+	DHD_TRACE(("Enter %s\n", __FUNCTION__));
+
+#if (0)
+	char iovbuf[WL_EVENTING_MASK_LEN + 12]; /*  Room for "event_msgs" + '\0' + bitvec  */
+#if defined(BCMSDIO) || defined(BCMDBUS)
+#ifdef PROP_TXSTATUS
+	int wlfc_enable = TRUE;
+#endif /* PROP_TXSTATUS */
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
+
+#if defined(ARP_OFFLOAD_SUPPORT)
+	int arpoe = 1;
+#endif
+
+#if defined(SOFTAP)
+	uint dtim = 1;
+#endif
+
+#ifdef WLTDLS
+	dhd->tdls_enable = FALSE;
+	dhd_tdls_set_mode(dhd, false);
+#endif /* WLTDLS */
+	dhd->suspend_bcn_li_dtim = CUSTOM_SUSPEND_BCN_LI_DTIM;
+
+	DHD_TRACE(("Enter %s\n", __FUNCTION__));
+	dhd->op_mode = 0;
+#endif
+
+	/* Get the default device MAC address directly from firmware */
+	ret = dhd_iovar(dhd, 0, "cur_etheraddr", NULL, 0, (char *)&buf, sizeof(buf), FALSE);
+	if (ret < 0) {
+		DHD_ERROR(("%s: can't get MAC address , error=%d\n", __FUNCTION__, ret));
+		ret = BCME_NOTUP;
+		goto done;
+	}
+	/* Update public MAC address after reading from Firmware */
+	memcpy(dhd->mac.octet, buf, ETHER_ADDR_LEN);
+
+	/* get a capabilities from firmware */
+	{
+		uint32 cap_buf_size = sizeof(dhd->fw_capabilities);
+		memset(dhd->fw_capabilities, 0, cap_buf_size);
+		ret = dhd_iovar(dhd, 0, "cap", NULL, 0, dhd->fw_capabilities, (cap_buf_size - 1),
+				FALSE);
+		if (ret < 0) {
+			DHD_ERROR(("%s: Get Capability failed (error=%d)\n",
+				__FUNCTION__, ret));
+			return 0;
+		}
+
+		memmove(&dhd->fw_capabilities[1], dhd->fw_capabilities, (cap_buf_size - 1));
+		dhd->fw_capabilities[0] = ' ';
+		dhd->fw_capabilities[cap_buf_size - 2] = ' ';
+		dhd->fw_capabilities[cap_buf_size - 1] = '\0';
+	}
+
+	dhd->op_mode = DHD_FLAG_STA_MODE;
+
+	DHD_ERROR(("Firmware up: op_mode=0x%04x, MAC="MACDBG"\n",
+		dhd->op_mode, MAC2STRDBG(dhd->mac.octet)));
+
+#if (0)
+#ifdef WLTDLS
+	/* by default TDLS on and auto mode off */
+	_dhd_tdls_enable(dhd, true, false, NULL);
+#endif /* WLTDLS */
+
+#ifdef ARP_OFFLOAD_SUPPORT
+	/* Set and enable ARP offload feature for STA only  */
+	//get arp offload from firmware
+	dhd_arp_enable = arpoe;
+#endif /* ARP_OFFLOAD_SUPPORT */
+
+#ifdef PKT_FILTER_SUPPORT
+	/* Setup default defintions for pktfilter , enable in suspend */
+	dhd->pktfilter_count = 6;
+	/* Setup filter to allow only unicast */
+	dhd->pktfilter[DHD_UNICAST_FILTER_NUM] = "100 0 0 0 0x01 0x00";
+	dhd->pktfilter[DHD_BROADCAST_FILTER_NUM] = NULL;
+	dhd->pktfilter[DHD_MULTICAST4_FILTER_NUM] = NULL;
+	dhd->pktfilter[DHD_MULTICAST6_FILTER_NUM] = NULL;
+	/* Add filter to pass multicastDNS packet and NOT filter out as Broadcast */
+	dhd->pktfilter[DHD_MDNS_FILTER_NUM] = "104 0 0 0 0xFFFFFFFFFFFF 0x01005E0000FB";
+	/* apply APP pktfilter */
+	dhd->pktfilter[DHD_ARP_FILTER_NUM] = "105 0 0 12 0xFFFF 0x0806";
+#endif /* PKT_FILTER_SUPPORT */
+
+#if defined(BCMSDIO) || defined(BCMDBUS)
+#ifdef PROP_TXSTATUS
+	if (disable_proptx ||
+#ifdef PROP_TXSTATUS_VSDB
+		/* enable WLFC only if the firmware is VSDB when it is in STA mode */
+		(dhd->op_mode != DHD_FLAG_HOSTAP_MODE &&
+		 dhd->op_mode != DHD_FLAG_IBSS_MODE) ||
+#endif /* PROP_TXSTATUS_VSDB */
+		FALSE) {
+		wlfc_enable = FALSE;
+	}
+
+	if (wlfc_enable)
+		dhd_wlfc_init(dhd);
+#ifndef DISABLE_11N
+	else if (hostreorder)
+		dhd_wlfc_hostreorder_init(dhd);
+#endif /* DISABLE_11N */
+
+#endif /* PROP_TXSTATUS */
+#endif /* BCMSDIO || BCMBUS */
+#endif
+
+done:
+	return ret;
+}
+#endif /* LOAD_DHD_WITH_FW_ALIVE */
+
 int
 dhd_iovar(dhd_pub_t *pub, int ifidx, char *name, char *param_buf, uint param_len, char *res_buf,
 		uint res_len, int set)
@@ -9039,7 +9842,16 @@ dhd_bus_detach(dhd_pub_t *dhdp)
 				dhd_prot_stop(&dhd->pub);
 
 				/* Stop the bus module */
+#ifdef BCMDBUS
+				/* Force Dongle terminated */
+				if (dhd_wl_ioctl_cmd(dhdp, WLC_TERMINATED, NULL, 0, TRUE, 0) < 0)
+					DHD_ERROR(("%s Setting WLC_TERMINATED failed\n",
+						__FUNCTION__));
+				dbus_stop(dhd->pub.dbus);
+				dhd->pub.busstate = DHD_BUS_DOWN;
+#else
 				dhd_bus_stop(dhd->pub.bus, TRUE);
+#endif /* BCMDBUS */
 			}
 
 #if defined(OOB_INTR_ONLY) || defined(BCMPCIE_OOB_HOST_WAKE)
@@ -9098,6 +9910,13 @@ void dhd_detach(dhd_pub_t *dhdp)
 #endif
 
 #if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
+#if defined(BCMDBUS)
+	if (dhd->fw_download_task) {
+		up(&dhd->fw_download_lock);
+		kthread_stop(dhd->fw_download_task);
+		dhd->fw_download_task = NULL;
+	}
+#endif /* BCMDBUS */
 #endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
 
 #ifdef PROP_TXSTATUS
@@ -9239,6 +10058,9 @@ void dhd_detach(dhd_pub_t *dhdp)
 	if (timer_valid)
 		del_timer_sync(&dhd->timer);
 
+#ifdef BCMDBUS
+	tasklet_kill(&dhd->tasklet);
+#else
 	if (dhd->dhd_state & DHD_ATTACH_STATE_THREADS_CREATED) {
 		if (dhd->thr_wdt_ctl.thr_pid >= 0) {
 			PROC_STOP(&dhd->thr_wdt_ctl);
@@ -9257,6 +10079,7 @@ void dhd_detach(dhd_pub_t *dhdp)
 #endif /* DHD_LB_RXP */
 		}
 	}
+#endif /* BCMDBUS */
 
 #if defined(DHD_LB)
 	/* Kill the Load Balancing Tasklets */
@@ -9268,9 +10091,15 @@ void dhd_detach(dhd_pub_t *dhdp)
 	tasklet_disable(&dhd->rx_compl_tasklet);
 	tasklet_kill(&dhd->rx_compl_tasklet);
 #endif /* DHD_LB_RXC */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+	cpuhp_state_remove_instance(dhd_cpuhp_online_state, &dhd->node_online);
+	cpuhp_remove_multi_state(dhd_cpuhp_online_state);
+#else
 	if (dhd->cpu_notifier.notifier_call != NULL)
 		unregister_cpu_notifier(&dhd->cpu_notifier);
+#endif
 	dhd_cpumasks_deinit(dhd);
+
 #endif /* DHD_LB */
 
 #ifdef WL_CFG80211
@@ -9283,6 +10112,12 @@ void dhd_detach(dhd_pub_t *dhdp)
 	dhd_deferred_work_deinit(dhd->dhd_deferred_wq);
 	dhd->dhd_deferred_wq = NULL;
 
+#ifdef BCMDBUS
+	if (dhdp->dbus) {
+		dbus_detach(dhdp->dbus);
+		dhdp->dbus = NULL;
+	}
+#endif /* BCMDBUS */
 #ifdef SHOW_LOGTRACE
 	if (dhdp->dbg)
 		dhd_os_dbg_detach(dhdp);
@@ -9321,18 +10156,9 @@ void dhd_detach(dhd_pub_t *dhdp)
 #ifdef CONFIG_HAS_WAKELOCK
 		dhd->wakelock_counter = 0;
 		dhd->wakelock_wd_counter = 0;
-		dhd->wakelock_rx_timeout_enable = 0;
-		dhd->wakelock_ctrl_timeout_enable = 0;
 		wake_lock_destroy(&dhd->wl_wifi);
-		wake_lock_destroy(&dhd->wl_rxwake);
-		wake_lock_destroy(&dhd->wl_ctrlwake);
 		wake_lock_destroy(&dhd->wl_wdwake);
-#ifdef BCMPCIE_OOB_HOST_WAKE
-		wake_lock_destroy(&dhd->wl_intrwake);
-#endif /* BCMPCIE_OOB_HOST_WAKE */
-#ifdef DHD_USE_SCAN_WAKELOCK
-		wake_lock_destroy(&dhd->wl_scanwake);
-#endif /* DHD_USE_SCAN_WAKELOCK */
+		DHD_OS_WAKE_LOCK_DESTROY(dhd);
 #endif /* CONFIG_HAS_WAKELOCK */
 	}
 
@@ -9452,18 +10278,18 @@ dhd_module_cleanup(void)
 {
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+#ifdef BCMDBUS
+	dbus_deregister();
+#else
 	dhd_bus_unregister();
+#endif /* BCMDBUS */
 
 	wl_android_exit();
 
 	dhd_wifi_platform_unregister_drv();
 }
 
-#ifdef CONFIG_PLAT_ROCKCHIP
-static void 
-#else /* CONFIG_PLAT_ROCKCHIP */
 static void __exit
-#endif /* CONFIG_PLAT_ROCKCHIP */
 dhd_module_exit(void)
 {
 	dhd_buzzz_detach();
@@ -9471,11 +10297,7 @@ dhd_module_exit(void)
 	unregister_reboot_notifier(&dhd_reboot_notifier);
 }
 
-#ifdef CONFIG_PLAT_ROCKCHIP
-static int 
-#else /* CONFIG_PLAT_ROCKCHIP */
 static int __init
-#endif /* CONFIG_PLAT_ROCKCHIP */
 dhd_module_init(void)
 {
 	int err;
@@ -9543,10 +10365,185 @@ dhd_reboot_callback(struct notifier_block *this, unsigned long code, void *unuse
 	return NOTIFY_DONE;
 }
 
+#ifdef BCMDBUS
+
+/*
+ * hdrlen is space to reserve in pkt headroom for DBUS
+ */
+void *
+dhd_dbus_probe_cb(void *arg, const char *desc, uint32 bustype, uint32 hdrlen)
+{
+	osl_t *osh;
+	int ret = 0;
+	dbus_attrib_t attrib;
+	dhd_pub_t *pub = NULL;
+
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
+
+	/* Ask the OS interface part for an OSL handle */
+	if (!(osh = osl_attach(NULL, bustype, TRUE))) {
+		DHD_ERROR(("%s: OSL attach failed\n", __FUNCTION__));
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	/* Attach to the dhd/OS interface */
+	if (!(pub = dhd_attach(osh, NULL /* bus */, hdrlen))) {
+		DHD_ERROR(("%s: dhd_attach failed\n", __FUNCTION__));
+		ret = -ENXIO;
+		goto fail;
+	}
+
+	/* Ok, finish the attach to the OS network interface */
+	if (dhd_register_if(pub, 0, TRUE) != 0) {
+		DHD_ERROR(("%s: dhd_register_if failed\n", __FUNCTION__));
+		ret = -ENXIO;
+		goto fail;
+	}
+
+	pub->dbus = dbus_attach(osh, pub->rxsz, DBUS_NRXQ, DBUS_NTXQ,
+		pub->info, &dhd_dbus_cbs, NULL, NULL);
+	if (pub->dbus) {
+		dbus_get_attrib(pub->dbus, &attrib);
+		DHD_ERROR(("DBUS: vid=0x%x pid=0x%x devid=0x%x bustype=0x%x mtu=%d\n",
+			attrib.vid, attrib.pid, attrib.devid, attrib.bustype, attrib.mtu));
+	} else {
+		ret = -ENXIO;
+		goto fail;
+	}
+#ifdef BCM_FD_AGGR
+	pub->info->rpc_th = bcm_rpc_tp_attach(osh, (void *)pub->dbus);
+	if (!pub->info->rpc_th) {
+		DHD_ERROR(("%s: bcm_rpc_tp_attach failed\n", __FUNCTION__));
+		ret = -ENXIO;
+		goto fail;
+	}
+
+	pub->info->rpc_osh = rpc_osl_attach(osh);
+	if (!pub->info->rpc_osh) {
+		DHD_ERROR(("%s: rpc_osl_attach failed\n", __FUNCTION__));
+		bcm_rpc_tp_detach(pub->info->rpc_th);
+		pub->info->rpc_th = NULL;
+		ret = -ENXIO;
+		goto fail;
+	}
+	/* Set up the aggregation release timer */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
+	timer_setup(&pub->info->rpcth_timer, dhd_rpcth_watchdog, 0)
+#else
+	init_timer(&pub->info->rpcth_timer);
+	pub->info->rpcth_timer.data = (ulong)pub->info;
+	pub->info->rpcth_timer.function = dhd_rpcth_watchdog;
+#endif
+	pub->info->rpcth_timer_active = FALSE;
+
+	bcm_rpc_tp_register_cb(pub->info->rpc_th, NULL, pub->info,
+		dbus_rpcth_rx_pkt, pub->info, pub->info->rpc_osh);
+#endif /* BCM_FD_AGGR */
+
+	/* This is passed to dhd_dbus_disconnect_cb */
+	return pub->info;
+fail:
+	/* Release resources in reverse order */
+	if (osh) {
+		if (pub) {
+			dhd_detach(pub);
+			dhd_free(pub);
+		}
+		osl_detach(osh);
+	}
+
+	BCM_REFERENCE(ret);
+	return NULL;
+}
+
+void
+dhd_dbus_disconnect_cb(void *arg)
+{
+	dhd_info_t *dhd = (dhd_info_t *)arg;
+	dhd_pub_t *pub;
+	osl_t *osh;
+
+	if (dhd == NULL)
+		return;
+
+	pub = &dhd->pub;
+	osh = pub->osh;
+#ifdef BCM_FD_AGGR
+	del_timer_sync(&dhd->rpcth_timer);
+	bcm_rpc_tp_deregister_cb(dhd->rpc_th);
+	rpc_osl_detach(dhd->rpc_osh);
+	bcm_rpc_tp_detach(dhd->rpc_th);
+#endif
+	dhd_detach(pub);
+	dhd_free(pub);
+
+	if (MALLOCED(osh)) {
+		DHD_ERROR(("%s: MEMORY LEAK %d bytes\n", __FUNCTION__, MALLOCED(osh)));
+	}
+	osl_detach(osh);
+}
+#endif /* BCMDBUS */
 
 #ifdef CONFIG_PLAT_ROCKCHIP
 #include <linux/rfkill-wlan.h>
 
+//rk
+/* The debugfs functions are optimized away when CONFIG_DEBUG_FS isn't set. */
+//static char tcp_keepalive_param[200];
+static char sabuf[20]="", dabuf[20]="";
+static char seabuf[ETHER_ADDR_STR_LEN]="";
+static char deabuf[ETHER_ADDR_STR_LEN]="";
+static uint16 source, dest, window, ip_id;
+static uint32 seq = 0, seq_ack = 0, tcp_option_len = 0, tcp_data_len = 0, tsval = 0, tsecr = 0;
+#include <linux/hrtimer.h>
+#include <linux/time.h>
+#include <net/tcp.h>
+#include <linux/proc_fs.h>
+
+static int tcp_param_show(struct seq_file *s, void *data)
+{
+	//seq_printf(s, "dhd_priv wl tcpka_conn_add 1 %s %s %s 1 %d %d 1 1 1 1 1 5 0x6865617274\n",
+	//		deabuf, sabuf, dabuf, source, dest);
+
+	//seq_printf(s, "dhd_priv wl tcpka_conn_add 1 %s %s %s %d %d %d %8u %8u %d %8u %8u 0 5 0x6865617274\n", deabuf, sabuf, dabuf, ip_id, source, dest, seq, seq_ack, window, tsval, tsecr);
+	seq_printf(s, "wl_cy tcpka_conn_add %s %s %s %d %d %d %8u %8u %d %8u %8u 0 7 Qghappy\n", deabuf, sabuf, dabuf, ip_id, source, dest, seq, seq_ack, window, tsval, tsecr);
+
+	return 0;
+}
+
+#ifndef CONFIG_PROC_FS
+DEFINE_SHOW_ATTRIBUTE(tcp_param);
+#endif
+
+static void rk_bcm_add_tcp_keepalive_debugfs(void)
+{
+#ifdef CONFIG_PROC_FS
+	proc_create_single("tcp_params", 0, NULL, tcp_param_show);
+#else
+	struct dentry *root;
+
+	root = debugfs_create_dir("tcp_keepalive_param", NULL);
+	if (IS_ERR(root))
+		/* Don't complain -- debugfs just isn't enabled */
+		return;
+	if (!root)
+		/* Complain -- debugfs is enabled, but it failed to
+		 * create the directory. */
+		goto err_root;
+
+	if (!debugfs_create_file("tcp_param", S_IRUSR, root, NULL, &tcp_param_fops))
+		goto err_node;
+
+	return;
+
+err_node:
+	debugfs_remove_recursive(root);
+err_root:
+	pr_err("failed to initialize keepalive debugfs\n");
+#endif
+}
+
 #define CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP 1
 
 extern int get_wifi_chip_type(void);
@@ -9556,6 +10553,7 @@ extern char RKWIFI_DRV_VERSION[];
 #ifdef CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP
 static int wifi_init_thread(void *data)
 {
+	rk_bcm_add_tcp_keepalive_debugfs();
     dhd_module_init();
     return 0;
 }
@@ -9564,20 +10562,13 @@ static int wifi_init_thread(void *data)
 int rockchip_wifi_init_module_rkwifi(void)
 {
 #ifdef CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP
-    struct task_struct *kthread;
-#endif /* CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP */
+	struct task_struct *kthread = NULL;
 
-    printk("=======================================================\n");
-    printk("==== Launching Wi-Fi driver! (Powered by Rockchip) ====\n");
-    printk("=======================================================\n");
-    printk("%s WiFi driver (Powered by Rockchip,Ver %s) init.\n", WIFI_MODULE_NAME, RKWIFI_DRV_VERSION);
+	kthread = kthread_run(wifi_init_thread, NULL, "wifi_init_thread");
 
-#ifdef CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP
-    kthread = kthread_run(wifi_init_thread, NULL, "wifi_init_thread");
-
-    if (kthread->pid < 0) {
-        printk("create wifi_init_thread failed.\n");
-    }
+	if (IS_ERR(kthread)) {
+		DHD_ERROR(("create wifi_init_thread failed.\n"));
+	}
 
     return 0; 
 #else /* CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP */
@@ -9587,9 +10578,6 @@ int rockchip_wifi_init_module_rkwifi(void)
 
 void rockchip_wifi_exit_module_rkwifi(void)
 {
-    printk("=======================================================\n");
-    printk("== Dis-launching Wi-Fi driver! (Powered by Rockchip) ==\n");
-    printk("=======================================================\n");
     dhd_module_exit();
 }
 
@@ -9765,6 +10753,7 @@ dhd_os_busbusy_wake(dhd_pub_t *pub)
 void
 dhd_os_wd_timer_extend(void *bus, bool extend)
 {
+#ifndef BCMDBUS
 	dhd_pub_t *pub = bus;
 	dhd_info_t *dhd = (dhd_info_t *)pub->info;
 
@@ -9772,12 +10761,14 @@ dhd_os_wd_timer_extend(void *bus, bool extend)
 		dhd_os_wd_timer(bus, WATCHDOG_EXTEND_INTERVAL);
 	else
 		dhd_os_wd_timer(bus, dhd->default_wd_interval);
+#endif /* !BCMDBUS */
 }
 
 
 void
 dhd_os_wd_timer(void *bus, uint wdtick)
 {
+#ifndef BCMDBUS
 	dhd_pub_t *pub = bus;
 	dhd_info_t *dhd = (dhd_info_t *)pub->info;
 	unsigned long flags;
@@ -9812,6 +10803,7 @@ dhd_os_wd_timer(void *bus, uint wdtick)
 		dhd->wd_timer_valid = TRUE;
 	}
 	DHD_GENERAL_UNLOCK(pub, flags);
+#endif /* BCMDBUS */
 }
 
 void *
@@ -9843,7 +10835,11 @@ dhd_os_get_image_block(char *buf, int len, void *image)
 		return 0;
 
 	pos = fp->f_pos;
-	rdlen = kernel_read(fp, buf, len, &pos);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
+	rdlen = kernel_read(fp, (void *) buf, (size_t) len, (loff_t *) &pos);
+#else
+	rdlen = kernel_read(fp, pos, buf, len);
+#endif
 	if (rdlen > 0)
 		fp->f_pos += rdlen;
 
@@ -9864,10 +10860,14 @@ dhd_os_sdlock(dhd_pub_t *pub)
 
 	dhd = (dhd_info_t *)(pub->info);
 
+#ifndef BCMDBUS
 	if (dhd_dpc_prio >= 0)
 		down(&dhd->sdsem);
 	else
 		spin_lock_bh(&dhd->sdlock);
+#else
+	spin_lock_bh(&dhd->sdlock);
+#endif /* BCMDBUS */
 }
 
 void
@@ -9877,10 +10877,14 @@ dhd_os_sdunlock(dhd_pub_t *pub)
 
 	dhd = (dhd_info_t *)(pub->info);
 
+#ifndef BCMDBUS
 	if (dhd_dpc_prio >= 0)
 		up(&dhd->sdsem);
 	else
 		spin_unlock_bh(&dhd->sdlock);
+#else
+	spin_unlock_bh(&dhd->sdlock);
+#endif /* BCMDBUS */
 }
 
 void
@@ -9889,7 +10893,11 @@ dhd_os_sdlock_txq(dhd_pub_t *pub)
 	dhd_info_t *dhd;
 
 	dhd = (dhd_info_t *)(pub->info);
+#ifdef BCMDBUS
+	spin_lock_irqsave(&dhd->txqlock, dhd->txqlock_flags);
+#else
 	spin_lock_bh(&dhd->txqlock);
+#endif
 }
 
 void
@@ -9898,7 +10906,11 @@ dhd_os_sdunlock_txq(dhd_pub_t *pub)
 	dhd_info_t *dhd;
 
 	dhd = (dhd_info_t *)(pub->info);
+#ifdef BCMDBUS
+	spin_unlock_irqrestore(&dhd->txqlock, dhd->txqlock_flags);
+#else
 	spin_unlock_bh(&dhd->txqlock);
+#endif
 }
 
 void
@@ -10008,16 +11020,18 @@ dhd_get_wireless_stats(struct net_device *dev)
 #endif /* defined(WL_WIRELESS_EXT) */
 
 static int
-dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
+dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata, uint16 pktlen,
 	wl_event_msg_t *event, void **data)
 {
 	int bcmerror = 0;
 	ASSERT(dhd != NULL);
 
 #ifdef SHOW_LOGTRACE
-		bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, event, data, &dhd->event_data);
+		bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, pktlen, event, data,
+			&dhd->event_data);
 #else
-		bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, event, data, NULL);
+		bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, pktlen, event, data,
+			NULL);
 #endif /* SHOW_LOGTRACE */
 
 	if (bcmerror != BCME_OK)
@@ -11477,18 +12491,30 @@ write_to_file(dhd_pub_t *dhd, uint8 *buf, int size)
 	int ret = 0;
 	char memdump_path[64];
 	char memdump_type[32];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
 	struct timeval curtime;
+#else
+	struct timespec64 curtime;
+#endif
 	uint32 file_mode;
 
-
 	/* Init file name */
 	memset(memdump_path, 0, sizeof(memdump_path));
 	memset(memdump_type, 0, sizeof(memdump_type));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
 	do_gettimeofday(&curtime);
+#else
+	ktime_get_real_ts64(&curtime);
+#endif
 	dhd_convert_memdump_type_to_str(dhd->memdump_type, memdump_type);
 	sprintf(memdump_path, "%s_%s_%ld.%ld", "/installmedia/mem_dump",
 		memdump_type, (unsigned long)curtime.tv_sec,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
 		(unsigned long)curtime.tv_usec);
+#else
+		(unsigned long)curtime.tv_nsec);
+#endif
+
 	/* Extra flags O_DIRECT and O_SYNC are required for Brix Android, as we are
 	 * calling BUG_ON immediately after collecting the socram dump.
 	 * So the file write operation should directly write the contents into the
@@ -11665,6 +12691,57 @@ int dhd_os_wake_unlock(dhd_pub_t *pub)
 	return ret;
 }
 
+void dhd_event_wake_lock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+
+	if (dhd) {
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock(&dhd->wl_evtwake);
+#elif defined(BCMSDIO) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+		dhd_bus_dev_pm_stay_awake(pub);
+#endif
+	}
+}
+
+void dhd_event_wake_unlock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+
+	if (dhd) {
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_unlock(&dhd->wl_evtwake);
+#elif defined(BCMSDIO) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+		dhd_bus_dev_pm_relax(pub);
+#endif
+	}
+}
+
+void dhd_txfl_wake_lock_timeout(dhd_pub_t *pub, int val)
+{
+#ifdef CONFIG_HAS_WAKELOCK
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+
+	if (dhd) {
+		wake_lock_timeout(&dhd->wl_txflwake, msecs_to_jiffies(val));
+	}
+#endif /* CONFIG_HAS_WAKE_LOCK */
+}
+
+void dhd_txfl_wake_unlock(dhd_pub_t *pub)
+{
+#ifdef CONFIG_HAS_WAKELOCK
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+
+	if (dhd) {
+		/* if wl_txflwake is active, unlock it */
+		if (wake_lock_active(&dhd->wl_txflwake)) {
+			wake_unlock(&dhd->wl_txflwake);
+		}
+	}
+#endif /* CONFIG_HAS_WAKELOCK */
+}
+
 int dhd_os_check_wakelock(dhd_pub_t *pub)
 {
 #if defined(CONFIG_HAS_WAKELOCK) || (defined(BCMSDIO) && (LINUX_VERSION_CODE > \
@@ -11694,6 +12771,7 @@ dhd_os_check_wakelock_all(dhd_pub_t *pub)
 #ifdef CONFIG_HAS_WAKELOCK
 	int l1, l2, l3, l4;
 	int l5 = 0, l6 = 0;
+	int l7, l8;
 	int c, lock_active;
 #endif /* CONFIG_HAS_WAKELOCK */
 #if defined(CONFIG_HAS_WAKELOCK) || (defined(BCMSDIO) && (LINUX_VERSION_CODE > \
@@ -11721,7 +12799,9 @@ dhd_os_check_wakelock_all(dhd_pub_t *pub)
 #ifdef DHD_USE_SCAN_WAKELOCK
 	l6 = wake_lock_active(&dhd->wl_scanwake);
 #endif /* DHD_USE_SCAN_WAKELOCK */
-	lock_active = (l1 || l2 || l3 || l4 || l5 || l6);
+	l7 = wake_lock_active(&dhd->wl_evtwake);
+	l8 = wake_lock_active(&dhd->wl_txflwake);
+	lock_active = (l1 || l2 || l3 || l4 || l5 || l6 || l7 || l8);
 
 	/* Indicate to the Host to avoid going to suspend if internal locks are up */
 	if (dhd && lock_active) {
@@ -11907,6 +12987,46 @@ int dhd_os_wake_lock_restore(dhd_pub_t *pub)
 	return ret;
 }
 
+void dhd_os_wake_lock_init(struct dhd_info *dhd)
+{
+	DHD_TRACE(("%s: initialize wake_lock_counters\n", __FUNCTION__));
+	dhd->wakelock_counter = 0;
+	dhd->wakelock_rx_timeout_enable = 0;
+	dhd->wakelock_ctrl_timeout_enable = 0;
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&dhd->wl_rxwake, WAKE_LOCK_SUSPEND, "wlan_rx_wake");
+	wake_lock_init(&dhd->wl_ctrlwake, WAKE_LOCK_SUSPEND, "wlan_ctrl_wake");
+	wake_lock_init(&dhd->wl_evtwake, WAKE_LOCK_SUSPEND, "wlan_evt_wake");
+	wake_lock_init(&dhd->wl_txflwake, WAKE_LOCK_SUSPEND, "wlan_txfl_wake");
+#ifdef BCMPCIE_OOB_HOST_WAKE
+	wake_lock_init(&dhd->wl_intrwake, WAKE_LOCK_SUSPEND, "wlan_oob_irq_wake");
+#endif /* BCMPCIE_OOB_HOST_WAKE */
+#ifdef DHD_USE_SCAN_WAKELOCK
+	wake_lock_init(&dhd->wl_scanwake, WAKE_LOCK_SUSPEND, "wlan_scan_wake");
+#endif /* DHD_USE_SCAN_WAKELOCK */
+#endif /* CONFIG_HAS_WAKELOCK */
+}
+
+void dhd_os_wake_lock_destroy(struct dhd_info *dhd)
+{
+	DHD_TRACE(("%s: deinit wake_lock_counters\n", __FUNCTION__));
+#ifdef CONFIG_HAS_WAKELOCK
+	dhd->wakelock_counter = 0;
+	dhd->wakelock_rx_timeout_enable = 0;
+	dhd->wakelock_ctrl_timeout_enable = 0;
+	wake_lock_destroy(&dhd->wl_rxwake);
+	wake_lock_destroy(&dhd->wl_ctrlwake);
+	wake_lock_destroy(&dhd->wl_evtwake);
+	wake_lock_destroy(&dhd->wl_txflwake);
+#ifdef BCMPCIE_OOB_HOST_WAKE
+	wake_lock_destroy(&dhd->wl_intrwake);
+#endif /* BCMPCIE_OOB_HOST_WAKE */
+#ifdef DHD_USE_SCAN_WAKELOCK
+	wake_lock_destroy(&dhd->wl_scanwake);
+#endif /* DHD_USE_SCAN_WAKELOCK */
+#endif /* CONFIG_HAS_WAKELOCK */
+}
+
 bool dhd_os_check_if_up(dhd_pub_t *pub)
 {
 	if (!pub)
@@ -12593,7 +13713,12 @@ void dhd_get_memdump_info(dhd_pub_t *dhd)
 		DHD_ERROR(("[WIFI_SEC] %s: File [%s] doesn't exist\n", __FUNCTION__, filepath));
 		goto done;
 	} else {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
+		loff_t zero = 0;
+		ret = kernel_read(fp, (void *) &mem_val, (size_t) 4, (loff_t *) &zero);
+#else
 		ret = kernel_read(fp, 0, (char *)&mem_val, 4);
+#endif
 		if (ret < 0) {
 			DHD_ERROR(("[WIFI_SEC] %s: File read error, ret=%d\n", __FUNCTION__, ret));
 			filp_close(fp, NULL);
@@ -13117,6 +14242,114 @@ dhd_pktid_audit_fail_cb(dhd_pub_t *dhdp)
 #endif /* DHD_PKTID_AUDIT_ENABLED */
 #endif /* DHD_DEBUG_PAGEALLOC */
 
+struct tcp_fmt {
+	struct iphdr ip_header;
+	struct tcphdr tcp_header;
+};
+
+#define KP_PORT 5150
+
+static void
+dhd_tcp_dump(char *ifname, uint8 *pktdata, bool tx)
+{
+	struct tcp_fmt *b = (struct tcp_fmt *) &pktdata[ETHER_HDR_LEN];
+	struct iphdr *h = &b->ip_header;
+	uint32 ip_saddr, ip_daddr, c, max_c, opt, tsval_t, tsecr_t;
+	unsigned char *opts;
+
+	/* check IP header */
+	if (h->ihl != 5 || h->version != 4 || h->protocol != IPPROTO_TCP) {
+		return;
+	}
+
+	if ((ntohs(b->tcp_header.source) != KP_PORT) && (ntohs(b->tcp_header.dest) != KP_PORT))
+		return;
+
+	if (tx) {
+		ip_saddr = h->saddr;
+		ip_daddr = h->daddr;
+		ip_id = ntohs(h->id);
+		bcm_ip_ntoa((struct ipv4_addr *)&ip_saddr, sabuf);
+		bcm_ip_ntoa((struct ipv4_addr *)&ip_daddr, dabuf);
+		bcm_ether_ntoa((struct ether_addr *)pktdata, deabuf);
+		bcm_ether_ntoa((struct ether_addr *)(pktdata+6), seabuf);
+		source = ntohs(b->tcp_header.source);
+		dest = ntohs(b->tcp_header.dest);
+		seq = ntohl(b->tcp_header.seq);
+		seq_ack = ntohl(b->tcp_header.ack_seq);
+		window = ntohs(b->tcp_header.window);
+		tcp_data_len = ntohs(h->tot_len) - 20 - (b->tcp_header.doff * 4);
+	}
+
+	tcp_option_len = (b->tcp_header.doff * 4) - 20;
+	if (tcp_option_len) {
+		max_c = tcp_option_len;
+		opts = &pktdata[ETHER_HDR_LEN + 40];
+		for (c = 0; c < max_c; ) {
+			opt = opts[c];
+			switch (opt) {
+			case 0x00:
+				/* End of options. */
+				pr_debug("rk tcp_parseopt: EOL\n");
+				return;
+			case 0x01:
+				/* NOP option. */
+				++c;
+				pr_debug("rk tcp_parseopt: NOP\n");
+				break;
+			case 0x02:
+				pr_debug("rk tcp_parseopt: MSS\n");
+				if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
+					/* Bad length */
+					pr_err("rk tcp_parseopt: bad length\n");
+					return;
+				}
+				/* Advance to next option */
+				c += 0x04;
+				break;
+			case 0x08:
+				pr_debug("rk tcp_parseopt: TS\n");
+				if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
+				  /* Bad length */
+				  pr_err("rk tcp_parseopt: bad length\n");
+				  return;
+				}
+				/* TCP timestamp option with valid length */
+				tsval_t = (opts[c+2]) | (opts[c+3] << 8) |
+				  (opts[c+4] << 16) | (opts[c+5] << 24);
+				tsecr_t = (opts[c+6]) | (opts[c+7] << 8) |
+				  (opts[c+8] << 16) | (opts[c+9] << 24);
+
+				if (tx) {
+					tsval = ntohl(tsval_t);
+					tsecr = ntohl(tsecr_t);
+				} else {
+					tsecr = ntohl(tsval_t);
+					tsval = ntohl(tsecr_t);
+				}
+				/* Advance to next option */
+				c += 0x0A;
+				break;
+			default:
+				pr_debug("rk tcp_parseopt: other\n");
+				if (opts[c + 1] == 0) {
+				  pr_err("rk tcp_parseopt: bad length\n");
+				  /* If the length field is zero, the options are malformed
+					 and we don't process them further. */
+				  return;
+				}
+				/* All other options have a length field, so that we easily
+				   can skip past them. */
+				c += opts[c + 1];
+			}
+		}
+	}
+
+	if (tx)
+		pr_debug("[%s-%s] %s %s %s %s %d, %d, %d, %8u, %8u, %d, %d, %d, %8u, %8u\n", ifname, tx ? "tx" : "rx",
+					sabuf, dabuf, seabuf, deabuf, ip_id, source, dest, seq, seq_ack, window,
+					tcp_option_len, tcp_data_len, tsval, tsecr);
+}
 
 #ifdef DHD_DHCP_DUMP
 static void
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux.h
index 72fc950ca1e2..dd25c1f01f92 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * DHD Linux header file (dhd_linux exports for cfg80211 and other components)
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_platdev.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_platdev.c
index 963117d82285..9c8403d149f8 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_platdev.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_platdev.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux platform device for DHD WLAN adapter
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -42,6 +43,9 @@
 #if defined(CONFIG_WIFI_CONTROL_FUNC)
 #include <linux/wlan_plat.h>
 #endif
+#ifdef BCMDBUS
+#include <dbus.h>
+#endif
 #ifdef CONFIG_DTS
 #include<linux/regulator/consumer.h>
 #include<linux/of_gpio.h>
@@ -195,6 +199,31 @@ int wifi_platform_set_power(wifi_adapter_info_t *adapter, bool on, unsigned long
 	return err;
 }
 
+#if defined(CUSTOMER_IMX)
+extern void wifi_card_detect(bool);
+int wifi_platform_bus_enumerate(wifi_adapter_info_t *adapter, bool device_present)
+{
+	int err = 0;
+	struct wifi_platform_data *plat_data;
+
+	if (!adapter) {
+		pr_err("!!!! %s: failed!  adapter variable is NULL!!!!!\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DHD_ERROR(("%s device present %d\n", __FUNCTION__, device_present));
+
+	if (!adapter->wifi_plat_data) {
+		wifi_card_detect(device_present); /* hook for card_detect */
+	} else {
+		plat_data = adapter->wifi_plat_data;
+		if (plat_data->set_carddetect)
+			err = plat_data->set_carddetect(device_present);
+	}
+
+	return 0; /* force success status returned */
+}
+#else
 int wifi_platform_bus_enumerate(wifi_adapter_info_t *adapter, bool device_present)
 {
 	int err = 0;
@@ -211,6 +240,7 @@ int wifi_platform_bus_enumerate(wifi_adapter_info_t *adapter, bool device_presen
 	return err;
 
 }
+#endif /* CUSTOMER_IMX */
 
 int wifi_platform_get_mac_addr(wifi_adapter_info_t *adapter, unsigned char *buf)
 {
@@ -386,7 +416,11 @@ static struct platform_driver wifi_platform_dev_driver_legacy = {
 	}
 };
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+static int wifi_platdev_match(struct device *dev, const void *data)
+#else
 static int wifi_platdev_match(struct device *dev, void *data)
+#endif
 {
 	char *name = (char*)data;
 	struct platform_device *pdev = to_platform_device(dev);
@@ -457,10 +491,9 @@ static int wifi_ctrlfunc_register_drv(void)
 	if (dts_enabled) {
 		struct resource *resource;
 
-        wifi_plat_dev_probe_ret = dhd_wlan_init_plat_data();
-
-        if (wifi_plat_dev_probe_ret)
-            return wifi_plat_dev_probe_ret;
+		wifi_plat_dev_probe_ret = dhd_wlan_init_plat_data();
+		if (wifi_plat_dev_probe_ret)
+			return wifi_plat_dev_probe_ret;
 
 		adapter->wifi_plat_data = (void *)&dhd_wlan_control;
 		resource = &dhd_wlan_resources;
@@ -802,16 +835,49 @@ static int dhd_wifi_platform_load_sdio(void)
 }
 #endif /* BCMSDIO */
 
+#ifdef BCMDBUS
+/* User-specified vid/pid */
+int dhd_vid = 0xa5c;
+int dhd_pid = 0x48f;
+module_param(dhd_vid, int, 0);
+module_param(dhd_pid, int, 0);
+void *dhd_dbus_probe_cb(void *arg, const char *desc, uint32 bustype, uint32 hdrlen);
+void dhd_dbus_disconnect_cb(void *arg);
+
+static int dhd_wifi_platform_load_usb(void)
+{
+	int err = 0;
+
+	if (dhd_vid < 0 || dhd_vid > 0xffff) {
+		DHD_ERROR(("%s: invalid dhd_vid 0x%x\n", __FUNCTION__, dhd_vid));
+		return -EINVAL;
+	}
+	if (dhd_pid < 0 || dhd_pid > 0xffff) {
+		DHD_ERROR(("%s: invalid dhd_pid 0x%x\n", __FUNCTION__, dhd_pid));
+		return -EINVAL;
+	}
+
+	err = dbus_register(dhd_vid, dhd_pid, dhd_dbus_probe_cb, dhd_dbus_disconnect_cb,
+		NULL, NULL, NULL);
+
+	/* Device not detected */
+	if (err == DBUS_ERR_NODEVICE)
+		err = DBUS_OK;
+
+	return err;
+}
+#else /* BCMDBUS */
 static int dhd_wifi_platform_load_usb(void)
 {
 	return 0;
 }
+#endif /* BCMDBUS */
 
 static int dhd_wifi_platform_load()
 {
 	int err = 0;
 
-	wl_android_init();
+		wl_android_init();
 
 	if ((err = dhd_wifi_platform_load_usb()))
 		goto end;
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_sched.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_sched.c
index 88c0cce635bd..8099e585196e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_sched.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_sched.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Expose some of the kernel scheduler routines
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_wq.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_wq.c
index abbfe48f88f3..35d04fc8a9cf 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_wq.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_wq.c
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Dongle Host Driver (DHD), Generic work queue framework
  * Generic interface to handle dhd deferred work events
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_wq.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_wq.h
index 37f633b09123..f0ab14c29d51 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_wq.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_linux_wq.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Dongle Host Driver (DHD), Generic work queue framework
  * Generic interface to handle dhd deferred work events
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_msgbuf.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_msgbuf.c
index 53354c3697e3..886787e00c24 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_msgbuf.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_msgbuf.c
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /**
  * @file definition of host message ring functionality
  * Provides type definitions and function prototypes used to link the
  * DHD OS, bus, and protocol modules.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -41,7 +42,11 @@
 #include <dhd.h>
 #include <dhd_proto.h>
 
+#ifdef BCMDBUS
+#include <dbus.h>
+#else
 #include <dhd_bus.h>
+#endif /* BCMDBUS */
 
 #include <dhd_dbg.h>
 #include <siutils.h>
@@ -3711,7 +3716,7 @@ dhd_prot_txstatus_process(dhd_pub_t *dhd, void *msg)
 
 		/* Release the Lock when no more tx packets are pending */
 		if (prot->active_tx_count == 0)
-			 DHD_OS_WAKE_UNLOCK(dhd);
+			 DHD_TXFL_WAKE_UNLOCK(dhd);
 
 	} else {
 		DHD_ERROR(("Extra packets are freed\n"));
@@ -4195,7 +4200,7 @@ dhd_prot_txdata(dhd_pub_t *dhd, void *PKTBUF, uint8 ifidx)
 	 * to finish.
 	 */
 	if (prot->active_tx_count == 1)
-		DHD_OS_WAKE_LOCK(dhd);
+		DHD_TXFL_WAKE_LOCK_TIMEOUT(dhd, MAX_TX_TIMEOUT);
 
 	DHD_GENERAL_UNLOCK(dhd, flags);
 
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.c
index 9b501c3f3d62..558fb10b6270 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * DHD Bus Module for PCIE
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.h
index 4bad18a86393..ce42238b7699 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux DHD Bus Module for PCIE
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie_linux.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie_linux.c
index 2bddc3cd50c3..f6c9d6eab8e3 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pcie_linux.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux DHD Bus Module for PCIE
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pno.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pno.c
index 324036429783..418a01f3be1c 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pno.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pno.c
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Dongle Host Driver (DHD)
  * Prefered Network Offload and Wi-Fi Location Service(WLS) code.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pno.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pno.h
index d3a5e3a2c366..ebaa400ef72f 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pno.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_pno.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Header file of Broadcom Dongle Host Driver (DHD)
  * Prefered Network Offload code and Wi-Fi Location Service(WLS) code.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_proto.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_proto.h
index 6221b6e696dd..420a5fe61bd5 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_proto.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_proto.h
@@ -1,10 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Header file describing the internal (inter-module) DHD interfaces.
  *
  * Provides type definitions and function prototypes used to link the
  * DHD OS, bus, and protocol modules.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -113,6 +114,9 @@ extern void dhd_prot_dstats(dhd_pub_t *dhdp);
 extern int dhd_ioctl(dhd_pub_t * dhd_pub, dhd_ioctl_t *ioc, void * buf, uint buflen);
 
 extern int dhd_preinit_ioctls(dhd_pub_t *dhd);
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+extern int dhd_preinit_ioctls_alive(dhd_pub_t *dhd);
+#endif /* LOAD_DHD_WITH_FW_ALIVE */
 
 extern int dhd_process_pkt_reorder_info(dhd_pub_t *dhd, uchar *reorder_info_buf,
 	uint reorder_info_len, void **pkt, uint32 *free_buf_count);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.c
index 21ea0d01b520..28717b5f8a46 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Dongle Host Driver (DHD), RTT
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -1512,7 +1513,11 @@ dhd_rtt_convert_results_to_host(rtt_report_t *rtt_report, uint8 *p_data, uint16
 	wl_proxd_result_flags_t flags;
 	wl_proxd_session_state_t session_state;
 	wl_proxd_status_t proxd_status;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0))
+	struct timespec64 ts;
+#else
 	struct timespec ts;
+#endif
 	uint32 ratespec;
 	uint32 avg_dist;
 	wl_proxd_rtt_sample_t *p_sample;
@@ -1601,7 +1606,11 @@ dhd_rtt_convert_results_to_host(rtt_report_t *rtt_report, uint8 *p_data, uint16
 	}
 	/* time stamp */
 	/* get the time elapsed from boot time */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0))
+	ktime_get_boottime_ts64(&ts);
+#else
 	get_monotonic_boottime(&ts);
+#endif
 	rtt_report->ts = (uint64)TIMESPEC_TO_US(ts);
 
 	if (proxd_status == WL_PROXD_E_REMOTE_FAIL) {
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.h
index 6d2c375a8858..cc5272fdcec3 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_rtt.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Dongle Host Driver (DHD), RTT
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_sdio.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_sdio.c
index fb6988b4c6f2..d059014858e2 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_sdio.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_sdio.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * DHD Bus Module for SDIO
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: dhd_sdio.c 674349 2017-10-19 07:59:24Z $
+ * $Id: dhd_sdio.c 722050 2019-08-21 02:24:57Z $
  */
 
 #include <typedefs.h>
@@ -67,6 +68,10 @@
 #include <dhdioctl.h>
 #include <sdiovar.h>
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+#include <dhd_chip_info.h>
+#endif
+
 #ifdef PROP_TXSTATUS
 #include <dhd_wlfc.h>
 #endif
@@ -98,13 +103,16 @@ extern bool  bcmsdh_fatal_error(void *sdh);
 #define DHD_TXBOUND	20	/* Default for max tx frames in one scheduling */
 #endif
 
-#define DHD_TXMINMAX	1	/* Max tx frames if rx still pending */
+#define DHD_TXMINMAX	DHD_TXBOUND	/* Max tx frames if rx still pending */
 
 #define MEMBLOCK	2048		/* Block size used for downloading of dongle image */
 #define MAX_MEMBLOCK  (32 * 1024)	/* Block size used for downloading of dongle image */
 
 #define MAX_DATA_BUF	(64 * 1024)	/* Must be large enough to hold biggest possible glom */
 
+//added 20190626 for fixed that download fw failed in new kernel version
+#define MAX_MEM_BUF    4096
+
 #ifndef DHD_FIRSTREAD
 #define DHD_FIRSTREAD   32
 #endif
@@ -377,6 +385,7 @@ typedef struct dhd_bus {
 	uint32		txglom_total_len;	/* Total length of pkts in glom array */
 	bool		txglom_enable;	/* Flag to indicate whether tx glom is enabled/disabled */
 	uint32		txglomsize;	/* Glom size limitation */
+	uint8		*membuf;
 #ifdef DHDENABLE_TAILPAD
 	void		*pad_pkt;
 #endif /* DHDENABLE_TAILPAD */
@@ -443,6 +452,9 @@ static bool forcealign;
 
 #define ALIGNMENT  4
 
+#define F2_BLOCK_SIZE_256              256
+#define SDIO_FUNC_BLOCK_SIZE_SHIFT     16
+
 #if defined(OOB_INTR_ONLY) && defined(HW_OOB)
 extern void bcmsdh_enable_hw_oob_intr(void *sdh, bool enable);
 #endif
@@ -749,7 +761,8 @@ dhdsdio_sr_cap(dhd_bus_t *bus)
 		(bus->sih->chip == BCM4358_CHIP_ID) ||
 		(BCM4349_CHIP(bus->sih->chip))		||
 		(bus->sih->chip == BCM4350_CHIP_ID) ||
-		(bus->sih->chip == BCM43012_CHIP_ID)) {
+		(bus->sih->chip == BCM43012_CHIP_ID) ||
+		(bus->sih->chip == BCM4373_CHIP_ID)) {
 		core_capext = TRUE;
 	} else {
 			core_capext = bcmsdh_reg_read(bus->sdh,
@@ -893,6 +906,10 @@ dhdsdio_clk_kso_init(dhd_bus_t *bus)
 #define KSO_WAKE_RETRY_COUNT 100
 #define ERROR_BCME_NODEVICE_MAX 1
 
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/host.h>
+#include "bcmsdh_sdmmc.h"
+
 #define MAX_KSO_ATTEMPTS (PMU_MAX_TRANSITION_DLY/KSO_WAIT_US)
 static int
 dhdsdio_clk_kso_enab(dhd_bus_t *bus, bool on)
@@ -900,6 +917,12 @@ dhdsdio_clk_kso_enab(dhd_bus_t *bus, bool on)
 	uint8 wr_val = 0, rd_val, cmp_val, bmask;
 	int err = 0;
 	int try_cnt = 0;
+	struct mmc_host *host;
+	struct sdioh_info *sd = (struct sdioh_info *)(bus->sdh->sdioh);
+	struct sdio_func *func = sd->func[SDIO_FUNC_0];
+
+	host = func->card->host;
+	mmc_retune_disable(host);
 
 	KSO_DBG(("%s> op:%s\n", __FUNCTION__, (on ? "KSO_SET" : "KSO_CLR")));
 
@@ -913,6 +936,7 @@ dhdsdio_clk_kso_enab(dhd_bus_t *bus, bool on)
 	 * after clearing KSO bit, to avoid polling of KSO bit.
 	 */
 	if ((!on) && (bus->sih->chip == BCM43012_CHIP_ID)) {
+		mmc_retune_enable(host);
 		return err;
 	}
 
@@ -953,6 +977,8 @@ dhdsdio_clk_kso_enab(dhd_bus_t *bus, bool on)
 			__FUNCTION__, (on ? "KSO_SET" : "KSO_CLR"), try_cnt, rd_val, err));
 	}
 
+	mmc_retune_enable(host);
+
 	return err;
 }
 
@@ -1542,7 +1568,7 @@ dhdsdio_bussleep(dhd_bus_t *bus, bool sleep)
 
 		/* Change state */
 		bus->sleeping = TRUE;
-#if defined(SUPPORT_P2P_GO_PS)  || defined(SUSPEND16)
+#if defined(SUPPORT_P2P_GO_PS) || defined(SUSPEND16)
 		wake_up(&bus->bus_sleep);
 #endif /* LINUX && SUPPORT_P2P_GO_PS */
 	} else {
@@ -2836,6 +2862,11 @@ dhdsdio_membytes(dhd_bus_t *bus, bool write, uint32 address, uint8 *data, uint s
 	else
 		dsize = size;
 
+	if (dsize > MAX_MEM_BUF) {
+		DHD_ERROR(("%s: dsize %d > %d\n", __FUNCTION__, dsize, MAX_MEM_BUF));
+		goto xfer_done;
+	}
+
 	/* Set the backplane window to include the start address */
 	if ((bcmerror = dhdsdio_set_siaddr_window(bus, address))) {
 		DHD_ERROR(("%s: window change failed\n", __FUNCTION__));
@@ -2847,10 +2878,16 @@ dhdsdio_membytes(dhd_bus_t *bus, bool write, uint32 address, uint8 *data, uint s
 		DHD_INFO(("%s: %s %d bytes at offset 0x%08x in window 0x%08x\n",
 		          __FUNCTION__, (write ? "write" : "read"), dsize, sdaddr,
 		          (address & SBSDIO_SBWINDOW_MASK)));
-		if ((bcmerror = bcmsdh_rwdata(bus->sdh, write, sdaddr, data, dsize))) {
+		if (write) {
+			memcpy(bus->membuf, data, dsize);
+		}
+		if ((bcmerror = bcmsdh_rwdata(bus->sdh, write, sdaddr, bus->membuf, dsize))) {
 			DHD_ERROR(("%s: membytes transfer failed\n", __FUNCTION__));
 			break;
 		}
+		if (!write) {
+			memcpy(data, bus->membuf, dsize);
+		}
 
 		/* Adjust for next transfer (if any) */
 		if ((size -= dsize)) {
@@ -5225,6 +5262,9 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 					dhd_os_sdunlock(bus->dhd);
 					dhd_rx_frame(bus->dhd, idx, list_head[idx], cnt, 0);
 					dhd_os_sdlock(bus->dhd);
+#if defined(SDIO_ISR_THREAD)
+					BUS_WAKE(bus);
+#endif
 				}
 			}
 		}
@@ -5847,6 +5887,9 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 		dhd_os_sdunlock(bus->dhd);
 		dhd_rx_frame(bus->dhd, ifidx, pkt, pkt_count, chan);
 		dhd_os_sdlock(bus->dhd);
+#if defined(SDIO_ISR_THREAD)
+		BUS_WAKE(bus);
+#endif
 	}
 	rxcount = maxframes - rxleft;
 #ifdef DHD_DEBUG
@@ -6018,16 +6061,12 @@ dhdsdio_isr(void *arg)
 	bcmsdh_intr_disable(sdh);
 	bus->intdis = TRUE;
 
-#if defined(SDIO_ISR_THREAD)
-	DHD_TRACE(("Calling dhdsdio_dpc() from %s\n", __FUNCTION__));
 	DHD_OS_WAKE_LOCK(bus->dhd);
-	dhdsdio_dpc(bus);
+	if (dhdsdio_dpc(bus)) {
+		bus->dpc_sched = TRUE;
+		dhd_sched_dpc(bus->dhd);
+	}
 	DHD_OS_WAKE_UNLOCK(bus->dhd);
-#else
-	bus->dpc_sched = TRUE;
-	dhd_sched_dpc(bus->dhd);
-
-#endif /* defined(SDIO_ISR_THREAD) */
 
 }
 
@@ -6046,6 +6085,9 @@ dhdsdio_dpc(dhd_bus_t *bus)
 	unsigned long flags;
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+	if (in_irq())
+		return TRUE;
+
 	dhd_os_sdlock(bus->dhd);
 	DHD_GENERAL_LOCK(bus->dhd, flags);
 	if (bus->dhd->busstate == DHD_BUS_DOWN) {
@@ -6997,11 +7039,14 @@ dhdsdio_chipmatch(uint16 chipid)
 		return TRUE;
 	if (chipid == BCM43012_CHIP_ID)
 		return TRUE;
+	if (chipid == BCM4373_CHIP_ID)
+		return TRUE;
 	return FALSE;
 }
 
+#ifdef GET_OTP_MAC_ENABLE
 static int
-dhd_conf_get_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, uint8 *mac)
+dhd_get_otp_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, uint8 *mac)
 {
 	int i, err = -1;
 	uint8 *ptr = 0;
@@ -7069,6 +7114,7 @@ dhd_conf_get_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, uint8 *mac)
 
 	return err;
 }
+#endif /* GET_OTP_MAC_ENABLE */
 
 static void *
 dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
@@ -7076,7 +7122,10 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 {
 	int ret;
 	dhd_bus_t *bus;
+#ifdef GET_OTP_MAC_ENABLE
 	struct ether_addr ea_addr;
+#endif
+
 
 	/* Init global variables at run-time, not as part of the declaration.
 	 * This is required to support init/de-init of the driver. Initialization
@@ -7224,10 +7273,12 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 		}
 	}
 
-	if (dhd_conf_get_mac(bus->dhd, sdh, ea_addr.octet)) {
+#ifdef GET_OTP_MAC_ENABLE
+	if (dhd_get_otp_mac(bus->dhd, sdh, ea_addr.octet)) {
 		DHD_TRACE(("%s: Can not read MAC address\n", __FUNCTION__));
 	} else
 		memcpy(bus->dhd->mac.octet, (void *)&ea_addr, ETHER_ADDR_LEN);
+#endif
 
 	/* Ok, have the per-port tell the stack we're open for business */
 	if (dhd_register_if(bus->dhd, 0, TRUE) != 0) {
@@ -7272,14 +7323,19 @@ dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
 
 
 
-	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, DHD_INIT_CLKCTL1, &err);
-	if (!err)
-		clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	if(alive != FW_ALIVE_MAGIC)
+#endif
+	{
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, DHD_INIT_CLKCTL1, &err);
+		if (!err)
+			clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
 
-	if (err || ((clkctl & ~SBSDIO_AVBITS) != DHD_INIT_CLKCTL1)) {
-		DHD_ERROR(("dhdsdio_probe: ChipClkCSR access: err %d wrote 0x%02x read 0x%02x\n",
-		           err, DHD_INIT_CLKCTL1, clkctl));
-		goto fail;
+		if (err || ((clkctl & ~SBSDIO_AVBITS) != DHD_INIT_CLKCTL1)) {
+			DHD_ERROR(("dhdsdio_probe: ChipClkCSR access: err %d wrote 0x%02x read 0x%02x\n",
+				   err, DHD_INIT_CLKCTL1, clkctl));
+			goto fail;
+		}
 	}
 
 #ifdef DHD_DEBUG
@@ -7340,6 +7396,11 @@ dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
 		bus->sih->socitype, bus->sih->chip, bus->sih->chiprev, bus->sih->chippkg));
 #endif /* DHD_DEBUG */
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	card_dev = bus->sih->chip;
+	card_rev = bus->sih->chiprev;
+#endif
+
 
 	bcmsdh_chipinfo(sdh, bus->sih->chip, bus->sih->chiprev);
 
@@ -7408,6 +7469,22 @@ dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
 				bus->dongle_ram_base = ((bus->sih->chiprev < 9) ?
 				CR4_4349_RAM_BASE: CR4_4349_RAM_BASE_FROM_REV_9);
 				break;
+			case BCM4373_CHIP_ID:
+				bus->dongle_ram_base = CR4_4373_RAM_BASE;
+				/* Updating F2 Block size to 256 for 4373 to fix TX Transmit
+				 *   Underflow issue during Bi-Directional Traffic
+				 */
+				{
+					uint fn = 2;
+					fn = fn << SDIO_FUNC_BLOCK_SIZE_SHIFT | F2_BLOCK_SIZE_256;
+					if (bcmsdh_iovar_op(sdh, "sd_blocksize",
+						NULL, 0, &fn, sizeof(fn), TRUE) != BCME_OK) {
+						DHD_ERROR(("%s: Set F2 Block size error\n",
+							__FUNCTION__));
+						goto fail;
+					}
+				}
+				break;
 			default:
 				bus->dongle_ram_base = 0;
 				DHD_ERROR(("%s: WARNING: Using default ram base at 0x%x\n",
@@ -7494,6 +7571,21 @@ dhdsdio_probe_malloc(dhd_bus_t *bus, osl_t *osh, void *sdh)
 		goto fail;
 	}
 
+	bus->membuf = MALLOC(osh, MAX_MEM_BUF);
+	if (bus->membuf == NULL) {
+		DHD_ERROR(("%s: MALLOC of %d-byte membuf failed\n", __FUNCTION__, MAX_MEM_BUF));
+		if (bus->databuf) {
+#ifndef CONFIG_DHD_USE_STATIC_BUF
+			MFREE(osh, bus->databuf, MAX_DATA_BUF);
+#endif
+			bus->databuf = NULL;
+		}
+		if (!bus->rxblen)
+			DHD_OS_PREFREE(bus->dhd, bus->rxbuf, bus->rxblen);
+		goto fail;
+	}
+	memset(bus->membuf, 0, MAX_MEM_BUF);
+
 	/* Align the buffer */
 	if ((uintptr)bus->databuf % DHD_SDALIGN)
 		bus->dataptr = bus->databuf + (DHD_SDALIGN - ((uintptr)bus->databuf % DHD_SDALIGN));
@@ -7519,8 +7611,15 @@ dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh)
 	dhdsdio_pktgen_init(bus);
 #endif /* SDTEST */
 
-	/* Disable F2 to clear any intermediate frame state on the dongle */
-	bcmsdh_cfg_write(sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	if(alive == FW_ALIVE_MAGIC) {
+		bus->txglom_enable = sd_txglom;
+	} else
+#endif /* LOAD_DHD_WITH_FW_ALIVE */
+	{
+		/* Disable F2 to clear any intermediate frame state on the dongle */
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
+	}
 
 	bus->dhd->busstate = DHD_BUS_DOWN;
 	bus->sleeping = FALSE;
@@ -7628,7 +7727,16 @@ dhdsdio_download_firmware(struct dhd_bus *bus, osl_t *osh, void *sdh)
 	/* Download the firmware */
 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 
-	ret = _dhdsdio_download_firmware(bus);
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	if(alive == FW_ALIVE_MAGIC) {
+		ret = 0;
+		bus->alp_only = FALSE;
+		bus->dhd->busstate = DHD_BUS_LOAD;
+		DHD_ERROR(("skip download FW and nv\n"));
+	}
+	else
+#endif
+		ret = _dhdsdio_download_firmware(bus);
 
 	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
 
@@ -7702,6 +7810,11 @@ dhdsdio_release_malloc(dhd_bus_t *bus, osl_t *osh)
 		bus->databuf = NULL;
 	}
 
+	if (bus->membuf) {
+		MFREE(osh, bus->membuf, MAX_DATA_BUF);
+		bus->membuf = NULL;
+	}
+
 	if (bus->vars && bus->varsz) {
 		MFREE(osh, bus->vars, bus->varsz);
 		bus->vars = NULL;
@@ -7778,6 +7891,10 @@ dhdsdio_suspend(void *context)
 		DHD_ERROR(("prot is not inited\n"));
 		return BCME_ERROR;
 	}
+	//added by May 20190628
+	if (bus->dhd->up == FALSE) {
+		return BCME_OK;
+	}
 	DHD_GENERAL_LOCK(bus->dhd, flags);
 	if (bus->dhd->busstate != DHD_BUS_DATA && bus->dhd->busstate != DHD_BUS_SUSPEND) {
 		DHD_ERROR(("not in a readystate to LPBK  is not inited\n"));
@@ -7808,12 +7925,17 @@ dhdsdio_suspend(void *context)
 #endif /* SUPPORT_P2P_GO_PS */
 	ret = dhd_os_check_wakelock(bus->dhd);
 #if defined(SUPPORT_P2P_GO_PS) || defined(SUSPEND16)
-	if (SLPAUTO_ENAB(bus) && (!ret) && (bus->dhd->up) && (bus->dhd->op_mode != DHD_FLAG_HOSTAP_MODE)) {
+	if ((ret) && (bus->dhd->up) && (bus->dhd->op_mode != DHD_FLAG_HOSTAP_MODE)) {
 		if (wait_event_timeout(bus->bus_sleep, bus->sleeping, wait_time) == 0) {
 			if (!bus->sleeping) {
+				bus->dhd->busstate = DHD_BUS_DATA;
 				return 1;
 			}
 		}
+		DHD_GENERAL_LOCK(bus->dhd, flags);
+		bus->dhd->dhd_bus_busy_state &= ~DHD_BUS_BUSY_IN_SUSPEND;
+		dhd_os_busbusy_wake(bus->dhd);
+		DHD_GENERAL_UNLOCK(bus->dhd, flags);
 		return 0;
 	}
 #endif /* SUPPORT_P2P_GO_PS */
@@ -7831,6 +7953,11 @@ dhdsdio_resume(void *context)
 	dhd_bus_t *bus = (dhd_bus_t*)context;
 	unsigned long flags;
 
+	//added by May 20190628
+	if (bus->dhd->up == FALSE) {
+		return BCME_OK;
+	}
+
 	DHD_GENERAL_LOCK(bus->dhd, flags);
 	bus->dhd->busstate = DHD_BUS_DATA;
 	DHD_GENERAL_UNLOCK(bus->dhd, flags);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.c
index 10652361a6f2..f8f1595efb64 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * DHD PROP_TXSTATUS Module.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -38,7 +39,12 @@
 #include <dngl_stats.h>
 #include <dhd.h>
 
+#ifdef BCMDBUS /* an abstraction layer that hides details of the underlying bus, eg \
+	Linux USB */
+#include <dbus.h>
+#else
 #include <dhd_bus.h>
+#endif /* BCMDBUS */
 
 #include <dhd_dbg.h>
 
@@ -66,6 +72,9 @@
 #define WLFC_THREAD_RETRY_WAIT_MS          10000   /* 10 sec */
 #endif /* defined (DHD_WLFC_THREAD) */
 
+#if defined(BCMDBUS)
+extern int dhd_dbus_txdata(dhd_pub_t *dhdp, void *pktbuf);
+#endif
 
 #ifdef PROP_TXSTATUS
 
@@ -997,6 +1006,8 @@ _dhd_wlfc_send_signalonly_packet(athost_wl_status_info_t* ctx, wlfc_mac_descript
 
 #if defined(BCMPCIE)
 		rc = dhd_bus_txdata(dhdp->bus, p, ctx->host_ifidx);
+#elif defined(BCMDBUS)
+		rc = dhd_dbus_txdata(dhdp, p);
 #else
 		rc = dhd_bus_txdata(dhdp->bus, p);
 #endif
@@ -1617,6 +1628,7 @@ _dhd_wlfc_pktq_flush(athost_wl_status_info_t* ctx, struct pktq *pq,
 		ASSERT(pq->len == 0);
 } /* _dhd_wlfc_pktq_flush */
 
+#ifndef BCMDBUS
 
 /** !BCMDBUS specific function. Dequeues a packet from the caller supplied queue. */
 static void*
@@ -1724,6 +1736,8 @@ _dhd_wlfc_cleanup_txq(dhd_pub_t *dhd, f_processpkt_t fn, void *arg)
 	}
 } /* _dhd_wlfc_cleanup_txq */
 
+#endif /* !BCMDBUS */
+
 /** called during eg detach */
 void
 _dhd_wlfc_cleanup(dhd_pub_t *dhd, f_processpkt_t fn, void *arg)
@@ -1741,8 +1755,10 @@ _dhd_wlfc_cleanup(dhd_pub_t *dhd, f_processpkt_t fn, void *arg)
 	/*
 	*  flush sequence should be txq -> psq -> hanger/afq, hanger has to be last one
 	*/
+#ifndef BCMDBUS
 	/* flush bus->txq */
 	_dhd_wlfc_cleanup_txq(dhd, fn, arg);
+#endif /* BCMDBUS */
 
 	/* flush psq, search all entries, include nodes as well as interfaces */
 	total_entries = sizeof(wlfc->destination_entries)/sizeof(wlfc_mac_descriptor_t);
@@ -2464,6 +2480,7 @@ _dhd_wlfc_fifocreditback_indicate(dhd_pub_t *dhd, uint8* credits)
 	return BCME_OK;
 } /* _dhd_wlfc_fifocreditback_indicate */
 
+#ifndef BCMDBUS
 
 /** !BCMDBUS specific function */
 static void
@@ -2541,6 +2558,8 @@ _dhd_wlfc_suppress_txq(dhd_pub_t *dhd, f_processpkt_t fn, void *arg)
 	}
 } /* _dhd_wlfc_suppress_txq */
 
+#endif /* !BCMDBUS */
+
 static int
 _dhd_wlfc_dbg_senum_check(dhd_pub_t *dhd, uint8 *value)
 {
@@ -3063,10 +3082,12 @@ dhd_wlfc_parse_header_info(dhd_pub_t *dhd, void* pktbuf, int tlv_hdr_len, uchar
 				_dhd_wlfc_interface_update(dhd, value, type);
 			}
 
+#ifndef BCMDBUS
 			if (entry && WLFC_GET_REORDERSUPP(dhd->wlfc_mode)) {
 				/* suppress all packets for this mac entry from bus->txq */
 				_dhd_wlfc_suppress_txq(dhd, _dhd_wlfc_entrypkt_fn, entry);
 			}
+#endif /* !BCMDBUS */
 		} /* while */
 
 		if (remainder != 0 && wlfc) {
@@ -3394,6 +3415,15 @@ dhd_wlfc_commit_packets(dhd_pub_t *dhdp, f_commitpkt_t fcommit, void* commit_ctx
 
 	ctx = (athost_wl_status_info_t*)dhdp->wlfc_state;
 
+#ifdef BCMDBUS
+	if (!dhdp->up || (dhdp->busstate == DHD_BUS_DOWN)) {
+		if (pktbuf) {
+			PKTFREE(ctx->osh, pktbuf, TRUE);
+			rc = BCME_OK;
+		}
+		goto exit;
+	}
+#endif
 
 	if (dhdp->proptxstatus_module_ignore) {
 		if (pktbuf) {
@@ -3580,10 +3610,17 @@ dhd_wlfc_init(dhd_pub_t *dhd)
 		DHD_INFO(("%s: query wlfc_mode succeed, fw_caps=0x%x\n", __FUNCTION__, fw_caps));
 
 		if (WLFC_IS_OLD_DEF(fw_caps)) {
+#ifdef BCMDBUS
+			mode = WLFC_MODE_HANGER;
+#else
 			/* enable proptxtstatus v2 by default */
 			mode = WLFC_MODE_AFQ;
+#endif /* BCMDBUS */
 		} else {
 			WLFC_SET_AFQ(mode, WLFC_GET_AFQ(fw_caps));
+#ifdef BCMDBUS
+			WLFC_SET_AFQ(mode, 0);
+#endif /* BCMDBUS */
 			WLFC_SET_REUSESEQ(mode, WLFC_GET_REUSESEQ(fw_caps));
 			WLFC_SET_REORDERSUPP(mode, WLFC_GET_REORDERSUPP(fw_caps));
 		}
@@ -3664,7 +3701,9 @@ dhd_wlfc_cleanup_txq(dhd_pub_t *dhd, f_processpkt_t fn, void *arg)
 		return WLFC_UNSUPPORTED;
 	}
 
+#ifndef BCMDBUS
 	_dhd_wlfc_cleanup_txq(dhd, fn, arg);
+#endif /* !BCMDBUS */
 
 	dhd_os_wlfc_unblock(dhd);
 
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.h
index f95969c0bc95..5c845941c94a 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dhd_wlfc.h
@@ -1,5 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -111,8 +112,13 @@ typedef struct wlfc_hanger {
 
 #define WLFC_PSQ_LEN			2048
 
+#ifdef BCMDBUS
+#define WLFC_FLOWCONTROL_HIWATER	512
+#define WLFC_FLOWCONTROL_LOWATER	(WLFC_FLOWCONTROL_HIWATER / 4)
+#else
 #define WLFC_FLOWCONTROL_HIWATER	(2048 - 256)
 #define WLFC_FLOWCONTROL_LOWATER	256
+#endif
 
 #if (WLFC_FLOWCONTROL_HIWATER >= (WLFC_PSQ_LEN - 256))
 #undef WLFC_FLOWCONTROL_HIWATER
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dngl_stats.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dngl_stats.h
index dd6338724a1d..f480eedafd4f 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dngl_stats.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dngl_stats.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Common stats definitions for clients of dongle
  * ports
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dngl_wlhdr.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dngl_wlhdr.h
index 96da42e5f570..0c6c220d5703 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dngl_wlhdr.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/dngl_wlhdr.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Dongle WL Header definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hnd_pktpool.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hnd_pktpool.c
index 5b0da6114f19..01157e7d30d3 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hnd_pktpool.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hnd_pktpool.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HND generic packet pool operation primitives
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hnd_pktq.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hnd_pktq.c
index 8bc636e00c2f..bbf3189338d4 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hnd_pktq.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hnd_pktq.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HND generic pktq operation primitives
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -61,7 +62,7 @@ pktq_penq(struct pktq *pq, int prec, void *p)
 
 	ASSERT(prec >= 0 && prec < pq->num_prec);
 	/* queueing chains not allowed and no segmented SKB (Kernel-3.18.y) */
-	ASSERT(!((PKTLINK(p) != NULL) && (PKTLINK(p) != p)));
+	//ASSERT(!((PKTLINK(p) != NULL) && (PKTLINK(p) != p)));
 
 	ASSERT(!pktq_full(pq));
 	ASSERT(!pktq_pfull(pq, prec));
@@ -100,7 +101,7 @@ pktq_penq_head(struct pktq *pq, int prec, void *p)
 
 	ASSERT(prec >= 0 && prec < pq->num_prec);
 	/* queueing chains not allowed and no segmented SKB (Kernel-3.18.y) */
-	ASSERT(!((PKTLINK(p) != NULL) && (PKTLINK(p) != p)));
+	//ASSERT(!((PKTLINK(p) != NULL) && (PKTLINK(p) != p)));
 
 	ASSERT(!pktq_full(pq));
 	ASSERT(!pktq_pfull(pq, prec));
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hndpmu.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hndpmu.c
index 25018874abe4..bd1e45027d72 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hndpmu.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/hndpmu.c
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc utility routines for accessing PMU corerev specific features
  * of the SiliconBackplane-based Broadcom chips.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/aidmp.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/aidmp.h
index bd49c982691f..f952a99724b9 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/aidmp.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/aidmp.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom AMBA Interconnect definitions.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_cfg.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_cfg.h
index 12e3cb2ca27a..c4b94dab7297 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_cfg.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_cfg.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BCM common config options
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_mpool_pub.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_mpool_pub.h
index 1e9a3ced5a9e..047660b5a42c 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_mpool_pub.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_mpool_pub.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Memory pools library, Public interface
  *
@@ -35,7 +36,7 @@
  *              and instrumentation on top of the heap, without modifying the heap
  *              allocation implementation.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_ring.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_ring.h
index 72dfc4290086..cea1983a4815 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_ring.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcm_ring.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __bcm_ring_included__
 #define __bcm_ring_included__
 
@@ -81,7 +82,7 @@
  * private L1 data cache.
  * +----------------------------------------------------------------------------
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmcdc.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmcdc.h
index a7d3d4af6e39..32d16f3882d7 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmcdc.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmcdc.h
@@ -1,10 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * CDC network driver ioctl/indication encoding
  * Broadcom 802.11abg Networking Device Driver
  *
  * Definitions subject to change without notice.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmdefs.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmdefs.h
index 125a28e0371f..6e17cf0e07eb 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmdefs.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmdefs.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc system wide definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: bcmdefs.h 588205 2015-09-23 11:54:25Z $
+ * $Id: bcmdefs.h 715966 2019-05-30 02:36:59Z $
  */
 
 #ifndef	_bcmdefs_h_
@@ -388,6 +389,6 @@ extern bool _pciedevenab;
 #endif /* DL_NVRAM */
 
 extern uint32 gFWID;
-
+#define SEC_ENHANCEMENT
 
 #endif /* _bcmdefs_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmdevs.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmdevs.h
index 9d0823a83d9e..923cbea87ae2 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmdevs.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmdevs.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom device-specific manifest constants.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: bcmdevs.h 596448 2015-11-01 13:29:01Z $
+ * $Id: bcmdevs.h 708808 2018-11-27 03:12:35Z $
  */
 
 #ifndef	_BCMDEVS_H
@@ -55,6 +56,7 @@
 #define	VENDOR_BROADCOM_SDIO	0x00BF
 
 /* DONGLE VID/PIDs */
+#define CY_DNGL_VID             0x04b4
 #define BCM_DNGL_VID		0x0a5c
 #define BCM_DNGL_BL_PID_4328	0xbd12
 #define BCM_DNGL_BL_PID_4322	0xbd13
@@ -77,6 +79,7 @@
 #define BCM_DNGL_BL_PID_4354	0xbd26
 #define BCM_DNGL_BL_PID_43569   0xbd27
 #define BCM_DNGL_BL_PID_43909	0xbd28
+#define BCM_DNGL_BL_PID_4373    0xbd29
 
 #define BCM_DNGL_BDC_PID	0x0bdc
 #define BCM_DNGL_JTAG_PID	0x4a44
@@ -275,6 +278,10 @@
 #define BCM4356_D11AC2G_ID	0x43ed		/* 4356 802.11ac 2.4G device */
 #define BCM4356_D11AC5G_ID	0x43ee		/* 4356 802.11ac 5G device */
 
+#define BCM4373_D11AC_ID	0x4418		/* 4373 802.11ac dualband device */
+#define BCM4373_D11AC2G_ID	0x4419		/* 4373 802.11ac 2.4G device */
+#define BCM4373_D11AC5G_ID	0x441a		/* 4373 802.11ac 5G device */
+
 #define	BCMGPRS_UART_ID		0x4333		/* Uart id used by 4306/gprs card */
 #define	BCMGPRS2_UART_ID	0x4344		/* Uart id used by 4306/gprs card */
 #define FPGA_JTAGM_ID		0x43f0		/* FPGA jtagm device id */
@@ -313,6 +320,7 @@
 #define	BCM4716_DEVICE_ID	0x4722		/* 4716 base devid */
 #define	BCM47XX_USB30H_ID	0x472a		/* 47xx usb 3.0 host */
 #define	BCM47XX_USB30D_ID	0x472b		/* 47xx usb 3.0 device */
+#define BCM47XX_USBHUB_ID	0x472c		/* 47xx usb hub */
 #define BCM47XX_SMBUS_EMU_ID	0x47fe		/* 47xx emulated SMBus device */
 #define	BCM47XX_XOR_EMU_ID	0x47ff		/* 47xx emulated XOR engine */
 #define	EPI41210_DEVICE_ID	0xa0fa		/* bcm4210 */
@@ -479,6 +487,7 @@
 #define BCM53573_CHIP(chipid)	(CHIPID(chipid) == BCM53573_CHIP_ID)
 #define BCM53573_CHIP_GRPID	BCM53573_CHIP_ID
 #define	BCM43012_CHIP_ID	0xA804		/* 43012 chipcommon chipid */
+#define BCM4373_CHIP_ID		0x4373		/* 4373 chipcommon chipid */
 
 /* Package IDs */
 #define	BCM4303_PKG_ID		2		/* 4303 package id */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmendian.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmendian.h
index 00adedf1cd97..d9031a4e975c 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmendian.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmendian.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Byte order utilities
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmmsgbuf.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmmsgbuf.h
index ca0bb21483db..6527b613af07 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmmsgbuf.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmmsgbuf.h
@@ -1,10 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * MSGBUF network driver ioctl/indication encoding
  * Broadcom 802.11abg Networking Device Driver
  *
  * Definitions subject to change without notice.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmnvram.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmnvram.h
index 7f6c51be3e04..35020577bcb7 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmnvram.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmnvram.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * NVRAM variable manipulation
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmpcie.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmpcie.h
index cd97c7267c81..67e5b99eea03 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmpcie.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmpcie.h
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom PCIE
  * Software-specific definitions shared between device and host side
  * Explains the shared area between host and dongle
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmpcispi.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmpcispi.h
index b3502ea7b884..7604fee034ea 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmpcispi.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmpcispi.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom PCI-SPI Host Controller Register Definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmperf.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmperf.h
index 09e607fc9b74..7c9595beac3f 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmperf.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmperf.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Performance counters software interface.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdbus.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdbus.h
index 88635f1eaec2..1306f4630cc8 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdbus.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdbus.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Definitions for API from sdio common code (bcmsdh) to individual
  * host controller drivers.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdh.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdh.h
index 2717a9097d0d..f3fd6de40a8d 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdh.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdh.h
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SDIO host client driver interface of Broadcom HNBU
  *     export functions to client drivers
  *     abstract OS and BUS specific details of SDIO
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdh_sdmmc.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdh_sdmmc.h
index b706289b0e85..0f3171c198d5 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdh_sdmmc.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdh_sdmmc.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BCMSDH Function Driver for the native SDIO/MMC driver in the Linux Kernel
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -30,12 +31,12 @@
 #ifndef __BCMSDH_SDMMC_H__
 #define __BCMSDH_SDMMC_H__
 
-#define sd_err(x)	do { if (sd_msglevel & SDH_ERROR_VAL) printf x; } while (0)
-#define sd_trace(x)	do { if (sd_msglevel & SDH_TRACE_VAL) printf x; } while (0)
-#define sd_info(x)	do { if (sd_msglevel & SDH_INFO_VAL) printf x; } while (0)
-#define sd_debug(x)	do { if (sd_msglevel & SDH_DEBUG_VAL) printf x; } while (0)
-#define sd_data(x)	do { if (sd_msglevel & SDH_DATA_VAL) printf x; } while (0)
-#define sd_ctrl(x)	do { if (sd_msglevel & SDH_CTRL_VAL) printf x; } while (0)
+#define sd_err(x)       do { if (sd_msglevel & SDH_ERROR_VAL) printf x; } while (0)
+#define sd_trace(x)     do { if (sd_msglevel & SDH_TRACE_VAL) printf x; } while (0)
+#define sd_info(x)      do { if (sd_msglevel & SDH_INFO_VAL) printf x; } while (0)
+#define sd_debug(x)     do { if (sd_msglevel & SDH_DEBUG_VAL) printf x; } while (0)
+#define sd_data(x)      do { if (sd_msglevel & SDH_DATA_VAL) printf x; } while (0)
+#define sd_ctrl(x)      do { if (sd_msglevel & SDH_CTRL_VAL) printf x; } while (0)
 
 
 #define sd_sync_dma(sd, read, nbytes)
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdpcm.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdpcm.h
index 78f212ad80f8..56941c2a9cd5 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdpcm.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdpcm.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom SDIO/PCMCIA
  * Software-specific definitions shared between device and host side
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdspi.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdspi.h
index 537876c3696d..76ab5e37ce35 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdspi.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdspi.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SD-SPI Protocol Conversion - BCMSDH->SPI Translation Layer
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdstd.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdstd.h
index ff3b0d1f2750..c8c73e73d14e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdstd.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsdstd.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  *  'Standard' SDIO HOST CONTROLLER driver
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmspi.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmspi.h
index 9b4bd2d8ac0d..f1f74a290022 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmspi.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmspi.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom SPI Low-Level Hardware Driver API
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmspibrcm.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmspibrcm.h
index e9735ffc621a..27fa8c52860d 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmspibrcm.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmspibrcm.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SD-SPI Protocol Conversion - BCMSDH->gSPI Translation Layer
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsrom_fmt.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsrom_fmt.h
index 2eabfaf62709..db2708079077 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsrom_fmt.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsrom_fmt.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SROM format definition.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsrom_tbl.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsrom_tbl.h
index acc9b91c98da..f62850d4f943 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsrom_tbl.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmsrom_tbl.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Table that encodes the srom formats for PCI/PCIe NICs.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmutils.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmutils.h
index 0a0bff823654..15b30d326ff5 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmutils.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/bcmutils.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc useful os-independent macros and functions.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: bcmutils.h 569587 2015-07-08 16:41:50Z $
+ * $Id: bcmutils.h 696078 2018-08-15 09:24:11Z $
  */
 
 #ifndef	_bcmutils_h_
@@ -1111,6 +1112,7 @@ extern void bcm_uint64_right_shift(uint32* r, uint32 a_high, uint32 a_low, uint3
 
 void bcm_add_64(uint32* r_hi, uint32* r_lo, uint32 offset);
 void bcm_sub_64(uint32* r_hi, uint32* r_lo, uint32 offset);
+uint16 ipv4_hdr_cksum(uint8 *ip, int ip_len);
 
 /* calculate checksum for ip header, tcp / udp header / data */
 uint16 bcm_ip_cksum(uint8 *buf, uint32 len, uint32 sum);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/brcm_nl80211.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/brcm_nl80211.h
index 43d66609a3a7..57196a5133d5 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/brcm_nl80211.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/brcm_nl80211.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Definitions for nl80211 vendor command/event access to host driver
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/dbus.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/dbus.h
index e14405dce088..ff36ab424c5f 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/dbus.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/dbus.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Dongle BUS interface Abstraction layer
  *   target serial buses like USB, SDIO, SPI, etc.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/devctrl_if/wlioctl_defs.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/devctrl_if/wlioctl_defs.h
index 7a54625a1daf..161109b7042e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/devctrl_if/wlioctl_defs.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/devctrl_if/wlioctl_defs.h
@@ -1,10 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Custom OID/ioctl definitions for
  * Broadcom 802.11abg Networking Device Driver
  *
  * Definitions subject to change without notice.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -27,7 +28,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: wlioctl_defs.h 607461 2015-12-20 02:01:43Z $
+ * $Id: wlioctl_defs.h 640883 2016-05-31 12:45:03Z $
  */
 
 
@@ -35,8 +36,6 @@
 #define wlioctl_defs_h
 
 
-
-
 /* All builds use the new 11ac ratespec/chanspec */
 #undef  D11AC_IOTYPES
 #define D11AC_IOTYPES
@@ -343,6 +342,10 @@
 #define WL_BSS_FLAGS_SNR_INVALID	0x40	/* BSS contains invalid SNR */
 #define WL_BSS_FLAGS_NF_INVALID		0x80	/* BSS contains invalid noise floor */
 
+/* bit definitions for bcnflags in wl_bss_info */
+#define WL_BSS_BCNFLAGS_INTERWORK_PRESENT	0x01 /* beacon had IE, accessnet valid */
+#define WL_BSS_BCNFLAGS_INTERWORK_PRESENT_VALID 0x02 /* on indicates support for this API */
+
 /* bssinfo flag for nbss_cap */
 #define VHT_BI_SGI_80MHZ			0x00000100
 #define VHT_BI_80MHZ			    0x00000200
@@ -385,6 +388,26 @@
 
 #define CRYPTO_ALGO_NONE        CRYPTO_ALGO_OFF
 
+/* algo bit vector */
+#define KEY_ALGO_MASK(_algo)	(1 << _algo)
+
+#if defined(BCMEXTCCX)
+#define KEY_ALGO_MASK_CCX		(KEY_ALGO_MASK(CRYPTO_ALGO_CKIP) | \
+					KEY_ALGO_MASK(CRYPTO_ALGO_CKIP_MMH) | \
+					KEY_ALGO_MASK(CRYPTO_ALGO_WEP_MMH))
+#endif 
+
+#define KEY_ALGO_MASK_WEP		(KEY_ALGO_MASK(CRYPTO_ALGO_WEP1) | \
+					KEY_ALGO_MASK(CRYPTO_ALGO_WEP128) | \
+					KEY_ALGO_MASK(CRYPTO_ALGO_NALG))
+
+#define KEY_ALGO_MASK_AES		(KEY_ALGO_MASK(CRYPTO_ALGO_AES_CCM) | \
+					KEY_ALGO_MASK(CRYPTO_ALGO_AES_CCM256) | \
+					KEY_ALGO_MASK(CRYPTO_ALGO_AES_GCM) | \
+					KEY_ALGO_MASK(CRYPTO_ALGO_AES_GCM256))
+#define KEY_ALGO_MASK_TKIP		(KEY_ALGO_MASK(CRYPTO_ALGO_TKIP))
+#define KEY_ALGO_MASK_WAPI		(KEY_ALGO_MASK(CRYPTO_ALGO_SMS4))
+
 #define WSEC_GEN_MIC_ERROR	0x0001
 #define WSEC_GEN_REPLAY		0x0002
 #define WSEC_GEN_ICV_ERROR	0x0004
@@ -410,14 +433,15 @@
 #define WSEC_SWFLAG		0x0008
 #define SES_OW_ENABLED		0x0040	/* to go into transition mode without setting wep */
 
-/* wsec macros for operating on the above definitions */
 #define WSEC_WEP_ENABLED(wsec)	((wsec) & WEP_ENABLED)
 #define WSEC_TKIP_ENABLED(wsec)	((wsec) & TKIP_ENABLED)
 #define WSEC_AES_ENABLED(wsec)	((wsec) & AES_ENABLED)
 
 #define WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
+
 #define WSEC_SES_OW_ENABLED(wsec)	((wsec) & SES_OW_ENABLED)
 
+
 /* Following macros are not used any more. Just kept here to
  * avoid build issue in BISON/CARIBOU branch
  */
@@ -1169,6 +1193,7 @@
 #define WL_LOFT_VAL		0x00000000	/* retired in TOT on 6/10/2009 */
 #define WL_PFN_VAL		0x00040000 /* Using retired LOFT_VAL */
 #define WL_REGULATORY_VAL	0x00080000
+#define WL_CSA_VAL		0x00080000  /* Reusing REGULATORY_VAL due to lackof bits */
 #define WL_TAF_VAL		0x00100000
 #define WL_RADAR_VAL		0x00000000	/* retired in TOT on 6/10/2009 */
 #define WL_WDI_VAL		0x00200000	/* Using retired WL_RADAR_VAL VAL */
@@ -1191,6 +1216,8 @@
  */
 #define WL_DPT_VAL		0x00000001
 /* re-using WL_DPT_VAL */
+/* re-using WL_MESH_VAL */
+#define WL_NATOE_VAL		0x00000001
 #define WL_MESH_VAL		0x00000001
 #define WL_SCAN_VAL		0x00000002
 #define WL_WOWL_VAL		0x00000004
@@ -1220,8 +1247,12 @@
 
 /* This level is currently used in Phoenix2 only */
 #define WL_SRSCAN_VAL		0x02000000
+/* Reusing it for CXO in trunk */
+#define WL_CXO_VAL		0x02000000
 
 #define WL_WNM_VAL		0x04000000
+/* re-using WL_WNM_VAL for MBO */
+#define WL_MBO_VAL		0x04000000
 #define WL_PWRSEL_VAL		0x10000000
 #define WL_NET_DETECT_VAL	0x20000000
 #define WL_PCIE_VAL		0x40000000
@@ -1275,6 +1306,8 @@
 #define BCMIO_NBBY		8
 #define WL_EVENTING_MASK_LEN	16
 
+#define WL_EVENTING_MASK_EXT_LEN \
+    MAX(WL_EVENTING_MASK_LEN, (ROUNDUP(WLC_E_LAST, NBBY)/NBBY))
 
 /* join preference types */
 #define WL_JOIN_PREF_RSSI	1	/* by RSSI */
@@ -1445,8 +1478,7 @@
 #define WL_WOWL_EAPID           (1 << 7)    /* Wakeup after receipt of EAP-Identity Req */
 #define WL_WOWL_PME_GPIO        (1 << 8)    /* Wakeind via PME(0) or GPIO(1) */
 #define WL_WOWL_ULP_BAILOUT     (1 << 8)    /* wakeind via unknown pkt by basic ULP-offloads -
- * WL_WOWL_ULP_BAILOUT - same as WL_WOWL_PME_GPIO used only for DONGLE BUILDS and
- * not WLC_HIGH_ONLY case
+ * WL_WOWL_ULP_BAILOUT - same as WL_WOWL_PME_GPIO used only for DONGLE BUILDS
  */
 #define WL_WOWL_NEEDTKIP1       (1 << 9)    /* need tkip phase 1 key to be updated by the driver */
 #define WL_WOWL_GTK_FAILURE     (1 << 10)   /* enable wakeup if GTK fails */
@@ -1547,6 +1579,7 @@
 #define VNDR_IE_PRBREQ_FLAG	0x10
 #define VNDR_IE_ASSOCREQ_FLAG	0x20
 #define VNDR_IE_IWAPID_FLAG	0x40 /* vendor IE in IW advertisement protocol ID field */
+#define VNDR_IE_AUTHREQ_FLAG	0x80
 #define VNDR_IE_CUSTOM_FLAG	0x100 /* allow custom IE id */
 
 #if defined(WLP2P)
@@ -1598,7 +1631,13 @@
 #define CCASTATS_TXOP	6
 #define CCASTATS_GDTXDUR        7
 #define CCASTATS_BDTXDUR        8
+
+#ifndef WLCHANIM_V2
 #define CCASTATS_MAX    9
+#else /* WLCHANIM_V2 */
+#define CCASTATS_MYRX      9
+#define CCASTATS_MAX    10
+#endif /* WLCHANIM_V2 */
 
 #define WL_CHANIM_COUNT_ALL	0xff
 #define WL_CHANIM_COUNT_ONE	0x1
@@ -1874,8 +1913,14 @@
 #define BESTN_BSSID_ONLY_MASK		0x1000
 
 #define PFN_VERSION			2
+#ifdef PFN_SCANRESULT_2
+#define PFN_SCANRESULT_VERSION		2
+#else
 #define PFN_SCANRESULT_VERSION		1
+#endif /* PFN_SCANRESULT_2 */
+#ifndef MAX_PFN_LIST_COUNT
 #define MAX_PFN_LIST_COUNT		16
+#endif /* MAX_PFN_LIST_COUNT */
 
 #define PFN_COMPLETE			1
 #define PFN_INCOMPLETE			0
@@ -1912,7 +1957,7 @@
 #define MAX_BSSID_BLACKLIST_NUM        32
 
 #ifndef BESTN_MAX
-#define BESTN_MAX			8
+#define BESTN_MAX			10
 #endif
 
 #ifndef MSCAN_MAX
@@ -2133,4 +2178,15 @@
 #define AP_ISOLATE_SENDUP_ALL		0x01
 #define AP_ISOLATE_SENDUP_MCAST		0x02
 
+/* Type values for the wl_pwrstats_t data field */
+#define WL_PWRSTATS_TYPE_PHY		0 /**< struct wl_pwr_phy_stats */
+#define WL_PWRSTATS_TYPE_SCAN		1 /**< struct wl_pwr_scan_stats */
+#define WL_PWRSTATS_TYPE_USB_HSIC	2 /**< struct wl_pwr_usb_hsic_stats */
+#define WL_PWRSTATS_TYPE_PM_AWAKE1	3 /**< struct wl_pwr_pm_awake_stats_v1 */
+#define WL_PWRSTATS_TYPE_CONNECTION	4 /* struct wl_pwr_connect_stats; assoc and key-exch time */
+#define WL_PWRSTATS_TYPE_PCIE		6 /**< struct wl_pwr_pcie_stats */
+#define WL_PWRSTATS_TYPE_PM_AWAKE2	7 /**< struct wl_pwr_pm_awake_stats_v2 */
+#define WL_PWRSTATS_TYPE_SDIO		8 /* struct wl_pwr_sdio_stats */
+#define WL_PWRSTATS_TYPE_MIMO_PS_METRICS 9 /* struct wl_mimo_meas_metrics_t */
+
 #endif /* wlioctl_defs_h */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/dhdioctl.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/dhdioctl.h
index 71221f2b600e..be1d13775a18 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/dhdioctl.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/dhdioctl.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Definitions for ioctls to access DHD iovars.
  * Based on wlioctl.h (for Broadcom 802.11abg driver).
@@ -5,7 +6,7 @@
  *
  * Definitions subject to change without notice.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/epivers.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/epivers.h
index b7bf8e12e4f5..f4889217680c 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/epivers.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/epivers.h
@@ -1,5 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -35,17 +36,17 @@
 
 #define	EPI_RC_NUMBER		125
 
-#define	EPI_INCREMENTAL_NUMBER	7
+#define	EPI_INCREMENTAL_NUMBER	19
 
 #define	EPI_BUILD_NUMBER	0
 
-#define	EPI_VERSION		1, 363, 125, 7
+#define	EPI_VERSION		1, 363, 125, 19
 
-#define	EPI_VERSION_NUM		0x0116b7d0
+#define	EPI_VERSION_NUM		0x0116b7d1
 
 #define EPI_VERSION_DEV		1.363.125
 
 /* Driver Version String, ASCII, 32 chars max */
-#define	EPI_VERSION_STR		"1.363.125.7 (r)"
+#define	EPI_VERSION_STR		"1.363.125.19 (r)"
 
 #endif /* _epivers_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/event_log.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/event_log.h
index 7d9ee636e2cf..19732d28f916 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/event_log.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/event_log.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * EVENT_LOG system definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/event_trace.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/event_trace.h
index 3907503e1d9d..2bed0454ccf3 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/event_trace.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/event_trace.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Trace log blocks sent over HBUS
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_armtrap.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_armtrap.h
index e9ee8ff47581..5f65d72bbdb3 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_armtrap.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_armtrap.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HND arm trap handling.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_cons.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_cons.h
index 7b2b90a67cc4..06971828af68 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_cons.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_cons.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Console support for RTE - for host use only.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_debug.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_debug.h
index 113ec10058cf..250c8fcf2470 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_debug.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_debug.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HND Run Time Environment debug info area
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_pktpool.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_pktpool.h
index 8c3a76143278..f9e6f3d8af60 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_pktpool.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_pktpool.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HND generic packet pool operation primitives
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_pktq.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_pktq.h
index f555100e7ed4..e4841fdc3ce1 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_pktq.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hnd_pktq.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HND generic pktq operation primitives
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hndpmu.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hndpmu.h
index d9c2774a121d..9d5629ae834a 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hndpmu.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hndpmu.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HND SiliconBackplane PMU support.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hndsoc.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hndsoc.h
index aa32105d2b12..822d7fae57f3 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hndsoc.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/hndsoc.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom HND chip & on-chip-interconnect-related definitions.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/linux_osl.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/linux_osl.h
index 9c19f765de6a..e6dad98fd00c 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/linux_osl.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/linux_osl.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux OS Independent Layer
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/linuxver.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/linuxver.h
index feaeed425ee2..88c499977729 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/linuxver.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/linuxver.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux-specific abstractions to gain some independence from linux kernel versions.
  * Pave over some 2.2 versus 2.4 versus 2.6 kernel differences.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/miniopt.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/miniopt.h
index 6722351436e3..7e1ae01e3b28 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/miniopt.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/miniopt.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Command line options parser.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/msgtrace.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/msgtrace.h
index 00e2b0f46bf8..69bded3d06fd 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/msgtrace.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/msgtrace.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Trace messages sent over HBUS
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl.h
index e18dde27c0bc..8899bc552a97 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * OS Abstraction Layer
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl_decl.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl_decl.h
index 3c147ef2c921..71ef17667702 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl_decl.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl_decl.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * osl forward declarations
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl_ext.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl_ext.h
index 13d59b6a2f1f..6bebb6435667 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl_ext.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/osl_ext.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * OS Abstraction Layer Extension - the APIs defined by the "extension" API
  * are only supported by a subset of all operating systems.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/packed_section_end.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/packed_section_end.h
index 4827c709af26..e209545e5212 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/packed_section_end.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/packed_section_end.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Declare directives for structure packing. No padding will be provided
  * between the members of packed structures, and therefore, there is no
@@ -15,7 +16,7 @@
  * #include <packed_section_end.h>
  *
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/packed_section_start.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/packed_section_start.h
index 9beb45d5e082..3893fd3a8a7d 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/packed_section_start.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/packed_section_start.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Declare directives for structure packing. No padding will be provided
  * between the members of packed structures, and therefore, there is no
@@ -15,7 +16,7 @@
  * #include <packed_section_end.h>
  *
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/pcicfg.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/pcicfg.h
index e4672031240f..ca5bcf7d7626 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/pcicfg.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/pcicfg.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * pcicfg.h: PCI configuration constants and structures.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/pcie_core.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/pcie_core.h
index 5ea5d7569dd8..daef6f422cef 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/pcie_core.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/pcie_core.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BCM43XX PCIE core hardware definitions.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11.h
index ca8684b0fecc..7947022e1396 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental types and constants relating to 802.11
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: 802.11.h 608148 2015-12-23 22:39:49Z $
+ * $Id: 802.11.h 639448 2016-05-23 20:23:42Z $
  */
 
 #ifndef _802_11_H_
@@ -632,6 +633,12 @@ BWL_PRE_PACKED_STRUCT struct dot11_meas_req_loc {
 			uint16 si; /* service interval */
 			uint8 data[1];
 		} BWL_POST_PACKED_STRUCT civic;
+		BWL_PRE_PACKED_STRUCT struct {
+			uint8 subject;
+			uint8 siu;   /* service interval units */
+			uint16 si; /* service interval */
+			uint8 data[1];
+		} BWL_POST_PACKED_STRUCT locid;
 		BWL_PRE_PACKED_STRUCT struct {
 			uint16 max_init_delay;		/* maximum random initial delay */
 			uint8 min_ap_count;
@@ -685,6 +692,12 @@ BWL_PRE_PACKED_STRUCT struct dot11_meas_rep {
 			uint8 length;
 			uint8 data[1];
 		} BWL_POST_PACKED_STRUCT civic;
+		BWL_PRE_PACKED_STRUCT struct {
+			uint8 exp_tsf[8];
+			uint8 subelement;
+			uint8 length;
+			uint8 data[1];
+		} BWL_POST_PACKED_STRUCT locid;
 		BWL_PRE_PACKED_STRUCT struct {
 			uint8 entry_count;
 			uint8 data[1];
@@ -696,6 +709,7 @@ typedef struct dot11_meas_rep dot11_meas_rep_t;
 #define DOT11_MNG_IE_MREP_MIN_LEN           5	/* d11 measurement report IE length */
 #define DOT11_MNG_IE_MREP_LCI_FIXED_LEN     5	/* d11 measurement report IE length */
 #define DOT11_MNG_IE_MREP_CIVIC_FIXED_LEN   6	/* d11 measurement report IE length */
+#define DOT11_MNG_IE_MREP_LOCID_FIXED_LEN   13	/* d11 measurement report IE length */
 #define DOT11_MNG_IE_MREP_BASIC_FIXED_LEN   15	/* d11 measurement report IE length */
 #define DOT11_MNG_IE_MREP_FRNG_FIXED_LEN    4
 
@@ -1330,6 +1344,7 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_MNG_COUNTRY_ID			7	/* d11 management country id */
 #define DOT11_MNG_HOPPING_PARMS_ID		8	/* d11 management hopping parameter id */
 #define DOT11_MNG_HOPPING_TABLE_ID		9	/* d11 management hopping table id */
+#define DOT11_MNG_FTM_SYNC_INFO_ID		9	/* 11mc D4.3 */
 #define DOT11_MNG_REQUEST_ID			10	/* d11 management request id */
 #define DOT11_MNG_QBSS_LOAD_ID 			11	/* d11 management QBSS Load id */
 #define DOT11_MNG_EDCA_PARAM_ID			12	/* 11E EDCA Parameter id */
@@ -1396,7 +1411,7 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_MNG_WAKEUP_SCHEDULE_ID		102	/* 11z TDLS Wakeup Schedule IE */
 #define DOT11_MNG_CHANNEL_SWITCH_TIMING_ID	104	/* 11z TDLS Channel Switch Timing IE */
 #define DOT11_MNG_PTI_CONTROL_ID		105	/* 11z TDLS PTI Control IE */
-#define DOT11_MNG_PU_BUFFER_STATUS_ID	106	/* 11z TDLS PU Buffer Status IE */
+#define DOT11_MNG_PU_BUFFER_STATUS_ID		106	/* 11z TDLS PU Buffer Status IE */
 #define DOT11_MNG_INTERWORKING_ID		107	/* 11u interworking */
 #define DOT11_MNG_ADVERTISEMENT_ID		108	/* 11u advertisement protocol */
 #define DOT11_MNG_EXP_BW_REQ_ID			109	/* 11u expedited bandwith request */
@@ -1406,7 +1421,6 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_MNG_MESH_CONFIG			113	/* Mesh Configuration */
 #define DOT11_MNG_MESH_ID			114	/* Mesh ID */
 #define DOT11_MNG_MESH_PEER_MGMT_ID		117	/* Mesh PEER MGMT IE */
-
 #define DOT11_MNG_EXT_CAP_ID			127	/* d11 mgmt ext capability */
 #define DOT11_MNG_EXT_PREQ_ID			130	/* Mesh PREQ IE */
 #define DOT11_MNG_EXT_PREP_ID			131	/* Mesh PREP IE */
@@ -1414,20 +1428,21 @@ typedef struct ti_ie ti_ie_t;
 #define	DOT11_MNG_VHT_CAP_ID			191	/* d11 mgmt VHT cap id */
 #define	DOT11_MNG_VHT_OPERATION_ID		192	/* d11 mgmt VHT op id */
 #define	DOT11_MNG_EXT_BSSLOAD_ID		193	/* d11 mgmt VHT extended bss load id */
-#define DOT11_MNG_WIDE_BW_CHANNEL_SWITCH_ID		194	/* Wide BW Channel Switch IE */
-#define DOT11_MNG_VHT_TRANSMIT_POWER_ENVELOPE_ID	195	/* VHT transmit Power Envelope IE */
-#define DOT11_MNG_CHANNEL_SWITCH_WRAPPER_ID		196	/* Channel Switch Wrapper IE */
-#define DOT11_MNG_AID_ID					197	/* Association ID  IE */
-#define	DOT11_MNG_OPER_MODE_NOTIF_ID	199	/* d11 mgmt VHT oper mode notif */
+#define DOT11_MNG_WIDE_BW_CHANNEL_SWITCH_ID	194	/* Wide BW Channel Switch IE */
+#define DOT11_MNG_VHT_TRANSMIT_POWER_ENVELOPE_ID 195	/* VHT transmit Power Envelope IE */
+#define DOT11_MNG_CHANNEL_SWITCH_WRAPPER_ID	196	/* Channel Switch Wrapper IE */
+#define DOT11_MNG_AID_ID			197	/* Association ID  IE */
+#define	DOT11_MNG_OPER_MODE_NOTIF_ID		199	/* d11 mgmt VHT oper mode notif */
+#define DOT11_MNG_HE_CAP_ID			201
+#define DOT11_MNG_HE_OP_ID			202
 #define DOT11_MNG_FTM_PARAMS_ID			206
-
+#define DOT11_MNG_TWT_ID			216	/* 11ah D5.0 */
 #define DOT11_MNG_WPA_ID			221	/* d11 management WPA id */
 #define DOT11_MNG_PROPR_ID			221
 /* should start using this one instead of above two */
 #define DOT11_MNG_VS_ID				221	/* d11 management Vendor Specific IE */
 
-#define DOT11_MNG_ID_EXT_ID			255 /* Element ID Extension 11mc D4.3 */
-#define DOT11_MNG_FTM_SYNC_INFO_ID		9	/* 11mc D4.3 */
+#define DOT11_MNG_ID_EXT_ID			255	/* Element ID Extension 11mc D4.3 */
 
 #define DOT11_MNG_IE_ID_EXT_MATCH(_ie, _id) (\
 	((_ie)->id == DOT11_MNG_ID_EXT_ID) && \
@@ -1545,6 +1560,8 @@ typedef struct ti_ie ti_ie_t;
 /* service Interval granularity bit position and mask */
 #define DOT11_EXT_CAP_SI			41
 #define DOT11_EXT_CAP_SI_MASK			0x0E
+/* Location Identifier service */
+#define DOT11_EXT_CAP_IDENT_LOC			44
 /* WNM notification */
 #define DOT11_EXT_CAP_WNM_NOTIF			46
 /* Operating mode notification - VHT (11ac D3.0 - 8.4.2.29) */
@@ -1647,6 +1664,7 @@ typedef struct dot11_oper_mode_notif_ie dot11_oper_mode_notif_ie_t;
 #define DOT11_ACTION_CAT_SELFPROT	15	/* category for Mesh, self protected */
 #define DOT11_ACTION_NOTIFICATION	17
 #define DOT11_ACTION_CAT_VHT		21	/* VHT action */
+#define DOT11_ACTION_CAT_HE		26	/* HE action frame */
 #define DOT11_ACTION_CAT_VSP		126	/* protected vendor specific */
 #define DOT11_ACTION_CAT_VS		127	/* category Vendor Specific */
 
@@ -2566,7 +2584,10 @@ typedef struct dot11_rrm_cap_ie dot11_rrm_cap_ie_t;
 #define DOT11_RRM_CAP_TTSCM		15
 #define DOT11_RRM_CAP_AP_CHANREP	16
 #define DOT11_RRM_CAP_RMMIB		17
-/* bit18-bit26, not used for RRM_IOVAR */
+/* bit18-bit23, not used for RRM_IOVAR */
+#define DOT11_RRM_CAP_MPC0		24
+#define DOT11_RRM_CAP_MPC1		25
+#define DOT11_RRM_CAP_MPC2		26
 #define DOT11_RRM_CAP_MPTI		27
 #define DOT11_RRM_CAP_NBRTSFO		28
 #define DOT11_RRM_CAP_RCPI		29
@@ -2576,8 +2597,10 @@ typedef struct dot11_rrm_cap_ie dot11_rrm_cap_ie_t;
 #define DOT11_RRM_CAP_AI		33
 #define DOT11_RRM_CAP_FTM_RANGE		34
 #define DOT11_RRM_CAP_CIVIC_LOC		35
-#define DOT11_RRM_CAP_LAST		35
+#define DOT11_RRM_CAP_IDENT_LOC		36
+#define DOT11_RRM_CAP_LAST		36
 
+#define DOT11_RRM_CAP_MPA_MASK		0x7
 /* Operating Class (formerly "Regulatory Class") definitions */
 #define DOT11_OP_CLASS_NONE			255
 
@@ -2596,6 +2619,7 @@ typedef struct do11_ap_chrep dot11_ap_chrep_t;
 #define DOT11_RM_ACTION_LM_REP		3	/* Link measurement report */
 #define DOT11_RM_ACTION_NR_REQ		4	/* Neighbor report request */
 #define DOT11_RM_ACTION_NR_REP		5	/* Neighbor report response */
+#define DOT11_PUB_ACTION_MP		7	/* Measurement Pilot public action id */
 
 /** Generic radio measurement action frame header */
 BWL_PRE_PACKED_STRUCT struct dot11_rm_action {
@@ -2991,6 +3015,7 @@ BWL_PRE_PACKED_STRUCT struct dot11_rmreq_tx_stream {
 	uint8 bin0_range;
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_rmreq_tx_stream dot11_rmreq_tx_stream_t;
+#define DOT11_RMREQ_TXSTREAM_LEN	17
 
 /** Transmit stream/category measurement report */
 BWL_PRE_PACKED_STRUCT struct dot11_rmrep_tx_stream {
@@ -3015,7 +3040,25 @@ BWL_PRE_PACKED_STRUCT struct dot11_rmrep_tx_stream {
 	uint32 bin5;
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_rmrep_tx_stream dot11_rmrep_tx_stream_t;
-
+#define DOT11_RMREP_TXSTREAM_LEN	71
+
+typedef struct rrm_tscm {
+	uint32 msdu_tx;
+	uint32 msdu_exp;
+	uint32 msdu_fail;
+	uint32 msdu_retries;
+	uint32 cfpolls_lost;
+	uint32 queue_delay;
+	uint32 tx_delay_sum;
+	uint32 tx_delay_cnt;
+	uint32 bin0_range_us;
+	uint32 bin0;
+	uint32 bin1;
+	uint32 bin2;
+	uint32 bin3;
+	uint32 bin4;
+	uint32 bin5;
+} rrm_tscm_t;
 enum {
 	DOT11_FTM_LOCATION_SUBJ_LOCAL = 0, 		/* Where am I? */
 	DOT11_FTM_LOCATION_SUBJ_REMOTE = 1,		/* Where are you? */
@@ -3038,6 +3081,7 @@ BWL_PRE_PACKED_STRUCT struct dot11_rmreq_ftm_lci {
 	/* optional sub-elements */
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_rmreq_ftm_lci dot11_rmreq_ftm_lci_t;
+#define DOT11_RMREQ_LCI_LEN	9
 
 BWL_PRE_PACKED_STRUCT struct dot11_rmrep_ftm_lci {
 	uint8 id;
@@ -3070,6 +3114,7 @@ BWL_PRE_PACKED_STRUCT struct dot11_rmreq_ftm_civic {
 	/* optional sub-elements */
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_rmreq_ftm_civic dot11_rmreq_ftm_civic_t;
+#define DOT11_RMREQ_CIVIC_LEN	10
 
 BWL_PRE_PACKED_STRUCT struct dot11_rmrep_ftm_civic {
 	uint8 id;
@@ -3092,6 +3137,37 @@ typedef struct dot11_rmrep_ftm_civic dot11_rmrep_ftm_civic_t;
 #define DOT11_FTM_CIVIC_TYPE_LEN			1
 #define DOT11_FTM_CIVIC_UNKNOWN_LEN 		3
 
+/* Location Identifier measurement request */
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq_locid {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint8 subj;
+	uint8 siu;
+	uint16 si;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq_locid dot11_rmreq_locid_t;
+#define DOT11_RMREQ_LOCID_LEN	9
+
+/* Location Identifier measurement report */
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_locid {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint8 exp_tsf[8];
+	uint8 locid_sub_id;
+	uint8 locid_sub_len;
+	/* optional location identifier field */
+	/* optional sub-elements */
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_locid dot11_rmrep_locid_t;
+#define DOT11_LOCID_UNKNOWN_LEN		10
+#define DOT11_LOCID_SUBELEM_ID		0
+
 BWL_PRE_PACKED_STRUCT struct dot11_ftm_range_subel {
 	uint8 id;
 	uint8 len;
@@ -3172,6 +3248,7 @@ BWL_PRE_PACKED_STRUCT struct dot11_rmreq_pause_time {
 	uint16 pause_time;
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_rmreq_pause_time dot11_rmreq_pause_time_t;
+#define DOT11_RMREQ_PAUSE_LEN	7
 
 
 /* Neighbor Report subelements ID (11k & 11v) */
@@ -3265,6 +3342,19 @@ BWL_PRE_PACKED_STRUCT struct dot11_lmrep {
 typedef struct dot11_lmrep dot11_lmrep_t;
 #define DOT11_LMREP_LEN	11
 
+#define DOT11_MP_CAP_SPECTRUM			0x01	/* d11 cap. spectrum */
+#define DOT11_MP_CAP_SHORTSLOT			0x02	/* d11 cap. shortslot */
+/* Measurement Pilot */
+BWL_PRE_PACKED_STRUCT struct dot11_mprep {
+	uint8 cap_info;				/* Condensed capability Info. */
+	uint8 country[2];				/* Condensed country string */
+	uint8 opclass;				/* Op. Class */
+	uint8 channel;				/* Channel */
+	uint8 mp_interval;			/* Measurement Pilot Interval */
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_mprep dot11_mprep_t;
+#define DOT11_MPREP_LEN	6
+
 /* 802.11 BRCM "Compromise" Pre N constants */
 #define PREN_PREAMBLE		24	/* green field preamble time */
 #define PREN_MM_EXT		12	/* extra mixed mode preamble time */
@@ -3416,12 +3506,18 @@ typedef struct d11cnt {
 #define BRCM_PROP_OUI		"\x00\x90\x4C"
 
 
-/* Action frame type for FTM Initiator Report */
-#define BRCM_FTM_VS_AF_TYPE	14
-enum {
-	BRCM_FTM_VS_INITIATOR_RPT_SUBTYPE = 1,	/* FTM Initiator Report */
-	BRCM_FTM_VS_COLLECT_SUBTYPE = 2,	/* FTM Collect debug protocol */
-};
+#define BRCM_FTM_IE_TYPE			14
+
+/* #define HT_CAP_IE_TYPE			51
+ * #define HT_ADD_IE_TYPE			52
+ * #define BRCM_EXTCH_IE_TYPE		53
+ * #define MEMBER_OF_BRCM_PROP_IE_TYPE	54
+ * #define BRCM_RELMACST_IE_TYPE		55
+ * #define BRCM_EVT_WL_BSS_INFO		64
+ * #define RWL_ACTION_WIFI_FRAG_TYPE	85
+ * #define BTC_INFO_BRCM_PROP_IE_TYPE	90
+ * #define ULB_BRCM_PROP_IE_TYPE	91
+ */
 
 /* Action frame type for RWL */
 #define RWL_WIFI_DEFAULT		0
@@ -3432,6 +3528,14 @@ enum {
 #define PROXD_AF_TYPE			11 /* Wifi proximity action frame type */
 #define BRCM_RELMACST_AF_TYPE	        12 /* RMC action frame type */
 
+/* Action frame type for FTM Initiator Report */
+#define BRCM_FTM_VS_AF_TYPE	14
+enum {
+	BRCM_FTM_VS_INITIATOR_RPT_SUBTYPE = 1,	/* FTM Initiator Report */
+	BRCM_FTM_VS_COLLECT_SUBTYPE = 2,	/* FTM Collect debug protocol */
+};
+
+
 
 
 /* brcm syscap_ie cap */
@@ -3630,6 +3734,11 @@ typedef struct ht_prop_cap_ie ht_prop_cap_ie_t;
 #define HT_CAP_TX_BF_CAP_EXPLICIT_COMPRESSED_FB_MASK 0x18000
 #define HT_CAP_TX_BF_CAP_EXPLICIT_COMPRESSED_FB_SHIFT 15
 
+#define HT_CAP_MCS_FLAGS_SUPP_BYTE 12 /* byte offset in HT Cap Supported MCS for various flags */
+#define HT_CAP_MCS_RX_8TO15_BYTE_OFFSET                1
+#define HT_CAP_MCS_FLAGS_TX_RX_UNEQUAL              0x02
+#define HT_CAP_MCS_FLAGS_MAX_SPATIAL_STREAM_MASK    0x0C
+
 #define VHT_MAX_MPDU		11454	/* max mpdu size for now (bytes) */
 #define VHT_MPDU_MSDU_DELTA	56		/* Difference in spec - vht mpdu, amsdu len */
 /* Max AMSDU len - per spec */
@@ -3746,6 +3855,13 @@ typedef struct ht_prop_add_ie ht_prop_add_ie_t;
 					== DOT11N_TXBURST)	/* Tx Burst present */
 #define DOT11N_OBSS_NONHT_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & DOT11N_OBSS_NONHT) \
 					== DOT11N_OBSS_NONHT)	/* OBSS Non-HT present */
+/* Macros for HT MCS filed access */
+#define HT_CAP_MCS_BITMASK(supp_mcs)                 \
+	((supp_mcs)[HT_CAP_MCS_RX_8TO15_BYTE_OFFSET])
+#define HT_CAP_MCS_TX_RX_UNEQUAL(supp_mcs)          \
+	((supp_mcs)[HT_CAP_MCS_FLAGS_SUPP_BYTE] & HT_CAP_MCS_FLAGS_TX_RX_UNEQUAL)
+#define HT_CAP_MCS_TX_STREAM_SUPPORT(supp_mcs)          \
+		((supp_mcs)[HT_CAP_MCS_FLAGS_SUPP_BYTE] & HT_CAP_MCS_FLAGS_MAX_SPATIAL_STREAM_MASK)
 
 BWL_PRE_PACKED_STRUCT struct obss_params {
 	uint16	passive_dwell;
@@ -3836,6 +3952,7 @@ typedef struct vht_cap_ie vht_cap_ie_t;
 /* VHT Supported MCS Set - 64-bit - in VHT Cap IE */
 #define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_MASK   0x1fff
 #define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_SHIFT  0
+#define VHT_CAP_SUPP_CHAN_WIDTH_SHIFT		5
 
 #define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_MASK   0x1fff
 #define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_SHIFT  0
@@ -3982,6 +4099,16 @@ typedef struct vht_features_ie_hdr vht_features_ie_hdr_t;
 #define VHT_MCS_SS_SUPPORTED(nss, mcsMap) \
 		 (VHT_MCS_MAP_GET_MCS_PER_SS((nss), (mcsMap)) != VHT_CAP_MCS_MAP_NONE)
 
+/* Get the max ss supported from the mcs map */
+#define VHT_MAX_SS_SUPPORTED(mcsMap) \
+	VHT_MCS_SS_SUPPORTED(8, mcsMap) ? 8 : \
+	VHT_MCS_SS_SUPPORTED(7, mcsMap) ? 7 : \
+	VHT_MCS_SS_SUPPORTED(6, mcsMap) ? 6 : \
+	VHT_MCS_SS_SUPPORTED(5, mcsMap) ? 5 : \
+	VHT_MCS_SS_SUPPORTED(4, mcsMap) ? 4 : \
+	VHT_MCS_SS_SUPPORTED(3, mcsMap) ? 3 : \
+	VHT_MCS_SS_SUPPORTED(2, mcsMap) ? 2 : \
+	VHT_MCS_SS_SUPPORTED(1, mcsMap) ? 1 : 0
 
 /* ************* WPA definitions. ************* */
 #define WPA_OUI			"\x00\x50\xF2"	/* WPA OUI */
@@ -4022,6 +4149,7 @@ typedef struct vht_features_ie_hdr vht_features_ie_hdr_t;
 #define WFA_OUI_TYPE_HS20	0x10
 #define WFA_OUI_TYPE_OSEN	0x12
 #define WFA_OUI_TYPE_NAN	0x13
+#define WFA_OUI_TYPE_MBO	0x16
 
 /* RSN authenticated key managment suite */
 #define RSN_AKM_NONE		0	/* None (IBSS) */
@@ -4532,26 +4660,52 @@ typedef BWL_PRE_PACKED_STRUCT struct {
 	uint8	data[1];
 } BWL_POST_PACKED_STRUCT ftm_vs_tlv_t;
 
-#define FTM_TPK_LEN		16
-#define FTM_RI_RR_BUF_LEN	32
-#define FTM_TPK_RI_RR_LEN	13
-#define FTM_TPK_DIGEST_LEN	32
-#define FTM_TPK_BUFFER_LEN	128
-#define FTM_TPK_RI_PHY_LEN	7
-#define FTM_TPK_RR_PHY_LEN	7
-#define FTM_TPK_DATA_BUFFER_LEN 88
+BWL_PRE_PACKED_STRUCT struct dot11_ftm_vs_ie {
+	uint8 id;						/* DOT11_MNG_VS_ID */
+	uint8 len;						/* length following */
+	uint8 oui[3];					/* BRCM_PROP_OUI (or Customer) */
+	uint8 sub_type;					/* BRCM_FTM_IE_TYPE (or Customer) */
+	uint8 version;
+	ftm_vs_tlv_t	tlvs[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_ftm_vs_ie dot11_ftm_vs_ie_t;
 
+/* ftm vs api version */
+#define BCM_FTM_VS_PARAMS_VERSION 0x01
+
+/* ftm vendor specific information tlv types */
+enum {
+	FTM_VS_TLV_NONE = 0,
+	FTM_VS_TLV_REQ_PARAMS = 1,		/* additional request params (in FTM_REQ) */
+	FTM_VS_TLV_MEAS_INFO = 2,		/* measurement information (in FTM_MEAS) */
+	FTM_VS_TLV_SEC_PARAMS = 3,		/* security parameters (in either) */
+	FTM_VS_TLV_SEQ_PARAMS = 4,		/* toast parameters (FTM_REQ, BRCM proprietary) */
+	FTM_VS_TLV_MF_BUF = 5,			/* multi frame buffer - may span ftm vs ie's */
+	/* add additional types above */
+};
+
+/* the following definitions are *DEPRECATED* and moved to implemenetion files. They
+ * are retained here because previous (May 2016) some branches use them
+ */
+#define FTM_TPK_LEN            16
+#define FTM_RI_RR_BUF_LEN      32
+#define FTM_TPK_RI_RR_LEN      13
+#define FTM_TPK_DIGEST_LEN     32
+#define FTM_TPK_BUFFER_LEN     128
+#define FTM_TPK_RI_PHY_LEN     7
+#define FTM_TPK_RR_PHY_LEN     7
+#define FTM_TPK_DATA_BUFFER_LEN 88
 
 BWL_PRE_PACKED_STRUCT struct dot11_ftm_vs_params {
-	uint8 id;						/* DOT11_MNG_VS_ID */
+	uint8 id;                       /* DOT11_MNG_VS_ID */
 	uint8 len;
-	uint8 oui[3];					/* Proprietary OUI, BRCM_PROP_OUI */
+	uint8 oui[3];                   /* Proprietary OUI, BRCM_PROP_OUI */
 	uint8 bcm_vs_id;
-	ftm_vs_tlv_t ftm_tpk_ri_rr[1];			/* ftm_TPK_ri_rr place holder */
+	ftm_vs_tlv_t ftm_tpk_ri_rr[1];          /* ftm_TPK_ri_rr place holder */
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_ftm_vs_params dot11_ftm_vs_tpk_ri_rr_params_t;
-
 #define DOT11_FTM_VS_LEN  (sizeof(dot11_ftm_vs_tpk_ri_rr_params_t) - TLV_HDR_LEN)
+/* end *DEPRECATED* ftm definitions */
 
 BWL_PRE_PACKED_STRUCT struct dot11_ftm_sync_info {
 	uint8 id;		/* Extended - 255 11mc D4.3  */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11_bta.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11_bta.h
index 981acd896860..89caf7d33d43 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11_bta.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11_bta.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BT-AMP (BlueTooth Alternate Mac and Phy) 802.11 PAL (Protocol Adaptation Layer)
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11e.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11e.h
index c0ad8e452b82..1abad0970d59 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11e.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.11e.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * 802.11e protocol header file
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.1d.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.1d.h
index 85fd7e4a2fae..dee157b3c55e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.1d.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.1d.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental types and constants relating to 802.1D
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.3.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.3.h
index d834cb741f39..051a3ef87aba 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.3.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/802.3.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental constants relating to 802.3
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmdhcp.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmdhcp.h
index 90d3c01617f0..a22a82d39cdc 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmdhcp.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmdhcp.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental constants relating to DHCP Protocol
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmeth.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmeth.h
index 97f893546b77..2bc2d4144461 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmeth.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmeth.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Ethernettype  protocol definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmevent.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmevent.h
index 3afc3178a705..07c63f9ee8df 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmevent.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmevent.h
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Event  protocol definitions
  *
  * Dependencies: proto/bcmeth.h
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -26,7 +27,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: bcmevent.h 609715 2016-01-05 08:00:59Z $
+ * $Id: bcmevent.h 641741 2016-06-05 19:11:40Z $
  *
  */
 
@@ -43,6 +44,9 @@
 #endif
 /* #include <ethernet.h> -- TODO: req., excluded to overwhelming coupling (break up ethernet.h) */
 #include <proto/bcmeth.h>
+#ifdef HEALTH_CHECK
+#include <proto/dnglevent.h>
+#endif /* HEALTH_CHECK */
 
 /* This marks the start of a packed structure section. */
 #include <packed_section_start.h>
@@ -97,6 +101,19 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 	/* data portion follows */
 } BWL_POST_PACKED_STRUCT bcm_event_t;
 
+/*
+ * used by host event
+ * note: if additional event types are added, it should go with is_wlc_event_frame() as well.
+ */
+typedef union bcm_event_msg_u {
+	wl_event_msg_t		event;
+#ifdef HEALTH_CHECK
+	bcm_dngl_event_msg_t	dngl_event;
+#endif /* HEALTH_CHECK */
+
+	/* add new event here */
+} bcm_event_msg_u_t;
+
 #define BCM_MSG_LEN	(sizeof(bcm_event_t) - sizeof(bcmeth_hdr_t) - sizeof(struct ether_header))
 
 /* Event messages */
@@ -214,7 +231,6 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_PROXD			109	/* Proximity Detection event */
 #define WLC_E_IBSS_COALESCE		110	/* IBSS Coalescing */
 #define WLC_E_AIBSS_TXFAIL		110	/* TXFAIL event for AIBSS, re using event 110 */
-#define WLC_E_SCAN_SUMMARY		111	/* Parallel scan statistics event */
 #define WLC_E_BSS_LOAD			114	/* Inform host of beacon bss load */
 #define WLC_E_MIMO_PWR_SAVE		115	/* Inform host MIMO PWR SAVE learning events */
 #define WLC_E_LEAKY_AP_STATS	116 /* Inform host leaky Ap stats events */
@@ -250,9 +266,18 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_TKO			151     /* TCP keepalive offload */
 #define WLC_E_SDB_TRANSITION            152     /* SDB mode-switch event */
 #define WLC_E_NATOE_NFCT		153     /* natoe event */
-#define WLC_E_LAST			154	/* highest val + 1 for range checking */
-#if (WLC_E_LAST > 154)
-#error "WLC_E_LAST: Invalid value for last event; must be <= 153."
+#define WLC_E_TEMP_THROTTLE		154	/* Temperature throttling control event */
+#define WLC_E_LINK_QUALITY		155     /* Link quality measurement complete */
+#define WLC_E_BSSTRANS_RESP		156 /* BSS Transition Response received */
+#define WLC_E_HE_TWT_SETUP		157	/* HE TWT Setup Complete event */
+#define WLC_E_NAN_DATA_IND		158	/* NAN 2.0 data indication */
+#define WLC_E_NAN_DATA_CONF		159	/* NAN 2.0 data confirmation */
+#define WLC_E_RADAR_DETECTED		160	/* Radar Detected event */
+#define WLC_E_RANGING_EVENT		161	/* Ranging event */
+#define WLC_E_INVALID_IE		162	/* Received invalid IE */
+#define WLC_E_LAST			163	/* highest val + 1 for range checking */
+#if (WLC_E_LAST > 163)
+#error "WLC_E_LAST: Invalid value for last event; must be <= 163."
 #endif /* WLC_E_LAST */
 
 /* define an API for getting the string name of an event */
@@ -260,6 +285,15 @@ extern const char *bcmevent_get_name(uint event_type);
 extern void wl_event_to_host_order(wl_event_msg_t * evt);
 extern void wl_event_to_network_order(wl_event_msg_t * evt);
 
+/* validate if the event is proper and if valid copy event header to event */
+#ifdef SEC_ENHANCEMENT
+extern int is_wlc_event_frame(void *pktdata, uint pktlen, uint16 exp_usr_subtype,
+	bcm_event_msg_u_t *out_event);
+#else
+extern int is_wlc_event_frame(void *pktdata, wl_event_msg_t *event,
+	uint pktlen);
+#endif
+
 /* conversion between host and network order for events */
 void wl_event_to_host_order(wl_event_msg_t * evt);
 void wl_event_to_network_order(wl_event_msg_t * evt);
@@ -295,6 +329,24 @@ void wl_event_to_network_order(wl_event_msg_t * evt);
 #define WLC_E_REASON_INFRA_DISASSOC	3
 #define WLC_E_REASON_NO_MODE_CHANGE_NEEDED	4
 
+/* WLC_E_SDB_TRANSITION event data */
+#define WL_MAX_BSSCFG     4
+#define WL_EVENT_SDB_TRANSITION_VER     1
+typedef struct wl_event_sdb_data {
+	uint8 wlunit;           /* Core index */
+	uint8 is_iftype;        /* Interface Type(Station, SoftAP, P2P_GO, P2P_GC */
+	uint16 chanspec;        /* Interface Channel/Chanspec */
+	char ssidbuf[(4 * 32) + 1];	/* SSID_FMT_BUF_LEN: ((4 * DOT11_MAX_SSID_LEN) + 1) */
+} wl_event_sdb_data_t;
+
+typedef struct wl_event_sdb_trans {
+	uint8 version;          /* Event Data Version */
+	uint8 rsdb_mode;
+	uint8 enable_bsscfg;
+	uint8 reserved;
+	struct wl_event_sdb_data values[WL_MAX_BSSCFG];
+} wl_event_sdb_trans_t;
+
 /* roam reason codes */
 #define WLC_E_REASON_INITIAL_ASSOC	0	/* initial assoc */
 #define WLC_E_REASON_LOW_RSSI		1	/* roamed due to low RSSI */
@@ -312,6 +364,7 @@ void wl_event_to_network_order(wl_event_msg_t * evt);
 #define WLC_E_REASON_REQUESTED_ROAM	11
 #define WLC_E_REASON_BSSTRANS_REQ	11	/* roamed due to BSS Transition request by AP */
 #define WLC_E_REASON_LOW_RSSI_CU		12 /* roamed due to low RSSI and Channel Usage */
+#define WLC_E_REASON_RADAR_DETECTED	13	/* roamed due to radar detection by STA */
 
 /* prune reason codes */
 #define WLC_E_PRUNE_ENCR_MISMATCH	1	/* encryption mismatch */
@@ -348,6 +401,9 @@ void wl_event_to_network_order(wl_event_msg_t * evt);
 #define WLC_E_SUP_SEND_FAIL		13	/* message send failure */
 #define WLC_E_SUP_DEAUTH		14	/* received FC_DEAUTH */
 #define WLC_E_SUP_WPA_PSK_TMO		15	/* WPA PSK 4-way handshake timeout */
+#define WLC_E_SUP_WPA_PSK_M1_TMO	16	/* WPA PSK 4-way handshake M1 timeout */
+#define WLC_E_SUP_WPA_PSK_M3_TMO	17	/* WPA PSK 4-way handshake M3 timeout */
+
 
 /* Ucode reason codes carried in the WLC_E_MACDBG event */
 #define WLC_E_MACDBG_LIST_PSM		0	/* Dump list update for PSM registers */
@@ -398,9 +454,7 @@ typedef struct wl_event_data_natoe {
 #define WLC_E_IF_ROLE_P2P_GO		3	/* P2P Group Owner */
 #define WLC_E_IF_ROLE_P2P_CLIENT	4	/* P2P Client */
 #define WLC_E_IF_ROLE_IBSS              8       /* IBSS */
-#ifdef WL_NAN
-#define WLC_E_IF_ROLE_NAN               9       /* NAN */
-#endif
+#define WLC_E_IF_ROLE_NAN              9       /* NAN */
 
 /* WLC_E_RSSI event data */
 typedef struct wl_event_data_rssi {
@@ -459,6 +513,9 @@ typedef BWL_PRE_PACKED_STRUCT struct ndis_link_parms {
 #define WLAN_TDLS_SET_WFD_DISABLED	14
 #endif
 
+/* WLC_E_RANGING_EVENT subtypes */
+#define WLC_E_RANGING_RESULTS	0
+
 
 /* GAS event data */
 typedef BWL_PRE_PACKED_STRUCT struct wl_event_gas {
@@ -614,6 +671,12 @@ typedef enum nan_app_events {
 	WL_NAN_EVENT_POST_DISC = 17, /* Event for post discovery data */
 	WL_NAN_EVENT_DATA_IF_ADD = 18, /* Event for Data IF add */
 	WL_NAN_EVENT_DATA_PEER_ADD = 19, /* Event for peer add */
+	/* nan 2.0 */
+	WL_NAN_EVENT_DATA_IND = 20, /* Data Indication to Host */
+	WL_NAN_EVENT_DATA_CONF = 21, /* Data Response to Host */
+	WL_NAN_EVENT_SDF_RX = 22,	/* entire service discovery frame */
+	WL_NAN_EVENT_DATA_END = 23,
+	WL_NAN_EVENT_BCN_RX = 24,	/* received beacon payload */
 	WL_NAN_EVENT_INVALID	/* delimiter for max value */
 } nan_app_events_e;
 
@@ -623,6 +686,7 @@ typedef enum nan_app_events {
 /* WLC_E_ULP event data */
 #define WL_ULP_EVENT_VERSION		1
 #define WL_ULP_DISABLE_CONSOLE		1	/* Disable console message on ULP entry */
+#define WL_ULP_UCODE_DOWNLOAD		2       /* Download ULP ucode file */
 
 typedef struct wl_ulp_event {
 	uint16 version;
@@ -635,6 +699,57 @@ typedef BWL_PRE_PACKED_STRUCT struct wl_event_tko {
 	uint8 pad[3];		/* 4-byte struct alignment */
 } BWL_POST_PACKED_STRUCT wl_event_tko_t;
 
+typedef struct {
+	uint8 radar_type;       /* one of RADAR_TYPE_XXX */
+	uint16 min_pw;          /* minimum pulse-width (usec * 20) */
+	uint16 max_pw;          /* maximum pulse-width (usec * 20) */
+	uint16 min_pri;         /* minimum pulse repetition interval (usec) */
+	uint16 max_pri;         /* maximum pulse repetition interval (usec) */
+	uint16 subband;         /* subband/frequency */
+} radar_detected_event_info_t;
+typedef struct wl_event_radar_detect_data {
+
+	uint32 version;
+	uint16 current_chanspec; /* chanspec on which the radar is recieved */
+	uint16 target_chanspec; /*  Target chanspec after detection of radar on current_chanspec */
+	radar_detected_event_info_t radar_info[2];
+} wl_event_radar_detect_data_t;
+
+/* TWT Setup Completion is designed to notify the user of TWT Setup process
+ * status. When 'status' field is value of BCME_OK, the user must check the
+ * 'setup_cmd' field value in 'wl_twt_sdesc_t' structure that at the end of
+ * the event data to see the response from the TWT Responding STA; when
+ * 'status' field is value of BCME_ERROR or non BCME_OK, user must not use
+ * anything from 'wl_twt_sdesc_t' structure as it is the TWT Requesting STA's
+ * own TWT parameter.
+ */
+
+#define WL_TWT_SETUP_CPLT_VER	0
+
+/* TWT Setup Completion event data */
+typedef struct wl_twt_setup_cplt {
+	uint16 version;
+	uint16 length;	/* the byte count of fields from 'dialog' onwards */
+	uint8 dialog;	/* the dialog token user supplied to the TWT setup API */
+	uint8 pad[3];
+	int32 status;
+	/* wl_twt_sdesc_t desc; - defined in wlioctl.h */
+} wl_twt_setup_cplt_t;
+
+#define WL_INVALID_IE_EVENT_VERSION	0
+
+/* Invalid IE Event data */
+typedef struct wl_invalid_ie_event {
+	uint16 version;
+	uint16 len;      /* Length of the invalid IE copy */
+	uint16 type;     /* Type/subtype of the frame which contains the invalid IE */
+	uint16 error;    /* error code of the wrong IE, defined in ie_error_code_t */
+	uint8  ie[];     /* Variable length buffer for the invalid IE copy */
+} wl_invalid_ie_event_t;
+
+typedef enum ie_error_code {
+	IE_ERROR_OUT_OF_RANGE = 0x01
+} ie_error_code_t;
 /* This marks the end of a packed structure section. */
 #include <packed_section_end.h>
 
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmip.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmip.h
index fdfd83c9ea9d..9ce7021937cf 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmip.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmip.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental constants relating to IP Protocol
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmipv6.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmipv6.h
index f446e47bf296..35752beb280f 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmipv6.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmipv6.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental constants relating to Neighbor Discovery Protocol
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmtcp.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmtcp.h
index 931a1a6f8fcf..14613baec036 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmtcp.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmtcp.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental constants relating to TCP Protocol
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmudp.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmudp.h
index ae0e8d1226db..500b7ca86320 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmudp.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bcmudp.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental constants relating to UDP Protocol
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bt_amp_hci.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bt_amp_hci.h
index 1a3ccaf83003..bf23c8563fde 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bt_amp_hci.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/bt_amp_hci.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BT-AMP (BlueTooth Alternate Mac and Phy) HCI (Host/Controller Interface)
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/eapol.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/eapol.h
index e28496dc5f09..7dd583790a63 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/eapol.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/eapol.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * 802.1x EAPOL definitions
  *
@@ -5,7 +6,7 @@
  * IEEE Std 802.1X-2001
  * IEEE 802.1X RADIUS Usage Guidelines
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/ethernet.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/ethernet.h
index d3a2e97c26b0..9afd3d526284 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/ethernet.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/ethernet.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * From FreeBSD 2.2.7: Fundamental constants relating to ethernet.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/event_log_set.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/event_log_set.h
index 3e0a129bbbd6..bd0bece80197 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/event_log_set.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/event_log_set.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * EVENT_LOG system definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/event_log_tag.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/event_log_tag.h
index 5b0a641a666f..d5decd168236 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/event_log_tag.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/event_log_tag.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * EVENT_LOG system definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: event_log_tag.h 607675 2015-12-21 22:08:55Z $
+ * $Id: event_log_tag.h 636987 2016-05-11 08:04:24Z $
  */
 
 #ifndef _EVENT_LOG_TAG_H_
@@ -76,7 +77,11 @@
 #define EVENT_LOG_TAG_PCI_DBG	52
 #define EVENT_LOG_TAG_PCI_DATA  53
 #define EVENT_LOG_TAG_PCI_RING	54
+/* EVENT_LOG_TAG_AWDL_TRACE_RANGING will be removed after wlc_ranging merge from IGUANA
+ * keeping it here to avoid compilation error on trunk
+ */
 #define EVENT_LOG_TAG_AWDL_TRACE_RANGING	55
+#define EVENT_LOG_TAG_RANGING_TRACE	55
 #define EVENT_LOG_TAG_WL_ERROR		56
 #define EVENT_LOG_TAG_PHY_ERROR		57
 #define EVENT_LOG_TAG_OTP_ERROR		58
@@ -137,8 +142,29 @@
 #define EVENT_LOG_TAG_SCAN_SUMMARY		113
 #define EVENT_LOG_TAG_PROXD_SAMPLE_COLLECT	114
 #define EVENT_LOG_TAG_OCL_INFO			115
+#define EVENT_LOG_TAG_RSDB_PMGR_DEBUG		116
+#define EVENT_LOG_TAG_RSDB_PMGR_ERR		117
+#define EVENT_LOG_TAG_NAT_ERR                   118
+#define EVENT_LOG_TAG_NAT_WARN                  119
+#define EVENT_LOG_TAG_NAT_INFO                  120
+#define EVENT_LOG_TAG_NAT_DEBUG                 121
+#define EVENT_LOG_TAG_STA_INFO			122
+#define EVENT_LOG_TAG_PROXD_ERROR		123
+#define EVENT_LOG_TAG_PROXD_TRACE		124
+#define EVENT_LOG_TAG_PROXD_INFO		125
+#define EVENT_LOG_TAG_IE_ERROR			126
+#define EVENT_LOG_TAG_ASSOC_ERROR		127
+#define EVENT_LOG_TAG_SCAN_ERR			128
+#define EVENT_LOG_TAG_AMSDU_ERROR		129
+#define EVENT_LOG_TAG_AMPDU_ERROR		130
+#define EVENT_LOG_TAG_KM_ERROR			131
+#define EVENT_LOG_TAG_DFS			132
+#define EVENT_LOG_TAG_REGULATORY	133
+#define EVENT_LOG_TAG_CSA				134
+#define EVENT_LOG_TAG_WNM_BSSTRANS_ERR	135
+
 /* EVENT_LOG_TAG_MAX	= Set to the same value of last tag, not last tag + 1 */
-#define EVENT_LOG_TAG_MAX			115
+#define EVENT_LOG_TAG_MAX			135
 /* Note: New event should be added/reserved in trunk before adding it to branches */
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/nan.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/nan.h
new file mode 100644
index 000000000000..0fbc6db1729a
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/nan.h
@@ -0,0 +1,680 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Fundamental types and constants relating to WFA NAN
+ * (Neighbor Awareness Networking)
+ *
+ * Copyright (C) 1999-2019, Broadcom Corporation
+ * 
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ * 
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ * 
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * $Id: nan.h 641251 2016-06-01 23:41:33Z $
+ */
+#ifndef _NAN_H_
+#define _NAN_H_
+
+#include <typedefs.h>
+#include <proto/802.11.h>
+
+
+/* This marks the start of a packed structure section. */
+#include <packed_section_start.h>
+
+/* WiFi NAN OUI values */
+#define NAN_OUI            WFA_OUI     /* WiFi OUI */
+/* For oui_type field identifying the type and version of the NAN IE. */
+#define NAN_OUI_TYPE       0x13        /* Type/Version */
+/* IEEE 802.11 vendor specific information element. (Same as P2P_IE_ID.) */
+#define NAN_IE_ID          0xdd
+
+/* Same as P2P_PUB_AF_CATEGORY and DOT11_ACTION_CAT_PUBLIC */
+#define NAN_PUB_AF_CATEGORY     0x04
+/* IEEE 802.11 Public Action Frame Vendor Specific. (Same as P2P_PUB_AF_ACTION.) */
+#define NAN_PUB_AF_ACTION       0x09
+/* Number of octents in hash of service name. (Same as P2P_WFDS_HASH_LEN.) */
+#define NAN_SVC_HASH_LEN    6
+/* Size of fixed length part of nan_pub_act_frame_t before attributes. */
+#define NAN_PUB_ACT_FRAME_FIXED_LEN 6
+/* Number of octents in master rank value. */
+#define NAN_MASTER_RANK_LEN     8
+/* NAN public action frame header size */
+#define NAN_PUB_ACT_FRAME_HDR_SIZE (OFFSETOF(nan_pub_act_frame_t, data))
+/* NAN network ID */
+#define NAN_NETWORK_ID		"\x51\x6F\x9A\x01\x00\x00"
+/* Service Control Type length */
+#define NAN_SVC_CONTROL_TYPE_LEN	2
+/* Binding Bitmap length */
+#define NAN_BINDING_BITMAP_LEN		2
+/* Service Response Filter (SRF) control field masks */
+#define NAN_SRF_BLOOM_MASK		0x01
+#define NAN_SRF_INCLUDE_MASK		0x02
+#define NAN_SRF_INDEX_MASK		0x0C
+/* SRF Bloom Filter index shift */
+#define NAN_SRF_BLOOM_SHIFT	2
+#define NAN_SRF_INCLUDE_SHIFT	1
+/* Mask for CRC32 output, used in hash function for NAN bloom filter */
+#define NAN_BLOOM_CRC32_MASK	0xFFFF
+
+/* Attribute TLV header size */
+#define NAN_ATTR_ID_OFF		0
+#define NAN_ATTR_LEN_OFF	1
+#define NAN_ATTR_DATA_OFF	3
+
+#define NAN_ATTR_ID_LEN		 1	/* ID field length */
+#define NAN_ATTR_LEN_LEN	 2	/* Length field length */
+#define NAN_ATTR_HDR_LEN	 3	/* ID + 2-byte length field */
+#define NAN_ENTRY_CTRL_LEN       1      /* Entry control field length from FAM attribute */
+#define NAN_MAP_ID_LEN           1	/* MAP ID length to signify band */
+#define NAN_OPERATING_CLASS_LEN  1	/* operating class field length from NAN FAM */
+#define NAN_CHANNEL_NUM_LEN      1	/* channel number field length 1 byte */
+
+#define NAN_MAP_ID_2G   2  /* NAN Further Avail Map ID for band 2.4G */
+#define NAN_MAP_ID_5G   5  /* NAN Further Avail Map ID for band 5G */
+#define NAN_MAP_NUM_IDS 2  /* Max number of NAN Further Avail Map IDs supported */
+
+/* no. of peer devices supported TODO make it tunable */
+#define NAN_DATA_PEER_DEV_SUPPORT	8
+/* no. of instaces supported (ndp, mgmt) */
+#define NAN_DATA_NDP_INST_SUPPORT	16
+/* instaces supported (same as ndp) */
+#define NAN_DATA_MGMT_INST_SUPPORT	NAN_DATA_NDP_INST_SUPPORT
+#define NAN_DATA_NDL_INST_SUPPORT	NAN_DATA_PEER_DEV_SUPPORT
+
+/*
+ * Period
+ * Indicate the repeat interval of the following bitmap.
+ * when set to 0, the indicated bitmap is not repeated.
+ * When set to non-zero, the repeat interval is:
+ * 1:128 TU, 2: 256 TU, 3: 512 TU, 4: 1024 TU, 5: 2048 TU, 6: 4096 TU, 7: 8192 TU
+*/
+#define NAN_DATA_MAX_AVAIL_INTRVL	7	/* no. of period intervals supported */
+
+#define NAN_AVAIL_ENTRY_LEN_RES0 7      /* Avail entry len in FAM attribute for resolution 16TU */
+#define NAN_AVAIL_ENTRY_LEN_RES1 5      /* Avail entry len in FAM attribute for resolution 32TU */
+#define NAN_AVAIL_ENTRY_LEN_RES2 4      /* Avail entry len in FAM attribute for resolution 64TU */
+
+/* NAN 2.0 NDP Setup */
+#define NAN_DATA_NDP_SETUP  0	 /* arbitrary value */
+/* NAN 2.0 Mgmt Setup */
+#define NAN_DATA_MGMT_SETUP 1	 /* arbitrary value */
+/* NAN 2.0 NDL Setup */
+#define NAN_DATA_NDL_SETUP 2	 /* arbitrary value */
+
+/* Vendor-specific public action frame for NAN */
+typedef BWL_PRE_PACKED_STRUCT struct nan_pub_act_frame_s {
+	/* NAN_PUB_AF_CATEGORY 0x04 */
+	uint8 category_id;
+	/* NAN_PUB_AF_ACTION 0x09 */
+	uint8 action_field;
+	/* NAN_OUI 0x50-6F-9A */
+	uint8 oui[DOT11_OUI_LEN];
+	/* NAN_OUI_TYPE 0x13 */
+	uint8 oui_type;
+	/* One or more NAN Attributes follow */
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT nan_pub_act_frame_t;
+
+/* NAN attributes as defined in the nan spec */
+enum {
+	NAN_ATTR_MASTER_IND	= 0,
+	NAN_ATTR_CLUSTER	= 1,
+	NAN_ATTR_SVC_ID_LIST    = 2,
+	NAN_ATTR_SVC_DESCRIPTOR = 3,
+	NAN_ATTR_CONN_CAP       = 4,
+	NAN_ATTR_INFRA		= 5,
+	NAN_ATTR_P2P		= 6,
+	NAN_ATTR_IBSS		= 7,
+	NAN_ATTR_MESH		= 8,
+	NAN_ATTR_FURTHER_NAN_SD = 9,
+	NAN_ATTR_FURTHER_AVAIL	= 10,
+	NAN_ATTR_COUNTRY_CODE	= 11,
+	NAN_ATTR_RANGING	= 12,
+	NAN_ATTR_CLUSTER_DISC	= 13,
+	/* nan 2.0 */
+	NAN_ATTR_UNALIGN_SCHED = 14,
+	NAN_ATTR_RANGING_SETUP = 15,
+	NAN_ATTR_FTM_RANGE_REPORT = 16,
+	NAN_ATTR_SVC_DESC_EXTENSION = 17,
+	NAN_ATTR_NAN_DEV_CAP = 18,
+	NAN_ATTR_NAN_NDP = 19,
+	NAN_ATTR_NAN_NMSG = 20,
+	NAN_ATTR_NAN_AVAIL = 21,
+	NAN_ATTR_NAN_NDC = 22,
+	NAN_ATTR_NAN_NDL = 23,
+	NAN_ATTR_NAN_NDL_QOS = 24,
+	NAN_ATTR_MCAST_SCHED = 25,
+	NAN_ATTR_UNALIGNED_SCHED = 26, /* Note: This is duplicate in spec. */
+	NAN_ATTR_PAGING_UCAST = 27,
+	NAN_ATTR_PAGING_MCAST = 28,
+	NAN_ATTR_RANGING_INFO = 29,
+	NAN_ATTR_NAN_RANGING_SETUP = 30, /* Note: This is duplicate in spec. */
+	NAN_ATTR_NAN_FTM_RANGE_REPORT = 31, /* Note: This is duplicate in spec. */
+	NAN_ATTR_ELEMENT_CONTAINER = 32,
+	NAN_ATTR_WLAN_INFRA_EXT = 33,
+	NAN_ATTR_EXT_P2P_OPER = 34,
+	NAN_ATTR_EXT_IBSS = 35,
+	NAN_ATTR_EXT_MESH = 36,
+
+	NAN_ATTR_VENDOR_SPECIFIC = 221,
+	NAN_ATTR_NAN_MGMT	= 222	/* NAN Mgmt Attr (TBD; not in spec yet) */
+};
+
+#define NAN_ALL_NAN_MGMT_FRAMES (NAN_FRM_MGMT_AF | \
+	NAN_FRM_NDP_AF | NAN_FRM_NDL_AF | \
+	NAN_FRM_DISC_BCN | NAN_FRM_SYNC_BCN | \
+	NAN_FRM_SVC_DISC)
+
+enum wifi_nan_avail_resolution {
+	NAN_AVAIL_RES_16_TU = 0,
+	NAN_AVAIL_RES_32_TU = 1,
+	NAN_AVAIL_RES_64_TU = 2,
+	NAN_AVAIL_RES_INVALID = 255
+};
+
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_ie_s {
+	uint8	id;		/* IE ID: NAN_IE_ID 0xDD */
+	uint8	len;		/* IE length */
+	uint8	oui[DOT11_OUI_LEN]; /* NAN_OUI 50:6F:9A */
+	uint8	oui_type;	/* NAN_OUI_TYPE 0x13 */
+	uint8	attr[1];	/* var len attributes */
+} BWL_POST_PACKED_STRUCT wifi_nan_ie_t;
+
+#define NAN_IE_HDR_SIZE	(OFFSETOF(wifi_nan_ie_t, attr))
+
+/* master indication record  */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_master_ind_attr_s {
+	uint8	id;
+	uint16	len;
+	uint8	master_preference;
+	uint8	random_factor;
+} BWL_POST_PACKED_STRUCT wifi_nan_master_ind_attr_t;
+
+/* cluster attr record  */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_cluster_attr_s {
+	uint8	id;
+	uint16	len;
+	uint8   amr[NAN_MASTER_RANK_LEN];
+	uint8   hop_count;
+	/* Anchor Master Beacon Transmission Time */
+	uint32  ambtt;
+} BWL_POST_PACKED_STRUCT wifi_nan_cluster_attr_t;
+
+/*  container for service ID records  */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_svc_id_attr_s {
+	uint8	id;
+	uint16	len;
+	uint8	svcid[0]; /* 6*len of srvc IDs */
+} BWL_POST_PACKED_STRUCT wifi_nan_svc_id_attr_t;
+
+/* service_control bitmap for wifi_nan_svc_descriptor_attr_t below */
+#define NAN_SC_PUBLISH 0x0
+#define NAN_SC_SUBSCRIBE 0x1
+#define NAN_SC_FOLLOWUP 0x2
+/* Set to 1 if a Matching Filter field is included in descriptors. */
+#define NAN_SC_MATCHING_FILTER_PRESENT 0x4
+/* Set to 1 if a Service Response Filter field is included in descriptors. */
+#define NAN_SC_SR_FILTER_PRESENT 0x8
+/* Set to 1 if a Service Info field is included in descriptors. */
+#define NAN_SC_SVC_INFO_PRESENT 0x10
+/* range is close proximity only */
+#define NAN_SC_RANGE_LIMITED 0x20
+/* Set to 1 if binding bitamp is present in descriptors */
+#define NAN_SC_BINDING_BITMAP_PRESENT 0x40
+
+/* Service descriptor */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_svc_descriptor_attr_s {
+	/* Attribute ID - 0x03. */
+	uint8 id;
+	/* Length of the following fields in the attribute */
+	uint16 len;
+	/* Hash of the Service Name */
+	uint8 svc_hash[NAN_SVC_HASH_LEN];
+	/* Publish or subscribe instance id */
+	uint8 instance_id;
+	/* Requestor Instance ID */
+	uint8 requestor_id;
+	/* Service Control Bitmask. Also determines what data follows. */
+	uint8 svc_control;
+	/* Optional fields follow */
+} BWL_POST_PACKED_STRUCT wifi_nan_svc_descriptor_attr_t;
+
+/* IBSS attribute */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_ibss_attr_s {
+	/* Attribute ID - 0x07. */
+	uint8 id;
+	/* Length of the following fields in the attribute */
+	uint16 len;
+	/* BSSID of the ibss */
+	struct ether_addr bssid;
+	/*
+	 map control:, bits:
+	[0-3]: Id for associated further avail map attribute
+	[4-5]: avail interval duration: 0:16ms; 1:32ms; 2:64ms; 3:reserved
+	[6] : repeat : 0 - applies to next DW, 1: 16 intervals max? wtf?
+	[7] : reserved
+	*/
+	uint8 map_ctrl;
+	/* avail. intervals bitmap, var len  */
+	uint8 avail_bmp[1];
+} BWL_POST_PACKED_STRUCT wifi_nan_ibss_attr_t;
+
+/* Further Availability MAP attr  */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_favail_attr_s {
+	/* Attribute ID - 0x0A. */
+	uint8 id;
+	/* Length of the following fields in the attribute */
+	uint16 len;
+	/* MAP id: val [0..15], values[16-255] reserved */
+	uint8 map_id;
+	/*  availibility entry, var len */
+	uint8 avil_entry[1];
+} BWL_POST_PACKED_STRUCT wifi_nan_favail_attr_t;
+
+/* Further Availability MAP attr  */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_avail_entry_s {
+	/*
+	 entry control
+	 [0-1]: avail interval duration: 0:16ms; 1:32ms; 2:64ms;
+	 [2:7] reserved
+	*/
+	uint8 entry_ctrl;
+	/* operating class: freq band etc IEEE 802.11 */
+	uint8 opclass;
+	/* channel number */
+	uint8 chan;
+	/*  avail bmp, var len */
+	uint8 avail_bmp[1];
+} BWL_POST_PACKED_STRUCT wifi_nan_avail_entry_t;
+
+/* Map control Field */
+#define NAN_MAPCTRL_IDMASK	0x7
+#define NAN_MAPCTRL_DURSHIFT	4
+#define NAN_MAPCTRL_DURMASK	0x30
+#define NAN_MAPCTRL_REPEAT	0x40
+#define NAN_MAPCTRL_REPEATSHIFT	6
+
+#define NAN_VENDOR_TYPE_RTT	0
+#define NAN_VENDOR_TYPE_P2P	1
+
+/* Vendor Specific Attribute */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_vendor_attr_s {
+	uint8	id;			/* 0xDD */
+	uint16	len;		/* IE length */
+	uint8	oui[DOT11_OUI_LEN]; /* 00-90-4C */
+	uint8	type;		/* attribute type */
+	uint8	attr[1];	/* var len attributes */
+} BWL_POST_PACKED_STRUCT wifi_nan_vendor_attr_t;
+
+#define NAN_VENDOR_HDR_SIZE	(OFFSETOF(wifi_nan_vendor_attr_t, attr))
+
+/* p2p operation attribute */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_p2p_op_attr_s {
+	/* Attribute ID - 0x06. */
+	uint8 id;
+	/* Length of the following fields in the attribute */
+	uint16 len;
+	/* P2P device role */
+	uint8 dev_role;
+	/* BSSID of the ibss */
+	struct ether_addr p2p_dev_addr;
+	/*
+	map control:, bits:
+	[0-3]: Id for associated further avail map attribute
+	[4-5]: avail interval duration: 0:16ms; 1:32ms; 2:64ms; 3:reserved
+	[6] : repeat : 0 - applies to next DW, 1: 16 intervals max? wtf?
+	[7] : reserved
+	*/
+	uint8 map_ctrl;
+	/* avail. intervals bitmap */
+	uint8 avail_bmp[1];
+} BWL_POST_PACKED_STRUCT wifi_nan_p2p_op_attr_t;
+
+/* ranging attribute */
+#define NAN_RANGING_MAP_CTRL_ID_SHIFT 0
+#define NAN_RANGING_MAP_CTRL_ID_MASK 0x0F
+#define NAN_RANGING_MAP_CTRL_DUR_SHIFT 4
+#define NAN_RANGING_MAP_CTRL_DUR_MASK 0x30
+#define NAN_RANGING_MAP_CTRL_REPEAT_SHIFT 6
+#define NAN_RANGING_MAP_CTRL_REPEAT_MASK 0x40
+#define NAN_RANGING_MAP_CTRL_REPEAT_DW(_ctrl) (((_ctrl) & \
+	NAN_RANGING_MAP_CTRL_DUR_MASK) ? 16 : 1)
+#define NAN_RANGING_MAP_CTRL(_id, _dur, _repeat) (\
+	(((_id) << NAN_RANGING_MAP_CTRL_ID_SHIFT) & \
+		 NAN_RANGING_MAP_CTRL_ID_MASK) | \
+	(((_dur) << NAN_RANGING_MAP_CTRL_DUR_SHIFT) & \
+		NAN_RANGING_MAP_CTRL_DUR_MASK) | \
+	(((_repeat) << NAN_RANGING_MAP_CTRL_REPEAT_SHIFT) & \
+		 NAN_RANGING_MAP_CTRL_REPEAT_MASK))
+
+enum {
+	NAN_RANGING_PROTO_FTM = 0
+};
+
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_ranging_attr_s {
+	uint8 id;			/* 0x0C */
+	uint16 len;			/* length that follows */
+	struct ether_addr dev_addr;	/* device mac address */
+
+	/*
+	map control:, bits:
+	[0-3]: Id for associated further avail map attribute
+	[4-5]: avail interval duration: 0:16ms; 1:32ms; 2:64ms; 3:reserved
+	[6] : repeat : 0 - applies to next DW, 1: 16 intervals max? wtf?
+	[7] : reserved
+	*/
+	uint8 map_ctrl;
+
+	uint8 protocol;					/* FTM = 0 */
+	uint32 avail_bmp;				/* avail interval bitmap */
+} BWL_POST_PACKED_STRUCT wifi_nan_ranging_attr_t;
+
+#define NAN_CONN_CAPABILITY_WFD		0x0001
+#define NAN_CONN_CAPABILITY_WFDS	0x0002
+#define NAN_CONN_CAPABILITY_TDLS	0x0004
+#define NAN_CONN_CAPABILITY_INFRA	0x0008
+#define NAN_CONN_CAPABILITY_IBSS	0x0010
+#define NAN_CONN_CAPABILITY_MESH	0x0020
+
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_conn_cap_attr_s {
+	/* Attribute ID - 0x04. */
+	uint8 id;
+	/* Length of the following fields in the attribute */
+	uint16	len;
+	uint16	conn_cap_bmp;	/* Connection capability bitmap */
+} BWL_POST_PACKED_STRUCT wifi_nan_conn_cap_attr_t;
+
+#define NAN_SLOT_RES_16TU 16
+#define NAN_SLOT_RES_32TU 32
+#define NAN_SLOT_RES_64TU 64
+
+/* NAN 2.0 (section 5.7.18.2): NAN availability attribute */
+
+/* NAN Availability Attribute */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_availability_attr_s {
+	uint8 id;				/* TBD */
+	uint16 len;				/* length that follows */
+	uint8 attr_cntrl[3];			/* attribute control */
+	uint8 avail_entry_list[1];		/* availability entry list */
+} BWL_POST_PACKED_STRUCT wifi_nan_availability_attr_t;
+
+/* Attribute Control field */
+#define NAN_ATTR_CNTRL_MAP_ID_MASK	0x0F	/* Map Id */
+#define NAN_ATTR_CNTRL_RSVD_MASK	0xF0	/* Reserved */
+#define NAN_ATTR_CNTRL_SEQ_ID_MASK	0xFF	/* Seq Id */
+
+/* Availability Entry format */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_avail_entry_attr_s {
+	uint16 len;		/* Length */
+	uint32 entry_cntrl;	/* Entry Control */
+	uint8 var[1];	/* Time Bitmap & Channel Entry List */
+} BWL_POST_PACKED_STRUCT wifi_nan_avail_entry_attr_t;
+
+/* Entry Control Field (section 5.7.18.2.2) */
+
+/* Type of  Availability */
+#define NAN_ENTRY_CNTRL_TYPE_OF_AVAIL_MASK	0x07
+#define NAN_ENTRY_CNTRL_TYPE_OF_AVAIL_SHIFT	0
+/* Usage Preference */
+#define NAN_ENTRY_CNTRL_USAGE_PREF_MASK		0x18
+#define NAN_ENTRY_CNTRL_USAGE_PREF_SHIFT	3
+/* Utilization */
+#define NAN_ENTRY_CNTRL_UTIL_MASK		0x1E0
+#define NAN_ENTRY_CNTRL_UTIL_SHIFT		5
+/* Rx Nss */
+#define NAN_ENTRY_CNTRL_RX_NSS_MASK		0x1E00
+#define NAN_ENTRY_CNTRL_RX_NSS_SHIFT		9
+/* Paged Resource block */
+#define NAN_ENTRY_CNTRL_PAGED_RSC_BLK_MASK	0x2000
+#define NAN_ENTRY_CNTRL_PAGED_RSC_BLK_SHIFT	13
+/* Time Bitmap Present */
+#define NAN_ENTRY_CNTRL_TIME_BMP_PRSNT_MASK	0x4000
+#define NAN_ENTRY_CNTRL_TIME_BMP_PRSNT_SHIFT	14
+/* Channel Entry Present */
+#define NAN_ENTRY_CNTRL_CHAN_ENTRY_PRSNT_MASK	0x8000
+#define NAN_ENTRY_CNTRL_CHAN_ENTRY_PRSNT_SHIFT	15
+/* Reserved */
+#define NAN_ENTRY_CNTRL_RESERVED_MASK		0xFF0000
+#define NAN_ENTRY_CNTRL_RESERVED_SHIFT		16
+
+/* Type of  Availability: committed */
+#define NAN_ENTRY_CNTRL_TYPE_COMM_AVAIL	        0x1
+/* Type of  Availability: potential */
+#define NAN_ENTRY_CNTRL_TYPE_POTEN_AVAIL	0x2
+/* Type of  Availability: conditional */
+#define NAN_ENTRY_CNTRL_TYPE_COND_AVAIL	        0x4
+
+/* Type of  Availability: committed */
+#define NAN_ENTRY_CNTRL_TYPE_COMM_AVAIL_MASK	0x1
+/* Type of  Availability: potential */
+#define NAN_ENTRY_CNTRL_TYPE_POTEN_AVAIL_MASK	0x2
+/* Type of  Availability: conditional */
+#define NAN_ENTRY_CNTRL_TYPE_COND_AVAIL_MASK	0x4
+
+
+/* Time Bitmap Control field (section 5.7.18.2.3) */
+
+/* Reserved */
+#define NAN_TIME_BMP_CNTRL_RSVD_MASK	0x01
+#define NAN_TIME_BMP_CNTRL_RSVD_SHIFT	0
+/* Bitmap Len */
+#define NAN_TIME_BMP_CNTRL_BMP_LEN_MASK	0x7E
+#define NAN_TIME_BMP_CNTRL_BMP_LEN_SHIFT 1
+/* Bit Duration */
+#define NAN_TIME_BMP_CNTRL_BIT_DUR_MASK	0x380
+#define NAN_TIME_BMP_CNTRL_BIT_DUR_SHIFT	7
+/* Bitmap Len */
+#define NAN_TIME_BMP_CNTRL_PERIOD_MASK	0x1C00
+#define NAN_TIME_BMP_CNTRL_PERIOD_SHIFT	10
+/* Start Offset */
+#define NAN_TIME_BMP_CNTRL_START_OFFSET_MASK	0x3FE000
+#define NAN_TIME_BMP_CNTRL_START_OFFSET_SHIFT	13
+/* Reserved */
+#define NAN_TIME_BMP_CNTRL_RESERVED_MASK	0xC00000
+#define NAN_TIME_BMP_CNTRL_RESERVED_SHIFT	22
+
+/* Time Bitmap Control field: Bit Duration */
+typedef enum
+{
+	NAN_TIME_BMP_CTRL_BIT_DUR_DUR_16TU = 0,
+	NAN_TIME_BMP_CTRL_BIT_DUR_DUR_32TU = 1,
+	NAN_TIME_BMP_CTRL_BIT_DUR_DUR_48TU = 2,
+	NAN_TIME_BMP_CTRL_BIT_DUR_DUR_64TU = 3,
+	NAN_TIME_BMP_CTRL_BIT_DUR_DUR_80TU = 4,
+	NAN_TIME_BMP_CTRL_BIT_DUR_DUR_96TU = 5,
+	NAN_TIME_BMP_CTRL_BIT_DUR_DUR_112TU = 6,
+	NAN_TIME_BMP_CTRL_BIT_DUR_DUR_128TU = 7
+} nan_time_bmp_ctrl_bit_dur_t;
+
+/* Time Bitmap Control field: Period */
+typedef enum
+{
+	NAN_TIME_BMP_CTRL_PERIOD_128TU = 1,
+	NAN_TIME_BMP_CTRL_PERIOD_256TU,
+	NAN_TIME_BMP_CTRL_PERIOD_512TU,
+	NAN_TIME_BMP_CTRL_PERIOD_1024TU,
+	NAN_TIME_BMP_CTRL_PERIOD_2048U,
+	NAN_TIME_BMP_CTRL_PERIOD_4096U,
+	NAN_TIME_BMP_CTRL_PERIOD_8192U
+} nan_time_bmp_ctrl_repeat_interval_t;
+
+/* FAC Channel Entry  (section 5.7.18.2.5) */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_fac_chan_entry_s {
+	uint8 oper_class;		/* Operating Class */
+	uint16 chan_bitmap;		/* Channel Bitmap */
+	uint8 primary_chan_bmp;		/* Primary Channel Bitmap */
+	uint8 aux_chan;			/* Auxiliary Channel */
+} BWL_POST_PACKED_STRUCT wifi_nan_fac_chan_entry_t;
+
+/* Channel Entries List field (section 5.7.18.2.4) */
+
+/* Type */
+#define NAN_CHAN_ENTRY_TYPE_MASK	0x01
+#define NAN_CHAN_ENTRY_TYPE_SHIFT	0
+/* Channel Entry Length Indication */
+#define NAN_CHAN_ENTRY_LEN_IND_MASK	0x02
+#define NAN_CHAN_ENTRY_LEN_IND_SHIFT	1
+/* Reserved */
+#define NAN_CHAN_ENTRY_RESERVED_MASK	0x0C
+#define NAN_CHAN_ENTRY_RESERVED_SHIFT	2
+/* Number of FAC Band or Channel Entries  */
+#define NAN_CHAN_ENTRY_NO_OF_CHAN_ENTRY_MASK	0xF0
+#define NAN_CHAN_ENTRY_NO_OF_CHAN_ENTRY_SHIFT	4
+
+#define NAN_CHAN_ENTRY_TYPE_BANDS	0
+#define NAN_CHAN_ENTRY_TYPE_OPCLASS_CHANS	1
+
+#define NAN_CHAN_ENTRY_BW_LT_80MHZ	0
+#define NAN_CHAN_ENTRY_BW_EQ_160MHZ	1
+
+/* Device Capability Attribute (section 5.7.17.4) */
+
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_dev_cap_s {
+	uint8 id;		/* TBD */
+	uint16 len;		/* Length */
+	uint8 awake_dw_info;	/* Awake DW Info */
+	uint8 bands_supported;	/* Supported Bands */
+	uint8 op_mode;		/* Operation Mode */
+} BWL_POST_PACKED_STRUCT wifi_nan_dev_cap_t;
+
+/* Awake DW Info field format */
+
+/* 2.4GHz DW */
+#define NAN_DEV_CAP_AWAKE_DW_2G_MASK	0x07
+/* 5GHz DW */
+#define NAN_DEV_CAP_AWAKE_DW_5G_MASK	0x38
+/* Reserved */
+#define NAN_DEV_CAP_AWAKE_DW_RSVD_MASK	0xC0
+
+/* bit shift for dev cap */
+#define NAN_DEV_CAP_AWAKE_DW_2G_SHIFT	0
+#define NAN_DEV_CAP_AWAKE_DW_5G_SHIFT	3
+
+
+/* Device Capability Attribute Format */
+
+/* Operation Mode: HT */
+#define NAN_DEV_CAP_HT_OPER_MODE_MASK	0x01
+/* Operation Mode: VHT */
+#define NAN_DEV_CAP_VHT_OPER_MODE_MASK	0x02
+
+/* NAN2 Management Frame (section 5.6) */
+
+/* Public action frame for NAN2 */
+typedef BWL_PRE_PACKED_STRUCT struct nan2_pub_act_frame_s {
+	/* NAN_PUB_AF_CATEGORY 0x04 */
+	uint8 category_id;
+	/* NAN_PUB_AF_ACTION 0x09 */
+	uint8 action_field;
+	/* NAN_OUI 0x50-6F-9A */
+	uint8 oui[DOT11_OUI_LEN];
+	/* NAN_OUI_TYPE TBD */
+	uint8 oui_type;
+	/* NAN_OUI_SUB_TYPE TBD */
+	uint8 oui_sub_type;
+	/* NAN_PUB_AF_DIALOG_TOKEN */
+	uint8 dialog_token;
+	/* One or more NAN Attributes follow */
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT nan2_pub_act_frame_t;
+
+#define NAN2_PUB_ACT_FRM_SIZE	(OFFSETOF(nan2_pub_act_frame_t, data))
+
+/* NAN2 Management Frame Subtypes */
+
+/* NAN2 Management */
+#define NAN_MGMT_FRM_SUBTYPE_MGMT		0
+/* NAN Ranging Report */
+#define NAN_MGMT_FRM_SUBTYPE_RANGING_RPT	1
+/* GAS Sechdule Request */
+#define NAN_MGMT_FRM_SUBTYPE_GAS_SCHED_REQ	2
+/* GAS Sechdule Response */
+#define NAN_MGMT_FRM_SUBTYPE_GAS_SCHED_RESP	3
+/* NAN Ranging Request */
+#define NAN_MGMT_FRM_SUBTYPE_RANGING_REQ	4
+/* NAN Ranging Response */
+#define NAN_MGMT_FRM_SUBTYPE_RANGING_RESP	5
+/* NDP Request */
+#define NAN_MGMT_FRM_SUBTYPE_NDP_REQ		6
+/* NDP Response */
+#define NAN_MGMT_FRM_SUBTYPE_NDP_RESP		7
+
+/* NDP End (internal implementation) */
+#define NAN_MGMT_FRM_SUBTYPE_NDP_END		8
+
+/* NDL Schedule request */
+#define NAN_MGMT_FRM_SUBTYPE_NDL_UPDATE_REQ	9
+/* NDL Schedule response */
+#define	NAN_MGMT_FRM_SUBTYPE_NDL_UPDATE_RESP	10
+
+/* nan 2.0 qos */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_ndp_qos_s {
+	uint8 tid;		/* traffic identifier */
+	uint16 pkt_size;	/* service data pkt size */
+	uint8 data_rate;	/* mean data rate */
+	uint8 svc_interval;	/* max service interval */
+} BWL_POST_PACKED_STRUCT wifi_nan_ndp_qos_t;
+
+/* NDP Information Element (internal) */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_ndp_setup_s {
+	uint8 id;		/* 221 */
+	uint8 len;		/* Length */
+	uint8 oui[DOT11_OUI_LEN];	/* "\x00\x10\x18" BRCM OUI */
+	uint8 type;		/* NAN_OUI_TYPE 0x13 */
+	uint8 subtype;		/* NAN_DATA_NDP_SETUP */
+	uint8 msg_type;		/* NDP Req, NDP Resp etc. */
+	uint8 pub_inst_id;	/* publish instance id */
+	struct ether_addr peer_mac_addr; /* publisher mac addr (aka peer mgmt address) */
+	struct ether_addr data_if_addr;	/* local data i/f address */
+	uint8 msg_status;
+	uint8 security;
+	wifi_nan_ndp_qos_t qos;	/* qos info */
+	uint8 var[1];		/* NDP specific info */
+} BWL_POST_PACKED_STRUCT wifi_nan_ndp_setup_t;
+
+/* NDP Setup Status */
+#define NAN_NDP_SETUP_STATUS_OK		1
+#define NAN_NDP_SETUP_STATUS_FAIL	0
+#define NAN_NDP_SETUP_STATUS_REJECT	2
+
+/* NAN mgmt information element */
+typedef BWL_PRE_PACKED_STRUCT struct wifi_nan_mgmt_setup_s {
+	uint8 id;		/* 221 */
+	uint8 len;		/* Length */
+	uint8 oui[DOT11_OUI_LEN];	/* "\x00\x10\x18" BRCM OUI */
+	uint8 type;		/* NAN_OUI_TYPE 0x13 */
+	uint8 subtype;		/* NAN_DATA_MGMT_SETUP */
+	uint8 msg_type;		/* Mgmt Req, Mgmt Resp etc. */
+	uint8 msg_status;
+} BWL_POST_PACKED_STRUCT wifi_nan_mgmt_setup_t;
+
+/* NAN Mgmt Request */
+#define NAN_MGMT_SETUP_MSG_REQ	1	/* don't use 0 */
+/* NAN Mgmt Response */
+#define NAN_MGMT_SETUP_MSG_RESP	2
+
+/* NAN Mgmt Setup Status */
+#define NAN_MGMT_SETUP_STATUS_OK	0
+#define NAN_MGMT_SETUP_STATUS_FAIL	1
+#define NAN_MGMT_SETUP_STATUS_REJECT	2
+
+/* This marks the end of a packed structure section. */
+#include <packed_section_end.h>
+
+#endif /* _NAN_H_ */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/p2p.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/p2p.h
index 747265b9a2c2..3bd8b5fa0673 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/p2p.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/p2p.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental types and constants relating to WFA P2P (aka WiFi Direct)
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/sdspi.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/sdspi.h
index ca6e96eac051..924aff9b0f70 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/sdspi.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/sdspi.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SD-SPI Protocol Standard
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/vlan.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/vlan.h
index 062119d1faf2..e839f32ceca4 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/vlan.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/vlan.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * 802.1Q VLAN protocol definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/wpa.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/wpa.h
index c45920e64033..8e63543e6eef 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/wpa.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/wpa.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Fundamental types and constants relating to WPA
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/wps.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/wps.h
index aa4cc1b9f0e0..6b0c9846b580 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/wps.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/proto/wps.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * WPS IE definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/rte_ioctl.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/rte_ioctl.h
index 2176c90d469f..83bbb0914b05 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/rte_ioctl.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/rte_ioctl.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HND Run Time Environment ioctl.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbchipc.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbchipc.h
index 24b3010e8f84..d5e434ab3f2e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbchipc.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbchipc.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SiliconBackplane Chipcommon core hardware definitions.
  *
@@ -5,9 +6,9 @@
  * JTAG, 0/1/2 UARTs, clock frequency control, a watchdog interrupt timer,
  * GPIO interface, extbus, and support for serial and parallel flashes.
  *
- * $Id: sbchipc.h 603826 2015-12-03 08:57:00Z $
+ * $Id: sbchipc.h 722050 2019-08-21 02:24:57Z $
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -2853,6 +2854,31 @@ typedef volatile struct {
 #define CC6_4349_PMU_EN_MDIO_MASK		(1 << 16)
 #define CC6_4349_PMU_EN_ASSERT_L2_MASK		(1 << 25)
 
+#define CR4_4373_RAM_BASE                       (0x160000)
+
+#define CST4373_JTAG_ENABLE(cs)                (((cs) & (1 << 0)) != 0)
+#define CST4373_CHIPMODE_RSRC_INIT0(cs) (((cs) & (1 << 1)) != 0)
+#define CST4373_SFLASH_PRESENT(cs)      (((cs) & (1 << 4)) != 0)
+#define CST4373_SDIO_PADVDDIO(cs)       (((cs) & (1 << 5)) != 0)
+#define CST4373_CHIPMODE_PCIE(cs)       (((cs) & (1 << 6)) != 0)
+#define CST4373_CHIPMODE_SDIOD(cs)      (((cs) & (1 << 7)) != 0)
+#define CST4373_CHIPMODE_USB20D(cs)     (((cs) & (1 << 8)) != 0)
+#define CST4373_USBHUB_BYPASS(cs)       (((cs) & (1 << 9)) != 0)
+#define STRAP4373_CHIPMODE_RSRC_INIT1           0x1
+#define STRAP4373_VTRIM_EN                      0x1
+#define STRAP4373_SFLASH_PRESENT                0x1
+#define OTP4373_SFLASH_BYTE_OFFSET              680
+#define OTP4373_SFLASH_MASK                     0x3F
+#define OTP4373_SFLASH_PRESENT_MASK             0x1
+#define OTP4373_SFLASH_TYPE_MASK                0x2
+#define OTP4373_SFLASH_TYPE_SHIFT               0x1
+#define OTP4373_SFLASH_CLKDIV_MASK              0x3C
+#define OTP4373_SFLASH_CLKDIV_SHIFT             0x2
+#define SPROM4373_OTP_SELECT                    0x00000010
+#define SPROM4373_OTP_PRESENT                   0x00000020
+#define CC4373_SFLASH_CLKDIV_MASK               0x1F000000
+#define CC4373_SFLASH_CLKDIV_SHIFT		25
+
 
 
 /* 43430 PMU resources based on pmu_params.xls */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbconfig.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbconfig.h
index ad9c408cd344..13a51b1a1a72 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbconfig.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbconfig.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom SiliconBackplane hardware register definitions.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbhnddma.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbhnddma.h
index d66a0b6172ae..0dd3848d38c3 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbhnddma.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbhnddma.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Generic Broadcom Home Networking Division (HND) DMA engine HW interface
  * This supports the following chips: BCM42xx, 44xx, 47xx .
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbpcmcia.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbpcmcia.h
index 121d22c4cec9..2908456bfb4c 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbpcmcia.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbpcmcia.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BCM43XX Sonics SiliconBackplane PCMCIA core hardware definitions.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsdio.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsdio.h
index 68707c4d489e..e69c37fa1f4d 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsdio.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsdio.h
@@ -1,10 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SDIO device core hardware definitions.
  * sdio is a portion of the pcmcia core in core rev 3 - rev 8
  *
  * SDIO core support 1bit, 4 bit SDIO mode as well as SPI mode.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsdpcmdev.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsdpcmdev.h
index 8c5fd56705a5..fb647e5cf6fe 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsdpcmdev.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsdpcmdev.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom SiliconBackplane SDIO/PCMCIA hardware-specific
  * device core support
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsocram.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsocram.h
index fba899daa463..fa266ffddb0b 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsocram.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsocram.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * BCM47XX Sonics SiliconBackplane embedded ram core
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsysmem.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsysmem.h
index af99cde25a36..7537009f1a93 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsysmem.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sbsysmem.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SiliconBackplane System Memory core
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdio.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdio.h
index 2bb33667872b..d6a2867a688d 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdio.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdio.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SDIO spec header file
  * Protocol and standard (common) device definitions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdioh.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdioh.h
index f37c5f62aef7..ce25bd87494e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdioh.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdioh.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SDIO Host Controller Spec header file
  * Register map and definitions for the Standard Host Controller
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdiovar.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdiovar.h
index 4f1d82d7ab0f..8abf4b44af65 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdiovar.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/sdiovar.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Structure used by apps whose drivers access SDIO drivers.
  * Pulled out separately so dhdu and wlu can both use it.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/siutils.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/siutils.h
index fae2349f4096..fb104c171117 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/siutils.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/siutils.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc utility routines for accessing the SOC Interconnects
  * of Broadcom HNBU chips.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/spid.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/spid.h
index 8fdefa43778b..bec76249b867 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/spid.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/spid.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SPI device spec header file
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/trxhdr.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/trxhdr.h
index 50cd3c1ac952..fa9b8c8ed27b 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/trxhdr.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/trxhdr.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * TRX image file header format.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/typedefs.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/typedefs.h
index 2a1aa5c11b2c..4cb67d5b03d2 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/typedefs.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/typedefs.h
@@ -1,5 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/usbrdl.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/usbrdl.h
new file mode 100644
index 000000000000..c5a565f40c8d
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/usbrdl.h
@@ -0,0 +1,135 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Broadcom USB remote download definitions
+ *
+ * Copyright (C) 1999-2019, Broadcom Corporation
+ * 
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ * 
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ * 
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * $Id: usbrdl.h 708672 2018-11-16 02:34:41Z $
+ */
+
+#ifndef _USB_RDL_H
+#define _USB_RDL_H
+
+/* Control messages: bRequest values */
+#define DL_GETSTATE		0	/* returns the rdl_state_t struct */
+#define DL_CHECK_CRC		1	/* currently unused */
+#define DL_GO			2	/* execute downloaded image */
+#define DL_START		3	/* initialize dl state */
+#define DL_REBOOT		4	/* reboot the device in 2 seconds */
+#define DL_GETVER		5	/* returns the bootrom_id_t struct */
+#define DL_GO_PROTECTED		6	/* execute the downloaded code and set reset event
+					 * to occur in 2 seconds.  It is the responsibility
+					 * of the downloaded code to clear this event
+					 */
+#define DL_EXEC			7	/* jump to a supplied address */
+#define DL_RESETCFG		8	/* To support single enum on dongle
+					 * - Not used by bootloader
+					 */
+#define DL_DEFER_RESP_OK	9	/* Potentially defer the response to setup
+					 * if resp unavailable
+					 */
+#define DL_CHGSPD		0x0A
+
+#define	DL_HWCMD_MASK		0xfc	/* Mask for hardware read commands: */
+#define	DL_RDHW			0x10	/* Read a hardware address (Ctl-in) */
+#define	DL_RDHW32		0x10	/* Read a 32 bit word */
+#define	DL_RDHW16		0x11	/* Read 16 bits */
+#define	DL_RDHW8		0x12	/* Read an 8 bit byte */
+#define	DL_WRHW			0x14	/* Write a hardware address (Ctl-out) */
+#define DL_WRHW_BLK		0x13	/* Block write to hardware access */
+
+#define DL_CMD_WRHW		2
+
+
+/* states */
+#define DL_WAITING	0	/* waiting to rx first pkt that includes the hdr info */
+#define DL_READY	1	/* hdr was good, waiting for more of the compressed image */
+#define DL_BAD_HDR	2	/* hdr was corrupted */
+#define DL_BAD_CRC	3	/* compressed image was corrupted */
+#define DL_RUNNABLE	4	/* download was successful, waiting for go cmd */
+#define DL_START_FAIL	5	/* failed to initialize correctly */
+#define DL_NVRAM_TOOBIG	6	/* host specified nvram data exceeds DL_NVRAM value */
+#define DL_IMAGE_TOOBIG	7	/* download image too big (exceeds DATA_START for rdl) */
+
+#define TIMEOUT		5000	/* Timeout for usb commands */
+
+struct bcm_device_id {
+	char	*name;
+	uint32	vend;
+	uint32	prod;
+};
+
+typedef struct {
+	uint32	state;
+	uint32	bytes;
+} rdl_state_t;
+
+typedef struct {
+	uint32	chip;		/* Chip id */
+	uint32	chiprev;	/* Chip rev */
+	uint32  ramsize;    /* Size of RAM */
+	uint32  remapbase;   /* Current remap base address */
+	uint32  boardtype;   /* Type of board */
+	uint32  boardrev;    /* Board revision */
+} bootrom_id_t;
+
+/* struct for backplane & jtag accesses */
+typedef struct {
+	uint32	cmd;		/* tag to identify the cmd */
+	uint32	addr;		/* backplane address for write */
+	uint32	len;		/* length of data: 1, 2, 4 bytes */
+	uint32	data;		/* data to write */
+} hwacc_t;
+
+
+/* struct for querying nvram params from bootloader */
+#define QUERY_STRING_MAX 32
+typedef struct {
+	uint32  cmd;                    /* tag to identify the cmd */
+	char    var[QUERY_STRING_MAX];  /* param name */
+} nvparam_t;
+
+typedef void (*exec_fn_t)(void *sih);
+
+#define USB_CTRL_IN (USB_TYPE_VENDOR | 0x80 | USB_RECIP_INTERFACE)
+#define USB_CTRL_OUT (USB_TYPE_VENDOR | 0 | USB_RECIP_INTERFACE)
+
+#define USB_CTRL_EP_TIMEOUT 500 /* Timeout used in USB control_msg transactions. */
+#define USB_BULK_EP_TIMEOUT 500 /* Timeout used in USB bulk transactions. */
+
+#define RDL_CHUNK_MAX	(64 * 1024)  /* max size of each dl transfer */
+#define RDL_CHUNK	1500  /* size of each dl transfer */
+
+/* bootloader makes special use of trx header "offsets" array */
+#define TRX_OFFSETS_DLFWLEN_IDX	0	/* Size of the fw; used in uncompressed case */
+#define TRX_OFFSETS_JUMPTO_IDX	1	/* RAM address for jumpto after download */
+#define TRX_OFFSETS_NVM_LEN_IDX	2	/* Length of appended NVRAM data */
+#ifdef BCMTRXV2
+#define TRX_OFFSETS_DSG_LEN_IDX	3	/* Length of digital signature for the first image */
+#define TRX_OFFSETS_CFG_LEN_IDX	4	/* Length of config region, which is not digitally signed */
+#endif /* BCMTRXV2 */
+
+#define TRX_OFFSETS_DLBASE_IDX  0       /* RAM start address for download */
+
+#endif  /* _USB_RDL_H */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlfc_proto.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlfc_proto.h
index a2d60f41f423..e604d538f4a7 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlfc_proto.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlfc_proto.h
@@ -1,5 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlioctl.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlioctl.h
index 2e0940179e79..7bf4b380b2c5 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlioctl.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlioctl.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Custom OID/ioctl definitions for
  *
@@ -6,7 +7,7 @@
  *
  * Definitions subject to change without notice.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -27,7 +28,7 @@
  * other than the GPL, without Broadcom's express prior written consent.
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: wlioctl.h 606700 2015-12-16 12:15:50Z $
+ * $Id: wlioctl.h 712434 2019-03-22 05:15:30Z $
  */
 
 #ifndef _wlioctl_h_
@@ -5198,6 +5199,34 @@ typedef BWL_PRE_PACKED_STRUCT struct wlc_ipfo_route_tbl {
 	wlc_ipfo_route_entry_t route_entry[1];
 } BWL_POST_PACKED_STRUCT wlc_ipfo_route_tbl_t;
 
+#ifdef WL_OLDPPR
+#define WL_CLM_NUM_RATES        178
+typedef BWL_PRE_PACKED_STRUCT struct {
+        uint32 flags;
+        chanspec_t chanspec;                    /* txpwr report for this channel */
+        chanspec_t local_chanspec;              /* channel on which we are associated */
+	uint8 local_max;                        /* local max according to the AP */
+	uint8 local_constraint;                 /* local constraint according to the AP */
+	int8  antgain[2];                       /* Ant gain for each band - from SROM */
+	uint8 rf_cores;                         /* count of RF Cores being reported */
+	uint8 est_Pout[4];                      /* Latest tx power out estimate per RF chain */
+	uint8 est_Pout_act[4];                  /* Latest tx power out estimate per RF chain
+	                                         * without adjustment
+	                                         */
+	uint8 est_Pout_cck;                     /* Latest CCK tx power out estimate */
+	uint8 tx_power_max[4];                  /* Maximum target power among all rates */
+	uint8 tx_power_max_rate_ind[4];         /* Index of the rate with the max target power */
+	uint8 user_limit;                       /* User limit */
+	int8 clm_limits[WL_CLM_NUM_RATES];              /* regulatory limits - 20 or 40MHz */
+	int8 clm_limits20in40[WL_CLM_NUM_RATES];        /* regulatory limits - 20in40MHz */
+	int8 sar;                               /* SAR limit for display by wl executable */
+	bool bandwidth_is_20MHz;                                /* 20 or 40MHz bandwidth? */
+	uint board_limit_len;                   /* board limit buffer length */
+	uint target_len;                        /* target limit buffer length */
+	uint8 ppr_buf[1];                       /* ppr serialization buffer */
+} BWL_POST_PACKED_STRUCT tx_pwr_rpt_t_old;
+#endif /* WL_OLDPPR */
+
 #define WL_IPFO_ROUTE_TBL_FIXED_LEN 4
 #define WL_MAX_IPFO_ROUTE_TBL_ENTRY	64
 
@@ -8505,6 +8534,14 @@ typedef struct {
 } wl_roam_channel_list_t;
 #endif 
 
+#ifdef MFP
+/* values for IOV_MFP arg */
+enum {
+    WL_MFP_NONE = 0,
+    WL_MFP_CAPABLE,
+    WL_MFP_REQUIRED
+};
+#endif /* MFP */
 
 /*
  * WOWL unassociated mode power svae pattern.
@@ -8527,4 +8564,204 @@ typedef struct wl_peer_rssi {
 	struct ether_addr ea;
 } wl_peer_rssi_t;
 
+#define GPIO_WAKE_PAYLOAD_MAXSIZE	1024
+#define MAX_GPIO_WAKE_INT_SIZE		(sizeof(wl_gpio_wake_int_t)+GPIO_WAKE_PAYLOAD_MAXSIZE-1)
+
+enum {
+	GPIO_WAKE_PROTO_TCP = 0,
+	GPIO_WAKE_PROTO_RAW,
+};
+
+typedef struct wl_gpio_wake_int_s {
+	uint8 enable;
+	uint8 proto;
+	uint8 idx;
+	uint16 data_len;
+	uint8 data[1];
+} wl_gpio_wake_int_t;
+
+/*
+ * DHCP lease time renew offload definitions
+ */
+
+/* common iovar struct */
+typedef struct wl_dltro {
+	uint8 subcmd_id;	/* subcommand id */
+	uint8 pad;
+	uint16 len;		/* total length of data[] */
+	uint8 data[1];		/* subcommand data */
+} wl_dltro_t;
+
+
+/* Subcommand ids */
+#define WL_DLTRO_SUBCMD_CONNECT     0   /* DLTRO connection info */
+#define WL_DLTRO_SUBCMD_PARAM       1   /* DLTRO parameter info */
+#define WL_DLTRO_SUBCMD_MAX_DLTRO   2   /* Max DLTRO supported */
+
+/* WL_DLTRO_SUBCMD_CONNECT subcommand data
+ * Invoke with unique 'index' for each DLTRO connection
+ */
+typedef struct wl_dltro_connect {
+	uint8 index;        /* DLTRO connection index, 0 to max-1 */
+	uint8 ip_addr_type;	/* 0 - IPv4, 1 - IPv6 */
+	uint8 offload_type; /* 0 - Client, 1 - Server */
+	uint8 pad;
+	uint32 tid;         /* Transaction id */
+	uint32 timer_val;   /* DHCP lease time remaining */
+	uint32 time_before_expiry; /* Time before expiry for DHCP lease renewal */
+	uint32 len;         /* Length of the variable data */
+	uint8 data[1];      /* Variable length field containing DLTRO packet */
+} wl_dltro_connect_t;
+
+/* WL_DLTRO_SUBCMD_PARAM subcommand data
+ * Invoke with unique 'index' for each DLTRO connection
+ */
+typedef struct wl_dltro_param {
+	uint8 index;        /* DLTRO connection index, 0 to max-1 */
+	uint8 retry;        /* Number of retries */
+} wl_dltro_param_t;
+
+/* WL_DLTRO_SUBCMD_PARAM subcommand data to GET configured info for specific index */
+typedef struct wl_dltro_get_param {
+	uint8 index;        /* DLTRO connection index, 0 to max-1 */
+} wl_dltro_get_param_t;
+
+/* WL_DLTRO_SUBCMD_MAX_DLTRO subcommand data */
+typedef struct wl_dltro_max_dltro {
+	uint8 max;	/* Max DLTRO supported */
+} wl_dltro_max_dltro_t;
+
+#ifdef WL_OLDPPR
+/* sslpnphy specifics */
+#define WL_TX_POWER_MCS20_SISO_FIRST_SSN   12       /* Index for first 20MHz MCS SISO rate */
+#define WL_TX_POWER_MCS40_SISO_FIRST_SSN   28       /* Index for first 40MHz MCS SISO rate */
+
+/* TX Power index defines */
+typedef struct cck {
+	uint8 s1x2[WL_NUM_RATES_CCK];	/* Legacy CCK to 2 Tx Chain */
+	uint8 s1x3[WL_NUM_RATES_CCK];	/* Legacy CCK to 3 Tx Chain */
+} cck_t;
+
+typedef struct ofdm {
+	uint8 s1x1[WL_NUM_RATES_OFDM];	/* Legacy OFDM to 1 Tx Chain */
+	uint8 s1x2[WL_NUM_RATES_OFDM];	/* Legacy OFDM to 2 Tx Chain */
+	uint8 s1x3[WL_NUM_RATES_OFDM];	/* Legacy OFDM to 3 Tx Chain */
+} ofdm_t;
+
+typedef struct stbc {
+	uint8 s2x2[WL_NUM_RATES_MCS_1STREAM];		/* STBC 20MHz to 2 Tx Chain */
+	uint8 s2x3[WL_NUM_RATES_MCS_1STREAM];		/* STBC 20MHz to 3 Tx Chain */
+	uint8 u40_s2x2[WL_NUM_RATES_MCS_1STREAM];	/* STBC 40MHz to 2 Tx Chain */
+	uint8 u40_s2x3[WL_NUM_RATES_MCS_1STREAM];	/* STBC 40MHz to 3 Tx Chain */
+	uint8 ul20_s2x2[WL_NUM_RATES_MCS_1STREAM];	/* STBC 20in40MHz to 2 Tx Chain */
+	uint8 ul20_s2x3[WL_NUM_RATES_MCS_1STREAM];	/* STBC 20in40MHz to 3 Tx Chain */
+} stbc_t;
+
+typedef struct n2x2 {
+	uint8 siso[WL_NUM_RATES_MCS_1STREAM];		/* SISO MCS 0-7 */
+	uint8 cdd[WL_NUM_RATES_MCS_1STREAM];		/* CDD MCS 0-7 */
+	uint8 stbc[WL_NUM_RATES_MCS_1STREAM];		/* STBC MCS 0-7 */
+	uint8 sdm[WL_NUM_RATES_MCS_1STREAM];		/* MCS 8-15 */
+} n2x2_t;
+
+typedef struct n3x3 {
+	uint8 s1x1[WL_NUM_RATES_MCS_1STREAM];		/* 1 Nsts to 1 Tx Chain */
+	uint8 s1x2[WL_NUM_RATES_MCS_1STREAM];		/* 1 Nsts to 2 Tx Chain */
+	uint8 s2x2[WL_NUM_RATES_MCS_1STREAM];		/* 2 Nsts to 2 Tx Chain */
+	uint8 s3x3[WL_NUM_RATES_MCS_1STREAM];		/* 3 Nsts to 3 Tx Chain */
+} n3x3_t;
+
+typedef struct n3x3a {
+	uint8 u20s1x3[WL_NUM_RATES_MCS_1STREAM];	/* 20 MHz 1 Nsts to 3 Tx Chain */
+	uint8 u20s2x3[WL_NUM_RATES_MCS_1STREAM];	/* 20 MHz 2 Nsts to 3 Tx Chain */
+	uint8 u40s1x3[WL_NUM_RATES_MCS_1STREAM];	/* 40 MHz 1 Nsts to 3 Tx Chain */
+	uint8 u40s2x3[WL_NUM_RATES_MCS_1STREAM];	/* 40 MHz 2 Nsts to 3 Tx Chain */
+	uint8 ul20s1x3[WL_NUM_RATES_MCS_1STREAM];	/* 20ul 1 Nsts to 3 Tx Chain */
+	uint8 ul20s2x3[WL_NUM_RATES_MCS_1STREAM];	/* 20ul 2 Nsts to 3 Tx Chain */
+} n3x3a_t;
+
+#define WL_NUM_2x2_ELEMENTS		4
+#define WL_NUM_3x3_ELEMENTS		6
+
+typedef struct txppr {
+	/* start of 20MHz tx power limits */
+	uint8 cck[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	uint8 ofdm[WL_NUM_RATES_OFDM];		/* 20 MHz Legacy OFDM transmission */
+	uint8 ofdm_cdd[WL_NUM_RATES_OFDM];	/* 20 MHz Legacy OFDM CDD transmission */
+	union {
+		struct n2x2 n;			/* nphy MCS rates */
+		struct n3x3 ht;			/* htphy MCS rates */
+	} u20;
+	/* start of 40MHz tx power limits */
+	uint8 ofdm_40[WL_NUM_RATES_OFDM];	/* 40 MHz Legacy OFDM transmission */
+	uint8 ofdm_40_cdd[WL_NUM_RATES_OFDM];	/* 40 MHz Legacy OFDM CDD transmission */
+	union {
+		struct n2x2 n;
+		struct n3x3 ht;
+	} u40;
+	/* MCS32 tx power limits */
+	uint8 mcs32;
+	/* start of 20in40MHz tx power limits */
+	uint8 cck_20ul[WL_NUM_RATES_CCK];	/* 20 in 40MHz Legacy CCK/DSSS */
+	uint8 ofdm_20ul[WL_NUM_RATES_OFDM];	/* 20 in 40MHz Legacy OFDM transmission */
+	uint8 ofdm_20ul_cdd[WL_NUM_RATES_OFDM]; /* 20 in 40MHz Legacy OFDM CDD transmission */
+	n3x3_t ht20ul;				/* 20 in 40MHz MCS rates */
+	n3x3a_t ht;				/* 1 & 2 Nsts to 3 Tx chain rates */
+	cck_t cck_cdd;				/* 20 MHz CCK CDD 2 and 3 Tx chains */
+	cck_t cck_20ul_cdd;			/* 20 in 40MHz CCK CDD 2 and 3 Tx chains */
+} txppr_t;
+
+/* SROM 8 TX Power defines */
+/* 20MHz */
+#define WL_TX_POWER_CCK_FIRST		OFFSETOF(txppr_t, cck)		/* CCK */
+#define WL_TX_POWER_CCK_CDD_S1x2_FIRST	OFFSETOF(txppr_t, cck_cdd.s1x2)	/* CCK CDD 1x2 rate */
+#define WL_TX_POWER_CCK_CDD_S1x3_FIRST	OFFSETOF(txppr_t, cck_cdd.s1x3)	/* CCK CDD 1x3 rate */
+#define WL_TX_POWER_OFDM20_FIRST	OFFSETOF(txppr_t, ofdm)		/* OFDM SISO */
+#define WL_TX_POWER_OFDM20_CDD_FIRST	OFFSETOF(txppr_t, ofdm_cdd)	/* OFDM CDD rate */
+#define WL_TX_POWER_MCS20_SISO_FIRST	OFFSETOF(txppr_t, u20.n.siso)	/* MCS SISO rate */
+#define WL_TX_POWER_MCS20_CDD_FIRST	OFFSETOF(txppr_t, u20.n.cdd)	/* MCS CDD rate */
+#define WL_TX_POWER_MCS20_STBC_FIRST	OFFSETOF(txppr_t, u20.n.stbc)	/* MCS STBC rate */
+#define WL_TX_POWER_MCS20_SDM_FIRST	OFFSETOF(txppr_t, u20.n.sdm)	/* MCS SDM rate */
+
+#define WL_TX_POWER_20_S1x1_FIRST	OFFSETOF(txppr_t, u20.ht.s1x1)	/* MCS 0-7 rate */
+#define WL_TX_POWER_20_S1x2_FIRST	OFFSETOF(txppr_t, u20.ht.s1x2)	/* MCS 0-7 rate */
+#define WL_TX_POWER_20_S1x3_FIRST	OFFSETOF(txppr_t, ht.u20s1x3)	/* MCS 0-7 rate */
+#define WL_TX_POWER_20_S2x2_FIRST	OFFSETOF(txppr_t, u20.ht.s2x2)	/* MCS 8-15 rate */
+#define WL_TX_POWER_20_S2x3_FIRST	OFFSETOF(txppr_t, ht.u20s2x3)	/* MCS 8-15 rate */
+#define WL_TX_POWER_20_S3x3_FIRST	OFFSETOF(txppr_t, u20.ht.s3x3)	/* MCS 16-23 rate */
+
+/* 40MHz */
+#define WL_TX_POWER_OFDM40_FIRST	OFFSETOF(txppr_t, ofdm_40)	/* OFDM SISO rate */
+#define WL_TX_POWER_OFDM40_CDD_FIRST	OFFSETOF(txppr_t, ofdm_40_cdd)	/* OFDM CDD rate */
+#define WL_TX_POWER_MCS40_SISO_FIRST	OFFSETOF(txppr_t, u40.n.siso)	/* MCS SISO rate */
+#define WL_TX_POWER_MCS40_CDD_FIRST     OFFSETOF(txppr_t, u40.n.cdd)	/* MCS CDD rate */
+#define WL_TX_POWER_MCS40_STBC_FIRST	OFFSETOF(txppr_t, u40.n.stbc)	/* MCS STBC rate */
+#define WL_TX_POWER_MCS40_SDM_FIRST     OFFSETOF(txppr_t, u40.n.sdm)	/* MCS SDM rate */
+
+#define WL_TX_POWER_40_S1x1_FIRST	OFFSETOF(txppr_t, u40.ht.s1x1)	/* MCS 0-7 rate */
+#define WL_TX_POWER_40_S1x2_FIRST	OFFSETOF(txppr_t, u40.ht.s1x2)	/* MCS 0-7 rate */
+#define WL_TX_POWER_40_S1x3_FIRST	OFFSETOF(txppr_t, ht.u40s1x3)	/* MCS 0-7 rate */
+#define WL_TX_POWER_40_S2x2_FIRST	OFFSETOF(txppr_t, u40.ht.s2x2)	/* MCS 8-15 rate */
+#define WL_TX_POWER_40_S2x3_FIRST	OFFSETOF(txppr_t, ht.u40s2x3)	/* MCS 8-15 rate */
+#define WL_TX_POWER_40_S3x3_FIRST	OFFSETOF(txppr_t, u40.ht.s3x3)	/* MCS 16-23 rate */
+#define WL_TX_POWER_MCS_32	        OFFSETOF(txppr_t, mcs32)        /* MCS 32 rate */
+
+/* 20 in 40MHz */
+#define WL_TX_POWER_20UL_CCK_FIRST	OFFSETOF(txppr_t, cck_20ul)
+/* CCK CDD 20in40 1x2 rate */
+#define WL_TX_POWER_CCK_20U_CDD_S1x2_FIRST	OFFSETOF(txppr_t, cck_20ul_cdd.s1x2)
+/* CCK CDD 20in40 1x3 rate */
+#define WL_TX_POWER_CCK_20U_CDD_S1x3_FIRST	OFFSETOF(txppr_t, cck_20ul_cdd.s1x3)
+#define WL_TX_POWER_20UL_OFDM_FIRST	OFFSETOF(txppr_t, ofdm_20ul)
+#define WL_TX_POWER_20UL_OFDM_CDD_FIRST	OFFSETOF(txppr_t, ofdm_20ul_cdd)
+#define WL_TX_POWER_20UL_S1x1_FIRST	OFFSETOF(txppr_t, ht20ul.s1x1) /* MCS 0-7 rate */
+#define WL_TX_POWER_20UL_S1x2_FIRST	OFFSETOF(txppr_t, ht20ul.s1x2) /* MCS 0-7 rate */
+#define WL_TX_POWER_20UL_S1x3_FIRST	OFFSETOF(txppr_t, ht.ul20s1x3) /* MCS 0-7 rate */
+#define WL_TX_POWER_20UL_S2x2_FIRST	OFFSETOF(txppr_t, ht20ul.s2x2) /* MCS 8-15 rate */
+#define WL_TX_POWER_20UL_S2x3_FIRST	OFFSETOF(txppr_t, ht.ul20s2x3) /* MCS 8-15 rate */
+#define WL_TX_POWER_20UL_S3x3_FIRST	OFFSETOF(txppr_t, ht20ul.s3x3) /* MCS 16-23 rate */
+
+
+#endif /* WL_OLDPPR */
+
 #endif /* _wlioctl_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlioctl_utils.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlioctl_utils.h
index 38eded4b4e10..51bfc6d2cadf 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlioctl_utils.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/include/wlioctl_utils.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Custom OID/ioctl related helper functions.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/linux_osl.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/linux_osl.c
index c96d3c509002..0e727432600e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/linux_osl.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/linux_osl.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux OS Independent Layer
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: linux_osl.c 589291 2015-09-29 07:09:00Z $
+ * $Id: linux_osl.c 709309 2019-01-17 09:04:00Z $
  */
 
 #define LINUX_PORT
@@ -993,6 +994,10 @@ osl_pkt_frmnative(osl_t *osh, void *pkt)
 	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next) {
 		atomic_add(PKTISCHAINED(nskb) ? PKTCCNT(nskb) : 1, &osh->cmn->pktalloced);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+		nskb->prev = NULL;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0) */
+
 #ifdef BCMDBG_CTRACE
 		for (nskb1 = nskb; nskb1 != NULL; nskb1 = nskb2) {
 			if (PKTISCHAINED(nskb1)) {
@@ -1984,7 +1989,11 @@ osl_os_get_image_block(char *buf, int len, void *image)
 		return 0;
 
 	pos = fp->f_pos;
-	rdlen = kernel_read(fp, buf, len, &pos);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
+	rdlen = kernel_read(fp, (void *) buf, (size_t) len, (loff_t *) &pos);
+#else
+	rdlen = kernel_read(fp, pos, buf, len);
+#endif
 	if (rdlen > 0)
 		fp->f_pos += rdlen;
 
@@ -2518,6 +2527,10 @@ osl_pkt_orphan_partial(struct sk_buff *skb)
 	 */
 	fraction = skb->truesize * (TSQ_MULTIPLIER - 1) / TSQ_MULTIPLIER;
 	skb->truesize -= fraction;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0))
+	WARN_ON(refcount_sub_and_test(fraction, &skb->sk->sk_wmem_alloc));
+#else
 	atomic_sub(fraction, &skb->sk->sk_wmem_alloc);
+#endif
 }
 #endif /* LINUX_VERSION >= 3.6.0 && TSQ_MULTIPLIER */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/pcie_core.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/pcie_core.c
index 53c90b8d3a49..551e5aaeb744 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/pcie_core.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/pcie_core.c
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /** @file pcie_core.c
  *
  * Contains PCIe related functions that are shared between different driver models (e.g. firmware
  * builds, DHD builds, BMAC builds), in order to avoid code duplication.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/rkversion.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/rkversion.c
deleted file mode 100644
index e16f292031fb..000000000000
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/rkversion.c
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* rk_wifi_config.c
- *
- * RKWIFI driver version.
- *
- * Define the firmware and nvram path
- *
- * Define default Country Code
- *
- * gwl @ Rockchip
- */
-
-
-const char RKWIFI_DRV_VERSION[] = "5.10.WFD.OOB.64bit";
-
-const char WIFI_MODULE_NAME[] = "";
-const char CONFIG_BCMDHD_FW_PATH[] = "";
-const char CONFIG_BCMDHD_NVRAM_PATH[] = "";
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/sbutils.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/sbutils.c
index 25c6cfd0a1b2..1fde44046fb0 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/sbutils.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/sbutils.c
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc utility routines for accessing chip-specific features
  * of the SiliconBackplane-based Broadcom chips.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/siutils.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/siutils.c
index 7d37a06d2d46..cb64267c1e26 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/siutils.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/siutils.c
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Misc utility routines for accessing chip-specific features
  * of the SiliconBackplane-based Broadcom chips.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -25,7 +26,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: siutils.c 666543 2017-08-25 07:42:40Z $
+ * $Id: siutils.c 722050 2019-08-21 02:24:57Z $
  */
 
 #include <bcm_cfg.h>
@@ -54,6 +55,10 @@
 #endif /* BCMSDIO */
 #include <hndpmu.h>
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+#include <dhd_chip_info.h>
+#endif
+
 #ifdef BCM_SDRBL
 #include <hndcpu.h>
 #endif /* BCM_SDRBL */
@@ -282,6 +287,24 @@ si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype, uint32 savewin,
 	uint i;
 	uint pciidx, pcieidx, pcirev, pcierev;
 
+#ifdef LOAD_DHD_WITH_FW_ALIVE
+	if(alive == FW_ALIVE_MAGIC) {
+		switch(card_dev) {
+			case BCM43430_CHIP_ID:
+				if(card_rev == 2)
+					memcpy(&sii->pub, &sii_pub_43436, sizeof(sii->pub));
+				else
+					memcpy(&sii->pub, &sii_pub_43430, sizeof(sii->pub));
+				break;
+
+			case BCM43012_CHIP_ID:
+				memcpy(&sii->pub, &sii_pub_43012, sizeof(sii->pub));
+				break;
+		}
+		return true;
+	}
+#endif
+
 	/* first, enable backplane timeouts */
 	if (CHIPTYPE(sii->pub.socitype) == SOCI_AI)
 		ai_enable_backplane_timeouts(&sii->pub);
@@ -1594,7 +1617,14 @@ si_chip_hostif(si_t *sih)
 		else if (CST4349_CHIPMODE_PCIE(sih->chipst))
 			hosti = CHIP_HOSTIF_PCIEMODE;
 		break;
-
+	case BCM4373_CHIP_ID:
+		if (CST4373_CHIPMODE_USB20D(sih->chipst))
+			hosti = CHIP_HOSTIF_USBMODE;
+		else if (CST4373_CHIPMODE_SDIOD(sih->chipst))
+			hosti = CHIP_HOSTIF_SDIOMODE;
+		else if (CST4373_CHIPMODE_PCIE(sih->chipst))
+			hosti = CHIP_HOSTIF_PCIEMODE;
+		break;
 	case BCM4350_CHIP_ID:
 	case BCM4354_CHIP_ID:
 	case BCM4356_CHIP_ID:
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/siutils_priv.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/siutils_priv.h
index 0dc02211e1b7..774a88210769 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/siutils_priv.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/siutils_priv.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Include file private to the SOC Interconnect support files.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/uamp_api.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/uamp_api.h
index 7fe81a859430..444bdc56e943 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/uamp_api.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/uamp_api.h
@@ -1,9 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  *  Name:       uamp_api.h
  *
  *  Description: Universal AMP API
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_android.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_android.c
index 1d7cc0f39b2b..b5824159a8b0 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_android.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_android.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver - Android related functions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -134,6 +135,9 @@
 
 #define	CMD_HAPD_MAC_FILTER	"HAPD_MAC_FILTER"
 
+#ifdef WLFBT
+#define CMD_GET_FTKEY      "GET_FTKEY"
+#endif
 
 
 #define CMD_ROAM_OFFLOAD			"SETROAMOFFLOAD"
@@ -2523,6 +2527,12 @@ wl_handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 		bytes_written = wl_cfg80211_set_wps_p2p_ie(net, command + skip,
 			priv_cmd.total_len - skip, *(command + skip - 2) - '0');
 	}
+#ifdef WLFBT
+	else if (strnicmp(command, CMD_GET_FTKEY, strlen(CMD_GET_FTKEY)) == 0) {
+		wl_cfg80211_get_fbt_key(command);
+		bytes_written = FBT_KEYLEN;
+	}
+#endif /* WLFBT */
 #endif /* WL_CFG80211 */
 	else if (strnicmp(command, CMD_OKC_SET_PMK, strlen(CMD_OKC_SET_PMK)) == 0)
 		bytes_written = wl_android_set_pmk(net, command, priv_cmd.total_len);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_android.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_android.h
index f2edd83ad943..73298c5af46a 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_android.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_android.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver - Android related functions
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.c
index 33451848f8c2..cf5359fe86f9 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: wl_cfg80211.c 674373 2017-10-20 07:05:57Z $
+ * $Id: wl_cfg80211.c 715966 2019-05-30 02:36:59Z $
  */
 /* */
 #include <typedefs.h>
@@ -92,6 +93,7 @@
 #endif /* !WL_ENABLE_P2P_IF && !WL_CFG80211_P2P_DEV_IF */
 #endif /* WL11U */
 
+module_param(wl_dbg_level, uint, 0664);
 
 #define IW_WSEC_ENABLED(wsec)   ((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
 
@@ -611,6 +613,9 @@ static void wl_update_hidden_ap_ie(struct wl_bss_info *bi, const u8 *ie_stream,
 static s32 wl_mrg_ie(struct bcm_cfg80211 *cfg, u8 *ie_stream, u16 ie_size);
 static s32 wl_cp_ie(struct bcm_cfg80211 *cfg, u8 *dst, u16 dst_size);
 static u32 wl_get_ielen(struct bcm_cfg80211 *cfg);
+#ifdef MFP
+static int wl_cfg80211_get_rsn_capa(bcm_tlv_t *wpa2ie, u8* capa);
+#endif
 
 #ifdef WL11U
 bcm_tlv_t *
@@ -923,12 +928,23 @@ static struct ieee80211_supported_band __wl_band_5ghz_a = {
 	.n_bitrates = wl_a_rates_size
 };
 
+#if defined(WLFBT)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
+#define WLAN_AKM_SUITE_FT_8021X         0x000FAC03
+#define WLAN_AKM_SUITE_FT_PSK           0x000FAC04
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)) */
+#define WLAN_CIPHER_SUITE_PMK           0x00904C00
+#endif /* WLFBT */
+
 static const u32 __wl_cipher_suites[] = {
 	WLAN_CIPHER_SUITE_WEP40,
 	WLAN_CIPHER_SUITE_WEP104,
 	WLAN_CIPHER_SUITE_TKIP,
 	WLAN_CIPHER_SUITE_CCMP,
 	WLAN_CIPHER_SUITE_AES_CMAC,
+#if defined(WLFBT) && defined(WLAN_CIPHER_SUITE_PMK)
+	WLAN_CIPHER_SUITE_PMK,
+#endif
 };
 
 #ifdef WL_SUPPORT_ACS
@@ -1454,7 +1470,11 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 	unsigned char name_assign_type,
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)) */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
 	enum nl80211_iftype type,
+#else
+	enum nl80211_iftype type, u32 *flags,
+#endif
 	struct vif_params *params)
 {
 	s32 err = -ENODEV;
@@ -1473,11 +1493,11 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy,
 	bcm_struct_cfgdev *new_cfgdev;
 #endif /* WL_VIRTUAL_APSTA */
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 	s32 up = 1;
 	dhd_pub_t *dhd;
 	bool enabled;
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 #if defined(SUPPORT_AP_POWERSAVE)
 	dhd_pub_t *dhd;
@@ -1487,9 +1507,9 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy,
 		return ERR_PTR(-EINVAL);
 
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 	dhd = (dhd_pub_t *)(cfg->pub);
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 #if defined(SUPPORT_AP_POWERSAVE)
 	dhd = (dhd_pub_t *)(cfg->pub);
@@ -1570,10 +1590,10 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy,
 		ASSERT(cfg->p2p); /* ensure expectation of p2p initialization */
 
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 		if (!dhd)
 			return ERR_PTR(-ENODEV);
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 		if (!cfg->p2p)
 			return ERR_PTR(-ENODEV);
@@ -1596,7 +1616,7 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy,
 
 		wl_cfg80211_scan_abort(cfg);
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 		if (!cfg->wlfc_on && !disable_proptx) {
 			dhd_wlfc_get_enable(dhd, &enabled);
 			if (!enabled && dhd->op_mode != DHD_FLAG_HOSTAP_MODE &&
@@ -1608,7 +1628,7 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy,
 			}
 			cfg->wlfc_on = true;
 		}
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 
 		/* Dual p2p doesn't support multiple P2PGO interfaces,
@@ -1776,14 +1796,14 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy,
 			memset(cfg->p2p->vir_ifname, '\0', IFNAMSIZ);
 			wl_to_p2p_bss_bssidx(cfg, cfg_type) = -1;
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 			dhd_wlfc_get_enable(dhd, &enabled);
 		if (enabled && cfg->wlfc_on && dhd->op_mode != DHD_FLAG_HOSTAP_MODE &&
 			dhd->op_mode != DHD_FLAG_IBSS_MODE) {
 			dhd_wlfc_deinit(dhd);
 			cfg->wlfc_on = false;
 		}
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 		}
 	}
@@ -1923,7 +1943,11 @@ wl_cfg80211_del_virtual_iface(struct wiphy *wiphy, bcm_struct_cfgdev *cfgdev)
 
 static s32
 wl_cfg80211_change_virtual_iface(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
 	enum nl80211_iftype type,
+#else
+	enum nl80211_iftype type, u32 *flags,
+#endif
 	struct vif_params *params)
 {
 	s32 ap = 0;
@@ -2136,10 +2160,10 @@ static s32 wl_cfg80211_handle_ifdel(struct bcm_cfg80211 *cfg, wl_if_event_info *
 	s32 type = -1;
 	s32 bssidx = -1;
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 	dhd_pub_t *dhd =  (dhd_pub_t *)(cfg->pub);
 	bool enabled;
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 
 	bssidx = if_event_info->bssidx;
@@ -2169,14 +2193,14 @@ static s32 wl_cfg80211_handle_ifdel(struct bcm_cfg80211 *cfg, wl_if_event_info *
 		}
 
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 		dhd_wlfc_get_enable(dhd, &enabled);
 		if (enabled && cfg->wlfc_on && dhd->op_mode != DHD_FLAG_HOSTAP_MODE &&
 			dhd->op_mode != DHD_FLAG_IBSS_MODE) {
 			dhd_wlfc_deinit(dhd);
 			cfg->wlfc_on = false;
 		}
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 	}
 
@@ -3793,6 +3817,42 @@ static s32 wl_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *dev)
 	return err;
 }
 
+#ifdef MFP
+static int wl_cfg80211_get_rsn_capa(bcm_tlv_t *wpa2ie, u8* capa)
+{
+	u16 suite_count;
+	wpa_suite_mcast_t *mcast;
+	wpa_suite_ucast_t *ucast;
+	u16 len;
+	wpa_suite_auth_key_mgmt_t *mgmt;
+
+	if (!wpa2ie)
+		return -1;
+
+	len = wpa2ie->len;
+	mcast = (wpa_suite_mcast_t *)&wpa2ie->data[WPA2_VERSION_LEN];
+	if ((len -= WPA_SUITE_LEN) <= 0)
+		return BCME_BADLEN;
+	ucast = (wpa_suite_ucast_t *)&mcast[1];
+	suite_count = ltoh16_ua(&ucast->count);
+	if ((suite_count > NL80211_MAX_NR_CIPHER_SUITES) ||
+		(len -= (WPA_IE_SUITE_COUNT_LEN +
+		(WPA_SUITE_LEN * suite_count))) <= 0)
+		return BCME_BADLEN;
+	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[suite_count];
+	suite_count = ltoh16_ua(&mgmt->count);
+
+	if ((suite_count > NL80211_MAX_NR_CIPHER_SUITES) ||
+		(len -= (WPA_IE_SUITE_COUNT_LEN +
+		(WPA_SUITE_LEN * suite_count))) >= RSN_CAP_LEN) {
+		capa[0] = *(u8 *)&mgmt->list[suite_count];
+		capa[1] = *((u8 *)&mgmt->list[suite_count] + 1);
+	} else
+		return BCME_BADLEN;
+
+	return 0;
+}
+#endif /* MFP */
 
 static s32
 wl_set_wpa_version(struct net_device *dev, struct cfg80211_connect_params *sme)
@@ -3969,6 +4029,11 @@ wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 	s32 val = 0;
 	s32 err = 0;
 	s32 bssidx;
+#ifdef MFP
+	s32 mfp = WL_MFP_NONE;
+	bcm_tlv_t *wpa2_ie;
+	u8 rsn_cap[2];
+#endif /* MFP */
 
 	if ((bssidx = wl_get_bssidx_by_wdev(cfg, dev->ieee80211_ptr)) < 0) {
 		WL_ERR(("Find p2p index from wdev(%p) failed\n", dev->ieee80211_ptr));
@@ -4001,9 +4066,27 @@ wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 			case WLAN_AKM_SUITE_8021X:
 				val = WPA2_AUTH_UNSPECIFIED;
 				break;
+#ifdef MFP
+			case WL_AKM_SUITE_SHA256_1X:
+				val = WPA2_AUTH_1X_SHA256;
+				break;
+			case WL_AKM_SUITE_SHA256_PSK:
+				val = WPA2_AUTH_PSK_SHA256;
+				break;
+#endif /* MFP */
 			case WLAN_AKM_SUITE_PSK:
 				val = WPA2_AUTH_PSK;
 				break;
+#if defined(WLFBT) && defined(WLAN_AKM_SUITE_FT_8021X)
+			case WLAN_AKM_SUITE_FT_8021X:
+				val = WPA2_AUTH_UNSPECIFIED | WPA2_AUTH_FT;
+				break;
+#endif
+#if defined(WLFBT) && defined(WLAN_AKM_SUITE_FT_PSK)
+			case WLAN_AKM_SUITE_FT_PSK:
+				val = WPA2_AUTH_PSK | WPA2_AUTH_FT;
+				break;
+#endif
 			default:
 				WL_ERR(("invalid cipher group (%d)\n",
 					sme->crypto.cipher_group));
@@ -4011,6 +4094,33 @@ wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 			}
 		}
 
+#ifdef MFP
+		if (((wpa2_ie = bcm_parse_tlvs((u8 *)sme->ie, sme->ie_len,
+			DOT11_MNG_RSN_ID)) != NULL) &&
+			(wl_cfg80211_get_rsn_capa(wpa2_ie, rsn_cap) == 0)) {
+				/* Check for MFP cap in the RSN capability field */
+				if (rsn_cap[0] & RSN_CAP_MFPR) {
+					mfp = WL_MFP_REQUIRED;
+				} else if (rsn_cap[0] & RSN_CAP_MFPC) {
+					mfp = WL_MFP_CAPABLE;
+				}
+		}
+		err = wldev_iovar_setint(dev, "mfp", mfp);
+		if (unlikely(err)) {
+			if (!mfp && (err == BCME_UNSUPPORTED)) {
+				/* For non-mfp cases, if firmware doesn't support MFP
+				 * ignore the failure and proceed ahead.
+				 */
+				WL_DBG(("fw doesn't support mfp \n"));
+				err = 0;
+			} else {
+				WL_ERR(("mfp set failed ret:%d \n", err));
+				return err;
+			}
+		} else {
+			WL_DBG(("mfp set to 0x%x \n", mfp));
+		}
+#endif /* MFP */
 
 		WL_DBG(("setting wpa_auth to 0x%x\n", val));
 
@@ -4868,6 +4978,37 @@ wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 		val = AES_ENABLED;
 		WL_DBG(("WLAN_CIPHER_SUITE_CCMP\n"));
 		break;
+#if defined(WLFBT) && defined(WLAN_CIPHER_SUITE_PMK)
+	case WLAN_CIPHER_SUITE_PMK: {
+		int j;
+		wsec_pmk_t pmk;
+		char keystring[WSEC_MAX_PSK_LEN + 1];
+		char* charptr = keystring;
+		uint len;
+		struct wl_security *sec;
+
+		sec = wl_read_prof(cfg, dev, WL_PROF_SEC);
+		if (sec->wpa_auth == WLAN_AKM_SUITE_8021X) {
+			err = wldev_iovar_setbuf(dev, "okc_info_pmk", (void *)params->key,
+				WSEC_MAX_PSK_LEN / 2, keystring, sizeof(keystring), NULL);
+			if (err) {
+				/* could fail in case that 'okc' is not supported */
+				WL_INFORM(("Setting 'okc_info_pmk' failed, err=%d\n", err));
+			}
+		}
+		/* copy the raw hex key to the appropriate format */
+		for (j = 0; j < (WSEC_MAX_PSK_LEN / 2); j++) {
+			charptr += snprintf(charptr, sizeof(keystring), "%02x", params->key[j]);
+		}
+		len = strlen(keystring);
+		pmk.key_len = htod16(len);
+		bcopy(keystring, pmk.key, len);
+		pmk.flags = htod16(WSEC_PASSPHRASE);
+		err = wldev_ioctl(dev, WLC_SET_WSEC_PMK, &pmk, sizeof(pmk), true);
+		if (err)
+			return err;
+	} break;
+#endif /* WLFBT && WLAN_CIPHER_SUITE_PMK */
 	default:
 		WL_ERR(("Invalid cipher (0x%x)\n", params->cipher));
 		return -EINVAL;
@@ -4931,8 +5072,10 @@ wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
 	}
 	WL_DBG(("Enter\n"));
 
+#ifndef MFP
 	if ((key_idx >= DOT11_MAX_DEFAULT_KEYS) && (key_idx < DOT11_MAX_DEFAULT_KEYS+2))
 		return -EINVAL;
+#endif
 
 	RETURN_EIO_IF_NOT_UP(cfg);
 	memset(&key, 0, sizeof(key));
@@ -5023,8 +5166,12 @@ static s32
 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
 	struct net_device *dev, u8 key_idx)
 {
+#ifdef MFP
+	return 0;
+#else
 	WL_INFORM(("Not supported\n"));
 	return -EOPNOTSUPP;
+#endif /* MFP */
 }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0))
@@ -5333,6 +5480,32 @@ static s32 wl_cfg80211_suspend(struct wiphy *wiphy)
 #endif /* DHD_CLEAR_ON_SUSPEND */
 
 
+#ifdef CUS_11321
+	{
+		struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+		struct net_device *ndev = bcmcfg_to_prmry_ndev(cfg);
+		u8 gpiopol = 0; // 0:Set active high when wake up, 1:Set active low when wake up
+		char strclear[6] = "clear";
+		u32 wowl = WL_WOWL_DIS | WL_WOWL_BCN | WL_WOWL_GTK_FAILURE | WL_WOWL_RETR |
+			WL_WOWL_TCPKEEP_TIME | WL_WOWL_TCPKEEP_DATA;
+
+		/* enable ARPOE */
+		wldev_iovar_setint(ndev, "arpoe", 1);
+		wldev_iovar_setint(ndev, "arp_ol", 0xf);
+		wldev_iovar_setint(ndev, "arp_peerage", 1000000);
+
+		/* enable GTKOE */
+		wldev_iovar_setint(ndev, "wake_event_enable", 4);
+
+		/* enable WOWL */
+		wldev_iovar_setint(ndev, "wowl_gpiopol", gpiopol);
+		wldev_iovar_setbuf(ndev, "wowl_wakeind", strclear, sizeof(strclear),
+			cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
+		wldev_iovar_setint(ndev, "wowl", wowl);
+		wldev_iovar_setint(ndev, "wowl_activate", 1);
+	}
+#endif
+
 	return err;
 }
 
@@ -5573,7 +5746,7 @@ wl_cfg80211_remain_on_channel(struct wiphy *wiphy, bcm_struct_cfgdev *cfgdev,
 				del_timer_sync(&cfg->p2p->listen_timer);
 			}
 
-			_timer = &cfg->p2p->listen_timer;
+			_timer = (struct timer_list *) &cfg->p2p->listen_timer;
 			wl_clr_p2p_status(cfg, LISTEN_EXPIRED);
 
 			INIT_TIMER(_timer, wl_cfgp2p_listen_expired, duration, 0);
@@ -6714,6 +6887,10 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 	wpa_suite_auth_key_mgmt_t *mgmt;
 	wpa_pmkid_list_t *pmkid;
 	int cnt = 0;
+#ifdef MFP
+	int mfp = 0;
+	struct bcm_cfg80211 *cfg = g_bcm_cfg;
+#endif /* MFP */
 
 	u16 suite_count;
 	u8 rsn_cap[2];
@@ -6786,6 +6963,14 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 		case RSN_AKM_PSK:
 				wpa_auth |= WPA2_AUTH_PSK;
 				break;
+#ifdef MFP
+			case RSN_AKM_MFP_PSK:
+				wpa_auth |= WPA2_AUTH_PSK_SHA256;
+				break;
+			case RSN_AKM_MFP_1X:
+				wpa_auth |= WPA2_AUTH_1X_SHA256;
+			break;
+#endif /* MFP */
 		default:
 			WL_ERR(("No Key Mgmt Info\n"));
 		}
@@ -6801,6 +6986,23 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 			wme_bss_disable = 1;
 		}
 
+#ifdef MFP
+	if (rsn_cap[0] & RSN_CAP_MFPR) {
+		WL_DBG(("MFP Required \n"));
+		mfp = WL_MFP_REQUIRED;
+		/* Our firmware has requirement that WPA2_AUTH_PSK/WPA2_AUTH_UNSPECIFIED
+		 * be set, if SHA256 OUI is to be included in the rsn ie.
+		 */
+		if (wpa_auth & WPA2_AUTH_PSK_SHA256) {
+			wpa_auth |= WPA2_AUTH_PSK;
+		} else if (wpa_auth & WPA2_AUTH_1X_SHA256) {
+			wpa_auth |= WPA2_AUTH_UNSPECIFIED;
+		}
+	} else if (rsn_cap[0] & RSN_CAP_MFPC) {
+		WL_DBG(("MFP Capable \n"));
+		mfp = WL_MFP_CAPABLE;
+	}
+#endif /* MFP */
 
 		/* set wme_bss_disable to sync RSN Capabilities */
 		err = wldev_iovar_setint_bsscfg(dev, "wme_bss_disable", wme_bss_disable, bssidx);
@@ -6824,6 +7026,19 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 		/* so don't bother to send down this info to firmware */
 	}
 
+#ifdef MFP
+	len -= WPA2_PMKID_COUNT_LEN;
+	if (len >= WPA_SUITE_LEN) {
+		err = wldev_iovar_setbuf_bsscfg(dev, "bip",
+		(void *)((u8 *)&mgmt->list[suite_count] + RSN_CAP_LEN + WPA2_PMKID_COUNT_LEN),
+		WPA_SUITE_LEN,
+		cfg->ioctl_buf, WLC_IOCTL_SMLEN, bssidx, &cfg->ioctl_buf_sync);
+		if (err < 0) {
+			WL_ERR(("bip set error %d\n", err));
+			return BCME_ERROR;
+		}
+	}
+#endif
 
 	/* set auth */
 	err = wldev_iovar_setint_bsscfg(dev, "auth", auth, bssidx);
@@ -6839,6 +7054,17 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 		return BCME_ERROR;
 	}
 
+#ifdef MFP
+	if (mfp) {
+		/* This needs to go after wsec otherwise the wsec command will
+		 * overwrite the values set by MFP
+		 */
+		if ((err = wldev_iovar_setint_bsscfg(dev, "mfp", mfp, bssidx)) < 0) {
+			WL_ERR(("MFP Setting failed. ret = %d \n", err));
+			return err;
+		}
+	}
+#endif /* MFP */
 
 	/* set upper-layer auth */
 	err = wldev_iovar_setint_bsscfg(dev, "wpa_auth", wpa_auth, bssidx);
@@ -7758,6 +7984,7 @@ wl_cfg80211_stop_ap(
 	int ap = 0;
 	s32 bssidx = 0;
 	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	struct net_device *primary_ndev = bcmcfg_to_prmry_ndev(cfg);
 	s32 is_rsdb_supported = BCME_ERROR;
 	dhd_pub_t *dhd = (dhd_pub_t *)(cfg->pub);
 
@@ -7796,37 +8023,64 @@ wl_cfg80211_stop_ap(
 	}
 
 	if (dev_role == NL80211_IFTYPE_AP) {
+		if (bssidx == 0) {
 		/*
 		 * Bring down the AP interface by changing role to STA.
 		 * Don't do a down or "WLC_SET_AP 0" since the shared
 		 * interface may be still running
 		 */
 		if (is_rsdb_supported) {
-			if ((err = wl_cfg80211_add_del_bss(cfg, dev,
-				bssidx, NL80211_IFTYPE_STATION, 0, NULL)) < 0) {
-				if ((err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32),
-					true)) < 0) {
-					WL_ERR(("setting AP mode failed %d \n", err));
+				if ((err = wl_cfg80211_add_del_bss(cfg, dev,
+					bssidx, NL80211_IFTYPE_STATION, 0, NULL)) < 0) {
+					if ((err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32),
+						true)) < 0) {
+						WL_ERR(("setting AP mode failed %d \n", err));
+						err = -ENOTSUPP;
+						goto exit;
+					}
+				}
+			} else if (is_rsdb_supported == 0) {
+				if (dev == primary_ndev) {
+					err = wldev_ioctl(dev, WLC_DOWN, &ap, sizeof(s32), true);
+					if (err < 0) {
+						WL_ERR(("WLC_DOWN error (%d)\n", err));
+						err = -ENOTSUPP;
+						goto exit;
+					}
+
+					err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32), true);
+					if (err < 0) {
+						WL_ERR(("SET AP error %d\n", err));
+						err = -ENOTSUPP;
+						goto exit;
+					}
+
+					err = wldev_ioctl(dev, WLC_UP, &ap, sizeof(s32), true);
+					if (err < 0) {
+						WL_ERR(("WLC_UP error (%d)\n", err));
+						err = -ENOTSUPP;
+						goto exit;
+					}
+				}
+
+				err = wldev_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(s32), true);
+				if (err < 0) {
+					WL_ERR(("SET INFRA error %d\n", err));
 					err = -ENOTSUPP;
 					goto exit;
 				}
+				err = wldev_ioctl(dev, WLC_UP, &ap, sizeof(s32), true);
+				if (unlikely(err)) {
+					WL_ERR(("WLC_UP error (%d)\n", err));
+					err = -EINVAL;
+					goto exit;
+				}
 			}
-		} else if (is_rsdb_supported == 0) {
-			if ((err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32), true)) < 0) {
-				WL_ERR(("setting AP mode failed %d \n", err));
-				err = -ENOTSUPP;
-				goto exit;
-			}
-			err = wldev_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(s32), true);
-			if (err < 0) {
-				WL_ERR(("SET INFRA error %d\n", err));
-				err = -ENOTSUPP;
-				goto exit;
-			}
-			err = wldev_ioctl(dev, WLC_UP, &ap, sizeof(s32), true);
-			if (unlikely(err)) {
-				WL_ERR(("WLC_UP error (%d)\n", err));
-				err = -EINVAL;
+		} else if (cfg->cfgdev_bssidx && (bssidx == cfg->cfgdev_bssidx)) {
+			WL_DBG(("Stop SoftAP on virtual Interface bssidx:%d \n", bssidx));
+			if ((err = wl_cfg80211_add_del_bss(cfg, dev,
+                    bssidx, NL80211_IFTYPE_STATION, 0, NULL)) < 0) {
+				WL_ERR(("wl add_del_bss returned error:%d\n", err));
 				goto exit;
 			}
 		}
@@ -8737,8 +8991,6 @@ static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *sdiofunc_dev
 	/* If this is not provided cfg stack will get disconnect
 	 * during suspend.
 	 */
-
-#if (1)
 	brcm_wowlan_config = kmalloc(sizeof(struct cfg80211_wowlan), GFP_KERNEL);
 	if (brcm_wowlan_config) {
 		brcm_wowlan_config->disconnect = true;
@@ -8755,7 +9007,6 @@ static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *sdiofunc_dev
 		WL_ERR(("Can not allocate memory for brcm_wowlan_config,"
 					" So wiphy->wowlan_config is set to NULL\n"));
 	}
-#endif
 	wdev->wiphy->wowlan_config = brcm_wowlan_config;
 #else
 	wdev->wiphy->wowlan.flags = WIPHY_WOWLAN_ANY;
@@ -8811,6 +9062,7 @@ static void wl_free_wdev(struct bcm_cfg80211 *cfg)
 #if defined(WL_VENDOR_EXT_SUPPORT)
 		wl_cfgvendor_detach(wdev->wiphy);
 #endif /* if defined(WL_VENDOR_EXT_SUPPORT) */
+#ifdef CONFIG_PM
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0))
 		/* Reset wowlan & wowlan_config before Unregister to avoid  Kernel Panic */
 		WL_DBG(("wl_free_wdev Clearing wowlan Config \n"));
@@ -8820,6 +9072,7 @@ static void wl_free_wdev(struct bcm_cfg80211 *cfg)
 			wdev->wiphy->wowlan_config = NULL;
 		}
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0) */
+#endif /* CONFIG_PM */
 		wiphy_unregister(wdev->wiphy);
 		wdev->wiphy->dev.parent = NULL;
 		wdev->wiphy = NULL;
@@ -8938,8 +9191,13 @@ static s32 wl_inform_single_bss(struct bcm_cfg80211 *cfg, struct wl_bss_info *bi
 	signal = notif_bss_info->rssi * 100;
 	if (!mgmt->u.probe_resp.timestamp) {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0))
+		struct timespec64 ts;
+		ktime_get_boottime_ts64(&ts);
+#else
 		struct timespec ts;
 		get_monotonic_boottime(&ts);
+#endif
 		mgmt->u.probe_resp.timestamp = ((u64)ts.tv_sec*1000000)
 				+ ts.tv_nsec / 1000;
 #else
@@ -9380,15 +9638,17 @@ wl_notify_connect_status(struct bcm_cfg80211 *cfg, bcm_struct_cfgdev *cfgdev,
 			wl_cfg80211_cancel_scan(cfg);
 
 			/* Explicitly calling unlink to remove BSS in CFG */
-			wiphy = bcmcfg_to_wiphy(cfg);
-			ssid = (struct wlc_ssid *)wl_read_prof(cfg, ndev, WL_PROF_SSID);
-			bssid = (u8 *)wl_read_prof(cfg, ndev, WL_PROF_BSSID);
-			if (ssid && bssid) {
-				bss = cfg80211_get_bss(wiphy, NULL, bssid,
-					ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS,
-					WLAN_CAPABILITY_ESS);
-				if (bss) {
-					cfg80211_unlink_bss(wiphy, bss);
+			if (wl_cfgp2p_vif_created(cfg)) {
+				wiphy = bcmcfg_to_wiphy(cfg);
+				ssid = (struct wlc_ssid *)wl_read_prof(cfg, ndev, WL_PROF_SSID);
+				bssid = (u8 *)wl_read_prof(cfg, ndev, WL_PROF_BSSID);
+				if (ssid && bssid) {
+					bss = cfg80211_get_bss(wiphy, NULL, bssid,
+						ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS,
+						WLAN_CAPABILITY_ESS);
+					if (bss) {
+						cfg80211_unlink_bss(wiphy, bss);
+					}
 				}
 			}
 
@@ -9900,7 +10160,16 @@ wl_bss_roaming_done(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 	u32 *channel;
 	u32 freq;
 #endif 
-	struct cfg80211_roam_info roam_info = {};
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+	struct cfg80211_roam_info roam_info;
+#endif
+
+
+#ifdef WLFBT
+	uint32 data_len = 0;
+	if (data)
+		data_len = ntoh32(e->datalen);
+#endif /* WLFBT */
 
 	wl_get_assoc_ies(cfg, ndev);
 	wl_update_prof(cfg, ndev, NULL, (const void *)(e->addr.octet), WL_PROF_BSSID);
@@ -9918,9 +10187,21 @@ wl_bss_roaming_done(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 	freq = ieee80211_channel_to_frequency(*channel, band->band);
 	notify_channel = ieee80211_get_channel(wiphy, freq);
 #endif 
+#ifdef WLFBT
+	/* back up the given FBT key for the further supplicant request,
+	 * currently not checking the FBT is enabled for current BSS in DHD,
+	 * because the supplicant decides to take it or not.
+	 */
+	if (data && (data_len == FBT_KEYLEN)) {
+		memcpy(cfg->fbt_key, data, FBT_KEYLEN);
+	}
+#endif /* WLFBT */
 	printk("wl_bss_roaming_done succeeded to " MACDBG "\n",
 		MAC2STRDBG((const u8*)(&e->addr)));
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+//added by Eason 20200528
+	memset(&roam_info, 0, sizeof(roam_info));
 	roam_info.channel = notify_channel;
 	roam_info.bssid = curbssid;
 	roam_info.req_ie = conn_info->req_ie;
@@ -9929,6 +10210,15 @@ wl_bss_roaming_done(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 	roam_info.resp_ie_len = conn_info->resp_ie_len;
 
 	cfg80211_roamed(ndev, &roam_info, GFP_KERNEL);
+#else
+	cfg80211_roamed(ndev,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39))
+		notify_channel,
+#endif
+		curbssid,
+		conn_info->req_ie, conn_info->req_ie_len,
+		conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
+#endif
 	WL_DBG(("Report roaming result\n"));
 
 	wl_set_drv_status(cfg, CONNECTED, ndev);
@@ -10637,8 +10927,13 @@ wl_notify_sched_scan_results(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 
 	WL_DBG(("Enter\n"));
 
-	if (e->event_type == WLC_E_PFN_NET_LOST) {
-		WL_PNO(("PFN NET LOST event. Do Nothing \n"));
+	if ((e->event_type == WLC_E_PFN_NET_LOST) || !data) {
+		WL_PNO(("Do Nothing %d\n", e->event_type));
+		return 0;
+	}
+	if (pfn_result->version != PFN_SCANRESULT_VERSION) {
+		WL_ERR(("Incorrect version %d, expected %d\n", pfn_result->version,
+		       PFN_SCANRESULT_VERSION));
 		return 0;
 	}
 	WL_PNO((">>> PFN NET FOUND event. count:%d \n", n_pfn_results));
@@ -10681,9 +10976,8 @@ wl_notify_sched_scan_results(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 			 * scan request in the form of cfg80211_scan_request. For timebeing, create
 			 * cfg80211_scan_request one out of the received PNO event.
 			 */
-			memcpy(ssid[i].ssid, netinfo->pfnsubnet.SSID,
-				netinfo->pfnsubnet.SSID_len);
-			ssid[i].ssid_len = netinfo->pfnsubnet.SSID_len;
+			ssid[i].ssid_len = MIN(netinfo->pfnsubnet.SSID_len, DOT11_MAX_SSID_LEN);
+			memcpy(ssid[i].ssid, netinfo->pfnsubnet.SSID, ssid[i].ssid_len);
 			request->n_ssids++;
 
 			channel_req = netinfo->pfnsubnet.channel;
@@ -10974,10 +11268,16 @@ void wl_terminate_event_handler(void)
 	}
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 static void wl_scan_timeout(struct timer_list *t)
 {
-	wl_event_msg_t msg;
 	struct bcm_cfg80211 *cfg = from_timer(cfg, t, scan_timeout);
+#else
+static void wl_scan_timeout(unsigned long data)
+{
+	struct bcm_cfg80211 *cfg = (struct bcm_cfg80211 *)data;
+#endif
+	wl_event_msg_t msg;
 	struct wireless_dev *wdev = NULL;
 	struct net_device *ndev = NULL;
 	struct wl_scan_results *bss_list;
@@ -11048,9 +11348,15 @@ static void wl_del_roam_timeout(struct bcm_cfg80211 *cfg)
 
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 static void wl_roam_timeout(struct timer_list *t)
 {
-	struct bcm_cfg80211 *cfg = from_timer(cfg, t, roam_timeout);
+	struct bcm_cfg80211 *cfg = from_timer(cfg, t, wl_roam_timeout);
+#else
+static void wl_roam_timeout(unsigned long data)
+{
+	struct bcm_cfg80211 *cfg = (struct bcm_cfg80211 *)data;
+#endif
 	dhd_pub_t *dhdp = (dhd_pub_t *)(cfg->pub);
 
 	WL_ERR(("roam timer expired\n"));
@@ -12000,7 +12306,13 @@ static s32 wl_init_scan(struct bcm_cfg80211 *cfg)
 	wl_escan_init_sync_id(cfg);
 
 	/* Init scan_timeout timer */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 	timer_setup(&cfg->scan_timeout, wl_scan_timeout, 0);
+#else
+	init_timer(&cfg->scan_timeout);
+	cfg->scan_timeout.data = (unsigned long) cfg;
+	cfg->scan_timeout.function = wl_scan_timeout;
+#endif
 
 	return err;
 }
@@ -12011,7 +12323,13 @@ static s32 wl_init_roam_timeout(struct bcm_cfg80211 *cfg)
 	int err = 0;
 
 	/* Init roam timer */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 	timer_setup(&cfg->roam_timeout, wl_roam_timeout, 0);
+#else
+	init_timer(&cfg->roam_timeout);
+	cfg->roam_timeout.data = (unsigned long) cfg;
+	cfg->roam_timeout.function = wl_roam_timeout;
+#endif
 
 	return err;
 }
@@ -12029,9 +12347,9 @@ static s32 wl_init_priv(struct bcm_cfg80211 *cfg)
 	cfg->active_scan = true;
 	cfg->rf_blocked = false;
 	cfg->vsdb_mode = false;
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 	cfg->wlfc_on = false;
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 	cfg->roam_flags |= WL_ROAM_OFF_ON_CONCURRENT;
 	cfg->disable_roam_event = false;
 	cfg->cfgdev_bssidx = -1;
@@ -12336,7 +12654,7 @@ void wl_cfg80211_detach(void *para)
 static void wl_wakeup_event(struct bcm_cfg80211 *cfg)
 {
 	if (cfg->event_tsk.thr_pid >= 0) {
-		DHD_OS_WAKE_LOCK(cfg->pub);
+		DHD_EVENT_WAKE_LOCK(cfg->pub);
 		up(&cfg->event_tsk.sema);
 	}
 }
@@ -12355,7 +12673,7 @@ static s32 wl_event_handler(void *data)
 	while (down_interruptible (&tsk->sema) == 0) {
 		SMP_RD_BARRIER_DEPENDS();
 		if (tsk->terminated) {
-			DHD_OS_WAKE_UNLOCK(cfg->pub);
+			DHD_EVENT_WAKE_LOCK(cfg->pub);
 			break;
 		}
 		while ((e = wl_deq_event(cfg))) {
@@ -12389,7 +12707,7 @@ static s32 wl_event_handler(void *data)
 fail:
 			wl_put_event(e);
 		}
-		DHD_OS_WAKE_UNLOCK(cfg->pub);
+		DHD_EVENT_WAKE_LOCK(cfg->pub);
 	}
 	WL_ERR(("was terminated\n"));
 	complete_and_exit(&tsk->completed, 0);
@@ -13130,9 +13448,9 @@ static s32 __wl_cfg80211_down(struct bcm_cfg80211 *cfg)
 	struct net_device *p2p_net = cfg->p2p_net;
 #endif 
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 	dhd_pub_t *dhd =  (dhd_pub_t *)(cfg->pub);
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 	WL_DBG(("In\n"));
 	/* Delete pm_enable_work */
@@ -13145,7 +13463,7 @@ static s32 __wl_cfg80211_down(struct bcm_cfg80211 *cfg)
 	if (cfg->p2p_supported) {
 		wl_clr_p2p_status(cfg, GO_NEG_PHASE);
 #ifdef PROP_TXSTATUS_VSDB
-#if defined(BCMSDIO)
+#if defined(BCMSDIO) || defined(BCMDBUS)
 		if (wl_cfgp2p_vif_created(cfg)) {
 			bool enabled = false;
 			dhd_wlfc_get_enable(dhd, &enabled);
@@ -13155,7 +13473,7 @@ static s32 __wl_cfg80211_down(struct bcm_cfg80211 *cfg)
 				cfg->wlfc_on = false;
 			}
 		}
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 #endif /* PROP_TXSTATUS_VSDB */
 	}
 
@@ -13394,9 +13712,12 @@ s32 wl_cfg80211_down(void *para)
 	(void)para;
 	WL_DBG(("In\n"));
 	cfg = g_bcm_cfg;
-	mutex_lock(&cfg->usr_sync);
-	err = __wl_cfg80211_down(cfg);
-	mutex_unlock(&cfg->usr_sync);
+
+	if (cfg) {
+		mutex_lock(&cfg->usr_sync);
+		err = __wl_cfg80211_down(cfg);
+		mutex_unlock(&cfg->usr_sync);
+	}
 
 	return err;
 }
@@ -15333,6 +15654,13 @@ wl_get_public_action(void *frame, u32 frame_len, u8 *ret_action)
 	return BCME_OK;
 }
 
+#ifdef WLFBT
+void
+wl_cfg80211_get_fbt_key(uint8 *key)
+{
+	memcpy(key, g_bcm_cfg->fbt_key, FBT_KEYLEN);
+}
+#endif /* WLFBT */
 
 static int
 wl_cfg80211_delayed_roam(struct bcm_cfg80211 *cfg, struct net_device *ndev,
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.h
index 06a6f20e602d..33822bba3482 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg80211.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -488,6 +489,9 @@ struct parsed_ies {
 /* Max length of Interworking element */
 #define IW_IES_MAX_BUF_LEN 		9
 #endif
+#ifdef WLFBT
+#define FBT_KEYLEN		32
+#endif
 #define MAX_EVENT_BUF_NUM 16
 typedef struct wl_eventmsg_buf {
     u16 num;
@@ -566,9 +570,9 @@ struct bcm_cfg80211 {
 	bool pwr_save;
 	bool roam_on;		/* on/off switch for self-roaming */
 	bool scan_tried;	/* indicates if first scan attempted */
-#if defined(BCMSDIO) || defined(BCMPCIE)
+#if defined(BCMSDIO) || defined(BCMDBUS) || defined(BCMPCIE)
 	bool wlfc_on;
-#endif 
+#endif /* defined(BCMSDIO) || defined(BCMDBUS) */
 	bool vsdb_mode;
 #define WL_ROAM_OFF_ON_CONCURRENT		0x0001
 #define WL_ROAM_OFF_REVERT				0x0002
@@ -626,6 +630,9 @@ struct bcm_cfg80211 {
 	bcm_struct_cfgdev *bss_cfgdev;  /* For DUAL STA/STA+AP */
 	s32 cfgdev_bssidx;
 	bool bss_pending_op;		/* indicate where there is a pending IF operation */
+#ifdef WLFBT
+	uint8 fbt_key[FBT_KEYLEN];
+#endif
 	int roam_offload;
 #ifdef WL_NAN
 	bool nan_enable;
@@ -1167,7 +1174,20 @@ wl_get_netinfo_by_wdev(struct bcm_cfg80211 *cfg, struct wireless_dev *wdev)
 	 (!_sme->crypto.n_ciphers_pairwise) && \
 	 (!_sme->crypto.cipher_group))
 
+#ifdef WLFBT
+#if defined(WLAN_AKM_SUITE_FT_8021X) && defined(WLAN_AKM_SUITE_FT_PSK)
+#define IS_AKM_SUITE_FT(sec) (sec->wpa_auth == WLAN_AKM_SUITE_FT_8021X || \
+	sec->wpa_auth == WLAN_AKM_SUITE_FT_PSK)
+#elif defined(WLAN_AKM_SUITE_FT_8021X)
+#define IS_AKM_SUITE_FT(sec) (sec->wpa_auth == WLAN_AKM_SUITE_FT_8021X)
+#elif defined(WLAN_AKM_SUITE_FT_PSK)
+#define IS_AKM_SUITE_FT(sec) (sec->wpa_auth == WLAN_AKM_SUITE_FT_PSK)
+#else
 #define IS_AKM_SUITE_FT(sec) false
+#endif /* WLAN_AKM_SUITE_FT_8021X && WLAN_AKM_SUITE_FT_PSK */
+#else
+#define IS_AKM_SUITE_FT(sec) false
+#endif /* WLFBT */
 
 #define IS_AKM_SUITE_CCKM(sec) false
 
@@ -1279,6 +1299,9 @@ extern int wl_cfg80211_set_mgmt_vndr_ies(struct bcm_cfg80211 *cfg,
 	bcm_struct_cfgdev *cfgdev, s32 bssidx, s32 pktflag,
 	const u8 *vndr_ie, u32 vndr_ie_len);
 
+#ifdef WLFBT
+extern void wl_cfg80211_get_fbt_key(uint8 *key);
+#endif
 
 /* Action frame specific functions */
 extern u8 wl_get_action_category(void *frame, u32 frame_len);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg_btcoex.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg_btcoex.c
index 321c7ad43fd8..363e92559a71 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg_btcoex.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfg_btcoex.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver - Dongle Host Driver (DHD) related
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: wl_cfg_btcoex.c 514727 2014-11-12 03:02:48Z $
+ * $Id: wl_cfg_btcoex.c 709309 2019-01-17 09:04:00Z $
  */
 
 #include <net/rtnetlink.h>
@@ -298,9 +299,15 @@ wl_cfg80211_bt_setflag(struct net_device *dev, bool set)
 #endif
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 static void wl_cfg80211_bt_timerfunc(struct timer_list *t)
 {
 	struct btcoex_info *bt_local = from_timer(bt_local, t, timer);
+#else
+static void wl_cfg80211_bt_timerfunc(ulong data)
+{
+	struct btcoex_info *bt_local = (struct btcoex_info *)data;
+#endif
 	WL_TRACE(("Enter\n"));
 	bt_local->timer_on = 0;
 	schedule_work(&bt_local->work);
@@ -390,7 +397,13 @@ void* wl_cfg80211_btcoex_init(struct net_device *ndev)
 	btco_inf->ts_dhcp_ok = 0;
 	/* Set up timer for BT  */
 	btco_inf->timer_ms = 10;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 	timer_setup(&btco_inf->timer, wl_cfg80211_bt_timerfunc, 0);
+#else
+	init_timer(&btco_inf->timer);
+	btco_inf->timer.data = (ulong)btco_inf;
+	btco_inf->timer.function = wl_cfg80211_bt_timerfunc;
+#endif
 
 	btco_inf->dev = ndev;
 
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.c
new file mode 100644
index 000000000000..1dd704758088
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.c
@@ -0,0 +1,2127 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Neighbor Awareness Networking
+ *
+ * Copyright (C) 1999-2019, Broadcom Corporation
+ * 
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ * 
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ * 
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * $Id: wl_cfgnan.c 559906 2015-05-29 02:42:35Z $
+ */
+
+#include <bcmutils.h>
+#include <bcmendian.h>
+#include <bcmwifi_channels.h>
+#include <proto/nan.h>
+
+#include <wl_cfg80211.h>
+#include <wl_android.h>
+#include <wl_cfgnan.h>
+
+#ifdef WL_NAN_DEBUG
+static u8 g_nan_debug = true;
+#endif /* WL_NAN_DEBUG */
+
+static nan_cmd_t nan_cmds [] = {
+	{ "NAN_START", wl_cfgnan_start_handler },
+	{ "NAN_STOP", wl_cfgnan_stop_handler },
+	{ "NAN_SUPPORT", wl_cfgnan_support_handler },
+	{ "NAN_STATUS", wl_cfgnan_status_handler },
+	{ "NAN_PUBLISH", wl_cfgnan_pub_handler },
+	{ "NAN_SUBSCRIBE", wl_cfgnan_sub_handler },
+	{ "NAN_CANCEL_PUBLISH", wl_cfgnan_cancel_pub_handler },
+	{ "NAN_CANCEL_SUBSCRIBE", wl_cfgnan_cancel_sub_handler },
+	{ "NAN_TRANSMIT", wl_cfgnan_transmit_handler },
+	{ "NAN_SET_CONFIG", wl_cfgnan_set_config_handler },
+	{ "NAN_GET_CONFIG", NULL },
+	{ "NAN_RTT_CONFIG", wl_cfgnan_rtt_config_handler },
+	{ "NAN_RTT_FIND", wl_cfgnan_rtt_find_handler },
+#ifdef WL_NAN_DEBUG
+	{ "NAN_DEBUG", wl_cfgnan_debug_handler },
+#endif /* WL_NAN_DEBUG */
+#ifdef NAN_P2P_CONFIG
+	{ "NAN_ADD_CONF", wl_cfgnan_p2p_ie_add_handler },
+	{ "NAN_ENABLE_CONF", wl_cfgnan_p2p_ie_enable_handler },
+	{ "NAN_DEL_CONF", wl_cfgnan_p2p_ie_del_handler },
+#endif /* NAN_P2P_CONFIG */
+	{ NULL, NULL },
+};
+
+static nan_config_attr_t nan_config_attrs [] = {
+	{ "ATTR_MASTER", WL_NAN_XTLV_MASTER_PREF },
+	{ "ATTR_ID", WL_NAN_XTLV_CLUSTER_ID },
+	{ "ATTR_ADDR", WL_NAN_XTLV_IF_ADDR },
+	{ "ATTR_ROLE", WL_NAN_XTLV_ROLE },
+	{ "ATTR_BCN_INT", WL_NAN_XTLV_BCN_INTERVAL },
+	{ "ATTR_CHAN", WL_NAN_XTLV_MAC_CHANSPEC },
+	{ "ATTR_TX_RATE", WL_NAN_XTLV_MAC_TXRATE },
+	{ "ATTR_DW_LEN", WL_NAN_XTLV_DW_LEN },
+	{ {0}, 0 }
+};
+
+#ifdef WL_NAN_DEBUG
+void print_event_name(u32 event_num)
+{
+	char *event_name = NULL;
+
+	switch (event_num) {
+	case WL_NAN_EVENT_START:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_START);
+		break;
+	case WL_NAN_EVENT_JOIN:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_JOIN);
+		break;
+	case WL_NAN_EVENT_ROLE:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_ROLE);
+		break;
+	case WL_NAN_EVENT_SCAN_COMPLETE:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_SCAN_COMPLETE);
+		break;
+	case WL_NAN_EVENT_DISCOVERY_RESULT:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_DISCOVERY_RESULT);
+		break;
+	case WL_NAN_EVENT_REPLIED:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_REPLIED);
+		break;
+	case WL_NAN_EVENT_TERMINATED:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_TERMINATED);
+		break;
+	case WL_NAN_EVENT_RECEIVE:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_RECEIVE);
+		break;
+	case WL_NAN_EVENT_STATUS_CHG:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_STATUS_CHG);
+		break;
+	case WL_NAN_EVENT_MERGE:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_MERGE);
+		break;
+	case WL_NAN_EVENT_STOP:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_STOP);
+		break;
+	case WL_NAN_EVENT_P2P:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_P2P);
+		break;
+	case WL_NAN_EVENT_WINDOW_BEGIN_P2P:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_WINDOW_BEGIN_P2P);
+		break;
+	case WL_NAN_EVENT_WINDOW_BEGIN_MESH:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_WINDOW_BEGIN_MESH);
+		break;
+	case WL_NAN_EVENT_WINDOW_BEGIN_IBSS:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_WINDOW_BEGIN_IBSS);
+		break;
+	case WL_NAN_EVENT_WINDOW_BEGIN_RANGING:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_WINDOW_BEGIN_RANGING);
+		break;
+	case WL_NAN_EVENT_INVALID:
+		event_name = NAME_TO_STR(WL_NAN_EVENT_INVALID);
+		break;
+	default:
+		break;
+	}
+	if (event_name) {
+		WL_DBG((" event name: %s \n", event_name));
+	} else {
+		WL_DBG(("Unknown event %d\n", event_num));
+	}
+}
+#endif /* WL_NAN_DEBUG */
+
+int
+wl_cfgnan_set_vars_cbfn(void *ctx, uint8 *buf, uint16 type, uint16 len)
+{
+	wl_nan_tlv_data_t *ndata = ((wl_nan_tlv_data_t *)(ctx));
+	int ret = BCME_OK;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+	WL_DBG((" enter, xtlv_type: 0x%x \n", type));
+
+	switch (type) {
+	case WL_NAN_XTLV_ENABLED:
+		memcpy(&ndata->enabled, buf, len);
+		break;
+	case WL_NAN_XTLV_MASTER_PREF:
+		/*
+		 * master role and preference  mac has them as two u8's,
+		 *
+		 * masterpref: val & 0x0ff
+		 * rnd_factor: val >> 8
+		 */
+		memcpy(&ndata->master_pref, buf, len);
+		break;
+	case WL_NAN_XTLV_IF_ADDR:
+		memcpy(&ndata->mac_addr, buf, len);
+		break;
+	case WL_NAN_XTLV_CLUSTER_ID:
+		memcpy(&ndata->clus_id, buf, len);
+		break;
+	case WL_NAN_XTLV_ROLE:
+		/*  nan device role, master, master-sync nosync etc  */
+		memcpy(&ndata->dev_role, buf, len);
+		break;
+	case WL_NAN_XTLV_MAC_CHANSPEC:
+		memcpy(&ndata->chanspec, buf, len);
+		if (wf_chspec_valid(ndata->chanspec)) {
+			wf_chspec_ntoa(ndata->chanspec, buf);
+			WL_DBG((" chanspec: %s 0x%x \n", buf, ndata->chanspec));
+		} else {
+			WL_DBG((" chanspec: 0x%x is not valid \n", ndata->chanspec));
+		}
+		break;
+	case WL_NAN_XTLV_MAC_AMR:
+		memcpy(ndata->amr, buf, len);
+		break;
+	case WL_NAN_XTLV_MAC_AMBTT:
+		memcpy(&ndata->ambtt, buf, len);
+		break;
+	case WL_NAN_XTLV_MAC_HOPCNT:
+		memcpy(&ndata->hop_count, buf, len);
+		break;
+	case WL_NAN_XTLV_INSTANCE_ID:
+		memcpy(&ndata->inst_id, buf, len);
+		break;
+	case WL_NAN_XTLV_SVC_NAME:
+		memcpy(ndata->svc_name, buf, len);
+		break;
+	case WL_NAN_XTLV_SVC_PARAMS:
+		memcpy(&ndata->params, buf, len);
+		break;
+	case WL_NAN_XTLV_MAC_STATUS:
+		memcpy(&ndata->nstatus, buf, len);
+		break;
+	case WL_NAN_XTLV_PUBLR_ID:
+		memcpy(&ndata->pub_id, buf, len);
+		break;
+	case WL_NAN_XTLV_SUBSCR_ID:
+		memcpy(&ndata->sub_id, buf, len);
+		break;
+	case WL_NAN_XTLV_MAC_ADDR:
+		memcpy(&ndata->mac_addr, buf, len);
+		break;
+	case WL_NAN_XTLV_VNDR:
+		ndata->vend_info.dlen = len;
+		ndata->vend_info.data = kzalloc(ndata->vend_info.dlen, kflags);
+		if (!ndata->vend_info.data) {
+			WL_ERR((" memory allocation failed \n"));
+			ret = -ENOMEM;
+			goto fail;
+		}
+		if (ndata->vend_info.data && ndata->vend_info.dlen) {
+			memcpy(ndata->vend_info.data, buf, len);
+		}
+		break;
+	case WL_NAN_XTLV_SVC_INFO:
+		ndata->svc_info.dlen = len;
+		ndata->svc_info.data = kzalloc(ndata->svc_info.dlen, kflags);
+		if (!ndata->svc_info.data) {
+			WL_ERR((" memory allocation failed \n"));
+			ret = -ENOMEM;
+			goto fail;
+		}
+		if (ndata->svc_info.data && ndata->svc_info.dlen) {
+			memcpy(ndata->svc_info.data, buf, len);
+		}
+		break;
+	case WL_NAN_XTLV_PEER_INSTANCE_ID:
+		memcpy(&ndata->peer_inst_id, buf, len);
+		break;
+	case WL_NAN_XTLV_NAN_SCANPARAMS:
+		memcpy(&ndata->scan_params, buf, len);
+		break;
+	case WL_NAN_XTLV_ZERO:
+		/* don't parse empty space in the buffer */
+		ret = BCME_ERROR;
+		break;
+
+	default:
+		break;
+	}
+
+fail:
+	return ret;
+}
+
+int
+wl_cfgnan_enable_events(struct net_device *ndev, struct bcm_cfg80211 *cfg)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	uint8 *pxtlv;
+	u32 event_mask = 0;
+	s32 ret = BCME_OK;
+	u16 start, end;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	ret = wl_add_remove_eventmsg(ndev, WLC_E_NAN, true);
+	if (unlikely(ret)) {
+		WL_ERR((" nan event enable failed, error = %d \n", ret));
+		goto fail;
+	}
+#ifdef WL_NAN_DEBUG
+	if (g_nan_debug) {
+		/* enable all nan events */
+		event_mask = NAN_EVENT_MASK_ALL;
+	} else
+#endif /* WL_NAN_DEBUG */
+	{
+		/* enable only selected nan events to avoid unnecessary host wake up */
+		event_mask |= NAN_EVENT_BIT(WL_NAN_EVENT_START);
+		event_mask |= NAN_EVENT_BIT(WL_NAN_EVENT_JOIN);
+		event_mask |= NAN_EVENT_BIT(WL_NAN_EVENT_DISCOVERY_RESULT);
+		event_mask |= NAN_EVENT_BIT(WL_NAN_EVENT_RECEIVE);
+		event_mask |= NAN_EVENT_BIT(WL_NAN_EVENT_TERMINATED);
+		event_mask |= NAN_EVENT_BIT(WL_NAN_EVENT_STOP);
+		event_mask |= NAN_EVENT_BIT(WL_NAN_EVENT_CLEAR_BIT);
+#ifdef NAN_P2P_CONFIG
+		event_mask |= NAN_EVENT_BIT(WL_NAN_EVENT_P2P);
+#endif /* NAN_P2P_CONFIG */
+		event_mask = htod32(event_mask);
+	}
+
+	start = end = NAN_IOCTL_BUF_SIZE;
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_EVENT_MASK);
+	pxtlv = nanioc->data;
+	ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_EVENT_MASK,
+		sizeof(event_mask), &event_mask, BCM_XTLV_OPTION_ALIGN32);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+	nanioc->len = start - end;
+	nanioc_size = sizeof(wl_nan_ioc_t) + nanioc->len;
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan event selective enable failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan event selective enable successful \n"));
+	}
+
+	ret = wl_add_remove_eventmsg(ndev, WLC_E_PROXD, true);
+	if (unlikely(ret)) {
+		WL_ERR((" proxd event enable failed, error = %d \n", ret));
+		goto fail;
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_enable_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	uint8 *pxtlv;
+	s32 ret = BCME_OK;
+	u16 start, end;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+	uint8 val;
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan 1
+	 *
+	 * wpa_cli: DRIVER NAN_ENABLE
+	 */
+
+	/* nan enable */
+	val = 1;
+	start = end = NAN_IOCTL_BUF_SIZE;
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_ENABLE);
+	pxtlv = nanioc->data;
+	ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_ENABLED,
+		sizeof(val), &val, BCM_XTLV_OPTION_ALIGN32);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+	nanioc->len = start - end;
+	nanioc_size = sizeof(wl_nan_ioc_t) + nanioc->len;
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan enable failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		cfg->nan_enable = true;
+		WL_DBG((" nan enable successful \n"));
+	}
+
+	/* enable nan events */
+	ret = wl_cfgnan_enable_events(ndev, cfg);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_start_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	struct ether_addr cluster_id = ether_null;
+	uint8 *pxtlv;
+	s32 ret = BCME_OK;
+	u16 start, end;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+	uint8 val;
+
+	if (cfg->nan_enable != true) {
+		ret = wl_cfgnan_enable_handler(ndev, cfg, cmd, cmd_data);
+		if (unlikely(ret)) {
+			goto fail;
+		}
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan join -start
+	 *
+	 * wpa_cli: DRIVER NAN_START
+	 */
+
+	/* nan join */
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	val = 1;
+	start = end = NAN_IOCTL_BUF_SIZE;
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_NAN_JOIN);
+	pxtlv = nanioc->data;
+	ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_CLUSTER_ID,
+		ETHER_ADDR_LEN, &cluster_id, BCM_XTLV_OPTION_ALIGN32);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+	ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_START,
+		sizeof(val), &val, BCM_XTLV_OPTION_ALIGN32);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+	nanioc->len = start - end;
+	nanioc_size = sizeof(wl_nan_ioc_t) + nanioc->len;
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan join failed, error = %d \n", ret));
+		goto fail;
+	}
+
+	WL_DBG((" nan join successful \n"));
+	cfg->nan_running = true;
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_stop_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	struct ether_addr cluster_id = ether_null;
+	uint8 *pxtlv;
+	s32 ret = BCME_OK;
+	u16 start, end;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+	uint8 nan_enable = FALSE;
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan stop
+	 *     wl nan 0
+	 *
+	 * wpa_cli: DRIVER NAN_STOP
+	 */
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	if (cfg->nan_running == true) {
+		/* nan stop */
+
+		start = end = NAN_IOCTL_BUF_SIZE;
+		nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+		nanioc->id = htod16(WL_NAN_CMD_STOP);
+		pxtlv = nanioc->data;
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_CLUSTER_ID,
+			ETHER_ADDR_LEN, &cluster_id, BCM_XTLV_OPTION_ALIGN32);
+		if (unlikely(ret)) {
+			goto fail;
+		}
+		nanioc->len = start - end;
+		nanioc_size = sizeof(wl_nan_ioc_t) + nanioc->len;
+		ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+			cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+		if (unlikely(ret)) {
+			WL_ERR((" nan stop failed, error = %d \n", ret));
+			goto fail;
+		} else {
+			cfg->nan_running = false;
+			WL_DBG((" nan stop successful \n"));
+		}
+	}
+
+	/* nan disable */
+	if (cfg->nan_enable == true) {
+		memset(nanioc, 0, nanioc_size);
+		start = end = NAN_IOCTL_BUF_SIZE;
+		nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+		nanioc->id = htod16(WL_NAN_CMD_ENABLE);
+		pxtlv = nanioc->data;
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_ENABLED,
+			sizeof(nan_enable), &nan_enable, BCM_XTLV_OPTION_ALIGN32);
+		if (unlikely(ret)) {
+			goto fail;
+		}
+		nanioc->len = start - end;
+		nanioc_size = sizeof(wl_nan_ioc_t) + nanioc->len;
+		ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+			cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+		if (unlikely(ret)) {
+			WL_ERR((" nan disable failed, error = %d \n", ret));
+			goto fail;
+		} else {
+			cfg->nan_enable = false;
+			WL_DBG((" nan disable successful \n"));
+		}
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_support_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	uint8 *pxtlv;
+	s32 ret = BCME_OK;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan
+	 *
+	 * wpa_cli: DRIVER NAN_SUPPORT
+	 */
+
+	/* nan support */
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_ENABLE);
+	pxtlv = nanioc->data;
+	nanioc->len = htod16(BCM_XTLV_HDR_SIZE + 1);
+	nanioc_size = sizeof(wl_nan_ioc_t) + sizeof(bcm_xtlv_t);
+	ret = wldev_iovar_getbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_SMLEN, &cfg->ioctl_buf_sync);
+	if (unlikely(ret)) {
+		WL_ERR((" nan is not supported, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan is supported \n"));
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_status_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	wl_nan_ioc_t *ioc_ret = NULL;
+	char *ptr = cmd;
+	char *end = cmd + size;
+	wl_nan_tlv_data_t tlv_data;
+	s32 ret = BCME_OK;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan status
+	 *
+	 * wpa_cli: DRIVER NAN_STATUS
+	 */
+
+	/* nan status */
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_STATUS);
+	nanioc->len = NAN_IOCTL_BUF_SIZE;
+	nanioc_size = sizeof(wl_nan_ioc_t) + sizeof(bcm_xtlv_t);
+	ret = wldev_iovar_getbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan status failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan status successful \n"));
+	}
+
+	/* unpack the tlvs */
+	memset(&tlv_data, 0, sizeof(tlv_data));
+	ioc_ret = (wl_nan_ioc_t *)cfg->ioctl_buf;
+	if (!ioc_ret) {
+		goto fail;
+	}
+#ifdef WL_NAN_DEBUG
+	if (g_nan_debug) {
+		prhex(" nanioc->data: ", (uint8 *)ioc_ret->data, ioc_ret->len);
+	}
+#endif /* WL_NAN_DEBUG */
+	bcm_unpack_xtlv_buf(&tlv_data, ioc_ret->data, ioc_ret->len,
+		BCM_XTLV_OPTION_ALIGN32, wl_cfgnan_set_vars_cbfn);
+
+	ptr += snprintf(ptr, end-ptr, ROLE_PREFIX"%d", tlv_data.dev_role);
+	ptr += snprintf(ptr, end-ptr, " " AMR_PREFIX);
+	ptr += bcm_format_hex(ptr, tlv_data.amr, NAN_MASTER_RANK_LEN);
+	ptr += snprintf(ptr, end-ptr, " " CLUS_ID_PREFIX MACF, ETHER_TO_MACF(tlv_data.clus_id));
+	ptr += snprintf(ptr, end-ptr, " " AMBTT_PREFIX"0x%x", tlv_data.ambtt);
+	ptr += snprintf(ptr, end-ptr, " " HOP_COUNT_PREFIX"%d", tlv_data.hop_count);
+
+	/* nan scan param */
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_SCAN_PARAMS);
+	nanioc->len = NAN_IOCTL_BUF_SIZE;
+	nanioc_size = sizeof(wl_nan_ioc_t) + sizeof(bcm_xtlv_t);
+	ret = wldev_iovar_getbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan scan params failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan scan params successful \n"));
+	}
+
+	if (tlv_data.svc_info.data) {
+		kfree(tlv_data.svc_info.data);
+		tlv_data.svc_info.data = NULL;
+		tlv_data.svc_info.dlen = 0;
+	}
+	if (tlv_data.vend_info.data) {
+		kfree(tlv_data.vend_info.data);
+		tlv_data.vend_info.data = NULL;
+		tlv_data.vend_info.dlen = 0;
+	}
+	/* unpack the tlvs */
+	memset(&tlv_data, 0, sizeof(tlv_data));
+	ioc_ret = (wl_nan_ioc_t *)cfg->ioctl_buf;
+	ASSERT(ioc_ret != NULL);
+#ifdef WL_NAN_DEBUG
+	if (g_nan_debug) {
+		prhex(" nanioc->data: ", (uint8 *)ioc_ret->data, ioc_ret->len);
+	}
+#endif /* WL_NAN_DEBUG */
+	bcm_unpack_xtlv_buf(&tlv_data, ioc_ret->data, ioc_ret->len,
+		BCM_XTLV_OPTION_ALIGN32, wl_cfgnan_set_vars_cbfn);
+
+	ptr += snprintf(ptr, end-ptr, " " SCAN_PERIOD_PREFIX"%d",
+		tlv_data.scan_params.ms_dur);
+	ptr += snprintf(ptr, end-ptr, " " SCAN_INTERVAL_PREFIX"%d",
+		tlv_data.scan_params.ms_intvl*512);
+
+	if (ptr > end) {
+		WL_ERR(("Buffer overflow. userspace string truncated: %s, len: %zu\n",
+			cmd, strlen(cmd)));
+	}
+
+	WL_DBG((" formatted string for userspace: %s, len: %zu \n",
+		cmd, strlen(cmd)));
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+	if (tlv_data.svc_info.data) {
+		kfree(tlv_data.svc_info.data);
+		tlv_data.svc_info.data = NULL;
+		tlv_data.svc_info.dlen = 0;
+	}
+	if (tlv_data.vend_info.data) {
+		kfree(tlv_data.vend_info.data);
+		tlv_data.vend_info.data = NULL;
+		tlv_data.vend_info.dlen = 0;
+	}
+
+	return ret;
+}
+
+
+#ifdef NAN_P2P_CONFIG
+
+static void
+wl_p2p_nan_ioctl_make_header(wl_p2p_nan_ioc_t *p2p_nanioc, uint16 cmd_id, uint16 len)
+{
+	p2p_nanioc->version = htod16(WL_P2P_NAN_IOCTL_VERSION);
+	p2p_nanioc->id = cmd_id;
+	p2p_nanioc->len = htod16(len);
+}
+
+static int
+wl_p2p_nan_do_get_ioctl(struct net_device *ndev, struct bcm_cfg80211 *cfg,
+	wl_p2p_nan_ioc_t *p2p_nanioc, uint16 alloc_size)
+{
+	wl_p2p_nan_ioc_t *iocresp = NULL;
+	int res;
+	uint8 *val;
+	/*  send getbuf p2p nan iovar */
+	res = wldev_iovar_getbuf(ndev, "p2p_nan", p2p_nanioc, alloc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+
+	if (res == BCME_OK) {
+		iocresp = (wl_p2p_nan_ioc_t *)cfg->ioctl_buf;
+		if (iocresp == NULL) {
+			res = BCME_ERROR;
+			return res;
+		}
+		switch (iocresp->id) {
+			case WL_P2P_NAN_CMD_ENABLE:
+				val = iocresp->data;
+				WL_ERR(("wl p2p_nan status is %s\n",
+					*val == 1? "Enabled":"Disabled"));
+				break;
+			case WL_P2P_NAN_CMD_CONFIG: {
+				wl_p2p_nan_config_t *p_p2p_nan_cfg =
+					(wl_p2p_nan_config_t *)iocresp->data;
+				WL_ERR(("wl p2p nan ie len = %u\n", p_p2p_nan_cfg->ie_len));
+				prhex("P2P IE", p_p2p_nan_cfg->ie, p_p2p_nan_cfg->ie_len);
+			}
+			break;
+			default:
+			WL_ERR(("Unknown command %d\n", iocresp->id));
+			break;
+		}
+	}
+	return res;
+}
+
+
+int wl_cfgnan_p2p_ie_enable_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char* buf, int size, nan_cmd_data_t *cmd_data)
+{
+	int res = BCME_OK;
+	wl_p2p_nan_ioc_t *p2p_nanioc;
+	uint16 alloc_size = OFFSETOF(wl_p2p_nan_ioc_t, data) + P2P_NAN_IOC_BUFSZ;
+	void *pdata = NULL;
+	uint8 val;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	p2p_nanioc = kzalloc(alloc_size, kflags);
+	if (p2p_nanioc == NULL) {
+		WL_ERR((" memory allocation failed \n"));
+		return BCME_NOMEM;
+	}
+
+	wl_p2p_nan_ioctl_make_header(p2p_nanioc, WL_P2P_NAN_CMD_ENABLE, sizeof(uint8));
+
+	if (cmd_data->p2p_info.data == NULL) { /* get  */
+		res = wl_p2p_nan_do_get_ioctl(ndev, cfg, p2p_nanioc, alloc_size);
+	} else {	/* set */
+
+		val =  (uint8) cmd_data->p2p_info.data[0];
+		pdata = p2p_nanioc->data;
+		memcpy(pdata, &val, sizeof(uint8));
+		res = wldev_iovar_setbuf(ndev, "p2p_nan", p2p_nanioc,
+			alloc_size, cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	}
+
+	kfree(p2p_nanioc);
+	return res;
+}
+int wl_cfgnan_p2p_ie_add_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	int res = BCME_OK;
+	int ie_len, data_len;
+	wl_p2p_nan_ioc_t *p2p_nanioc;
+	uint16 alloc_size = OFFSETOF(wl_p2p_nan_ioc_t, data) + cmd_data->p2p_info.dlen;
+	wl_p2p_nan_config_t *p_p2p_nan_cfg;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+	p2p_nanioc = kzalloc(alloc_size, kflags);
+	if (p2p_nanioc == NULL)
+		return BCME_NOMEM;
+
+	cmd_data->p2p_info.dlen /= 2;	/* Number of hex values will be half of ascii */
+	wl_p2p_nan_ioctl_make_header(p2p_nanioc, WL_P2P_NAN_CMD_CONFIG, P2P_NAN_IOC_BUFSZ);
+
+	if (cmd_data->p2p_info.data == NULL) { /* get */
+		wl_p2p_nan_do_get_ioctl(ndev, cfg, p2p_nanioc, alloc_size);
+	} else {
+		ie_len = cmd_data->p2p_info.dlen;
+		data_len = OFFSETOF(wl_p2p_nan_config_t, ie) + ie_len;
+
+		p_p2p_nan_cfg = (wl_p2p_nan_config_t *)p2p_nanioc->data;
+		p_p2p_nan_cfg->version = WL_P2P_NAN_CONFIG_VERSION;
+		p_p2p_nan_cfg->len = data_len;
+		p_p2p_nan_cfg->ie_len = ie_len;
+
+	if (!wl_cfg80211_hex_str_to_bin
+		(p_p2p_nan_cfg->ie, (int)p_p2p_nan_cfg->ie_len, (uchar*)cmd_data->p2p_info.data)) {
+		res = BCME_BADARG;
+		goto fail;
+	}
+	p2p_nanioc->len = htod16(data_len);
+
+	res = wldev_iovar_setbuf(ndev, "p2p_nan", p2p_nanioc, alloc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	}
+fail:
+	kfree(p2p_nanioc);
+	return res;
+}
+int wl_cfgnan_p2p_ie_del_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	int res = BCME_OK;
+	wl_p2p_nan_ioc_t *p2p_nanioc;
+	uint16 alloc_size = OFFSETOF(wl_p2p_nan_ioc_t, data);
+
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	p2p_nanioc = kzalloc(alloc_size, kflags);
+	if (p2p_nanioc == NULL) {
+		WL_ERR((" Memory is not enough\n"));
+		return BCME_NOMEM;
+	}
+	wl_p2p_nan_ioctl_make_header(p2p_nanioc, WL_P2P_NAN_CMD_DEL_CONFIG, 0);
+	res = wldev_iovar_setbuf(ndev, "p2p_nan", p2p_nanioc, alloc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	kfree(p2p_nanioc);
+	return res;
+}
+
+#endif /* NAN_P2P_CONFIG */
+
+/*
+ *  packs user data (in hex string) into tlv record
+ *  advances tlv pointer to next xtlv slot
+ *  buflen is used for tlv_buf space check
+ */
+static int
+get_ie_data(uchar *data_str, uchar *ie_data, int len)
+{
+	uchar *src, *dest;
+	uchar val;
+	int idx;
+	char hexstr[3];
+
+	src = data_str;
+	dest = ie_data;
+
+	for (idx = 0; idx < len; idx++) {
+		hexstr[0] = src[0];
+		hexstr[1] = src[1];
+		hexstr[2] = '\0';
+
+#ifdef BCMDRIVER
+		val = (uchar) simple_strtoul(hexstr, NULL, 16);
+#else
+		val = (uchar) strtoul(hexstr, NULL, 16);
+#endif
+
+		*dest++ = val;
+		src += 2;
+	}
+
+	return 0;
+}
+
+int
+wl_cfgnan_pub_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	wl_nan_disc_params_t params;
+	s32 ret = BCME_OK;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+	uint8 *pxtlv;
+	u16 start, end;
+	uchar *buf = NULL;
+
+	/*
+	 * proceed only if mandatory arguments are present - publisher id,
+	 * service hash
+	 */
+	if ((!cmd_data->pub_id) || (!cmd_data->svc_hash.data) ||
+		(!cmd_data->svc_hash.dlen)) {
+		WL_ERR((" mandatory arguments are not present \n"));
+		return -EINVAL;
+	}
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan publish 10 NAN123 -info <hex_string
+	 *     wl nan publish 10 NAN123 -info <hex_string -period 1 -ttl 0xffffffff
+	 *
+	 * wpa_cli: DRIVER NAN_PUBLISH PUB_ID=10 SVC_HASH=NAN123
+	 *          SVC_INFO=<hex_string>
+	 *          DRIVER NAN_PUBLISH PUB_ID=10 SVC_HASH=NAN123
+	 *          SVC_INFO=<hex_string> PUB_PR=1 PUB_INT=0xffffffff
+	 */
+
+	/* nan publish */
+	start = end = NAN_IOCTL_BUF_SIZE;
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_PUBLISH);
+	pxtlv = nanioc->data;
+
+	/* disovery parameters */
+	if (cmd_data->pub_pr) {
+		params.period = cmd_data->pub_pr;
+	} else {
+		params.period = 1;
+	}
+	if (cmd_data->pub_int) {
+		params.ttl = cmd_data->pub_int;
+	} else {
+		params.ttl = WL_NAN_TTL_UNTIL_CANCEL;
+	}
+	params.flags = 0;
+	if (cmd_data->flags & WL_NAN_PUB_UNSOLICIT) {
+		params.flags |= WL_NAN_PUB_UNSOLICIT;
+		WL_DBG((" nan publish type - unsolicited\n"));
+	}
+	if (cmd_data->flags & WL_NAN_PUB_SOLICIT) {
+		params.flags |= WL_NAN_PUB_SOLICIT;
+		WL_DBG((" nan publish type - solicited\n"));
+	}
+	if (!params.flags) {
+		params.flags = WL_NAN_PUB_BOTH; /* default. */
+	}
+	params.instance_id = (wl_nan_instance_id_t)cmd_data->pub_id;
+	memcpy((char *)params.svc_hash, cmd_data->svc_hash.data,
+		cmd_data->svc_hash.dlen);
+	ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_SVC_PARAMS,
+		sizeof(params), &params, BCM_XTLV_OPTION_ALIGN32);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+	if (cmd_data->svc_info.data && cmd_data->svc_info.dlen) {
+		uint16 len = cmd_data->svc_info.dlen/2;
+
+		WL_DBG((" optional svc_info present, pack it \n"));
+		buf = kzalloc(len, kflags);
+		if (!buf) {
+			WL_ERR((" memory allocation failed \n"));
+			ret = -ENOMEM;
+			goto fail;
+		}
+		if (get_ie_data((uchar*)cmd_data->svc_info.data, buf, len)) {
+			goto fail;
+		}
+
+		ret = bcm_pack_xtlv_entry(&pxtlv,
+			&end, WL_NAN_XTLV_SVC_INFO, len, buf, BCM_XTLV_OPTION_ALIGN32);
+		if (unlikely(ret)) {
+			goto fail;
+		}
+	}
+
+	nanioc->len = start - end;
+	nanioc_size = sizeof(wl_nan_ioc_t) + nanioc->len;
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan publish failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan publish successful \n"));
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+	if (buf) {
+		kfree(buf);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_sub_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	bcm_xtlvbuf_t tbuf;
+	wl_nan_disc_params_t params;
+	s32 ret = BCME_OK;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+
+	/*
+	 * proceed only if mandatory arguments are present - subscriber id,
+	 * service hash
+	 */
+	if ((!cmd_data->sub_id) || (!cmd_data->svc_hash.data) ||
+		(!cmd_data->svc_hash.dlen)) {
+		WL_ERR((" mandatory arguments are not present \n"));
+		return -EINVAL;
+	}
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	bcm_xtlv_buf_init(&tbuf, nanioc->data,
+		BCM_XTLV_HDR_SIZE + sizeof(params), BCM_XTLV_OPTION_ALIGN32);
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan subscribe 10 NAN123
+	 *
+	 * wpa_cli: DRIVER NAN_SUBSCRIBE SUB_ID=10 SVC_HASH=NAN123
+	 */
+
+	/* nan subscribe */
+	params.period = 1;
+	params.ttl = WL_NAN_TTL_UNTIL_CANCEL;
+	params.flags = 0;
+	if (cmd_data->flags & WL_NAN_SUB_ACTIVE) {
+		params.flags = WL_NAN_SUB_ACTIVE;
+		WL_DBG((" nan subscribe type - Active\n"));
+	}
+	params.instance_id = (wl_nan_instance_id_t)cmd_data->sub_id;
+	memcpy((char *)params.svc_hash, cmd_data->svc_hash.data,
+		cmd_data->svc_hash.dlen);
+	bcm_xtlv_put_data(&tbuf, WL_NAN_XTLV_SVC_PARAMS, &params, sizeof(params));
+
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_SUBSCRIBE);
+	nanioc->len = htod16(bcm_xtlv_buf_len(&tbuf));
+	nanioc_size = sizeof(wl_nan_ioc_t) + bcm_xtlv_buf_len(&tbuf);
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan subscribe failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan subscribe successful \n"));
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_cancel_pub_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	bcm_xtlvbuf_t tbuf;
+	wl_nan_disc_params_t params;
+	s32 ret = BCME_OK;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+
+	/* proceed only if mandatory argument is present - publisher id */
+	if (!cmd_data->pub_id) {
+		WL_ERR((" mandatory argument is not present \n"));
+		return -EINVAL;
+	}
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	bcm_xtlv_buf_init(&tbuf, nanioc->data,
+		BCM_XTLV_HDR_SIZE + sizeof(params), BCM_XTLV_OPTION_ALIGN32);
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan cancel_publish 10
+	 *
+	 * wpa_cli: DRIVER NAN_CANCEL_PUBLISH PUB_ID=10
+	 */
+
+	bcm_xtlv_put_data(&tbuf, WL_NAN_XTLV_INSTANCE_ID, &cmd_data->pub_id,
+		sizeof(wl_nan_instance_id_t));
+
+	/* nan cancel publish */
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_CANCEL_PUBLISH);
+	nanioc->len = htod16(bcm_xtlv_buf_len(&tbuf));
+	nanioc_size = sizeof(wl_nan_ioc_t) + bcm_xtlv_buf_len(&tbuf);
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan cancel publish failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan cancel publish successful \n"));
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_cancel_sub_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	bcm_xtlvbuf_t tbuf;
+	wl_nan_disc_params_t params;
+	s32 ret = BCME_OK;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+
+	/* proceed only if mandatory argument is present - subscriber id */
+	if (!cmd_data->sub_id) {
+		WL_ERR((" mandatory argument is not present \n"));
+		return -EINVAL;
+	}
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	bcm_xtlv_buf_init(&tbuf, nanioc->data,
+		BCM_XTLV_HDR_SIZE + sizeof(params), BCM_XTLV_OPTION_ALIGN32);
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan cancel_subscribe 10
+	 *
+	 * wpa_cli: DRIVER NAN_CANCEL_SUBSCRIBE PUB_ID=10
+	 */
+
+	bcm_xtlv_put_data(&tbuf, WL_NAN_XTLV_INSTANCE_ID, &cmd_data->sub_id,
+		sizeof(wl_nan_instance_id_t));
+
+	/* nan cancel subscribe */
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_CANCEL_SUBSCRIBE);
+	nanioc->len = htod16(bcm_xtlv_buf_len(&tbuf));
+	nanioc_size = sizeof(wl_nan_ioc_t) + bcm_xtlv_buf_len(&tbuf);
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan cancel subscribe failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan cancel subscribe successful \n"));
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_transmit_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	uint8 *pxtlv;
+	s32 ret = BCME_OK;
+	u16 start, end;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+	uchar *buf = NULL;
+
+	/*
+	 * proceed only if mandatory arguments are present - subscriber id,
+	 * publisher id, mac address
+	 */
+	if ((!cmd_data->local_id) || (!cmd_data->remote_id) ||
+		ETHER_ISNULLADDR(&cmd_data->mac_addr.octet)) {
+		WL_ERR((" mandatory arguments are not present \n"));
+		return -EINVAL;
+	}
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan trasnmit <sub_id> <pub_id> <mac_addr> -info <hex_string>
+	 *
+	 * wpa_cli: DRIVER NAN_TRANSMIT SUB_ID=<sub_id> PUB_ID=<pub_id>
+	 *          MAC_ADDR=<mac_addr> SVC_INFO=<hex_string>
+	 */
+
+	/* nan transmit */
+	start = end = NAN_IOCTL_BUF_SIZE;
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_TRANSMIT);
+	pxtlv = nanioc->data;
+
+	ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_INSTANCE_ID,
+		sizeof(cmd_data->local_id), &cmd_data->local_id,
+		BCM_XTLV_OPTION_ALIGN32);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+	ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_REQUESTOR_ID,
+		sizeof(cmd_data->remote_id), &cmd_data->remote_id,
+		BCM_XTLV_OPTION_ALIGN32);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+	ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_MAC_ADDR,
+		ETHER_ADDR_LEN, &cmd_data->mac_addr.octet,
+		BCM_XTLV_OPTION_ALIGN32);
+	if (unlikely(ret)) {
+		goto fail;
+	}
+	if (cmd_data->svc_info.data && cmd_data->svc_info.dlen) {
+		uint16 len = cmd_data->svc_info.dlen/2;
+
+		WL_DBG((" optional svc_info present, pack it \n"));
+		buf = kzalloc(len, kflags);
+		if (!buf) {
+			WL_ERR((" memory allocation failed \n"));
+			ret = -ENOMEM;
+			goto fail;
+		}
+		if (get_ie_data((uchar*)cmd_data->svc_info.data, buf, len)) {
+			goto fail;
+		}
+
+		ret = bcm_pack_xtlv_entry(&pxtlv,
+			&end, WL_NAN_XTLV_SVC_INFO, len, buf,
+			BCM_XTLV_OPTION_ALIGN32);
+		if (unlikely(ret)) {
+			goto fail;
+		}
+	}
+
+	nanioc->len = start - end;
+	nanioc_size = sizeof(wl_nan_ioc_t) + nanioc->len;
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan transmit failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan transmit successful \n"));
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+	if (buf) {
+		kfree(buf);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_set_config_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ioc_t *nanioc = NULL;
+	uint8 *pxtlv;
+	s32 ret = BCME_OK;
+	u16 start, end;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	uint16 nanioc_size = sizeof(wl_nan_ioc_t) + NAN_IOCTL_BUF_SIZE;
+
+	if (cfg->nan_running == true) {
+		WL_ERR((" Stop nan (NAN_STOP) before issuing NAN_CONFIG command\n"));
+		return BCME_ERROR;
+	}
+
+	if (cfg->nan_enable != true) {
+		ret = wl_cfgnan_enable_handler(ndev, cfg, cmd, cmd_data);
+		if (unlikely(ret)) {
+			goto fail;
+		}
+	}
+
+	nanioc = kzalloc(nanioc_size, kflags);
+	if (!nanioc) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl nan <attr> <value> (wl nan role 1)
+	 *
+	 * wpa_cli: DRIVER NAN_CONFIG_SET ATTR=<attr> <value>...<value>
+	 *
+	 * wpa_cli: DRIVER NAN_SET_CONFIG ATTR=ATTR_ROLE ROLE=1
+	 */
+
+	/* nan set config */
+	start = end = NAN_IOCTL_BUF_SIZE;
+	nanioc->version = htod16(WL_NAN_IOCTL_VERSION);
+	nanioc->id = htod16(WL_NAN_CMD_ATTR);
+	pxtlv = nanioc->data;
+
+	switch (cmd_data->attr.type) {
+	case WL_NAN_XTLV_ROLE:
+		WL_DBG((" set nan ROLE = %#x\n", cmd_data->role));
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_ROLE,
+			sizeof(cmd_data->role), &cmd_data->role,
+			BCM_XTLV_OPTION_ALIGN32);
+		break;
+	case WL_NAN_XTLV_MASTER_PREF:
+		WL_DBG((" set nan MASTER PREF = %#x\n", cmd_data->master_pref));
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_MASTER_PREF,
+			sizeof(cmd_data->master_pref), &cmd_data->master_pref,
+			BCM_XTLV_OPTION_ALIGN32);
+		break;
+	case WL_NAN_XTLV_DW_LEN:
+		WL_DBG((" set nan DW LEN = %#x\n", cmd_data->dw_len));
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_DW_LEN,
+			sizeof(cmd_data->dw_len), &cmd_data->dw_len,
+			BCM_XTLV_OPTION_ALIGN32);
+		break;
+	case WL_NAN_XTLV_CLUSTER_ID:
+		WL_DBG((" set nan CLUSTER ID "));
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_CLUSTER_ID,
+			sizeof(cmd_data->clus_id), &cmd_data->clus_id,
+			BCM_XTLV_OPTION_ALIGN32);
+		break;
+	case WL_NAN_XTLV_IF_ADDR:
+		WL_DBG((" set nan IFADDR "));
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_IF_ADDR,
+			sizeof(cmd_data->if_addr), &cmd_data->if_addr,
+			BCM_XTLV_OPTION_ALIGN32);
+		break;
+	case WL_NAN_XTLV_MAC_CHANSPEC:
+		WL_DBG((" set nan CHANSPEC = %#x\n", cmd_data->chanspec));
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_MAC_CHANSPEC,
+			sizeof(cmd_data->chanspec), &cmd_data->chanspec,
+			BCM_XTLV_OPTION_ALIGN32);
+		break;
+	case WL_NAN_XTLV_BCN_INTERVAL:
+		WL_DBG((" set nan BCN_INTERVAL = %#x\n", cmd_data->beacon_int));
+		ret = bcm_pack_xtlv_entry(&pxtlv, &end, WL_NAN_XTLV_BCN_INTERVAL,
+			sizeof(cmd_data->beacon_int), &cmd_data->beacon_int,
+			BCM_XTLV_OPTION_ALIGN32);
+		break;
+	case WL_NAN_XTLV_MAC_TXRATE:
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	if (unlikely(ret)) {
+		WL_ERR((" unsupported attribute, attr = %s (%d) \n",
+			cmd_data->attr.name, cmd_data->attr.type));
+		goto fail;
+	}
+
+	nanioc->len = start - end;
+	nanioc_size = sizeof(wl_nan_ioc_t) + nanioc->len;
+	ret = wldev_iovar_setbuf(ndev, "nan", nanioc, nanioc_size,
+		cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan set config failed, error = %d \n", ret));
+		goto fail;
+	} else {
+		WL_DBG((" nan set config successful \n"));
+	}
+
+fail:
+	if (nanioc) {
+		kfree(nanioc);
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_rtt_config_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	wl_nan_ranging_config_t rtt_config;
+	s32 ret = BCME_OK;
+
+	/* proceed only if mandatory argument is present - channel */
+	if (!cmd_data->chanspec) {
+		WL_ERR((" mandatory argument is not present \n"));
+		return -EINVAL;
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl proxd_nancfg 44/80 128 32 ff:ff:ff:ff:ff:ff 1
+	 *
+	 * wpa_cli: DRIVER NAN_RTT_CONFIG CHAN=44/80
+	 */
+
+	memset(&rtt_config, 0, sizeof(rtt_config));
+	rtt_config.chanspec = cmd_data->chanspec;
+	rtt_config.timeslot = 128;
+	rtt_config.duration = 32;
+	memcpy(&rtt_config.allow_mac, &ether_bcast, ETHER_ADDR_LEN);
+	rtt_config.flags = 1;
+
+	ret = wldev_iovar_setbuf(ndev, "proxd_nancfg", &rtt_config,
+		sizeof(wl_nan_ranging_config_t), cfg->ioctl_buf,
+		WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan rtt config failed, error = %d \n", ret));
+	} else {
+		WL_DBG((" nan rtt config successful \n"));
+	}
+
+	return ret;
+}
+
+int
+wl_cfgnan_rtt_find_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	void *iovbuf;
+	wl_nan_ranging_list_t *rtt_list;
+	s32 iovbuf_size = NAN_RTT_IOVAR_BUF_SIZE;
+	s32 ret = BCME_OK;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+	/*
+	 * proceed only if mandatory arguments are present - channel, bitmap,
+	 * mac address
+	 */
+	if ((!cmd_data->chanspec) || (!cmd_data->bmap) ||
+		ETHER_ISNULLADDR(&cmd_data->mac_addr.octet)) {
+		WL_ERR((" mandatory arguments are not present \n"));
+		return -EINVAL;
+	}
+
+	iovbuf = kzalloc(iovbuf_size, kflags);
+	if (!iovbuf) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+
+	/*
+	 * command to test
+	 *
+	 * wl: wl proxd_nanfind 1 44/80 <mac_addr> 0x300 5 6 1
+	 *
+	 * wpa_cli: DRIVER NAN_RTT_FIND MAC_ADDR=<mac_addr> CHAN=44/80 BMAP=0x300
+	 *
+	 */
+	rtt_list = (wl_nan_ranging_list_t *)iovbuf;
+	rtt_list->count = 1;
+	rtt_list->num_peers_done = 0;
+	rtt_list->num_dws = 1;
+	rtt_list->rp[0].chanspec = cmd_data->chanspec;
+	memcpy(&rtt_list->rp[0].ea, &cmd_data->mac_addr,
+		sizeof(struct ether_addr));
+	rtt_list->rp[0].abitmap = cmd_data->bmap;
+	rtt_list->rp[0].frmcnt = 5;
+	rtt_list->rp[0].retrycnt = 6;
+	rtt_list->rp[0].flags = 1;
+
+	iovbuf_size = sizeof(wl_nan_ranging_list_t) +
+		sizeof(wl_nan_ranging_peer_t);
+	ret = wldev_iovar_setbuf(ndev, "proxd_nanfind", iovbuf,
+		iovbuf_size, cfg->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(ret)) {
+		WL_ERR((" nan rtt find failed, error = %d \n", ret));
+	} else {
+		WL_DBG((" nan rtt find successful \n"));
+	}
+
+	if (iovbuf) {
+		kfree(iovbuf);
+	}
+
+	return ret;
+}
+
+#ifdef WL_NAN_DEBUG
+int
+wl_cfgnan_debug_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data)
+{
+	/*
+	 * command to test
+	 *
+	 * wpa_cli: DRIVER NAN_DEBUG DEBUG=1
+	 *
+	 */
+
+	g_nan_debug = cmd_data->debug_flag;
+
+	/* reconfigure nan events */
+	return wl_cfgnan_enable_events(ndev, cfg);
+}
+#endif /* WL_NAN_DEBUG */
+
+static int wl_cfgnan_config_attr(char *buf, nan_config_attr_t *attr)
+{
+	s32 ret = BCME_OK;
+	nan_config_attr_t *nanc = NULL;
+
+	/* only one attribute at a time */
+	for (nanc = &nan_config_attrs[0]; strlen(nanc->name) != 0; nanc++) {
+		if (!strncmp(nanc->name, buf, strlen(nanc->name))) {
+			strncpy((char *)attr->name, buf, strlen(nanc->name));
+			attr->type = nanc->type;
+			ret = strlen(nanc->name);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int wl_cfgnan_parse_args(char *buf, nan_cmd_data_t *cmd_data)
+{
+	s32 ret = BCME_OK;
+	char *token = buf;
+	char delim[] = " ";
+
+	while ((buf != NULL) && (token != NULL)) {
+		if (!strncmp(buf, PUB_ID_PREFIX, strlen(PUB_ID_PREFIX))) {
+			buf += strlen(PUB_ID_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->pub_id = simple_strtoul(token, NULL, 10);
+			cmd_data->local_id ? (cmd_data->remote_id = cmd_data->pub_id) :
+				(cmd_data->local_id = cmd_data->pub_id);
+			if (NAN_INVALID_ID(cmd_data->pub_id)) {
+				WL_ERR((" invalid publisher id, pub_id = %d \n",
+					cmd_data->pub_id));
+				ret = -EINVAL;
+				goto fail;
+			}
+#ifdef NAN_P2P_CONFIG
+		} else if (!strncmp(buf, P2P_IE_PREFIX, strlen(P2P_IE_PREFIX))) {
+			buf += strlen(P2P_IE_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->p2p_info.data = token;
+			cmd_data->p2p_info.dlen = strlen(token);
+		} else if (!strncmp(buf, IE_EN_PREFIX, strlen(IE_EN_PREFIX))) {
+			buf += strlen(IE_EN_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->p2p_info.data = token;
+			cmd_data->p2p_info.dlen = strlen(token);
+#endif /* NAN_P2P_CONFIG */
+		} else if (!strncmp(buf, SUB_ID_PREFIX, strlen(SUB_ID_PREFIX))) {
+			buf += strlen(SUB_ID_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->sub_id = simple_strtoul(token, NULL, 10);
+			cmd_data->local_id ? (cmd_data->remote_id = cmd_data->sub_id) :
+				(cmd_data->local_id = cmd_data->sub_id);
+			if (NAN_INVALID_ID(cmd_data->sub_id)) {
+				WL_ERR((" invalid subscriber id, sub_id = %d \n",
+					cmd_data->sub_id));
+				ret = -EINVAL;
+				goto fail;
+			}
+		} else if (!strncmp(buf, MAC_ADDR_PREFIX, strlen(MAC_ADDR_PREFIX))) {
+			buf += strlen(MAC_ADDR_PREFIX);
+			token = strsep(&buf, delim);
+			if (!wl_cfg80211_ether_atoe(token, &cmd_data->mac_addr)) {
+				WL_ERR((" invalid mac address, mac_addr = "MACDBG "\n",
+					MAC2STRDBG(cmd_data->mac_addr.octet)));
+				ret = -EINVAL;
+				goto fail;
+			}
+		} else if (!strncmp(buf, SVC_HASH_PREFIX, strlen(SVC_HASH_PREFIX))) {
+			buf += strlen(SVC_HASH_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->svc_hash.data = token;
+			cmd_data->svc_hash.dlen = WL_NAN_SVC_HASH_LEN;
+		} else if (!strncmp(buf, SVC_INFO_PREFIX, strlen(SVC_INFO_PREFIX))) {
+			buf += strlen(SVC_INFO_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->svc_info.data = token;
+			cmd_data->svc_info.dlen = strlen(token);
+		} else if (!strncmp(buf, CHAN_PREFIX, strlen(CHAN_PREFIX))) {
+			buf += strlen(CHAN_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->chanspec = wf_chspec_aton(token);
+			cmd_data->chanspec = wl_chspec_host_to_driver(cmd_data->chanspec);
+			if (NAN_INVALID_CHANSPEC(cmd_data->chanspec)) {
+				WL_ERR((" invalid chanspec, chanspec = 0x%04x \n",
+					cmd_data->chanspec));
+				ret = -EINVAL;
+				goto fail;
+			}
+		} else if (!strncmp(buf, BITMAP_PREFIX, strlen(BITMAP_PREFIX))) {
+			buf += strlen(BITMAP_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->bmap = simple_strtoul(token, NULL, 16);
+		} else if (!strncmp(buf, ATTR_PREFIX, strlen(ATTR_PREFIX))) {
+			buf += strlen(ATTR_PREFIX);
+			token = strsep(&buf, delim);
+			if (!wl_cfgnan_config_attr(token, &cmd_data->attr)) {
+				WL_ERR((" invalid attribute, attr = %s \n",
+					cmd_data->attr.name));
+				ret = -EINVAL;
+				goto fail;
+			}
+		} else if (!strncmp(buf, ROLE_PREFIX, strlen(ROLE_PREFIX))) {
+			buf += strlen(ROLE_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->role = simple_strtoul(token, NULL, 10);
+			if (NAN_INVALID_ROLE(cmd_data->role)) {
+				WL_ERR((" invalid role, role = %d \n", cmd_data->role));
+				ret = -EINVAL;
+				goto fail;
+			}
+		} else if (!strncmp(buf, MASTER_PREF_PREFIX,
+			strlen(MASTER_PREF_PREFIX))) {
+			buf += strlen(MASTER_PREF_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->master_pref = simple_strtoul(token, NULL, 10);
+		} else if (!strncmp(buf, CLUS_ID_PREFIX, strlen(CLUS_ID_PREFIX))) {
+			buf += strlen(CLUS_ID_PREFIX);
+			token = strsep(&buf, delim);
+			if (!wl_cfg80211_ether_atoe(token, &cmd_data->clus_id)) {
+				WL_ERR((" invalid cluster id, CLUS_ID = "MACDBG "\n",
+					MAC2STRDBG(cmd_data->clus_id.octet)));
+				ret = -EINVAL;
+				goto fail;
+			}
+		} else if (!strncmp(buf, IF_ADDR_PREFIX, strlen(IF_ADDR_PREFIX))) {
+			buf += strlen(IF_ADDR_PREFIX);
+			token = strsep(&buf, delim);
+			if (!wl_cfg80211_ether_atoe(token, &cmd_data->if_addr)) {
+				WL_ERR((" invalid cluster id, IF_ADDR = "MACDBG "\n",
+					MAC2STRDBG(cmd_data->if_addr.octet)));
+				ret = -EINVAL;
+				goto fail;
+			}
+		} else if (!strncmp(buf, BCN_INTERVAL_PREFIX,
+			strlen(BCN_INTERVAL_PREFIX))) {
+			buf += strlen(BCN_INTERVAL_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->beacon_int = simple_strtoul(token, NULL, 10);
+		} else if (!strncmp(buf, PUB_PR_PREFIX, strlen(PUB_PR_PREFIX))) {
+			buf += strlen(PUB_PR_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->pub_pr = simple_strtoul(token, NULL, 10);
+		} else if (!strncmp(buf, PUB_INT_PREFIX, strlen(PUB_INT_PREFIX))) {
+			buf += strlen(PUB_INT_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->pub_int = simple_strtoul(token, NULL, 10);
+		} else if (!strncmp(buf, DW_LEN_PREFIX, strlen(DW_LEN_PREFIX))) {
+			buf += strlen(DW_LEN_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->dw_len = simple_strtoul(token, NULL, 10);
+		} else if (!strncmp(buf, DEBUG_PREFIX, strlen(DEBUG_PREFIX))) {
+			buf += strlen(DEBUG_PREFIX);
+			token = strsep(&buf, delim);
+			cmd_data->debug_flag = simple_strtoul(token, NULL, 10);
+		} else if (!strncmp(buf, ACTIVE_OPTION, strlen(ACTIVE_OPTION))) {
+			buf += strlen(ACTIVE_OPTION);
+			token = strsep(&buf, delim);
+			cmd_data->flags |= WL_NAN_SUB_ACTIVE;
+		} else if (!strncmp(buf, SOLICITED_OPTION, strlen(SOLICITED_OPTION))) {
+			buf += strlen(SOLICITED_OPTION);
+			token = strsep(&buf, delim);
+			cmd_data->flags |= WL_NAN_PUB_SOLICIT;
+		} else if (!strncmp(buf, UNSOLICITED_OPTION, strlen(UNSOLICITED_OPTION))) {
+			buf += strlen(UNSOLICITED_OPTION);
+			token = strsep(&buf, delim);
+			cmd_data->flags |= WL_NAN_PUB_UNSOLICIT;
+		} else {
+			WL_ERR((" unknown token, token = %s, buf = %s \n", token, buf));
+			ret = -EINVAL;
+			goto fail;
+		}
+	}
+
+fail:
+	return ret;
+}
+
+int
+wl_cfgnan_cmd_handler(struct net_device *ndev, struct bcm_cfg80211 *cfg,
+	char *cmd, int cmd_len)
+{
+	nan_cmd_data_t cmd_data;
+	u8 *buf = cmd;
+	u8 *cmd_name = NULL;
+	nan_cmd_t *nanc = NULL;
+	int buf_len = 0;
+	int ret = BCME_OK;
+
+	cmd_name = strsep((char **)&buf, " ");
+	if (buf) {
+		buf_len = strlen(buf);
+	}
+
+	WL_DBG((" cmd_name: %s, buf_len: %d, buf: %s \n", cmd_name, buf_len, buf));
+
+	memset(&cmd_data, 0, sizeof(cmd_data));
+	ret = wl_cfgnan_parse_args(buf, &cmd_data);
+	if (unlikely(ret)) {
+		WL_ERR((" argument parsing failed with error (%d), buf = %s \n",
+			ret, buf));
+		goto fail;
+	}
+
+	for (nanc = nan_cmds; nanc->name; nanc++) {
+		if (strncmp(nanc->name, cmd_name, strlen(nanc->name)) == 0) {
+			ret = (*nanc->func)(ndev, cfg, cmd, cmd_len, &cmd_data);
+			if (ret < BCME_OK) {
+				WL_ERR((" command (%s) failed with error (%d) \n",
+					cmd_name, ret));
+			}
+		}
+	}
+
+fail:
+	return ret;
+}
+
+s32
+wl_cfgnan_notify_proxd_status(struct bcm_cfg80211 *cfg,
+	bcm_struct_cfgdev *cfgdev, const wl_event_msg_t *event, void *data)
+{
+	s32 ret = BCME_OK;
+	wl_nan_ranging_event_data_t *rdata;
+	s32 status;
+	u16 data_len;
+	s32 event_type;
+	s32 event_num;
+	u8 *buf = NULL;
+	u32 buf_len;
+	u8 *ptr, *end;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	s32 i;
+
+	if (!event || !data) {
+		WL_ERR((" event data is NULL \n"));
+		return -EINVAL;
+	}
+
+	status = ntoh32(event->reason);
+	event_type = ntoh32(event->event_type);
+	event_num = ntoh32(event->reason);
+	data_len = ntoh32(event->datalen);
+
+	WL_DBG((" proxd event: type: %d num: %d len: %d \n",
+		event_type, event_num, data_len));
+
+	if (NAN_INVALID_PROXD_EVENT(event_num)) {
+		WL_ERR((" unsupported event, num: %d \n", event_num));
+		return -EINVAL;
+	}
+
+#ifdef WL_NAN_DEBUG
+	if (g_nan_debug) {
+		WL_DBG((" event name: WLC_E_PROXD_NAN_EVENT \n"));
+		WL_DBG((" event data: \n"));
+		prhex(NULL, data, data_len);
+	}
+#endif /* WL_NAN_DEBUG */
+
+	if (data_len < sizeof(wl_nan_ranging_event_data_t)) {
+		WL_ERR((" wrong data len \n"));
+		return -EINVAL;
+	}
+
+	rdata = (wl_nan_ranging_event_data_t *)data;
+
+	WL_DBG((" proxd event: count:%d success_count:%d mode:%d \n",
+		rdata->count, rdata->success_count, rdata->mode));
+
+#ifdef WL_NAN_DEBUG
+	if (g_nan_debug) {
+		prhex(" event data: ", data, data_len);
+	}
+#endif /* WL_NAN_DEBUG */
+
+	buf_len = NAN_IOCTL_BUF_SIZE;
+	buf = kzalloc(buf_len, kflags);
+	if (!buf) {
+		WL_ERR((" memory allocation failed \n"));
+		return -ENOMEM;
+	}
+	end = buf + buf_len;
+
+	for (i = 0; i < rdata->count; i++) {
+		if (&rdata->rr[i] == NULL) {
+			ret = -EINVAL;
+			goto fail;
+		}
+
+		ptr = buf;
+		WL_DBG((" ranging data for mac:"MACDBG" \n",
+			MAC2STRDBG(rdata->rr[i].ea.octet)));
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " MAC_ADDR_PREFIX MACF
+			" "STATUS_PREFIX"%s", EVENT_RTT_STATUS_STR,
+			ETHER_TO_MACF(rdata->rr[i].ea), (rdata->rr[i].status == 1) ?
+			"success" : "fail");
+
+		if (rdata->rr[i].status == 1) {
+			/* add tsf and distance only if status is success */
+			ptr += snprintf(ptr, end-ptr, " "TIMESTAMP_PREFIX"0x%x "
+				DISTANCE_PREFIX"%d.%04d", rdata->rr[i].timestamp,
+				rdata->rr[i].distance >> 4,
+				((rdata->rr[i].distance & 0x0f) * 625));
+		}
+		if (ptr > end) {
+			WL_ERR(("Buffer overflow. userspace string truncated: %s, len: %zu\n",
+				buf, strlen(buf)));
+		}
+
+	}
+
+fail:
+	if (buf) {
+		kfree(buf);
+	}
+
+	return ret;
+}
+
+s32
+wl_cfgnan_notify_nan_status(struct bcm_cfg80211 *cfg,
+	bcm_struct_cfgdev *cfgdev, const wl_event_msg_t *event, void *data)
+{
+	s32 ret = BCME_OK;
+	u16 data_len;
+	u32 event_num;
+	s32 event_type;
+	nan_event_hdr_t nan_hdr;
+	wl_nan_tlv_data_t tlv_data;
+	u8 *buf = NULL;
+	u32 buf_len;
+	u8 *ptr, *end;
+	u16 kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+	if (!event || !data) {
+		WL_ERR((" event data is NULL \n"));
+		return -EINVAL;
+	}
+
+	event_type = ntoh32(event->event_type);
+	event_num = ntoh32(event->reason);
+	data_len = ntoh32(event->datalen);
+	memset(&nan_hdr, 0, sizeof(nan_event_hdr_t));
+	nan_hdr.event_subtype = event_num;
+
+	WL_DBG((" nan event: type: %d num: %d len: %d \n",
+		event_type, event_num, data_len));
+
+	if (NAN_INVALID_EVENT(event_num)) {
+		WL_ERR((" unsupported event, num: %d \n", event_num));
+		return -EINVAL;
+	}
+
+#ifdef WL_NAN_DEBUG
+	if (g_nan_debug) {
+		print_event_name(event_num);
+		WL_DBG((" event data: \n"));
+		prhex(NULL, data, data_len);
+	}
+#endif /* WL_NAN_DEBUG */
+
+	/* unpack the tlvs */
+	memset(&tlv_data, 0, sizeof(wl_nan_tlv_data_t));
+	bcm_unpack_xtlv_buf(&tlv_data, data, data_len,
+		BCM_XTLV_OPTION_ALIGN32, wl_cfgnan_set_vars_cbfn);
+
+	/*
+	 * send as preformatted hex string
+	 *
+	 * EVENT_NAN <event_type> <tlv_hex_string>
+	 */
+
+	buf_len = NAN_IOCTL_BUF_SIZE;
+	buf = ptr = kzalloc(buf_len, kflags);
+	if (!buf) {
+		WL_ERR((" memory allocation failed \n"));
+		ret = -ENOMEM;
+		goto fail;
+	}
+	end = buf + buf_len;
+
+	switch (event_num) {
+	case WL_NAN_EVENT_START:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " CLUS_ID_PREFIX MACF,
+			NAN_EVENT_STR_STARTED, ETHER_TO_MACF(tlv_data.nstatus.cid));
+		break;
+	case WL_NAN_EVENT_JOIN:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " CLUS_ID_PREFIX MACF,
+			NAN_EVENT_STR_JOINED, ETHER_TO_MACF(tlv_data.nstatus.cid));
+		break;
+	case WL_NAN_EVENT_STOP:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " CLUS_ID_PREFIX MACF,
+			NAN_EVENT_STR_STOPPED, ETHER_TO_MACF(tlv_data.nstatus.cid));
+		break;
+	case WL_NAN_EVENT_ROLE:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s "ROLE_PREFIX "%d "
+			CLUS_ID_PREFIX MACF, NAN_EVENT_STR_ROLE_CHANGE,
+			tlv_data.nstatus.role, ETHER_TO_MACF(tlv_data.nstatus.cid));
+		break;
+	case WL_NAN_EVENT_DISCOVERY_RESULT:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " PUB_ID_PREFIX"%d "
+			SUB_ID_PREFIX"%d " MAC_ADDR_PREFIX MACF,
+			NAN_EVENT_STR_SDF_RX, tlv_data.pub_id, tlv_data.sub_id,
+			ETHER_TO_MACF(tlv_data.mac_addr));
+		if (tlv_data.svc_info.data && tlv_data.svc_info.dlen) {
+			WL_DBG((" service info present \n"));
+			if ((strlen(ptr) + tlv_data.svc_info.dlen) >= buf_len) {
+				WL_ERR((" service info length = %d\n",
+					tlv_data.svc_info.dlen));
+				WL_ERR((" insufficent buffer to copy service info \n"));
+				ret = -EOVERFLOW;
+				goto fail;
+			}
+			ptr += snprintf(ptr, end-ptr, " %s", SVC_INFO_PREFIX);
+			ptr += bcm_format_hex(ptr, tlv_data.svc_info.data,
+				tlv_data.svc_info.dlen);
+		} else {
+			WL_DBG((" service info not present \n"));
+		}
+
+		if (tlv_data.vend_info.data && tlv_data.vend_info.dlen) {
+			struct ether_addr *ea;
+			u8 *temp_data = tlv_data.vend_info.data;
+			uint32 bitmap;
+			u16 dlen = tlv_data.vend_info.dlen;
+			chanspec_t chanspec;
+			uint8 mapcontrol;
+			uint8 proto;
+
+			WL_DBG((" vendor info present \n"));
+			if ((*temp_data != NAN_ATTR_VENDOR_SPECIFIC) ||
+				(dlen < NAN_VENDOR_HDR_SIZE)) {
+				WL_ERR((" error in vendor info attribute \n"));
+				ret = -EINVAL;
+				goto fail;
+			} else {
+				WL_DBG((" vendor info not present \n"));
+			}
+
+			if (*(temp_data + 6) == NAN_VENDOR_TYPE_RTT) {
+				temp_data += NAN_VENDOR_HDR_SIZE;
+				ea = (struct ether_addr *)temp_data;
+				temp_data += ETHER_ADDR_LEN;
+				mapcontrol = *temp_data++;
+				proto = *temp_data++;
+				bitmap = *(uint32 *)temp_data;
+				temp_data += 4;
+				chanspec = *(chanspec_t *)temp_data;
+				ptr += snprintf(ptr, end-ptr,
+					" "BITMAP_PREFIX"0x%x "CHAN_PREFIX"%d/%s",
+					bitmap, wf_chspec_ctlchan(chanspec),
+					wf_chspec_to_bw_str(chanspec));
+				WL_DBG((" bitmap: 0x%x channel: %d bandwidth: %s \n", bitmap,
+					wf_chspec_ctlchan(chanspec),
+					wf_chspec_to_bw_str(chanspec)));
+			}
+		}
+		break;
+	case WL_NAN_EVENT_REPLIED:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " PUB_ID_PREFIX"%d "
+				MAC_ADDR_PREFIX MACF, NAN_EVENT_STR_REPLIED,
+				tlv_data.pub_id, ETHER_TO_MACF(tlv_data.mac_addr));
+		break;
+	case WL_NAN_EVENT_TERMINATED:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " PUB_ID_PREFIX"%d ",
+			NAN_EVENT_STR_TERMINATED, tlv_data.pub_id);
+		break;
+	case WL_NAN_EVENT_RECEIVE:
+		ptr += snprintf(ptr, end-ptr,
+			SUPP_EVENT_PREFIX"%s " INSTANCE_ID_PREFIX"%d "
+			REMOTE_INSTANCE_ID_PREFIX"%d " MAC_ADDR_PREFIX MACF,
+			NAN_EVENT_STR_FOLLOWUP_RX, tlv_data.inst_id,
+			tlv_data.peer_inst_id, ETHER_TO_MACF(tlv_data.mac_addr));
+		if (tlv_data.svc_info.data && tlv_data.svc_info.dlen) {
+			WL_DBG((" service info present \n"));
+			if ((strlen(ptr) + tlv_data.svc_info.dlen) >= buf_len) {
+				WL_ERR((" service info length = %d\n",
+					tlv_data.svc_info.dlen));
+				WL_ERR((" insufficent buffer to copy service info \n"));
+				ret = -EOVERFLOW;
+				goto fail;
+			}
+			ptr += snprintf(ptr, end-ptr, " %s", SVC_INFO_PREFIX);
+			ptr += bcm_format_hex(ptr, tlv_data.svc_info.data,
+				tlv_data.svc_info.dlen);
+		} else {
+			WL_DBG((" service info not present \n"));
+		}
+		break;
+	case WL_NAN_EVENT_SCAN_COMPLETE:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " CLUS_ID_PREFIX MACF,
+			NAN_EVENT_STR_SCAN_COMPLETE, ETHER_TO_MACF(tlv_data.nstatus.cid));
+		break;
+	case WL_NAN_EVENT_STATUS_CHG:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " CLUS_ID_PREFIX MACF,
+			NAN_EVENT_STR_STATUS_CHANGE, ETHER_TO_MACF(tlv_data.nstatus.cid));
+		break;
+	case WL_NAN_EVENT_MERGE:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s " CLUS_ID_PREFIX MACF,
+			NAN_EVENT_STR_MERGED, ETHER_TO_MACF(tlv_data.nstatus.cid));
+		break;
+#ifdef NAN_P2P_CONFIG
+	case WL_NAN_EVENT_P2P:
+		ptr += snprintf(ptr, end-ptr, SUPP_EVENT_PREFIX"%s "
+				MAC_ADDR_PREFIX MACF, NAN_EVENT_STR_P2P_RX,
+				ETHER_TO_MACF(tlv_data.mac_addr));
+		if (tlv_data.vend_info.data && tlv_data.vend_info.dlen) {
+			u8 *data = tlv_data.vend_info.data;
+			u16 dlen = tlv_data.vend_info.dlen;
+
+			WL_DBG((" vendor info present %d  dlen  = %d\n",
+				*(data + 6), (dlen - (NAN_VENDOR_HDR_SIZE+1))));
+			if ((*data != NAN_ATTR_VENDOR_SPECIFIC) ||
+				(dlen < NAN_VENDOR_HDR_SIZE)) {
+				WL_ERR((" error in vendor info attribute \n"));
+				ret = -EINVAL;
+				goto fail;
+			} else {
+				WL_DBG((" vendor info present \n"));
+			}
+
+			if (*(data + 6) == NAN_VENDOR_TYPE_P2P) {
+				data += NAN_VENDOR_HDR_SIZE;
+				ptr += snprintf(ptr, end-ptr, " %s", P2P_IE_PREFIX);
+				ptr += bcm_format_hex(ptr, data, (dlen - (NAN_VENDOR_HDR_SIZE)));
+			}
+		}
+		break;
+#endif /* NAN_P2P_CONFIG */
+	default:
+		WL_ERR((" unknown event \n"));
+		break;
+	}
+	if (ptr > end) {
+		WL_ERR(("Buffer overflow. userspace string truncated: %s, len: %zu\n",
+			buf, strlen(buf)));
+	}
+
+
+fail:
+	if (buf) {
+		kfree(buf);
+	}
+	if (tlv_data.svc_info.data) {
+		kfree(tlv_data.svc_info.data);
+		tlv_data.svc_info.data = NULL;
+		tlv_data.svc_info.dlen = 0;
+	}
+	if (tlv_data.vend_info.data) {
+		kfree(tlv_data.vend_info.data);
+		tlv_data.vend_info.data = NULL;
+		tlv_data.vend_info.dlen = 0;
+	}
+
+	return ret;
+}
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.h
new file mode 100644
index 000000000000..22833bf62655
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgnan.h
@@ -0,0 +1,227 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Neighbor Awareness Networking
+ *
+ * Copyright (C) 1999-2019, Broadcom Corporation
+ * 
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ * 
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ * 
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * $Id: wl_cfgnan.h 559906 2015-05-29 02:42:35Z $
+ */
+
+#ifndef _wl_cfgnan_h_
+#define _wl_cfgnan_h_
+
+#define NAN_IOCTL_BUF_SIZE			512
+#define NAN_EVENT_NAME_MAX_LEN		40
+#define NAN_CONFIG_ATTR_MAX_LEN		24
+#define NAN_RTT_IOVAR_BUF_SIZE		1024
+#define WL_NAN_EVENT_CLEAR_BIT		32
+#define NAN_EVENT_MASK_ALL			0x7fffffff
+
+#define NAN_INVALID_ID(id)	(id > 255)
+#define NAN_INVALID_ROLE(role)	(role > WL_NAN_ROLE_ANCHOR_MASTER)
+#define NAN_INVALID_CHANSPEC(chanspec)	((chanspec == INVCHANSPEC) || \
+	(chanspec == 0))
+#define NAN_INVALID_EVENT(num)	((num < WL_NAN_EVENT_START) || \
+	(num >= WL_NAN_EVENT_INVALID))
+#define NAN_INVALID_PROXD_EVENT(num)	(num != WLC_E_PROXD_NAN_EVENT)
+#define NAN_EVENT_BIT(event) (1U << (event - WL_NAN_EVENT_START))
+#define NAME_TO_STR(name) #name
+
+#define SUPP_EVENT_PREFIX		"CTRL-EVENT-"
+#define EVENT_RTT_STATUS_STR	"NAN-RTT-STATUS"
+
+#define TIMESTAMP_PREFIX	"TSF="			/* timestamp */
+#define AMR_PREFIX			"AMR="			/* anchor master rank */
+#define DISTANCE_PREFIX		"DIST="			/* distance */
+#define ATTR_PREFIX			"ATTR="			/* attribute */
+#define ROLE_PREFIX			"ROLE="			/* role */
+#define CHAN_PREFIX			"CHAN="			/* channel */
+#define BITMAP_PREFIX		"BMAP="			/* bitmap */
+#define DEBUG_PREFIX		"DEBUG="		/* debug enable/disable flag */
+#define DW_LEN_PREFIX		"DW_LEN="		/* discovery window length */
+#define DW_INT_PREFIX		"DW_INT="		/* discovery window interval */
+#define STATUS_PREFIX		"STATUS="		/* status */
+#define PUB_ID_PREFIX		"PUB_ID="		/* publisher id */
+#define SUB_ID_PREFIX		"SUB_ID="		/* subscriber id */
+#define INSTANCE_ID_PREFIX		"LOCAL_ID="		/* Instance id */
+#define REMOTE_INSTANCE_ID_PREFIX		"PEER_ID="		/* Peer id */
+
+#ifdef NAN_P2P_CONFIG
+#define P2P_IE_PREFIX		"P2P_IE="		/* p2p ie  id */
+#define IE_EN_PREFIX		"ENBLE_IE="		/* enable p2p ie  */
+#endif
+#define PUB_PR_PREFIX		"PUB_PR="		/* publish period */
+#define PUB_INT_PREFIX		"PUB_INT="		/* publish interval (ttl) */
+#define CLUS_ID_PREFIX		"CLUS_ID="		/* cluster id */
+#define IF_ADDR_PREFIX		"IF_ADDR="		/* IF address */
+#define MAC_ADDR_PREFIX		"MAC_ADDR="		/* mac address */
+#define SVC_HASH_PREFIX		"SVC_HASH="		/* service hash */
+#define SVC_INFO_PREFIX		"SVC_INFO="		/* service information */
+#define HOP_COUNT_PREFIX	"HOP_COUNT="	/* hop count */
+#define MASTER_PREF_PREFIX	"MASTER_PREF="	/* master preference */
+#define ACTIVE_OPTION		"ACTIVE"		/* Active Subscribe. */
+#define SOLICITED_OPTION	"SOLICITED"		/* Solicited Publish. */
+#define UNSOLICITED_OPTION	"UNSOLICITED"	/* Unsolicited Publish. */
+/* anchor master beacon transmission time */
+#define AMBTT_PREFIX		"AMBTT="
+/* passive scan period for cluster merge */
+#define SCAN_PERIOD_PREFIX	"SCAN_PERIOD="
+/* passive scan interval for cluster merge */
+#define SCAN_INTERVAL_PREFIX	"SCAN_INTERVAL="
+#define BCN_INTERVAL_PREFIX		"BCN_INTERVAL="
+
+#define NAN_EVENT_STR_STARTED               "NAN-STARTED"
+#define NAN_EVENT_STR_JOINED                "NAN-JOINED"
+#define NAN_EVENT_STR_ROLE_CHANGE           "NAN-ROLE-CHANGE"
+#define NAN_EVENT_STR_SCAN_COMPLETE         "NAN-SCAN-COMPLETE"
+#define NAN_EVENT_STR_SDF_RX                "NAN-SDF-RX"
+#define NAN_EVENT_STR_REPLIED               "NAN-REPLIED"
+#define NAN_EVENT_STR_TERMINATED            "NAN-TERMINATED"
+#define NAN_EVENT_STR_FOLLOWUP_RX           "NAN-FOLLOWUP-RX"
+#define NAN_EVENT_STR_STATUS_CHANGE         "NAN-STATUS-CHANGE"
+#define NAN_EVENT_STR_MERGED                "NAN-MERGED"
+#define NAN_EVENT_STR_STOPPED               "NAN-STOPPED"
+#define NAN_EVENT_STR_P2P_RX                "NAN-P2P-RX"
+#define NAN_EVENT_STR_WINDOW_BEGUN_P2P      "NAN-WINDOW-BEGUN-P2P"
+#define NAN_EVENT_STR_WINDOW_BEGUN_MESH     "NAN-WINDOW-BEGUN-MESH"
+#define NAN_EVENT_STR_WINDOW_BEGUN_IBSS     "NAN-WINDOW-BEGUN-IBSS"
+#define NAN_EVENT_STR_WINDOW_BEGUN_RANGING  "NAN-WINDOW-BEGUN-RANGING"
+#define NAN_EVENT_STR_INVALID               "NAN-INVALID"
+
+typedef struct nan_str_data {
+	u8 *data;
+	u32 dlen;
+} nan_str_data_t;
+
+typedef struct nan_config_attr {
+	char name[NAN_CONFIG_ATTR_MAX_LEN];	/* attribute name */
+	u16 type;							/* attribute xtlv type */
+} nan_config_attr_t;
+
+typedef struct nan_cmd_data {
+	nan_config_attr_t attr;			/* set config attributes */
+	nan_str_data_t svc_hash;		/* service hash */
+	nan_str_data_t svc_info;		/* service information */
+	nan_str_data_t p2p_info;		/* p2p information */
+	struct ether_addr mac_addr;		/* mac address */
+	struct ether_addr clus_id;		/* cluster id */
+	struct ether_addr if_addr;		/* if addr */
+	u32 beacon_int;					/* beacon interval */
+	u32 pub_int;					/* publish interval (ttl) */
+	u32 pub_pr;						/* publish period */
+	u32 bmap;						/* bitmap */
+	u32 role;						/* role */
+	u16 pub_id;						/* publisher id */
+	u16 sub_id;						/* subscriber id */
+	u16 local_id;					/* Local id */
+	u16 remote_id;					/* Remote id */
+	uint32 flags;					/* Flag bits */
+	u16 dw_len;						/* discovery window length */
+	u16 master_pref;				/* master preference */
+	chanspec_t chanspec;			/* channel */
+	u8 debug_flag;					/* debug enable/disable flag */
+} nan_cmd_data_t;
+
+typedef int (nan_func_t)(struct net_device *ndev, struct bcm_cfg80211 *cfg,
+	char *cmd, int size, nan_cmd_data_t *cmd_data);
+
+typedef struct nan_cmd {
+	const char *name;					/* command name */
+	nan_func_t *func;					/* command hadler */
+} nan_cmd_t;
+
+typedef struct nan_event_hdr {
+	u16 event_subtype;
+	u32 flags;							/* future use */
+} nan_event_hdr_t;
+
+typedef struct wl_nan_tlv_data {
+	wl_nan_status_t nstatus;			/* status data */
+	wl_nan_disc_params_t params;		/* discovery parameters */
+	struct ether_addr mac_addr;			/* peer mac address */
+	struct ether_addr clus_id;			/* cluster id */
+	nan_str_data_t svc_info;			/* service info */
+	nan_str_data_t vend_info;			/* vendor info */
+	/* anchor master beacon transmission time */
+	u32 ambtt;
+	u32 dev_role;						/* device role */
+	u16 inst_id;						/* instance id */
+	u16 peer_inst_id;					/* Peer instance id */
+	u16 pub_id;							/* publisher id */
+	u16 sub_id;							/* subscriber id */
+	u16 master_pref;					/* master preference */
+	chanspec_t chanspec;				/* channel */
+	u8 amr[NAN_MASTER_RANK_LEN];		/* anchor master role */
+	u8 svc_name[WL_NAN_SVC_HASH_LEN];	/* service name */
+	u8 hop_count;						/* hop count */
+	u8 enabled;							/* nan status flag */
+	nan_scan_params_t scan_params;		/* scan_param */
+} wl_nan_tlv_data_t;
+
+extern int wl_cfgnan_set_vars_cbfn(void *ctx, uint8 *tlv_buf,
+	uint16 type, uint16 len);
+extern int wl_cfgnan_enable_events(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg);
+extern int wl_cfgnan_start_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_stop_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_support_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_status_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_pub_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_p2p_ie_add_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_p2p_ie_enable_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_p2p_ie_del_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+
+extern int wl_cfgnan_sub_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_cancel_pub_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_cancel_sub_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_transmit_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_set_config_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_rtt_config_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+extern int wl_cfgnan_rtt_find_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+#ifdef WL_NAN_DEBUG
+extern int wl_cfgnan_debug_handler(struct net_device *ndev,
+	struct bcm_cfg80211 *cfg, char *cmd, int size, nan_cmd_data_t *cmd_data);
+#endif /* WL_NAN_DEBUG */
+extern int wl_cfgnan_cmd_handler(struct net_device *dev,
+	struct bcm_cfg80211 *cfg, char *cmd, int cmd_len);
+extern s32 wl_cfgnan_notify_nan_status(struct bcm_cfg80211 *cfg,
+	bcm_struct_cfgdev *cfgdev, const wl_event_msg_t *e, void *data);
+extern s32 wl_cfgnan_notify_proxd_status(struct bcm_cfg80211 *cfg,
+	bcm_struct_cfgdev *cfgdev, const wl_event_msg_t *e, void *data);
+
+#endif	/* _wl_cfgnan_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.c
index de987f9554a4..f55475f8774f 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfgp2p driver
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: wl_cfgp2p.c 598851 2015-11-11 06:48:53Z $
+ * $Id: wl_cfgp2p.c 709309 2019-01-17 09:04:00Z $
  *
  */
 #include <typedefs.h>
@@ -337,6 +338,9 @@ wl_cfgp2p_init_priv(struct bcm_cfg80211 *cfg)
 	wl_to_p2p_bss_bssidx(cfg, P2PAPI_BSSCFG_CONNECTION1) = -1;
 	wl_to_p2p_bss_ndev(cfg, P2PAPI_BSSCFG_CONNECTION2) = NULL;
 	wl_to_p2p_bss_bssidx(cfg, P2PAPI_BSSCFG_CONNECTION2) = -1;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
+	cfg->p2p->cfg = cfg;
+#endif
 	return BCME_OK;
 
 }
@@ -1347,12 +1351,19 @@ wl_cfgp2p_listen_complete(struct bcm_cfg80211 *cfg, bcm_struct_cfgdev *cfgdev,
  *  We can't report cfg80211_remain_on_channel_expired from Timer ISR context,
  *  so lets do it from thread context.
  */
+
 void
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 wl_cfgp2p_listen_expired(struct timer_list *t)
 {
-	wl_event_msg_t msg;
 	struct p2p_info *p2p = from_timer(p2p, t, listen_timer);
-	struct bcm_cfg80211 *cfg = container_of(&p2p, typeof(*cfg), p2p);
+	struct bcm_cfg80211 *cfg = p2p->cfg;
+#else
+wl_cfgp2p_listen_expired(unsigned long data)
+{
+	struct bcm_cfg80211 *cfg = (struct bcm_cfg80211 *) data;
+#endif
+	wl_event_msg_t msg;
 	CFGP2P_DBG((" Enter\n"));
 	bzero(&msg, sizeof(wl_event_msg_t));
 	msg.event_type =  hton32(WLC_E_P2P_DISC_LISTEN_COMPLETE);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.h
index 429c3e653961..ffc46f16efb4 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgp2p.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfgp2p driver
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: wl_cfgp2p.h 594074 2015-10-20 11:48:33Z $
+ * $Id: wl_cfgp2p.h 709309 2019-01-17 09:04:00Z $
  */
 #ifndef _wl_cfgp2p_h_
 #define _wl_cfgp2p_h_
@@ -82,6 +83,7 @@ struct p2p_info {
 	wl_p2p_ops_t ops;
 	wlc_ssid_t ssid;
 	s8 p2p_go_count;
+	struct bcm_cfg80211 *cfg;
 };
 
 #define MAX_VNDR_IE_NUMBER	5
@@ -167,12 +169,23 @@ enum wl_cfgp2p_status {
 			printk args;							\
 		}									\
 	} while (0)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 #define INIT_TIMER(timer, func, duration, extra_delay)	\
 	do {				   \
 		timer_setup(timer, func, 0); \
 		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
 		add_timer(timer); \
 	} while (0);
+#else
+#define INIT_TIMER(timer, func, duration, extra_delay)	\
+	do {				   \
+		init_timer(timer); \
+		timer->function = func; \
+		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
+		timer->data = (unsigned long) cfg; \
+		add_timer(timer); \
+	} while (0);
+#endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)) && !defined(WL_CFG80211_P2P_DEV_IF)
 #define WL_CFG80211_P2P_DEV_IF
@@ -215,7 +228,11 @@ enum wl_cfgp2p_status {
 #define P2P_ECSA_CNT 50
 
 extern void
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 wl_cfgp2p_listen_expired(struct timer_list *t);
+#else
+wl_cfgp2p_listen_expired(unsigned long data);
+#endif
 extern bool
 wl_cfgp2p_is_pub_action(void *frame, u32 frame_len);
 extern bool
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgvendor.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgvendor.c
index 30d73cdee16f..aff5eb25609a 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgvendor.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgvendor.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 Vendor Extension Code
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -89,6 +90,35 @@
  * do_it handler context (instead wl_cfgvendor_send_cmd_reply should
  * be used).
  */
+static int
+wl_cfgvendor_set_country(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void *data, int len)
+{
+	int err = BCME_ERROR, rem, type;
+	char country_code[WLC_CNTRY_BUF_SZ] = {0};
+	const struct nlattr *iter;
+
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+			case ANDR_WIFI_ATTRIBUTE_COUNTRY:
+				memcpy(country_code, nla_data(iter),
+					MIN(nla_len(iter), WLC_CNTRY_BUF_SZ));
+				break;
+			default:
+				WL_ERR(("Unknown type: %d\n", type));
+				return err;
+		}
+	}
+
+	err = wldev_set_country(wdev->netdev, country_code, true, true, -1);
+	if (err < 0) {
+		WL_ERR(("Set country failed ret:%d\n", err));
+	}
+
+	return err;
+}
+
 int wl_cfgvendor_send_async_event(struct wiphy *wiphy,
 	struct net_device *dev, int event_id, const void  *data, int len)
 {
@@ -2513,6 +2543,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = BRCM_VENDOR_SCMD_PRIV_STR
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_priv_string_handler
 	},
 	{
@@ -2521,6 +2554,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = BRCM_VENDOR_SCMD_BCM_STR
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_priv_bcm_handler
 	},
 #ifdef GSCAN_SUPPORT
@@ -2530,6 +2566,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_GET_CAPABILITIES
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_gscan_get_capabilities
 	},
 	{
@@ -2538,6 +2577,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_SET_CONFIG
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_scan_cfg
 	},
 	{
@@ -2546,6 +2588,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_SET_SCAN_CONFIG
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_batch_scan_cfg
 	},
 	{
@@ -2554,6 +2599,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_ENABLE_GSCAN
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_initiate_gscan
 	},
 	{
@@ -2562,6 +2610,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_enable_full_scan_result
 	},
 	{
@@ -2570,6 +2621,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_SET_HOTLIST
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_hotlist_cfg
 	},
 	{
@@ -2578,6 +2632,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_significant_change_cfg
 	},
 	{
@@ -2586,6 +2643,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_GET_SCAN_RESULTS
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_gscan_get_batch_results
 	},
 	{
@@ -2594,6 +2654,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_GET_CHANNEL_LIST
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_gscan_get_channel_list
 	},
 #endif /* GSCAN_SUPPORT */
@@ -2604,6 +2667,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = RTT_SUBCMD_SET_CONFIG
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_rtt_set_config
 	},
 	{
@@ -2612,6 +2678,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = RTT_SUBCMD_CANCEL_CONFIG
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_rtt_cancel_config
 	},
 	{
@@ -2620,6 +2689,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = RTT_SUBCMD_GETCAPABILITY
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_rtt_get_capability
 	},
 #endif /* RTT_SUPPORT */
@@ -2630,6 +2702,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = WIFI_OFFLOAD_SUBCMD_START_MKEEP_ALIVE
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_start_mkeep_alive
 	},
 	{
@@ -2638,6 +2713,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = WIFI_OFFLOAD_SUBCMD_STOP_MKEEP_ALIVE
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_stop_mkeep_alive
 	},
 #endif /* KEEP_ALIVE */
@@ -2647,6 +2725,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = ANDR_WIFI_SUBCMD_GET_FEATURE_SET
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_get_feature_set
 	},
 	{
@@ -2655,6 +2736,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_get_feature_set_matrix
 	},
 	{
@@ -2663,6 +2747,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = ANDR_WIFI_RANDOM_MAC_OUI
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_rand_mac_oui
 	},
 #ifdef CUSTOM_FORCE_NODFS_FLAG
@@ -2672,6 +2759,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = ANDR_WIFI_NODFS_CHANNELS
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_nodfs_flag
 
 	},
@@ -2683,6 +2773,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = LSTATS_SUBCMD_GET_INFO
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_lstats_get_info
 	},
 #endif /* LINKSTAT_SUPPORT */
@@ -2693,6 +2786,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = GSCAN_SUBCMD_SET_EPNO_SSID
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_epno_cfg
 
 	},
@@ -2702,6 +2798,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = WIFI_SUBCMD_SET_SSID_WHITELIST
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_ssid_whitelist
 
 	},
@@ -2711,6 +2810,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = WIFI_SUBCMD_SET_LAZY_ROAM_PARAMS
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_lazy_roam_cfg
 
 	},
@@ -2720,6 +2822,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = WIFI_SUBCMD_ENABLE_LAZY_ROAM
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_enable_lazy_roam
 
 	},
@@ -2729,6 +2834,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = WIFI_SUBCMD_SET_BSSID_PREF
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_bssid_pref
 
 	},
@@ -2738,6 +2846,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = WIFI_SUBCMD_SET_BSSID_BLACKLIST
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_bssid_blacklist
 	},
 #endif /* GSCAN_SUPPORT */
@@ -2747,6 +2858,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = WIFI_SUBCMD_SET_RSSI_MONITOR
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_set_rssi_monitor
 	},
 	{
@@ -2755,6 +2869,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = DEBUG_START_LOGGING
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_dbg_start_logging
 	},
 #ifdef DHD_FW_COREDUMP
@@ -2764,6 +2881,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = DEBUG_TRIGGER_MEM_DUMP
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_dbg_trigger_mem_dump
 	},
 	{
@@ -2772,6 +2892,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = DEBUG_GET_MEM_DUMP
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_dbg_get_mem_dump
 	},
 #endif /* DHD_FW_COREDUMP */
@@ -2781,6 +2904,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = DEBUG_RESET_LOGGING
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_dbg_reset_logging
 	},
 #ifdef DHD_FW_COREDUMP
@@ -2790,6 +2916,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = DEBUG_GET_VER
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_dbg_get_version
 	},
 #endif /* DHD_FW_COREDUMP */
@@ -2799,6 +2928,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = DEBUG_GET_RING_STATUS
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_dbg_get_ring_status
 	},
 	{
@@ -2807,6 +2939,9 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = DEBUG_GET_RING_DATA
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_dbg_get_ring_data
 	},
 	{
@@ -2815,8 +2950,19 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 			.subcmd = DEBUG_GET_FEATURE
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
 		.doit = wl_cfgvendor_dbg_get_feature
 	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = ANDR_WIFI_SET_COUNTRY
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_set_country
+	},
 };
 
 static const struct  nl80211_vendor_cmd_info wl_vendor_events [] = {
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgvendor.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgvendor.h
index 151650c90abb..fa4639a5eb8b 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgvendor.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_cfgvendor.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 Vendor Extension Code
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -367,7 +368,8 @@ enum andr_wifi_attr {
 	ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET,
 	ANDR_WIFI_ATTRIBUTE_FEATURE_SET,
 	ANDR_WIFI_ATTRIBUTE_RANDOM_MAC_OUI,
-	ANDR_WIFI_ATTRIBUTE_NODFS_SET
+	ANDR_WIFI_ATTRIBUTE_NODFS_SET,
+	ANDR_WIFI_ATTRIBUTE_COUNTRY
 };
 
 typedef enum wl_vendor_gscan_attribute {
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_dbg.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_dbg.h
index 8d0a44045757..98d0b79ecb7f 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_dbg.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_dbg.h
@@ -1,8 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Minimal debug/trace/assert driver definitions for
  * Broadcom 802.11 Networking Adapter.
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_iw.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_iw.c
index 11961dbaa591..56d7fb735308 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_iw.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_iw.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux Wireless Extensions support
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +25,7 @@
  *
  * <<Broadcom-WL-IPTag/Open:>>
  *
- * $Id: wl_iw.c 666543 2017-08-25 07:42:40Z $
+ * $Id: wl_iw.c 709309 2019-01-17 09:04:00Z $
  */
 
 #if defined(USE_IW)
@@ -38,6 +39,10 @@
 #include <bcmendian.h>
 #include <proto/ethernet.h>
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/sched/signal.h>
+#endif
+
 #include <linux/if_arp.h>
 #include <asm/uaccess.h>
 
@@ -157,7 +162,7 @@ typedef struct iscan_info {
 	char ioctlbuf[WLC_IOCTL_SMLEN];
 } iscan_info_t;
 iscan_info_t *g_iscan = NULL;
-static void wl_iw_timerfunc(struct timer_list *t);
+static void wl_iw_timerfunc(ulong data);
 static void wl_iw_set_event_mask(struct net_device *dev);
 static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action);
 
@@ -3522,9 +3527,9 @@ int wl_iw_get_wireless_stats(struct net_device *dev, struct iw_statistics *wstat
 }
 
 static void
-wl_iw_timerfunc(struct timer_list *t)
+wl_iw_timerfunc(ulong data)
 {
-	iscan_info_t *iscan = from_timer(iscan, t, timer);
+	iscan_info_t *iscan = (iscan_info_t *)data;
 	iscan->timer_on = 0;
 	if (iscan->iscan_state != ISCAN_STATE_IDLE) {
 		WL_TRACE(("timer trigger\n"));
@@ -3757,7 +3762,9 @@ wl_iw_attach(struct net_device *dev, void * dhdp)
 
 	/* Set up the timer */
 	iscan->timer_ms    = 2000;
-	timer_setup(&iscan->timer, wl_iw_timerfunc, 0);
+	init_timer(&iscan->timer);
+	iscan->timer.data = (ulong)iscan;
+	iscan->timer.function = wl_iw_timerfunc;
 
 	sema_init(&iscan->sysioc_sem, 0);
 	init_completion(&iscan->sysioc_exited);
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_iw.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_iw.h
index 484d9bb43818..e1dfc3379bec 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_iw.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_iw.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux Wireless Extensions support
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_linux_mon.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_linux_mon.c
index 755f3d97ec1b..6b268f957c8a 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_linux_mon.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_linux_mon.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom Dongle Host Driver (DHD), Linux monitor network interface
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_roam.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_roam.c
index 4f98c9db52ef..aa5f6ffbc944 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_roam.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wl_roam.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux roam cache
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wldev_common.c b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wldev_common.c
index 0bf26b2bfcf7..d374136a991e 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wldev_common.c
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wldev_common.c
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Common function shared by Linux WEXT, cfg80211 and p2p drivers
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wldev_common.h b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wldev_common.h
index 2cdd36f4273a..aa3d25a1f883 100644
--- a/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wldev_common.h
+++ b/drivers/net/wireless/rockchip_wlan/cywdhd/bcmdhd/wldev_common.h
@@ -1,7 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Common function shared by Linux WEXT, cfg80211 and p2p drivers
  *
- * Copyright (C) 1999-2017, Broadcom Corporation
+ * Copyright (C) 1999-2019, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.c
index 64410fe0f254..07c878d2043c 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.c
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver
  *
@@ -34,8 +35,6 @@
 
 #include <wlc_types.h>
 #include <bcmutils.h>
-
-/* SPDX-License-Identifier: GPL-2.0 */
 #include <bcmstdlib_s.h>
 #include <bcmwifi_channels.h>
 #include <bcmendian.h>
-- 
2.35.3

