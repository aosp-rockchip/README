From 495446cde66113a285099eb56ecb54e1289a2903 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Sat, 3 Nov 2018 13:37:26 +0800
Subject: [PATCH] drivers/mfd: remove unused ricoh619 driver

Change-Id: I8e2be84e4356399b32816b829c5e07614717f848
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 .../devicetree/bindings/mfd/ricoh619.txt      |  229 -
 arch/arm/boot/dts/ricoh619.dtsi               |  169 -
 drivers/input/misc/ricoh619-pwrkey.c          |  382 --
 drivers/mfd/ricoh619-irq.c                    |  618 --
 drivers/mfd/ricoh619.c                        | 1022 ----
 drivers/power/ricoh619-battery.c              | 5010 -----------------
 drivers/regulator/ricoh619-regulator.c        |  690 ---
 drivers/rtc/rtc-ricoh619.c                    |  845 ---
 include/linux/mfd/ricoh619.h                  |  378 --
 include/linux/power/ricoh619_battery.h        |  153 -
 include/linux/regulator/ricoh619-regulator.h  |   72 -
 include/linux/rtc/rtc-ricoh619.h              |   59 -
 12 files changed, 9627 deletions(-)
 delete mode 100755 Documentation/devicetree/bindings/mfd/ricoh619.txt
 delete mode 100644 arch/arm/boot/dts/ricoh619.dtsi
 delete mode 100644 drivers/input/misc/ricoh619-pwrkey.c
 delete mode 100755 drivers/mfd/ricoh619-irq.c
 delete mode 100755 drivers/mfd/ricoh619.c
 delete mode 100755 drivers/power/ricoh619-battery.c
 delete mode 100755 drivers/regulator/ricoh619-regulator.c
 delete mode 100755 drivers/rtc/rtc-ricoh619.c
 delete mode 100755 include/linux/mfd/ricoh619.h
 delete mode 100755 include/linux/power/ricoh619_battery.h
 delete mode 100755 include/linux/regulator/ricoh619-regulator.h
 delete mode 100755 include/linux/rtc/rtc-ricoh619.h

diff --git a/Documentation/devicetree/bindings/mfd/ricoh619.txt b/Documentation/devicetree/bindings/mfd/ricoh619.txt
deleted file mode 100755
index 1abdec339617..000000000000
--- a/Documentation/devicetree/bindings/mfd/ricoh619.txt
+++ /dev/null
@@ -1,229 +0,0 @@
-ricoh619 Power Management Integrated Circuit
-
-Required properties:
-- compatible: "rockchip,ricoh619" 
-- reg: I2C slave address
-- gpios: the interrupt pin\ sleep pin \dc_dec pin
-  use gpio get IRQ number
-  get adp plug in or out
-- regulators: This is the list of child nodes that specify the regulator
-  initialization data for defined regulators. Not all regulators for the given
-  device need to be present. The definition for each of these nodes is defined
-  using the standard binding for regulators found at
-  Documentation/devicetree/bindings/regulator/regulator.txt.
-  The regulator is matched with the regulator-compatible.
-
-  The valid regulator-compatible values are:
-  ricoh619: ricoh619_dc1, ricoh619_dc2, ricoh619_dc3, ricoh619_dc4, ricoh619_dc5,ricoh619_ldo1, ricoh619_ldo2, ricoh619_ldo3, ricoh619_ldo4, ricoh619_ldo5, ricoh619_ldo6,
-            ricoh619_ldo7, ricoh619_ldo8,ricoh619_ldo9,ricoh619_ldo10,ricoh619_ldortc1,ricoh619_ldortc2
-
-Optional properties:
-- gpios: 
-	gpios 0 :irq pin gpio
-	gpios 1 :sleep pin gpio
-	gpios 2 :dc det pin
-- regulator-initial-mode: default mode to set on startup
-- regulator-initial-state: suspend state to set at init
-- regulator-state-mem, regulator-state-disk, regulator-state-standby:
-	defines regulator suspend to memory, suspend to disk (hibernate) and standby respectively.
-	have following sub-constarints:
-	- regulator-state-uv: suspend voltage
-	- regulator-state-mode: suspend regulator operating mode
-	- regulator-state-enabled: is regulator enabled in this suspend state
-	- regulator-state-disabled: is the regulator disbled in this suspend state
--regulator-initial-mode and regulator-state-mode is set as:
-	REGULATOR_MODE_FAST			0x1
-	REGULATOR_MODE_NORMAL			0x2
-	REGULATOR_MODE_IDLE			0x4
-	REGULATOR_MODE_STANDBY			0x8
- 
-Example:
-
-	ricoh619: ricoh619@32 {
-		reg = <0x32>;
-		status = "okay";
-	};
-
-	gpios =<&gpio0 GPIO_A4 GPIO_ACTIVE_HIGH>,<&gpio0 GPIO_B3 GPIO_ACTIVE_LOW>,<&gpio0 GPIO_B0 GPIO_ACTIVE_HIGH>;
-	ricoh619,system-power-controller;  //support power off
-
-&ricoh619 {
-	compatible = "ricoh,ricoh619";
-	
-	regulators {
-		#address-cells = <1>;
-		#size-cells = <0>;	
-
-		regulators {
-		ricoh619_dcdc1_reg: regulator@0 {
-			regulator-name = "vdd_logic";
-			regulator-min-microvolt = < 700000>;
-			regulator-max-microvolt = <1500000>;
-			regulator-initial-mode = <0x2>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-mode = <0x2>;
-				regulator-state-enabled;
-				regulator-state-uv = <900000>;
-			};	
-		};
-		ricoh619_dcdc2_reg: regulator@1 {
-			regulator-name = "ricoh619_dcdc2";
-			regulator-min-microvolt = <1200000>;
-			regulator-max-microvolt = <1200000>;
-			regulator-initial-mode = <0x2>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-mode = <0x2>;
-				regulator-state-enabled;
-				regulator-state-uv = <1200000>;
-			};	
-		};
-		ricoh619_dcdc3_reg: regulator@2 {
-			regulator-name = "ricoh619_dcdc3";
-			regulator-min-microvolt = < 1200000>;
-			regulator-max-microvolt = <1200000>;
-			regulator-initial-mode = <0x2>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-mode = <0x2>;
-				regulator-state-enabled;
-				regulator-state-uv = <1200000>;
-			};	
-		};
-		ricoh619_dcdc4_reg: regulator@3 {
-			regulator-name = "ricoh619_dcdc4";
-			regulator-min-microvolt = < 3300000>;
-			regulator-max-microvolt = <3300000>;
-			regulator-initial-mode = <0x2>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-mode = <0x2>;
-				regulator-state-enabled;
-				regulator-state-uv = <2800000>;
-			};	
-		};
-		ricoh619_dcdc5_reg: regulator@4 {
-			regulator-name = "ricoh619_dcdc5";
-			regulator-min-microvolt = < 2000000>;
-			regulator-max-microvolt = <2000000>;
-			regulator-initial-mode = <0x2>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-mode = <0x2>;
-				regulator-state-enabled;
-				regulator-state-uv = <2000000>;
-			};	
-		};
-		ricoh619_ldo1_reg: regulator@5  {
-			regulator-name = "ricoh619_ldo1";
-			regulator-min-microvolt = <3300000>;
-			regulator-max-microvolt = <3300000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};	
-		};
-		ricoh619_ldo2_reg: regulator@6  {
-			regulator-name = "ricoh619_ldo2";
-			regulator-min-microvolt = <3300000>;
-			regulator-max-microvolt = <3300000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};
-		};
-		ricoh619_ldo3_reg: regulator@7  {
-			regulator-name = "ricoh619_ldo3";
-			regulator-min-microvolt = <3300000>;
-			regulator-max-microvolt = <3300000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};
-		};
-		ricoh619_ldo4_reg: regulator@8  {
-			regulator-name = "vcc_sd";
-			regulator-min-microvolt = <3300000>;
-			regulator-max-microvolt = <3300000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};
-		};
-		ricoh619_ldo5_reg: regulator@9  {
-			regulator-name = "ricoh619_ldo5";
-			regulator-min-microvolt = <3300000>;
-			regulator-max-microvolt = <3300000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};
-		};
-		ricoh619_ldo6_reg: regulator@10  {
-			regulator-name = "ricoh619_ldo6";
-			regulator-min-microvolt = <1800000>;
-			regulator-max-microvolt = <1800000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <1800000>;
-			};
-		};
-		ricoh619_ldo7_reg: regulator@11  {
-			regulator-name = "ricoh619_ldo7";
-			regulator-min-microvolt = <1000000>;
-			regulator-max-microvolt = <1000000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};
-		};
-		ricoh619_ldo8_reg: regulator@12  {
-			regulator-name = "ricoh619_ldo8";
-			regulator-min-microvolt = <1800000>;
-			regulator-max-microvolt = <1800000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};
-		};
-		ricoh619_ldo9_reg: regulator@13  {
-			regulator-name = "ricoh619_ldo9";
-			regulator-min-microvolt = <1000000>;
-			regulator-max-microvolt = <1000000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};
-		};
-		ricoh619_ldo10_reg: regulator@14  {
-			regulator-name = "ricoh619_ldo10";
-			regulator-min-microvolt = <1800000>;
-			regulator-max-microvolt = <1800000>;
-			regulator-initial-state = <3>;
-			regulator-state-mem {
-				regulator-state-enabled;
-				regulator-state-uv = <3300000>;
-			};
-		};
-		ricoh619_ldortc1_reg: regulator@15  {
-			regulator-name = "ricoh619_ldortc1";
-			regulator-min-microvolt = < 3300000>;
-			regulator-max-microvolt = <3300000>;
-		};
-		ricoh619_ldortc2_reg: regulator@16  {
-			regulator-name = "ricoh619_ldortc2";
-			regulator-min-microvolt = < 3300000>;
-			regulator-max-microvolt = <3300000>;
-		};
-	};
-};
diff --git a/arch/arm/boot/dts/ricoh619.dtsi b/arch/arm/boot/dts/ricoh619.dtsi
deleted file mode 100644
index 99af2fa695df..000000000000
--- a/arch/arm/boot/dts/ricoh619.dtsi
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright (C) 2014 Ricoh Electronic Devices Co., Ltd. - http://www.rioch.com/LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/*
- * Integrated Power Management Chip
- * http://www.ricoh.com/LSI/product_pmic/multiple-pmu/rc5t619/
- */
-
-&ricoh619
-{
-	compatible = "ricoh,ricoh619";
-	interrupt-controller;
-	#interrupt-cells = <0>;
-	
-	pwrkey: pwrkey@0 {
-		compatible = "ricoh,ricoh619-pwrkey";
-		ricoh,pwrkey-delay-ms = <20>;		
-	};
-
-	rtc {
-		compatible = "ricoh,ricoh619-rtc";
-		ricoh,rtc-tm-year = <2014>;
-		ricoh,rtc-tm-month = <1>;
-		ricoh,rtc-tm-mday = <1>;
-		ricoh,rtc-tm-hour = <8>;
-		ricoh,rtc-tm-min = <0>;
-		ricoh,rtc-tm-sec = <0>;
-	};
-
-	battery {
-		compatible = "ricoh,ricoh619-battery";
-		ricoh,alarm-vol-mv = <3300>;
-		ricoh,multiple = <100>;
-		ricoh,monitor-time = <1>;
-
-		ricoh,ch-vfchg = <0xff>;/* VFCHG	= 0 - 4 (4.05v, 4.10v, 4.15v, 4.20v, 4.35v) */
-		ricoh,ch-vrchg = <0xff>;/* VRCHG	= 0 - 4 (3.85v, 3.90v, 3.95v, 4.00v, 4.10v) */
-		ricoh,ch-vbatovset = <0xff>;/* VBATOVSET	= 0 or 1 (0 : 4.38v(up)/3.95v(down) 1: 4.53v(up)/4.10v(down)) */
-		ricoh,ch-ichg = <0xff>;/* ICHG		= 0 - 0x1D (100mA - 3000mA) */
-		ricoh,ch-ilim-adp = <0xff>;/* ILIM_ADP	= 0 - 0x1D (100mA - 3000mA) */
-		ricoh,ch-ilim-usb = <0xff>;/* ILIM_USB	= 0 - 0x1D (100mA - 3000mA) */
-		ricoh,ch-icchg = <0x03>;/* ICCHG	= 0 - 3 (50mA 100mA 150mA 200mA) */
-		ricoh,fg-target-vsys = <3000>;/* This value is the target one to DSOC=0% */
-		ricoh,fg-target-ibat = <1000>;/* This value is the target one to DSOC=0% */
-		ricoh,fg-poff-vbat = <0>;/* setting value of 0 per Vbat */
-		ricoh,jt-en = <0>;/* JEITA Enable	  = 0 or 1 (1:enable, 0:disable) */
-		ricoh,jt-hw-sw = <1>;/* JEITA HW or SW = 0 or 1 (1:HardWare, 0:SoftWare) */
-		ricoh,jt-temp-h = <50>;/* degree C */
-		ricoh,jt-temp-l = <12>;/* degree C */
-		ricoh,jt-vfchg-h = <0x03>;/* VFCHG High  	= 0 - 4 (4.05v, 4.10v, 4.15v, 4.20v, 4.35v) */
-		ricoh,jt-vfchg-l = <0>;/* VFCHG High  	= 0 - 4 (4.05v, 4.10v, 4.15v, 4.20v, 4.35v) */
-		ricoh,jt-ichg-h = <0x0D>;/* VFCHG Low  	= 0 - 4 (4.05v, 4.10v, 4.15v, 4.20v, 4.35v) */
-		ricoh,jt-ichg-l = <0x09>;/* ICHG Low   	= 0 - 0x1D (100mA - 3000mA) */
-	};
-
-	regulators {
-		#address-cells = <1>;
-		#size-cells = <0>;	
-		
-		ricoh619_dcdc1_reg: regulator@0 {
-			reg = <0>;
-			regulator-compatible = "ricoh619_dc1";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_dcdc2_reg: regulator@1 {
-			reg = <1>;
-			regulator-compatible = "ricoh619_dc2";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_dcdc3_reg: regulator@2 {
-			reg = <2>;
-			regulator-compatible = "ricoh619_dc3";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_dcdc4_reg: regulator@3 {
-			reg = <3>;
-			regulator-compatible = "ricoh619_dc4";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_dcdc5_reg: regulator@4 {
-			reg = <4>;
-			regulator-compatible = "ricoh619_dc5";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo1_reg: regulator@5  {
-			reg = <5>;
-			regulator-compatible = "ricoh619_ldo1";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo2_reg: regulator@6  {
-			reg = <6>;
-			regulator-compatible = "ricoh619_ldo2";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo3_reg: regulator@7  {
-			reg = <7>;
-			regulator-compatible = "ricoh619_ldo3";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo4_reg: regulator@8  {
-			reg = <8>;
-			regulator-compatible = "ricoh619_ldo4";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo5_reg: regulator@9  {
-			reg = <9>;
-			regulator-compatible = "ricoh619_ldo5";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo6_reg: regulator@10  {
-			reg = <10>;
-			regulator-compatible = "ricoh619_ldo6";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo7_reg: regulator@11  {
-			reg = <11>;
-			regulator-compatible = "ricoh619_ldo7";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo8_reg: regulator@12  {
-			reg = <12>;
-			regulator-compatible = "ricoh619_ldo8";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo9_reg: regulator@13  {
-			reg = <13>;
-			regulator-compatible = "ricoh619_ldo9";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldo10_reg: regulator@14  {
-			reg = <14>;
-			regulator-compatible = "ricoh619_ldo10";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldortc1_reg: regulator@15  {
-			reg = <15>;
-			regulator-compatible = "ricoh619_ldortc1";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-		ricoh619_ldortc2_reg: regulator@16  {
-			reg = <16>;
-			regulator-compatible = "ricoh619_ldortc2";
-			regulator-always-on;
-			regulator-boot-on;
-		};
-	};
-};
-
diff --git a/drivers/input/misc/ricoh619-pwrkey.c b/drivers/input/misc/ricoh619-pwrkey.c
deleted file mode 100644
index 35b17f27f88f..000000000000
--- a/drivers/input/misc/ricoh619-pwrkey.c
+++ /dev/null
@@ -1,382 +0,0 @@
-/*
-* driver/input/misc/ricoh619-pwrkey.c
-*
-* Power Key driver for RICOH RC5T619 power management chip.
-*
-* Copyright (C) 2012-2013 RICOH COMPANY,LTD
-*
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-* more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program. If not, see <http://www.gnu.org/licenses/>.
-*
-*/
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/mfd/ricoh619.h>
-#include <linux/spinlock.h>
-#include <linux/timer.h>
-#include <linux/pm.h>
-#include <linux/slab.h>
-#include <linux/pm_runtime.h>
-#include <linux/workqueue.h>
-#include <linux/gpio.h>
-#include <linux/of.h>
-#include <linux/delay.h>
-
-#include <linux/mfd/ricoh619.h>
-#include <linux/irq.h>
-#include <linux/irqdomain.h>
-
-#define RICOH619_ONKEY_TRIGGER_LEVEL	0
-#define RICOH619_ONKEY_OFF_IRQ		0
-
-struct ricoh619_pwrkey {
-	struct device *dev;
-	struct input_dev *pwr;
-	#if RICOH619_ONKEY_TRIGGER_LEVEL
-		struct timer_list timer;
-	#endif
-	struct workqueue_struct *workqueue;
-	struct work_struct work;
-	unsigned long delay;
-	int key_irq;
-	bool pressed_first;
-	struct ricoh619_pwrkey_platform_data *pdata;
-	spinlock_t lock;
-};
-
-struct ricoh619_pwrkey *g_pwrkey;
-
-#if RICOH619_ONKEY_TRIGGER_LEVEL
-void ricoh619_pwrkey_timer(unsigned long t)
-{
-	queue_work(g_pwrkey->workqueue, &g_pwrkey->work);
-}
-#endif
-extern u8 ricoh619_pwr_key_reg;
-static void ricoh619_irq_work(struct work_struct *work)
-{
-	/* unsigned long flags; */
-	uint8_t val;
-	int i=0;
-
-//	printk("PMU: %s: \n",__func__);
-	//spin_lock_irqsave(&g_pwrkey->lock, flags);
-	if((ricoh619_pwr_key_reg & 0x01) && ricoh619_pwrkey_wakeup){
-		printk("PMU: %s: pwrkey_wakeup\n",__func__);
-		ricoh619_pwrkey_wakeup = 0;
-		input_event(g_pwrkey->pwr, EV_KEY, KEY_POWER, 1);
-		input_event(g_pwrkey->pwr, EV_SYN, 0, 0);
-		input_event(g_pwrkey->pwr, EV_KEY, KEY_POWER, 0);
-		input_event(g_pwrkey->pwr, EV_SYN, 0, 0);
-		do{
-			ricoh619_read(g_pwrkey->dev->parent, RICOH619_INT_MON_SYS, &val);
-       		val &= 0x01;
-			i += 1;
-			msleep(100);
-		}while(val && (i < 15));
-		return;
-	}
-	ricoh619_read(g_pwrkey->dev->parent, RICOH619_INT_MON_SYS, &val);
-	dev_dbg(g_pwrkey->dev, "pwrkey is pressed?(0x%x): 0x%x\n",
-						RICOH619_INT_MON_SYS, val);
-//	printk(KERN_INFO "PMU: %s: val=0x%x\n", __func__, val);
-	val &= 0x1;
-	if(val){
-		#if (RICOH619_ONKEY_TRIGGER_LEVEL)
-		g_pwrkey->timer.expires = jiffies + g_pwrkey->delay;
-		add_timer(&g_pwrkey->timer);
-		#endif
-		if (!g_pwrkey->pressed_first){
-			g_pwrkey->pressed_first = true;
-//			printk("PMU1: %s: Power Key!!!\n",__func__);
-			//input_report_key(g_pwrkey->pwr, KEY_POWER, 1);
-			//input_sync(g_pwrkey->pwr);
-			input_event(g_pwrkey->pwr, EV_KEY, KEY_POWER, 1);
-			input_event(g_pwrkey->pwr, EV_SYN, 0, 0);
-		}
-	} else {
-		if (g_pwrkey->pressed_first) {
-//			printk(KERN_INFO "PMU2: %s: Power Key!!!\n", __func__);
-			/* input_report_key(g_pwrkey->pwr, KEY_POWER, 0); */
-			/* input_sync(g_pwrkey->pwr); */
-			input_event(g_pwrkey->pwr, EV_KEY, KEY_POWER, 0);
-			input_event(g_pwrkey->pwr, EV_SYN, 0, 0);
-		}
-		g_pwrkey->pressed_first = false;
-	}
-
-	/* spin_unlock_irqrestore(&g_pwrkey->lock, flags); */
-}
-
-static irqreturn_t pwrkey_irq(int irq, void *_pwrkey)
-{
-//	printk(KERN_INFO "PMU: %s:\n", __func__);
-//	rk_send_wakeup_key();
-	#if (RICOH619_ONKEY_TRIGGER_LEVEL)
-	g_pwrkey->timer.expires = jiffies + g_pwrkey->delay;
-	add_timer(&g_pwrkey->timer);
-	#else
-	queue_work(g_pwrkey->workqueue, &g_pwrkey->work);
-	#endif
-	return IRQ_HANDLED;
-}
-
-#if RICOH619_ONKEY_OFF_IRQ
-static irqreturn_t pwrkey_irq_off(int irq, void *_pwrkey)
-{
-	dev_warn(g_pwrkey->dev, "ONKEY is pressed long time!\n");
-	return IRQ_HANDLED;
-}
-#endif
-
-#ifdef CONFIG_OF
-static struct ricoh619_pwrkey_platform_data *
-ricoh619_pwrkey_dt_init(struct platform_device *pdev)
-{
-	struct device_node *nproot = pdev->dev.parent->of_node;
-	struct device_node *np;
-	struct ricoh619_pwrkey_platform_data *pdata;
-
-	if (!nproot)
-		return pdev->dev.platform_data;
-
-	np = of_find_node_by_name(nproot, "pwrkey");
-	if (!np) {
-		dev_err(&pdev->dev, "failed to find pwrkey node\n");
-		return NULL;
-	}
-
-	pdata = devm_kzalloc(&pdev->dev,
-			sizeof(struct ricoh619_pwrkey_platform_data),
-			GFP_KERNEL);
-
-	of_property_read_u32(np, "ricoh,pwrkey-delay-ms", &pdata->delay_ms);
-	of_node_put(np);
-
-	return pdata;
-}
-#else
-static struct ricoh619_pwrkey_platform_data *
-ricoh619_pwrkey_dt_init(struct platform_device *pdev)
-{
-	return pdev->dev.platform_data;
-}
-#endif
-
-static int ricoh619_pwrkey_probe(struct platform_device *pdev)
-{
-	struct input_dev *pwr;
-	int key_irq;
-	int err;
-	struct ricoh619_pwrkey *pwrkey;
-	struct ricoh619_pwrkey_platform_data *pdata;
-	struct ricoh619 *ricoh619 = dev_get_drvdata(pdev->dev.parent);
-	uint8_t val;
-
-//	printk("PMU: %s: \n",__func__);
-
-	pdata = ricoh619_pwrkey_dt_init(pdev);
-	if (!pdata) {
-		dev_err(&pdev->dev, "platform data isn't assigned to "
-			"power key\n");
-		return -EINVAL;
-	}
-	key_irq  = irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_POWER_ON);
-	printk(KERN_INFO "PMU1: %s: key_irq=%d\n", __func__, key_irq);
-	pwrkey = kzalloc(sizeof(*pwrkey), GFP_KERNEL);
-	if (!pwrkey)
-		return -ENOMEM;
-
-	pwrkey->dev = &pdev->dev;
-	pwrkey->pdata = pdata;
-	pwrkey->pressed_first = false;
-	pwrkey->delay = HZ / 1000 * pdata->delay_ms;
-	g_pwrkey = pwrkey;
-	pwr = input_allocate_device();
-	if (!pwr) {
-		dev_dbg(&pdev->dev, "Can't allocate power button\n");
-		err = -ENOMEM;
-		goto free_pwrkey;
-	}
-	input_set_capability(pwr, EV_KEY, KEY_POWER);
-	pwr->name = "ricoh619_pwrkey";
-	pwr->phys = "ricoh619_pwrkey/input0";
-	pwr->dev.parent = &pdev->dev;
-
-	#if RICOH619_ONKEY_TRIGGER_LEVEL
-	init_timer(&pwrkey->timer);
-	pwrkey->timer.function = ricoh619_pwrkey_timer;
-	#endif
-
-	spin_lock_init(&pwrkey->lock);
-	err = input_register_device(pwr);
-	if (err) {
-		dev_dbg(&pdev->dev, "Can't register power key: %d\n", err);
-		goto free_input_dev;
-	}
-	pwrkey->key_irq = key_irq;
-	pwrkey->pwr = pwr;
-	platform_set_drvdata(pdev, pwrkey);
-
-	/* Check if power-key is pressed at boot up */
-	err = ricoh619_read(pwrkey->dev->parent, RICOH619_INT_MON_SYS, &val);
-	if (err < 0) {
-		dev_err(&pdev->dev, "Key-press status at boot failed rc=%d\n",
-									 err);
-		goto unreg_input_dev;
-	}
-	val &= 0x1;
-	if (val) {
-		input_report_key(pwrkey->pwr, KEY_POWER, 1);
-//		printk(KERN_INFO "******KEY_POWER:1\n");
-		input_sync(pwrkey->pwr);
-		pwrkey->pressed_first = true;
-	}
-
-	#if !(RICOH619_ONKEY_TRIGGER_LEVEL)
-		/* trigger both edge */
-		ricoh619_set_bits(pwrkey->dev->parent, RICOH619_PWR_IRSEL, 0x1);
-	#endif
-	err = request_threaded_irq(key_irq, NULL, pwrkey_irq,IRQF_ONESHOT, "ricoh619_pwrkey", pwrkey);
-	if (err < 0) {
-		dev_err(&pdev->dev, "Can't get %d IRQ for pwrkey: %d\n",
-								key_irq, err);
-		goto unreg_input_dev;
-	}
-	/*
-	#if RICOH619_ONKEY_OFF_IRQ
-	err = request_threaded_irq( key_irq +RICOH619_ONKEY_OFF_IRQ, NULL,pwrkey_irq_off, IRQF_ONESHOT,
-						"ricoh619_pwrkey_off", pwrkey);
-	if (err < 0) {
-		dev_err(&pdev->dev, "Can't get %d IRQ for ricoh619_pwrkey_off: %d\n",
-			key_irq + RICOH619_ONKEY_OFF_IRQ, err);
-		free_irq(key_irq, pwrkey);
-		goto unreg_input_dev;
-	}
-	#endif
-*/
-	pwrkey->workqueue = create_singlethread_workqueue("ricoh619_pwrkey");
-	INIT_WORK(&pwrkey->work, ricoh619_irq_work);
-
-	/* Enable power key IRQ */
-	/* trigger both edge */
-	ricoh619_set_bits(pwrkey->dev->parent, RICOH619_PWR_IRSEL, 0x1);
-	/* Enable system interrupt */
-	ricoh619_set_bits(pwrkey->dev->parent, RICOH619_INTC_INTEN, 0x1);
-	/* Enable power-on interrupt */
-	ricoh619_set_bits(pwrkey->dev->parent, RICOH619_INT_EN_SYS, 0x1);
-//	printk(KERN_INFO "PMU: %s is OK!\n", __func__);
-	return 0;
-
-unreg_input_dev:
-	input_unregister_device(pwr);
-	pwr = NULL;
-
-free_input_dev:
-	input_free_device(pwr);
-	free_pwrkey:
-	kfree(pwrkey);
-
-	return err;
-}
-
-static int ricoh619_pwrkey_remove(struct platform_device *pdev)
-{
-	struct ricoh619_pwrkey *pwrkey = platform_get_drvdata(pdev);
-
-	flush_workqueue(pwrkey->workqueue);
-	destroy_workqueue(pwrkey->workqueue);
-	free_irq(pwrkey->key_irq, pwrkey);
-	input_unregister_device(pwrkey->pwr);
-	kfree(pwrkey);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int ricoh619_pwrkey_suspend(struct device *dev)
-{
-	struct ricoh619_pwrkey *info = dev_get_drvdata(dev);
-
-//	printk(KERN_INFO "PMU: %s\n", __func__);
-
-//	if (info->key_irq)
-//		disable_irq(info->key_irq);
-	cancel_work_sync(&info->work);
-	flush_workqueue(info->workqueue);
-
-	return 0;
-}
-
-static int ricoh619_pwrkey_resume(struct device *dev)
-{
-	struct ricoh619_pwrkey *info = dev_get_drvdata(dev);
-
-//	printk(KERN_INFO "PMU: %s\n", __func__);
-	queue_work(info->workqueue, &info->work);
-//	if (info->key_irq)
-//		enable_irq(info->key_irq);
-
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id ricoh619_pwrkey_dt_match[] = {
-	{ .compatible = "ricoh,ricoh619-pwrkey", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ricoh619_pwrkey_dt_match);
-#endif
-
-static const struct dev_pm_ops ricoh619_pwrkey_pm_ops = {
-	.suspend	= ricoh619_pwrkey_suspend,
-	.resume		= ricoh619_pwrkey_resume,
-};
-#endif
-
-static struct platform_driver ricoh619_pwrkey_driver = {
-	.probe = ricoh619_pwrkey_probe,
-	.remove = ricoh619_pwrkey_remove,
-	.driver = {
-		.name = "ricoh619-pwrkey",
-		.owner = THIS_MODULE,
-		.of_match_table = of_match_ptr(ricoh619_pwrkey_dt_match),
-#ifdef CONFIG_PM
-		.pm	= &ricoh619_pwrkey_pm_ops,
-#endif
-	},
-};
-
-static int __init ricoh619_pwrkey_init(void)
-{
-	return platform_driver_register(&ricoh619_pwrkey_driver);
-}
-subsys_initcall_sync(ricoh619_pwrkey_init);
-
-static void __exit ricoh619_pwrkey_exit(void)
-{
-	platform_driver_unregister(&ricoh619_pwrkey_driver);
-}
-module_exit(ricoh619_pwrkey_exit);
-
-
-MODULE_ALIAS("platform:ricoh619-pwrkey");
-MODULE_AUTHOR("zhangqing <zhangqing@rock-chips.com>");
-MODULE_DESCRIPTION("ricoh619 Power Key");
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/mfd/ricoh619-irq.c b/drivers/mfd/ricoh619-irq.c
deleted file mode 100755
index 472a75502bd9..000000000000
--- a/drivers/mfd/ricoh619-irq.c
+++ /dev/null
@@ -1,618 +0,0 @@
-/* 
- * driver/mfd/ricoh619-irq.c
- *
- * Interrupt driver for RICOH RC5T619 power management chip.
- *
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * Based on code
- *	Copyright (C) 2011 NVIDIA Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/i2c.h>
-#include <linux/mfd/ricoh619.h>
-#include <linux/irqdomain.h>
-
-static DEFINE_MUTEX(int_flag_mutex);
-
-enum int_type {
-	SYS_INT  = 0x1,
-	DCDC_INT = 0x2,
-	RTC_INT  = 0x4,
-	ADC_INT  = 0x8,	
-	GPIO_INT = 0x10,
-	CHG_INT	 = 0x40,
-};
-
-static int gpedge_add[] = {
-	RICOH619_GPIO_GPEDGE1,
-	RICOH619_GPIO_GPEDGE2
-};
-
-static int irq_en_add[] = {
-	RICOH619_INT_EN_SYS,
-	RICOH619_INT_EN_DCDC,
-	RICOH619_INT_EN_RTC,
-	RICOH619_INT_EN_ADC1,
-	RICOH619_INT_EN_ADC2,
-	RICOH619_INT_EN_ADC3,
-	RICOH619_INT_EN_GPIO,
-	RICOH619_INT_EN_GPIO2,
-	RICOH619_INT_MSK_CHGCTR,
-	RICOH619_INT_MSK_CHGSTS1,
-	RICOH619_INT_MSK_CHGSTS2,
-	RICOH619_INT_MSK_CHGERR,
-	RICOH619_INT_MSK_CHGEXTIF
-};
-
-static int irq_mon_add[] = {
-	RICOH619_INT_IR_SYS, //RICOH619_INT_MON_SYS,
-	RICOH619_INT_IR_DCDC, //RICOH619_INT_MON_DCDC,
-	RICOH619_INT_IR_RTC, //RICOH619_INT_MON_RTC,
-	RICOH619_INT_IR_ADCL,
-	RICOH619_INT_IR_ADCH,
-	RICOH619_INT_IR_ADCEND,
-	RICOH619_INT_IR_GPIOR,
-	RICOH619_INT_IR_GPIOF,
-	RICOH619_INT_IR_CHGCTR, //RICOH619_INT_MON_CHGCTR,
-	RICOH619_INT_IR_CHGSTS1, //RICOH619_INT_MON_CHGSTS1,
-	RICOH619_INT_IR_CHGSTS2, //RICOH619_INT_MON_CHGSTS2,
-	RICOH619_INT_IR_CHGERR, //RICOH619_INT_MON_CHGERR
-	RICOH619_INT_IR_CHGEXTIF //RICOH619_INT_MON_CHGEXTIF
-};
-
-static int irq_clr_add[] = {
-	RICOH619_INT_IR_SYS,
-	RICOH619_INT_IR_DCDC,
-	RICOH619_INT_IR_RTC,
-	RICOH619_INT_IR_ADCL,
-	RICOH619_INT_IR_ADCH,
-	RICOH619_INT_IR_ADCEND,
-	RICOH619_INT_IR_GPIOR,
-	RICOH619_INT_IR_GPIOF,
-	RICOH619_INT_IR_CHGCTR,
-	RICOH619_INT_IR_CHGSTS1,
-	RICOH619_INT_IR_CHGSTS2,
-	RICOH619_INT_IR_CHGERR,
-	RICOH619_INT_IR_CHGEXTIF
-};
-
-static int main_int_type[] = {
-	SYS_INT,
-	DCDC_INT,
-	RTC_INT,
-	ADC_INT,
-	ADC_INT,
-	ADC_INT,
-	GPIO_INT,
-	GPIO_INT,
-	CHG_INT,
-	CHG_INT,
-	CHG_INT,
-	CHG_INT,
-	CHG_INT,
-};
-
-struct ricoh619_irq_data {
-	u8	int_type;
-	u8	master_bit;
-	u8	int_en_bit;
-	u8	mask_reg_index;
-	int	grp_index;
-};
-
-#define RICOH619_IRQ(_int_type, _master_bit, _grp_index, _int_bit, _mask_ind) \
-	{						\
-		.int_type	= _int_type,		\
-		.master_bit	= _master_bit,		\
-		.grp_index	= _grp_index,		\
-		.int_en_bit	= _int_bit,		\
-		.mask_reg_index	= _mask_ind,		\
-	}
-
-static const struct ricoh619_irq_data ricoh619_irqs[RICOH619_NR_IRQS] = {
-	[RICOH619_IRQ_POWER_ON]		= RICOH619_IRQ(SYS_INT,  0, 0, 0, 0),
-	[RICOH619_IRQ_EXTIN]		= RICOH619_IRQ(SYS_INT,  0, 1, 1, 0),
-	[RICOH619_IRQ_PRE_VINDT]	= RICOH619_IRQ(SYS_INT,  0, 2, 2, 0),
-	[RICOH619_IRQ_PREOT]		= RICOH619_IRQ(SYS_INT,  0, 3, 3, 0),
-	[RICOH619_IRQ_POWER_OFF]	= RICOH619_IRQ(SYS_INT,  0, 4, 4, 0),
-	[RICOH619_IRQ_NOE_OFF]		= RICOH619_IRQ(SYS_INT,  0, 5, 5, 0),
-	[RICOH619_IRQ_WD]		= RICOH619_IRQ(SYS_INT,  0, 6, 6, 0),
-
-	[RICOH619_IRQ_DC1LIM]		= RICOH619_IRQ(DCDC_INT, 1, 0, 0, 1),
-	[RICOH619_IRQ_DC2LIM]		= RICOH619_IRQ(DCDC_INT, 1, 1, 1, 1),
-	[RICOH619_IRQ_DC3LIM]		= RICOH619_IRQ(DCDC_INT, 1, 2, 2, 1),
-	[RICOH619_IRQ_DC4LIM]		= RICOH619_IRQ(DCDC_INT, 1, 3, 3, 1),
-	[RICOH619_IRQ_DC5LIM]		= RICOH619_IRQ(DCDC_INT, 1, 4, 4, 1),
-	
-	[RICOH619_IRQ_CTC]		= RICOH619_IRQ(RTC_INT,  2, 0, 0, 2),
-	[RICOH619_IRQ_DALE]		= RICOH619_IRQ(RTC_INT,  2, 1, 6, 2),
-
-	[RICOH619_IRQ_ILIMLIR]		= RICOH619_IRQ(ADC_INT,  3, 0, 0, 3),
-	[RICOH619_IRQ_VBATLIR]		= RICOH619_IRQ(ADC_INT,  3, 1, 1, 3),
-	[RICOH619_IRQ_VADPLIR]		= RICOH619_IRQ(ADC_INT,  3, 2, 2, 3),
-	[RICOH619_IRQ_VUSBLIR]		= RICOH619_IRQ(ADC_INT,  3, 3, 3, 3),
-	[RICOH619_IRQ_VSYSLIR]		= RICOH619_IRQ(ADC_INT,  3, 4, 4, 3),
-	[RICOH619_IRQ_VTHMLIR]		= RICOH619_IRQ(ADC_INT,  3, 5, 5, 3),
-	[RICOH619_IRQ_AIN1LIR]		= RICOH619_IRQ(ADC_INT,  3, 6, 6, 3),
-	[RICOH619_IRQ_AIN0LIR]		= RICOH619_IRQ(ADC_INT,  3, 7, 7, 3),
-	
-	[RICOH619_IRQ_ILIMHIR]		= RICOH619_IRQ(ADC_INT,  3, 8, 0, 4),
-	[RICOH619_IRQ_VBATHIR]		= RICOH619_IRQ(ADC_INT,  3, 9, 1, 4),
-	[RICOH619_IRQ_VADPHIR]		= RICOH619_IRQ(ADC_INT,  3, 10, 2, 4),
-	[RICOH619_IRQ_VUSBHIR]		= RICOH619_IRQ(ADC_INT,  3, 11, 3, 4),
-	[RICOH619_IRQ_VSYSHIR]		= RICOH619_IRQ(ADC_INT,  3, 12, 4, 4),
-	[RICOH619_IRQ_VTHMHIR]		= RICOH619_IRQ(ADC_INT,  3, 13, 5, 4),
-	[RICOH619_IRQ_AIN1HIR]		= RICOH619_IRQ(ADC_INT,  3, 14, 6, 4),
-	[RICOH619_IRQ_AIN0HIR]		= RICOH619_IRQ(ADC_INT,  3, 15, 7, 4),
-
-	[RICOH619_IRQ_ADC_ENDIR]	= RICOH619_IRQ(ADC_INT,  3, 16, 0, 5),
-
-	[RICOH619_IRQ_GPIO0]		= RICOH619_IRQ(GPIO_INT, 4, 0, 0, 6),
-	[RICOH619_IRQ_GPIO1]		= RICOH619_IRQ(GPIO_INT, 4, 1, 1, 6),
-	[RICOH619_IRQ_GPIO2]		= RICOH619_IRQ(GPIO_INT, 4, 2, 2, 6),
-	[RICOH619_IRQ_GPIO3]		= RICOH619_IRQ(GPIO_INT, 4, 3, 3, 6),
-	[RICOH619_IRQ_GPIO4]		= RICOH619_IRQ(GPIO_INT, 4, 4, 4, 6),
-
-	[RICOH619_IRQ_FVADPDETSINT]	= RICOH619_IRQ(CHG_INT, 6, 0, 0, 8),
-	[RICOH619_IRQ_FVUSBDETSINT]	= RICOH619_IRQ(CHG_INT, 6, 1, 1, 8),
-	[RICOH619_IRQ_FVADPLVSINT]	= RICOH619_IRQ(CHG_INT, 6, 2, 2, 8),
-	[RICOH619_IRQ_FVUSBLVSINT]	= RICOH619_IRQ(CHG_INT, 6, 3, 3, 8),
-	[RICOH619_IRQ_FWVADPSINT]	= RICOH619_IRQ(CHG_INT, 6, 4, 4, 8),
-	[RICOH619_IRQ_FWVUSBSINT]	= RICOH619_IRQ(CHG_INT, 6, 5, 5, 8),
-
-	[RICOH619_IRQ_FONCHGINT]	= RICOH619_IRQ(CHG_INT, 6, 6, 0, 9),
-	[RICOH619_IRQ_FCHGCMPINT]	= RICOH619_IRQ(CHG_INT, 6, 7, 1, 9),
-	[RICOH619_IRQ_FBATOPENINT]	= RICOH619_IRQ(CHG_INT, 6, 8, 2, 9),
-	[RICOH619_IRQ_FSLPMODEINT]	= RICOH619_IRQ(CHG_INT, 6, 9, 3, 9),
-	[RICOH619_IRQ_FBTEMPJTA1INT]	= RICOH619_IRQ(CHG_INT, 6, 10, 4, 9),
-	[RICOH619_IRQ_FBTEMPJTA2INT]	= RICOH619_IRQ(CHG_INT, 6, 11, 5, 9),
-	[RICOH619_IRQ_FBTEMPJTA3INT]	= RICOH619_IRQ(CHG_INT, 6, 12, 6, 9),
-	[RICOH619_IRQ_FBTEMPJTA4INT]	= RICOH619_IRQ(CHG_INT, 6, 13, 7, 9),
-
-	[RICOH619_IRQ_FCURTERMINT]	= RICOH619_IRQ(CHG_INT, 6, 14, 0, 10),
-	[RICOH619_IRQ_FVOLTERMINT]	= RICOH619_IRQ(CHG_INT, 6, 15, 1, 10),
-	[RICOH619_IRQ_FICRVSINT]	= RICOH619_IRQ(CHG_INT, 6, 16, 2, 10),
-	[RICOH619_IRQ_FPOOR_CHGCURINT]	= RICOH619_IRQ(CHG_INT, 6, 17, 3, 10),
-	[RICOH619_IRQ_FOSCFDETINT1]	= RICOH619_IRQ(CHG_INT, 6, 18, 4, 10),
-	[RICOH619_IRQ_FOSCFDETINT2]	= RICOH619_IRQ(CHG_INT, 6, 19, 5, 10),
-	[RICOH619_IRQ_FOSCFDETINT3]	= RICOH619_IRQ(CHG_INT, 6, 20, 6, 10),
-	[RICOH619_IRQ_FOSCMDETINT]	= RICOH619_IRQ(CHG_INT, 6, 21, 7, 10),
-
-	[RICOH619_IRQ_FDIEOFFINT]	= RICOH619_IRQ(CHG_INT, 6, 22, 0, 11),
-	[RICOH619_IRQ_FDIEERRINT]	= RICOH619_IRQ(CHG_INT, 6, 23, 1, 11),
-	[RICOH619_IRQ_FBTEMPERRINT]	= RICOH619_IRQ(CHG_INT, 6, 24, 2, 11),
-	[RICOH619_IRQ_FVBATOVINT]	= RICOH619_IRQ(CHG_INT, 6, 25, 3, 11),
-	[RICOH619_IRQ_FTTIMOVINT]	= RICOH619_IRQ(CHG_INT, 6, 26, 4, 11),
-	[RICOH619_IRQ_FRTIMOVINT]	= RICOH619_IRQ(CHG_INT, 6, 27, 5, 11),
-	[RICOH619_IRQ_FVADPOVSINT]	= RICOH619_IRQ(CHG_INT, 6, 28, 6, 11),
-	[RICOH619_IRQ_FVUSBOVSINT]	= RICOH619_IRQ(CHG_INT, 6, 29, 7, 11),
-
-	[RICOH619_IRQ_FGCDET]		= RICOH619_IRQ(CHG_INT, 6, 30, 0, 12),
-	[RICOH619_IRQ_FPCDET]		= RICOH619_IRQ(CHG_INT, 6, 31, 1, 12),
-	[RICOH619_IRQ_FWARN_ADP]	= RICOH619_IRQ(CHG_INT, 6, 32, 3, 12),
-
-};
-static const inline struct ricoh619_irq_data * irq_to_ricoh619_irq(struct ricoh619 *ricoh619, int irq)
-{
-	struct irq_data *data = irq_get_irq_data(irq);
-	return &ricoh619_irqs[data->hwirq];
-}
-static void ricoh619_irq_lock(struct irq_data *irq_data)
-{
-	struct ricoh619 *ricoh619 = irq_data_get_irq_chip_data(irq_data);
-
-	mutex_lock(&ricoh619->irq_lock);
-}
-
-static void ricoh619_irq_unmask(struct irq_data *irq_data)
-{
-	struct ricoh619 *ricoh619 = irq_data_get_irq_chip_data(irq_data);
-	const struct ricoh619_irq_data *data= irq_to_ricoh619_irq(ricoh619,irq_data->irq);
-    	mutex_lock(&int_flag_mutex);
-
-	ricoh619->group_irq_en[data->master_bit] |= (1 << data->grp_index);
-	if (ricoh619->group_irq_en[data->master_bit])
-		ricoh619->intc_inten_reg |= 1 << data->master_bit;
-
-	if (data->master_bit == 6)	/* if Charger */
-		ricoh619->irq_en_reg[data->mask_reg_index]
-						&= ~(1 << data->int_en_bit);
-	else
-		ricoh619->irq_en_reg[data->mask_reg_index]
-						|= 1 << data->int_en_bit;
-   	 mutex_unlock(&int_flag_mutex);
-}
-
-static void ricoh619_irq_mask(struct irq_data *irq_data)
-{
-	struct ricoh619 *ricoh619 = irq_data_get_irq_chip_data(irq_data);
-	const struct ricoh619_irq_data *data= irq_to_ricoh619_irq(ricoh619,irq_data->irq);
-        mutex_lock(&int_flag_mutex);
-
-	ricoh619->group_irq_en[data->master_bit] &= ~(1 << data->grp_index);
-	if (!ricoh619->group_irq_en[data->master_bit])
-		ricoh619->intc_inten_reg &= ~(1 << data->master_bit);
-
-	if (data->master_bit == 6)	/* if Charger */
-		ricoh619->irq_en_reg[data->mask_reg_index]
-						|= 1 << data->int_en_bit;
-	else
-		ricoh619->irq_en_reg[data->mask_reg_index]
-						&= ~(1 << data->int_en_bit);
-        mutex_unlock(&int_flag_mutex);
-}
-
-static void ricoh619_irq_sync_unlock(struct irq_data *irq_data)
-{
-	struct ricoh619 *ricoh619 = irq_data_get_irq_chip_data(irq_data);
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ricoh619->gpedge_reg); i++) {
-		if (ricoh619->gpedge_reg[i] != ricoh619->gpedge_cache[i]) {
-			if (!WARN_ON(ricoh619_write(ricoh619->dev, gpedge_add[i],ricoh619->gpedge_reg[i])))
-				ricoh619->gpedge_cache[i] =ricoh619->gpedge_reg[i];
-		}
-	}
-
-	for (i = 0; i < ARRAY_SIZE(ricoh619->irq_en_reg); i++) {
-		if (ricoh619->irq_en_reg[i] != ricoh619->irq_en_cache[i]) {
-			if (!WARN_ON(ricoh619_write(ricoh619->dev, irq_en_add[i],ricoh619->irq_en_reg[i])))
-				ricoh619->irq_en_cache[i] =ricoh619->irq_en_reg[i];
-		}
-	}
-
-	if (ricoh619->intc_inten_reg != ricoh619->intc_inten_cache) {
-		if (!WARN_ON(ricoh619_write(ricoh619->dev,RICOH619_INTC_INTEN, ricoh619->intc_inten_reg)))
-			ricoh619->intc_inten_cache = ricoh619->intc_inten_reg;
-	}
-
-	mutex_unlock(&ricoh619->irq_lock);
-}
-
-static int ricoh619_irq_set_type(struct irq_data *irq_data, unsigned int type)
-{
-	struct ricoh619 *ricoh619 = irq_data_get_irq_chip_data(irq_data);
-	const struct ricoh619_irq_data *data= irq_to_ricoh619_irq(ricoh619,irq_data->irq);
-	int val = 0;
-	int gpedge_index;
-	int gpedge_bit_pos;
-
-	if (data->int_type & GPIO_INT) {
-		gpedge_index = data->int_en_bit / 4;
-		gpedge_bit_pos = data->int_en_bit % 4;
-
-		if (type & IRQ_TYPE_EDGE_FALLING)
-			val |= 0x2;
-
-		if (type & IRQ_TYPE_EDGE_RISING)
-			val |= 0x1;
-
-		ricoh619->gpedge_reg[gpedge_index] &= ~(3 << gpedge_bit_pos);
-		ricoh619->gpedge_reg[gpedge_index] |= (val << gpedge_bit_pos);
-		ricoh619_irq_unmask(irq_data);
-	}
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int ricoh619_irq_set_wake(struct irq_data *irq_data, unsigned int on)
-{
-	struct ricoh619 *ricoh619 = irq_data_get_irq_chip_data(irq_data);
-	return irq_set_irq_wake(ricoh619->chip_irq, on);	//i2c->irq
-}
-#else
-#define ricoh619_irq_set_wake NULL
-#endif
-u8 ricoh619_pwr_key_reg;
-static irqreturn_t ricoh619_irq(int irq, void *data)
-{
-	struct ricoh619 *ricoh619 = data;
-	u8 int_sts[MAX_INTERRUPT_MASKS];
-	u8 master_int;
-	int i;
-	int ret;
-	unsigned int rtc_int_sts = 0;
-	int cur_irq = 0;
-
-	ret = ricoh619_read(ricoh619->dev, RICOH619_INT_IR_SYS, &ricoh619_pwr_key_reg);
-
-	/* Clear the status */
-	for (i = 0; i < MAX_INTERRUPT_MASKS; i++)
-		int_sts[i] = 0;
-
-	ret = ricoh619_read(ricoh619->dev, RICOH619_INTC_INTMON,
-						&master_int);
-//	printk("PMU1: %s: master_int=0x%x\n", __func__, master_int);
-	if (ret < 0) {
-		dev_err(ricoh619->dev, "Error in reading reg 0x%02x "
-			"error: %d\n", RICOH619_INTC_INTMON, ret);
-		return IRQ_HANDLED;
-	}
-
-	for (i = 0; i < MAX_INTERRUPT_MASKS; ++i) {
-		/* Even if INTC_INTMON register = 1, INT signal might not output
-	  	 because INTC_INTMON register indicates only interrupt facter level.
-	  	 So remove the following procedure */
-		if (!(master_int & main_int_type[i]))
-			continue;
-			
-		ret = ricoh619_read(ricoh619->dev,
-				irq_mon_add[i], &int_sts[i]);
-//		printk("PMU2: %s: int_sts[%d]=0x%x\n", __func__,i, int_sts[i]);
-		if (ret < 0) {
-			dev_err(ricoh619->dev, "Error in reading reg 0x%02x "
-				"error: %d\n", irq_mon_add[i], ret);
-			int_sts[i] = 0;
-			continue;
-		}
-		if (!int_sts[i])
-			continue;
-
-		if (main_int_type[i] & RTC_INT) {
-			// Changes status bit position from RTCCNT2 to RTCCNT1 
-			rtc_int_sts = 0;
-			if (int_sts[i] & 0x1)
-				rtc_int_sts |= BIT(6);
-			if (int_sts[i] & 0x4)
-				rtc_int_sts |= BIT(0);
-		}
-
-		if(irq_clr_add[i] == RICOH619_INT_IR_RTC)
-		{
-			int_sts[i] &= ~0x85;
-			ret = ricoh619_write(ricoh619->dev,
-				irq_clr_add[i], int_sts[i]);
-			if (ret < 0)
-				dev_err(ricoh619->dev, "Error in writing reg 0x%02x "
-					"error: %d\n", irq_clr_add[i], ret);
-		}
-		else
-		{
-			ret = ricoh619_write(ricoh619->dev,
-				irq_clr_add[i], ~int_sts[i]);
-			if (ret < 0)
-				dev_err(ricoh619->dev, "Error in reading reg 0x%02x "
-				"error: %d\n", irq_clr_add[i], ret);
-		}
-		
-		/* Mask Charger Interrupt */
-		if (main_int_type[i] & CHG_INT) {
-			if (int_sts[i]) {
-				ret = ricoh619_write(ricoh619->dev,
-							irq_en_add[i], 0xff);
-				if (ret < 0) {
-					dev_err(ricoh619->dev,
-						"Error in write reg 0x%02x error: %d\n",
-							irq_en_add[i], ret);
-				}
-			}
-		}
-		/* Mask ADC Interrupt */
-		if (main_int_type[i] & ADC_INT) {
-			if (int_sts[i]) {
-				ret = ricoh619_write(ricoh619->dev,
-							irq_en_add[i], 0);
-				if (ret < 0) {
-					dev_err(ricoh619->dev,
-						"Error in write reg 0x%02x error: %d\n",
-							irq_en_add[i], ret);
-				}
-			}
-		}
-
-		if (main_int_type[i] & RTC_INT)
-			int_sts[i] = rtc_int_sts;
-
-	}
-
-	/* Merge gpio interrupts  for rising and falling case*/
-	int_sts[6] |= int_sts[7];
-
-	/* Call interrupt handler if enabled */
-        mutex_lock(&int_flag_mutex);
-	for (i = 0; i <RICOH619_NR_IRQS; ++i) {
-		const struct ricoh619_irq_data *data = &ricoh619_irqs[i];
-		if ((int_sts[data->mask_reg_index] & (1 << data->int_en_bit)) &&(ricoh619->group_irq_en[data->master_bit] & (1 << data->grp_index))){
-			cur_irq = irq_find_mapping(ricoh619->irq_domain, i);
-			if (cur_irq)
-				handle_nested_irq(cur_irq);
-		}
-	}
-        mutex_unlock(&int_flag_mutex);
-
-//	printk(KERN_INFO "PMU: %s: out\n", __func__);
-	return IRQ_HANDLED;
-}
-
-static struct irq_chip ricoh619_irq_chip = {
-	.name = "ricoh619",
-	//.irq_mask = ricoh619_irq_mask,
-	//.irq_unmask = ricoh619_irq_unmask,
-	.irq_enable = ricoh619_irq_unmask,
-	.irq_disable = ricoh619_irq_mask,
-	.irq_bus_lock = ricoh619_irq_lock,
-	.irq_bus_sync_unlock = ricoh619_irq_sync_unlock,
-	.irq_set_type = ricoh619_irq_set_type,
-	.irq_set_wake = ricoh619_irq_set_wake,
-};
-
-static int ricoh619_irq_domain_map(struct irq_domain *d, unsigned int irq,
-					irq_hw_number_t hw)
-{
-	struct ricoh619 *ricoh619 = d->host_data;
-
-	irq_set_chip_data(irq, ricoh619);
-	irq_set_chip_and_handler(irq, &ricoh619_irq_chip, handle_edge_irq);
-	irq_set_nested_thread(irq, 1);
-#ifdef CONFIG_ARM
-	set_irq_flags(irq, IRQF_VALID);
-#else
-	irq_set_noprobe(irq);
-#endif
-	return 0;
-}
-
-static struct irq_domain_ops ricoh619_irq_domain_ops = {
-	.map = ricoh619_irq_domain_map,
-};
-
-int ricoh619_irq_init(struct ricoh619 *ricoh619, int irq,
-				struct ricoh619_platform_data *pdata)
-{
-	int i, ret,val,irq_type,flags;
-	u8 reg_data = 0;
-	struct irq_domain *domain;
-	
-	//	printk("%s,line=%d\n", __func__,__LINE__);	
-	if (!irq) {
-		dev_warn(ricoh619->dev, "No interrupt support, no core IRQ\n");
-		return 0;
-	}
-	
-	mutex_init(&ricoh619->irq_lock);
-
-	/* Initialize all locals to 0 */
-	for (i = 0; i < 2; i++) {
-		ricoh619->irq_en_cache[i] = 0;
-		ricoh619->irq_en_reg[i] = 0;
-	}
-
-	/* Initialize rtc */
-	ricoh619->irq_en_cache[2] = 0x20;
-	ricoh619->irq_en_reg[2] = 0x20;
-
-	/* Initialize all locals to 0 */
-	for (i = 3; i < 8; i++) {
-		ricoh619->irq_en_cache[i] = 0;
-		ricoh619->irq_en_reg[i] = 0;
-	}
-
-	// Charger Mask register must be set to 1 for masking Int output.
-	for (i = 8; i < MAX_INTERRUPT_MASKS; i++) {
-		ricoh619->irq_en_cache[i] = 0xff;
-		ricoh619->irq_en_reg[i] = 0xff;
-	}
-	
-	ricoh619->intc_inten_cache = 0;
-	ricoh619->intc_inten_reg = 0;
-	for (i = 0; i < MAX_GPEDGE_REG; i++) {
-		ricoh619->gpedge_cache[i] = 0;
-		ricoh619->gpedge_reg[i] = 0;
-	}
-
-	/* Initailize all int register to 0 */
-	for (i = 0; i < MAX_INTERRUPT_MASKS; i++)  {
-		ret = ricoh619_write(ricoh619->dev,
-				irq_en_add[i],
-				ricoh619->irq_en_reg[i]);
-		if (ret < 0)
-			dev_err(ricoh619->dev, "Error in writing reg 0x%02x "
-				"error: %d\n", irq_en_add[i], ret);
-	}
-
-	for (i = 0; i < MAX_GPEDGE_REG; i++)  {
-		ret = ricoh619_write(ricoh619->dev,
-				gpedge_add[i],
-				ricoh619->gpedge_reg[i]);
-		if (ret < 0)
-			dev_err(ricoh619->dev, "Error in writing reg 0x%02x "
-				"error: %d\n", gpedge_add[i], ret);
-	}
-
-	ret = ricoh619_write(ricoh619->dev, RICOH619_INTC_INTEN, 0x0);
-	if (ret < 0)
-		dev_err(ricoh619->dev, "Error in writing reg 0x%02x "
-				"error: %d\n", RICOH619_INTC_INTEN, ret);
-
-	/* Clear all interrupts in case they woke up active. */
-	for (i = 0; i < MAX_INTERRUPT_MASKS; i++)  {
-		if(irq_clr_add[i] != RICOH619_INT_IR_RTC)
-		{
-			ret = ricoh619_write(ricoh619->dev,
-					irq_clr_add[i], 0);
-			if (ret < 0)
-				dev_err(ricoh619->dev, "Error in writing reg 0x%02x "
-					"error: %d\n", irq_clr_add[i], ret);
-		}
-		else
-		{
-			ret = ricoh619_read(ricoh619->dev,
-					RICOH619_INT_IR_RTC, &reg_data);
-			if (ret < 0)
-				dev_err(ricoh619->dev, "Error in reading reg 0x%02x "
-					"error: %d\n", RICOH619_INT_IR_RTC, ret);
-			reg_data &= 0xf0;
-			ret = ricoh619_write(ricoh619->dev,
-					RICOH619_INT_IR_RTC, reg_data);
-			if (ret < 0)
-				dev_err(ricoh619->dev, "Error in writing reg 0x%02x "
-					"error: %d\n", RICOH619_INT_IR_RTC, ret);
-			
-		}
-	}
-
-	if (pdata->irq_gpio && !ricoh619->chip_irq) {
-		ricoh619->chip_irq = gpio_to_irq(pdata->irq_gpio);
-
-		if (pdata->irq_gpio) {
-			ret = gpio_request(pdata->irq_gpio, "ricoh619_pmic_irq");
-			if (ret < 0) {
-				dev_err(ricoh619->dev,
-					"Failed to request gpio %d with ret:"
-					"%d\n",	pdata->irq_gpio, ret);
-				return IRQ_NONE;
-			}
-			gpio_direction_input(pdata->irq_gpio);
-			val = gpio_get_value(pdata->irq_gpio);
-			if (val){
-				irq_type = IRQ_TYPE_LEVEL_LOW;
-				flags = IRQF_TRIGGER_LOW;
-			}
-			else{
-				irq_type = IRQ_TYPE_LEVEL_HIGH;
-				flags = IRQF_TRIGGER_HIGH;
-			}
-			gpio_free(pdata->irq_gpio);
-			pr_info("%s: ricoh619_pmic_irq=%x\n", __func__, val);
-		}
-	}
-	
-	domain = irq_domain_add_linear(NULL, RICOH619_NR_IRQS,
-					&ricoh619_irq_domain_ops, ricoh619);
-	if (!domain) {
-		dev_err(ricoh619->dev, "could not create irq domain\n");
-		return -ENODEV;
-	}
-	ricoh619->irq_domain = domain;
-	ret = devm_request_threaded_irq(ricoh619->dev,ricoh619->chip_irq, NULL, ricoh619_irq, flags |IRQF_ONESHOT, "ricoh619", ricoh619);
-//	ret = devm_request_threaded_irq(ricoh619->dev,ricoh619->chip_irq, NULL, ricoh619_irq, IRQF_TRIGGER_FALLING | IRQF_ONESHOT , "ricoh619", ricoh619);
-
-	irq_set_irq_type(ricoh619->chip_irq, irq_type);
-	enable_irq_wake(ricoh619->chip_irq);
-	return ret;
-}
-
-int ricoh619_irq_exit(struct ricoh619 *ricoh619)
-{
-	return 0;
-}
-
diff --git a/drivers/mfd/ricoh619.c b/drivers/mfd/ricoh619.c
deleted file mode 100755
index c20f1aebd21a..000000000000
--- a/drivers/mfd/ricoh619.c
+++ /dev/null
@@ -1,1022 +0,0 @@
-/* 
- * driver/mfd/ricoh619.c
- *
- * Core driver implementation to access RICOH RC5T619 power management chip.
- *
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * Based on code
- *	Copyright (C) 2011 NVIDIA Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-/*#define DEBUG			1*/
-/*#define VERBOSE_DEBUG		1*/
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/mfd/core.h>
-#include <linux/mfd/ricoh619.h>
-#include <linux/power/ricoh619_battery.h>
-#include <linux/of_irq.h>
-#include <linux/of_gpio.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/regulator/of_regulator.h>
-#include <linux/regulator/driver.h>
-#include <linux/regulator/machine.h>
-#include <linux/regmap.h>
-#include <linux/delay.h>
-#include <linux/syscore_ops.h>
-
-struct ricoh619 *g_ricoh619;
-struct sleep_control_data {
-	u8 reg_add;
-};
-static struct mfd_cell ricoh619s[] = {
-	{
-		.name = "ricoh619-regulator",
-	},
-	{
-		.name = "ricoh619-battery",
-	},
-	{
-		.name = "ricoh619-rtc",
-	},
-	{
-		.name = "ricoh619-pwrkey",
-	},
-};
-
-
-#define SLEEP_INIT(_id, _reg)		\
-	[RICOH619_DS_##_id] = {.reg_add = _reg}
-/*
-static struct sleep_control_data sleep_data[] = {
-	SLEEP_INIT(DC1, 0x16),
-	SLEEP_INIT(DC2, 0x17),
-	SLEEP_INIT(DC3, 0x18),
-	SLEEP_INIT(DC4, 0x19),
-	SLEEP_INIT(DC5, 0x1A),
-	SLEEP_INIT(LDO1, 0x1B),
-	SLEEP_INIT(LDO2, 0x1C),
-	SLEEP_INIT(LDO3, 0x1D),
-	SLEEP_INIT(LDO4, 0x1E),
-	SLEEP_INIT(LDO5, 0x1F),
-	SLEEP_INIT(LDO6, 0x20),
-	SLEEP_INIT(LDO7, 0x21),
-	SLEEP_INIT(LDO8, 0x22),
-	SLEEP_INIT(LDO9, 0x23),
-	SLEEP_INIT(LDO10, 0x24),
-	SLEEP_INIT(PSO0, 0x25),
-	SLEEP_INIT(PSO1, 0x26),
-	SLEEP_INIT(PSO2, 0x27),
-	SLEEP_INIT(PSO3, 0x28),
-	SLEEP_INIT(PSO4, 0x29),
-	SLEEP_INIT(LDORTC1, 0x2A),
-};
-*/
-static inline int __ricoh619_read(struct i2c_client *client,
-				  u8 reg, uint8_t *val)
-{
-	int ret =0;
-	ret = i2c_smbus_read_byte_data(client, reg);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed reading at 0x%02x %d\n", reg,ret);
-		return ret;
-	}
-
-	*val = (uint8_t)ret;
-	dev_dbg(&client->dev, "ricoh619: reg read  reg=%x, val=%x\n",
-				reg, *val);
-	return 0;
-}
-
-static inline int __ricoh619_bulk_reads(struct i2c_client *client, u8 reg,
-				int len, uint8_t *val)
-{
-	int ret;
-	int i;
-
-	ret = i2c_smbus_read_i2c_block_data(client, reg, len, val);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed reading from 0x%02x %dn", reg,ret);
-		return ret;
-	}
-	for (i = 0; i < len; ++i) {
-		dev_dbg(&client->dev, "ricoh619: reg read  reg=%x, val=%x\n",
-				reg + i, *(val + i));
-	}
-	return 0;
-}
-
-static inline int __ricoh619_write(struct i2c_client *client,
-				 u8 reg, uint8_t val)
-{
-	int ret=0;
-
-	dev_dbg(&client->dev, "ricoh619: reg write  reg=%x, val=%x\n",
-				reg, val);
-	ret = i2c_smbus_write_byte_data(client, reg, val);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n",
-				val, reg);
-		return ret;
-	}
-	return 0;
-}
-
-static inline int __ricoh619_bulk_writes(struct i2c_client *client, u8 reg,
-				  int len, uint8_t *val)
-{
-	int ret=0;
-	int i;
-
-	for (i = 0; i < len; ++i) {
-		dev_dbg(&client->dev, "ricoh619: reg write  reg=%x, val=%x\n",
-				reg + i, *(val + i));
-	}
-
-	ret = i2c_smbus_write_i2c_block_data(client, reg, len, val);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed writings to 0x%02x\n", reg);
-		return ret;
-	}
-	return 0;
-}
-
-static inline int set_bank_ricoh619(struct device *dev, int bank)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret;
-
-	if (bank != (bank & 1))
-		return -EINVAL;
-	if (bank == ricoh619->bank_num)
-		return 0;
-	ret = __ricoh619_write(to_i2c_client(dev), RICOH619_REG_BANKSEL, bank);
-	if (!ret)
-		ricoh619->bank_num = bank;
-
-	return ret;
-}
-
-int ricoh619_write(struct device *dev, u8 reg, uint8_t val)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 0);
-	if( !ret )
-		ret = __ricoh619_write(to_i2c_client(dev), reg, val);
-	mutex_unlock(&ricoh619->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_write);
-
-int ricoh619_write_bank1(struct device *dev, u8 reg, uint8_t val)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 1);
-	if( !ret ) 
-		ret = __ricoh619_write(to_i2c_client(dev), reg, val);
-	mutex_unlock(&ricoh619->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_write_bank1);
-
-int ricoh619_bulk_writes(struct device *dev, u8 reg, u8 len, uint8_t *val)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 0);
-	if( !ret )
-		ret = __ricoh619_bulk_writes(to_i2c_client(dev), reg, len, val);
-	mutex_unlock(&ricoh619->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_bulk_writes);
-
-int ricoh619_bulk_writes_bank1(struct device *dev, u8 reg, u8 len, uint8_t *val)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 1);
-	if( !ret ) 
-		ret = __ricoh619_bulk_writes(to_i2c_client(dev), reg, len, val);
-	mutex_unlock(&ricoh619->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_bulk_writes_bank1);
-
-int ricoh619_read(struct device *dev, u8 reg, uint8_t *val)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 0);
-	if( !ret )
-		ret = __ricoh619_read(to_i2c_client(dev), reg, val);
-	mutex_unlock(&ricoh619->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_read);
-
-int ricoh619_read_bank1(struct device *dev, u8 reg, uint8_t *val)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 1);
-	if( !ret )
-		ret =  __ricoh619_read(to_i2c_client(dev), reg, val);
-	mutex_unlock(&ricoh619->io_lock);
-
-	return ret;
-}
-
-EXPORT_SYMBOL_GPL(ricoh619_read_bank1);
-
-int ricoh619_bulk_reads(struct device *dev, u8 reg, u8 len, uint8_t *val)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 0);
-	if( !ret ) 
-		ret = __ricoh619_bulk_reads(to_i2c_client(dev), reg, len, val);
-	mutex_unlock(&ricoh619->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_bulk_reads);
-
-int ricoh619_bulk_reads_bank1(struct device *dev, u8 reg, u8 len, uint8_t *val)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 1);
-	if( !ret ) 
-		ret = __ricoh619_bulk_reads(to_i2c_client(dev), reg, len, val);
-	mutex_unlock(&ricoh619->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_bulk_reads_bank1);
-
-int ricoh619_set_bits(struct device *dev, u8 reg, uint8_t bit_mask)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	uint8_t reg_val;
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 0);
-	if (!ret) {
-		ret = __ricoh619_read(to_i2c_client(dev), reg, &reg_val);
-		if (ret<0)
-			goto out;
-
-		if ((reg_val & bit_mask) != bit_mask) {
-			reg_val |= bit_mask;
-			ret = __ricoh619_write(to_i2c_client(dev), reg,
-								 reg_val);
-		}
-	}
-out:
-	mutex_unlock(&ricoh619->io_lock);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_set_bits);
-
-int ricoh619_clr_bits(struct device *dev, u8 reg, uint8_t bit_mask)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	uint8_t reg_val;
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 0);
-	if( !ret ){
-		ret = __ricoh619_read(to_i2c_client(dev), reg, &reg_val);
-		if (ret<0)
-			goto out;
-
-		if (reg_val & bit_mask) {
-			reg_val &= ~bit_mask;
-			ret = __ricoh619_write(to_i2c_client(dev), reg,
-								 reg_val);
-		}
-	}
-out:
-	mutex_unlock(&ricoh619->io_lock);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_clr_bits);
-
-int ricoh619_update(struct device *dev, u8 reg, uint8_t val, uint8_t mask)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	uint8_t reg_val;
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 0);
-	if( !ret ){
-		ret = __ricoh619_read(ricoh619->client, reg, &reg_val);
-		if (ret<0)
-			goto out;
-
-		if ((reg_val & mask) != val) {
-			reg_val = (reg_val & ~mask) | (val & mask);
-			ret = __ricoh619_write(ricoh619->client, reg, reg_val);
-		}
-	}
-out:
-	mutex_unlock(&ricoh619->io_lock);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_update);
-
-int ricoh619_update_bank1(struct device *dev, u8 reg, uint8_t val, uint8_t mask)
-{
-	struct ricoh619 *ricoh619 = dev_get_drvdata(dev);
-	uint8_t reg_val;
-	int ret = 0;
-
-	mutex_lock(&ricoh619->io_lock);
-	ret = set_bank_ricoh619(dev, 1);
-	if( !ret ){
-		ret = __ricoh619_read(ricoh619->client, reg, &reg_val);
-		if (ret<0)
-			goto out;
-
-		if ((reg_val & mask) != val) {
-			reg_val = (reg_val & ~mask) | (val & mask);
-			ret = __ricoh619_write(ricoh619->client, reg, reg_val);
-		}
-	}
-out:
-	mutex_unlock(&ricoh619->io_lock);
-	return ret;
-}
-
-static struct i2c_client *ricoh619_i2c_client;
-static void ricoh619_device_shutdown(void)
-{
-	int ret;
-	uint8_t val;
-	struct ricoh619 *ricoh619 = g_ricoh619;
-	printk("%s,line=%d\n", __func__,__LINE__);
-
-#ifdef CONFIG_BATTERY_RICOH619
-	val = g_soc;
-	val &= 0x7f;
-	ret = ricoh619_write(ricoh619->dev, RICOH619_PSWR, val);
-	if (ret < 0)
-		dev_err(ricoh619->dev, "Error in writing PSWR_REG\n");
-
-	if (g_fg_on_mode == 0) {
-		ret = ricoh619_clr_bits(ricoh619->dev,
-					 RICOH619_FG_CTRL, 0x01);
-		if (ret < 0)
-			dev_err(ricoh619->dev, "Error in writing FG_CTRL\n");
-	}
-	
-	/* set rapid timer 300 min */
-	ret = ricoh619_set_bits(ricoh619->dev, TIMSET_REG, 0x03);
-	if (ret < 0)
-		dev_err(ricoh619->dev, "Error in writing the TIMSET_Reg\n");
-#endif  
-	ret = ricoh619_clr_bits(ricoh619->dev, 0xae, (0x1 <<6)); //disable alam_d
-       ret = ricoh619_write(ricoh619->dev, RICOH619_INTC_INTEN, 0); 
-	ret = ricoh619_clr_bits(ricoh619->dev,RICOH619_PWR_REP_CNT,(0x1<<0));//Not repeat power ON after power off(Power Off/N_OE)
-	mutex_lock(&ricoh619->io_lock);
-	mdelay(100);
-}
-EXPORT_SYMBOL_GPL(ricoh619_device_shutdown);
-static void ricoh619_power_off(void)
-{
-	int ret,i=0;
-	uint8_t val,charge_state;
-	struct i2c_client *client = ricoh619_i2c_client;
-
-	for(i=0;i < 10;i++){
-		printk("%s,line=%d\n", __func__,__LINE__);
-		#ifdef CONFIG_BATTERY_RICOH619
-			ret = __ricoh619_read(client, 0xBD, &val);
-			if(ret < 0)
-				continue;
-			charge_state = (val & 0x1F);
-			if(( charge_state == CHG_STATE_CHG_TRICKLE)||( charge_state == CHG_STATE_CHG_RAPID) ||(charge_state == CHG_STATE_CHG_COMPLETE)){
-			 ret = __ricoh619_read(client, RICOH619_PWR_REP_CNT,&val);//Power OFF
-			 if(ret < 0)
-				continue;
-		 	ret = __ricoh619_write(client, RICOH619_PWR_REP_CNT,(val |(0x1<<0)));//Power OFF
-		 	if(ret < 0)
-				continue;
-		}
-		#endif  
-		ret = __ricoh619_read(client, RICOH619_PWR_SLP_CNT,&val);//Power OFF
-		if(ret < 0)
-			continue;
-		ret = __ricoh619_write(client, RICOH619_PWR_SLP_CNT,(val |(0x1<<0)));//Power OFF
-		if (ret < 0) {
-			printk("ricoh619 power off error!\n");
-			continue;
-		}
-	}
-	while(1)wfi();
-}
-EXPORT_SYMBOL_GPL(ricoh619_power_off);
-
-#if 0
-static int ricoh619_gpio_get(struct gpio_chip *gc, unsigned offset)
-{
-	struct ricoh619 *ricoh619 = container_of(gc, struct ricoh619, gpio_chip);
-	uint8_t val;
-	int ret;
-
-	ret = ricoh619_read(ricoh619->dev, RICOH619_GPIO_MON_IOIN, &val);
-	if (ret < 0)
-		return ret;
-
-	return ((val & (0x1 << offset)) != 0);
-}
-
-static void ricoh619_gpio_set(struct gpio_chip *gc, unsigned offset,
-			int value)
-{
-	struct ricoh619 *ricoh619 = container_of(gc, struct ricoh619, gpio_chip);
-	if (value)
-		ricoh619_set_bits(ricoh619->dev, RICOH619_GPIO_IOOUT,
-						1 << offset);
-	else
-		ricoh619_clr_bits(ricoh619->dev, RICOH619_GPIO_IOOUT,
-						1 << offset);
-}
-
-static int ricoh619_gpio_input(struct gpio_chip *gc, unsigned offset)
-{
-	struct ricoh619 *ricoh619 = container_of(gc, struct ricoh619, gpio_chip);
-
-	return ricoh619_clr_bits(ricoh619->dev, RICOH619_GPIO_IOSEL,
-						1 << offset);
-}
-
-static int ricoh619_gpio_output(struct gpio_chip *gc, unsigned offset,
-				int value)
-{
-	struct ricoh619 *ricoh619 = container_of(gc, struct ricoh619, gpio_chip);
-
-	ricoh619_gpio_set(gc, offset, value);
-	return ricoh619_set_bits(ricoh619->dev, RICOH619_GPIO_IOSEL,
-						1 << offset);
-}
-
-static int ricoh619_gpio_to_irq(struct gpio_chip *gc, unsigned off)
-{
-	struct ricoh619 *ricoh619 = container_of(gc, struct ricoh619, gpio_chip);
-
-	if ((off >= 0) && (off < 8))
-		return ricoh619->irq_base + RICOH619_IRQ_GPIO0 + off;
-
-	return -EIO;
-}
-
-static void ricoh619_gpio_init(struct ricoh619 *ricoh619,
-	struct ricoh619_platform_data *pdata)
-{
-	int ret;
-	int i;
-	struct ricoh619_gpio_init_data *ginit;
-
-	if (pdata->gpio_base  <= 0)
-		return;
-
-	for (i = 0; i < pdata->num_gpioinit_data; ++i) {
-		ginit = &pdata->gpio_init_data[i];
-
-		if (!ginit->init_apply)
-			continue;
-
-		if (ginit->output_mode_en) {
-			/* GPIO output mode */
-			if (ginit->output_val)
-				/* output H */
-				ret = ricoh619_set_bits(ricoh619->dev,
-					RICOH619_GPIO_IOOUT, 1 << i);
-			else
-				/* output L */
-				ret = ricoh619_clr_bits(ricoh619->dev,
-					RICOH619_GPIO_IOOUT, 1 << i);
-			if (!ret)
-				ret = ricoh619_set_bits(ricoh619->dev,
-					RICOH619_GPIO_IOSEL, 1 << i);
-		} else
-			/* GPIO input mode */
-			ret = ricoh619_clr_bits(ricoh619->dev,
-					RICOH619_GPIO_IOSEL, 1 << i);
-
-		/* if LED function enabled in OTP */
-		if (ginit->led_mode) {
-			/* LED Mode 1 */
-			if (i == 0)	/* GP0 */
-				ret = ricoh619_set_bits(ricoh619->dev,
-					 RICOH619_GPIO_LED_FUNC,
-					 0x04 | (ginit->led_func & 0x03));
-			if (i == 1)	/* GP1 */
-				ret = ricoh619_set_bits(ricoh619->dev,
-					 RICOH619_GPIO_LED_FUNC,
-					 0x40 | (ginit->led_func & 0x03) << 4);
-
-		}
-
-
-		if (ret < 0)
-			dev_err(ricoh619->dev, "Gpio %d init "
-				"dir configuration failed: %d\n", i, ret);
-
-	}
-
-	ricoh619->gpio_chip.owner		= THIS_MODULE;
-	ricoh619->gpio_chip.label		= ricoh619->client->name;
-	ricoh619->gpio_chip.dev			= ricoh619->dev;
-	ricoh619->gpio_chip.base		= pdata->gpio_base;
-	ricoh619->gpio_chip.ngpio		= RICOH619_NR_GPIO;
-	ricoh619->gpio_chip.can_sleep	= 1;
-
-	ricoh619->gpio_chip.direction_input	= ricoh619_gpio_input;
-	ricoh619->gpio_chip.direction_output	= ricoh619_gpio_output;
-	ricoh619->gpio_chip.set			= ricoh619_gpio_set;
-	ricoh619->gpio_chip.get			= ricoh619_gpio_get;
-	ricoh619->gpio_chip.to_irq	  	= ricoh619_gpio_to_irq;
-
-	ret = gpiochip_add(&ricoh619->gpio_chip);
-	if (ret)
-		dev_warn(ricoh619->dev, "GPIO registration failed: %d\n", ret);
-}
-#endif
-static int ricoh619_remove_subdev(struct device *dev, void *unused)
-{
-	platform_device_unregister(to_platform_device(dev));
-	return 0;
-}
-
-static int ricoh619_remove_subdevs(struct ricoh619 *ricoh619)
-{
-	return device_for_each_child(ricoh619->dev, NULL,
-				     ricoh619_remove_subdev);
-}
-#if 0
-static int ricoh619_add_subdevs(struct ricoh619 *ricoh619,
-				struct ricoh619_platform_data *pdata)
-{
-	struct ricoh619_subdev_info *subdev;
-	struct platform_device *pdev;
-	int i, ret = 0;
-
-	for (i = 0; i < pdata->num_subdevs; i++) {
-		subdev = &pdata->subdevs[i];
-
-		pdev = platform_device_alloc(subdev->name, subdev->id);
-
-		pdev->dev.parent = ricoh619->dev;
-		pdev->dev.platform_data = subdev->platform_data;
-
-		ret = platform_device_add(pdev);
-		if (ret)
-			goto failed;
-	}
-	return 0;
-
-failed:
-	ricoh619_remove_subdevs(ricoh619);
-	return ret;
-}
-#endif
-#ifdef CONFIG_DEBUG_FS
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-static void print_regs(const char *header, struct seq_file *s,
-		struct i2c_client *client, int start_offset,
-		int end_offset)
-{
-	uint8_t reg_val;
-	int i;
-	int ret;
-
-	seq_printf(s, "%s\n", header);
-	for (i = start_offset; i <= end_offset; ++i) {
-		ret = __ricoh619_read(client, i, &reg_val);
-		if (ret >= 0)
-			seq_printf(s, "Reg 0x%02x Value 0x%02x\n", i, reg_val);
-	}
-	seq_printf(s, "------------------\n");
-}
-
-static int dbg_ricoh_show(struct seq_file *s, void *unused)
-{
-	struct ricoh619 *ricoh = s->private;
-	struct i2c_client *client = ricoh->client;
-
-	seq_printf(s, "RICOH619 Registers\n");
-	seq_printf(s, "------------------\n");
-
-	print_regs("System Regs",		s, client, 0x0, 0x05);
-	print_regs("Power Control Regs",	s, client, 0x07, 0x2B);
-	print_regs("DCDC  Regs",		s, client, 0x2C, 0x43);
-	print_regs("LDO   Regs",		s, client, 0x44, 0x61);
-	print_regs("ADC   Regs",		s, client, 0x64, 0x8F);
-	print_regs("GPIO  Regs",		s, client, 0x90, 0x98);
-	print_regs("INTC  Regs",		s, client, 0x9C, 0x9E);
-	print_regs("RTC   Regs",		s, client, 0xA0, 0xAF);
-	print_regs("OPT   Regs",		s, client, 0xB0, 0xB1);
-	print_regs("CHG   Regs",		s, client, 0xB2, 0xDF);
-	print_regs("FUEL  Regs",		s, client, 0xE0, 0xFC);
-	return 0;
-}
-
-static int dbg_ricoh_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, dbg_ricoh_show, inode->i_private);
-}
-
-static const struct file_operations debug_fops = {
-	.open		= dbg_ricoh_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-static void __init ricoh619_debuginit(struct ricoh619 *ricoh)
-{
-	(void)debugfs_create_file("ricoh619", S_IRUGO, NULL,
-			ricoh, &debug_fops);
-}
-#else
-static void print_regs(const char *header, struct i2c_client *client,
-		int start_offset, int end_offset)
-{
-	uint8_t reg_val;
-	int i;
-	int ret;
-
-	printk(KERN_INFO "%s\n", header);
-	for (i = start_offset; i <= end_offset; ++i) {
-		ret = __ricoh619_read(client, i, &reg_val);
-		if (ret >= 0)
-			printk(KERN_INFO "Reg 0x%02x Value 0x%02x\n",
-							 i, reg_val);
-	}
-	printk(KERN_INFO "------------------\n");
-}
-static void __init ricoh619_debuginit(struct ricoh619 *ricoh)
-{
-	struct i2c_client *client = ricoh->client;
-
-	printk(KERN_INFO "RICOH619 Registers\n");
-	printk(KERN_INFO "------------------\n");
-
-	print_regs("System Regs",		client, 0x0, 0x05);
-	print_regs("Power Control Regs",	client, 0x07, 0x2B);
-	print_regs("DCDC  Regs",		client, 0x2C, 0x43);
-	print_regs("LDO   Regs",		client, 0x44, 0x5C);
-	print_regs("ADC   Regs",		client, 0x64, 0x8F);
-	print_regs("GPIO  Regs",		client, 0x90, 0x9B);
-	print_regs("INTC  Regs",		client, 0x9C, 0x9E);
-	print_regs("OPT   Regs",		client, 0xB0, 0xB1);
-	print_regs("CHG   Regs",		client, 0xB2, 0xDF);
-	print_regs("FUEL  Regs",		client, 0xE0, 0xFC);
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_OF
-static struct ricoh619_platform_data *ricoh619_parse_dt(struct ricoh619 *ricoh619)
-{
-	struct ricoh619_platform_data *pdata;
-	struct device_node *ricoh619_pmic_np;
-
-	ricoh619_pmic_np = of_node_get(ricoh619->dev->of_node);
-	if (!ricoh619_pmic_np) {
-		printk("could not find pmic sub-node\n");
-		return NULL;
-	}
-	pdata = devm_kzalloc(ricoh619->dev, sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)
-		return NULL;
-
-	pdata->irq_gpio = of_get_named_gpio(ricoh619_pmic_np,"gpios",0);
-		if (!gpio_is_valid(pdata->irq_gpio)) {
-			printk("invalid gpio: %d\n",  pdata->irq_gpio);
-			return NULL;
-		}
-
-	pdata->pmic_sleep_gpio = of_get_named_gpio(ricoh619_pmic_np,"gpios",1);
-			if (!gpio_is_valid(pdata->pmic_sleep_gpio)) {
-				printk("invalid gpio: %d\n",  pdata->pmic_sleep_gpio);
-		}
-
-	pdata->dc_det = of_get_named_gpio(ricoh619_pmic_np,"gpios",2);
-			if (!gpio_is_valid(pdata->dc_det)) {
-				printk("invalid gpio: %d\n",  pdata->dc_det);
-		}
-	pdata->pmic_sleep = true;
-	
-	pdata->pm_off = of_property_read_bool(ricoh619_pmic_np,"ricoh619,system-power-controller");
-		
-	return pdata;
-}
-
-#else
-static struct ricoh619_platform_data *ricoh619_parse_dt(struct ricoh619 *ricoh619)
-{
-	return NULL;
-}
-#endif
-
-static struct syscore_ops ricoh619_syscore_ops = {
-	.shutdown = ricoh619_device_shutdown,
-};
-
-static void ricoh619_noe_init(struct ricoh619 *ricoh)
-{
-	int ret;
-	
-	/***************set noe time 128ms**************/
-	ret = ricoh619_set_bits(ricoh->dev,0x11,(0x1 <<3));
-	ret = ricoh619_clr_bits(ricoh->dev,0x11,(0x7 <<0));
-	ret = ricoh619_clr_bits(ricoh->dev,0x11,(0x1 <<3));//N_OE timer setting to 128mS
- 	/**********************************************/
-	ret = ricoh619_clr_bits(ricoh->dev,RICOH619_PWR_REP_CNT,(1 << 0));  //Repeat power ON after reset (Power Off/N_OE) :1:reset 0:power off
-}
-
-static int ricoh619_pre_init(struct ricoh619 *ricoh619)
-{
-	int ret=0;
-	 printk("%s,line=%d\n", __func__,__LINE__);
-	 /*
-	ret = ricoh619_read(ricoh619->dev,0x09,&val);
-	printk("%s,line=%d ricoh619 power on his %08x\n", __func__,__LINE__,val);
-	ret = ricoh619_read(ricoh619->dev,0x0a,&val);
-	printk("%s,line=%d ricoh619 power off his %08x\n", __func__,__LINE__,val);
-	*/
-	ricoh619_set_bits(ricoh619->dev, 0xae, (0x1 <<6));//enable alam_d
-	ricoh619_write(ricoh619->dev, 0x2f, 0x43);//slove ripple
-	ricoh619_write(ricoh619->dev, 0x05, 0x07);//enable clkout2
-	
-	ricoh619_noe_init(ricoh619);
-	/***************set PKEY long press time 0sec*******/
-	ret = ricoh619_set_bits(ricoh619->dev,0x10,(0x1 <<7));
-	ret = ricoh619_clr_bits(ricoh619->dev,0x10,(0x1 <<3));
-	ret = ricoh619_clr_bits(ricoh619->dev,0x10,(0x1 <<7));
- 	/**********************************************/
-	ret = ricoh619_set_bits(ricoh619->dev,BATSET2_REG,(3 << 0)); 
-	ret = ricoh619_clr_bits(ricoh619->dev,BATSET2_REG,(1 << 2)); //set vrchg 4v
-
-	
-	return ret;
-}
-
-static int ricoh619_i2c_probe(struct i2c_client *client,
-			      const struct i2c_device_id *id)
-{
-	struct ricoh619 *ricoh619;
-	struct ricoh619_platform_data *pdata;
-	int ret;
-	uint8_t control;
-	int i=0;
-	 printk("%s,line=%d\n", __func__,__LINE__);
-
-	ricoh619 = devm_kzalloc(&client->dev,sizeof(struct ricoh619), GFP_KERNEL);
-	if (ricoh619 == NULL)
-		return -ENOMEM;
-
-	ricoh619->client = client;
-	ricoh619->dev = &client->dev;
-	i2c_set_clientdata(client, ricoh619);
-	mutex_init(&ricoh619->io_lock);
-
-	ret = ricoh619_read(ricoh619->dev, 0x36, &control);
-	if ((ret <0) || (control < 0) || (control == 0xff) || (control == 0) ){
-		if (ret <0){
-			printk(KERN_INFO "The device is not ricoh619 %08x %d\n",control,ret);
-			goto err;
-		}
-		else{
-			do{
-				ret = ricoh619_write(ricoh619->dev, 0xff, 0x00);
-				ret = ricoh619_read(ricoh619->dev, 0x36, &control);
-				i += 1;
-				printk(KERN_INFO "##################:read ricoh619 0x36 error retry %08x %d\n",control,ret);
-			}while( ((control == 0xff) || (control == 0) ) && (i < 10));
-			if ((control == 0xff) || (control == 0) ){
-				ret = -ENXIO;	
-				printk(KERN_INFO "##################The device is not ricoh619 %08x %d\n",control,ret);
-				goto err;
-			}
-		}
-	}
-
-	ret = ricoh619_pre_init(ricoh619);
-	if (ret < 0){
-		printk("The ricoh619_pre_init failed %d\n",ret);
-		goto err;
-	}
-
-	ricoh619->bank_num = 0;
-	
-	if (ricoh619->dev->of_node)
-		pdata = ricoh619_parse_dt(ricoh619);
-	
-	if (pdata->dc_det) 
-		ricoh619->dc_det = pdata->dc_det;
-	
-	/******************************set sleep vol & dcdc mode******************/
-	#ifdef CONFIG_OF
-	if (pdata->pmic_sleep_gpio) {
-			ret = gpio_request(pdata->pmic_sleep_gpio, "ricoh619_pmic_sleep");
-			if (ret < 0) {
-				dev_err(ricoh619->dev,"Failed to request gpio %d with ret:""%d\n",	pdata->pmic_sleep_gpio, ret);
-				return IRQ_NONE;
-			}
-			gpio_direction_output(pdata->pmic_sleep_gpio,0);
-			ret = gpio_get_value(pdata->pmic_sleep_gpio);
-			gpio_free(pdata->pmic_sleep_gpio);
-			pr_info("%s: ricoh619_pmic_sleep=%x\n", __func__, ret);
-	}	
-	#endif
-	/**********************************************************/
-	ret = ricoh619_irq_init(ricoh619, pdata->irq_gpio, pdata);
-	if (ret < 0)
-		goto err;
-	
-	ret = mfd_add_devices(ricoh619->dev, -1,
-			     ricoh619s, ARRAY_SIZE(ricoh619s),
-			      NULL, 0,NULL);
-	g_ricoh619 = ricoh619;
-	if (pdata->pm_off && !pm_power_off) {
-		pm_power_off = ricoh619_power_off;
-	}
-	ricoh619_debuginit(ricoh619);
-
-	ricoh619_i2c_client = client;
-	register_syscore_ops(&ricoh619_syscore_ops);
-	return 0;
-err:
-	mfd_remove_devices(ricoh619->dev);
-	return ret;
-}
-
-static int ricoh619_i2c_remove(struct i2c_client *client)
-{
-	struct ricoh619 *ricoh619 = i2c_get_clientdata(client);
-
-	unregister_syscore_ops(&ricoh619_syscore_ops);
-	ricoh619_remove_subdevs(ricoh619);
-	return 0;
-}
-
-#ifdef CONFIG_PM
-extern u8 ricoh619_pwr_key_reg;
-int ricoh619_pwrkey_wakeup = 0;
-static int ricoh619_i2c_suspend(struct i2c_client *client, pm_message_t state)
-{
-//	printk("PMU: %s: \n",__func__);
-
-	if (g_ricoh619->chip_irq)
-		disable_irq(g_ricoh619->chip_irq);
-	ricoh619_pwrkey_wakeup = 1;
-	__ricoh619_write(client, RICOH619_INT_IR_SYS, 0x0); //Clear PWR_KEY IRQ
-	 __ricoh619_read(client, RICOH619_INT_IR_SYS, &ricoh619_pwr_key_reg);
-	return 0;
-}
-static int ricoh619_i2c_resume(struct i2c_client *client)
-{
-	/*
-	uint8_t reg_val;
-	int ret;
-	ret = __ricoh619_read(client, RICOH619_INT_IR_SYS, &reg_val);
-	if(ricoh619_pwr_key_reg & 0x01) { //If PWR_KEY wakeup
-		//printk("PMU: %s: PWR_KEY Wakeup %08x\n",__func__,ricoh619_pwr_key_reg);
-		rcoh619_pwrkey_wakeup = 1;
-		__ricoh619_write(client, RICOH619_INT_IR_SYS, 0x0); //Clear PWR_KEY IRQ
-	}
-	*/
-	
-	if (g_ricoh619->chip_irq)
-		enable_irq(g_ricoh619->chip_irq);
-	return 0;
-}
-
-static int  ricoh619_i2c_late_suspend(struct device *dev)
-{
-	struct i2c_client *client = i2c_verify_client(dev);
-
-        ricoh619_i2c_suspend(client,PMSG_SUSPEND);
-	return 0;
-}
-
-static int rockchip_i2c_late_resume(struct device *dev)
-{
-	struct i2c_client *client = i2c_verify_client(dev);    
-    
-        ricoh619_i2c_resume(client);
-	return 0;
-}
-
-static const struct dev_pm_ops ricoh619_i2c_dev_pm= {
-	.suspend_late = ricoh619_i2c_late_suspend,
-	.resume_early = rockchip_i2c_late_resume,
-};
-
-#endif
-
-static const struct i2c_device_id ricoh619_i2c_id[] = {
-	{"ricoh619", 0},
-	{}
-};
-MODULE_DEVICE_TABLE(i2c, ricoh619_i2c_id);
-
-#ifdef CONFIG_OF
-static const struct of_device_id ricoh619_dt_match[] = {
-	{ .compatible = "ricoh,ricoh619", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ricoh619_dt_match);
-#endif
-
-static struct i2c_driver ricoh619_i2c_driver = {
-	.driver = {
-		   .name = "ricoh619",
-		   .owner = THIS_MODULE,
-                  #ifdef CONFIG_PM
-		    .pm	= (&ricoh619_i2c_dev_pm),
-                  #endif		   
-		   .of_match_table = of_match_ptr(ricoh619_dt_match),
-		   },
-	.probe = ricoh619_i2c_probe,
-	.remove = ricoh619_i2c_remove,
-
-	.id_table = ricoh619_i2c_id,
-};
-
-
-static int __init ricoh619_i2c_init(void)
-{
-	int ret = -ENODEV;
-	ret = i2c_add_driver(&ricoh619_i2c_driver);
-	if (ret != 0)
-		pr_err("Failed to register I2C driver: %d\n", ret);
-
-	return ret;
-}
-
-subsys_initcall_sync(ricoh619_i2c_init);
-
-static void __exit ricoh619_i2c_exit(void)
-{
-	i2c_del_driver(&ricoh619_i2c_driver);
-}
-
-module_exit(ricoh619_i2c_exit);
-
-MODULE_DESCRIPTION("RICOH RC5T619 PMU multi-function core driver");
-MODULE_AUTHOR("zhangqing <zhangqing@rock-chips.com>");
-MODULE_LICENSE("GPL");
diff --git a/drivers/power/ricoh619-battery.c b/drivers/power/ricoh619-battery.c
deleted file mode 100755
index 3e4d521c23c1..000000000000
--- a/drivers/power/ricoh619-battery.c
+++ /dev/null
@@ -1,5010 +0,0 @@
-/*
- * drivers/power/ricoh619-battery.c
- *
- * Charger driver for RICOH RC5T619 power management chip.
- *
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-#define RICOH619_BATTERY_VERSION "RICOH619_BATTERY_VERSION: 2014.05.06"
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/mutex.h>
-#include <linux/string.h>
-#include <linux/power_supply.h>
-#include <linux/mfd/ricoh619.h>
-#include <linux/power/ricoh619_battery.h>
-#include <linux/power/ricoh61x_battery_init.h>
-#include <linux/delay.h>
-#include <linux/workqueue.h>
-#include <linux/of.h>
-#include <linux/rk_keys.h>
-#include <linux/rtc.h>
-
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/irqdomain.h>
-
-
-/* define for function */
-#define ENABLE_FUEL_GAUGE_FUNCTION
-#define ENABLE_LOW_BATTERY_DETECTION
-//#define ENABLE_FACTORY_MODE
-#define DISABLE_CHARGER_TIMER
-/* #define ENABLE_FG_KEEP_ON_MODE */
-/* #define ENABLE_OCV_TABLE_CALIB */
-//#define SUPPORT_USB_CONNECT_TO_ADP
-
-
-/* FG setting */
-#define RICOH619_REL1_SEL_VALUE		64
-#define RICOH619_REL2_SEL_VALUE		0
-
-enum int_type {
-	SYS_INT  = 0x01,
-	DCDC_INT = 0x02,
-	ADC_INT  = 0x08,
-	GPIO_INT = 0x10,
-	CHG_INT	 = 0x40,
-};
-
-//for debug   #ifdef ENABLE_FUEL_GAUGE_FUNCTION
-/* define for FG delayed time */
-#define RICOH619_MONITOR_START_TIME		15
-#define RICOH619_FG_RESET_TIME			6
-#define RICOH619_FG_STABLE_TIME		120
-#define RICOH619_DISPLAY_UPDATE_TIME		15
-#define RICOH619_LOW_VOL_DOWN_TIME		10
-#define RICOH619_CHARGE_MONITOR_TIME		20
-#define RICOH619_CHARGE_RESUME_TIME		1
-#define RICOH619_CHARGE_CALC_TIME		1
-#define RICOH619_JEITA_UPDATE_TIME		60
-#define RICOH619_DELAY_TIME				60
-/* define for FG parameter */
-#define RICOH619_MAX_RESET_SOC_DIFF		5
-#define RICOH619_GET_CHARGE_NUM		10
-#define RICOH619_UPDATE_COUNT_DISP		4
-#define RICOH619_UPDATE_COUNT_FULL		4
-#define RICOH619_UPDATE_COUNT_FULL_RESET 	7
-#define RICOH619_CHARGE_UPDATE_TIME		3
-#define RICOH619_FULL_WAIT_TIME			4
-#define RE_CAP_GO_DOWN				10	/* 40 */
-#define RICOH619_ENTER_LOW_VOL			70
-#define RICOH619_TAH_SEL2			5
-#define RICOH619_TAL_SEL2			6
-
-#define RICOH619_OCV_OFFSET_BOUND	3
-#define RICOH619_OCV_OFFSET_RATIO	2
-
-#define RICOH619_VADP_DROP_WORK
-#define RICOH619_TIME_CHG_STEP	(1*HZ)// unit:secound
-#define RICOH619_TIME_CHG_COUNT	15*60//only for test //15*60 
-
-/* define for FG status */
-enum {
-	RICOH619_SOCA_START,
-	RICOH619_SOCA_UNSTABLE,
-	RICOH619_SOCA_FG_RESET,
-	RICOH619_SOCA_DISP,
-	RICOH619_SOCA_STABLE,
-	RICOH619_SOCA_ZERO,
-	RICOH619_SOCA_FULL,
-	RICOH619_SOCA_LOW_VOL,
-};
-//#endif
-
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-#define LOW_BATTERY_DETECTION_TIME		10
-#endif
-
-struct ricoh619_soca_info {
-	int Rbat;
-	int n_cap;
-	int ocv_table_def[11];
-	int ocv_table[11];
-	int ocv_table_low[11];
-	int soc;		/* Latest FG SOC value */
-	int displayed_soc;
-	int suspend_soc;
-	int status;		/* SOCA status 0: Not initial; 5: Finished */
-	int stable_count;
-	int chg_status;		/* chg_status */
-	int soc_delta;		/* soc delta for status3(DISP) */
-	int cc_delta;
-	int cc_cap_offset;
-	int last_soc;
-	int last_displayed_soc;
-	int ready_fg;
-	int reset_count;
-	int reset_soc[3];
-	int chg_cmp_times;
-	int dischg_state;
-	int Vbat[RICOH619_GET_CHARGE_NUM];
-	int Vsys[RICOH619_GET_CHARGE_NUM];
-	int Ibat[RICOH619_GET_CHARGE_NUM];
-	int Vbat_ave;
-	int Vbat_old;
-	int Vsys_ave;
-	int Ibat_ave;
-	int chg_count;
-	int full_reset_count;
-	int soc_full;
-	int fc_cap;
-	/* for LOW VOL state */
-	int target_use_cap;
-	int hurry_up_flg;
-	int zero_flg;
-	int re_cap_old;
-	int cutoff_ocv;
-	int Rsys;
-	int target_vsys;
-	int target_ibat;
-	int jt_limit;
-	int OCV100_min;
-	int OCV100_max;
-	int R_low;
-	int rsoc_ready_flag;
-	int init_pswr;
-	int last_cc_sum;
-};
-
-struct ricoh619_battery_info {
-	struct device      *dev;
-	struct power_supply	battery;
-	struct delayed_work	monitor_work;
-	struct delayed_work	displayed_work;
-	struct delayed_work	charge_stable_work;
-	struct delayed_work	changed_work;
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-	struct delayed_work	low_battery_work;
-#endif
-	struct delayed_work	charge_monitor_work;
-	struct delayed_work	get_charge_work;
-	struct delayed_work	jeita_work;
-	struct delayed_work	charge_complete_ready;
-
-	struct work_struct	irq_work;	/* for Charging & VUSB/VADP */
-	struct work_struct	usb_irq_work;	/* for ADC_VUSB */
-	#ifdef RICOH619_VADP_DROP_WORK
-	struct delayed_work	vadp_drop_work;
-	#endif
-	struct workqueue_struct *monitor_wqueue;
-	struct workqueue_struct *workqueue;	/* for Charging & VUSB/VADP */
-	struct workqueue_struct *usb_workqueue;	/* for ADC_VUSB */
-
-#ifdef ENABLE_FACTORY_MODE
-	struct delayed_work	factory_mode_work;
-	struct workqueue_struct *factory_mode_wqueue;
-#endif
-
-	struct mutex		lock;
-	unsigned long		monitor_time;
-	int		adc_vdd_mv;
-	int		multiple;
-	int		alarm_vol_mv;
-	int		status;
-	int		min_voltage;
-	int		max_voltage;
-	int		cur_voltage;
-	int		capacity;
-	int		battery_temp;
-	int		time_to_empty;
-	int		time_to_full;
-	int		chg_ctr;
-	int		chg_stat1;
-	unsigned	present:1;
-	u16		delay;
-	struct		ricoh619_soca_info *soca;
-	int		first_pwon;
-	bool		entry_factory_mode;
-	int		ch_vfchg;
-	int		ch_vrchg;
-	int		ch_vbatovset;
-	int		ch_ichg;
-	int		ch_ilim_adp;
-	int		ch_ilim_usb;
-	int		ch_icchg;
-	int		fg_target_vsys;
-	int		fg_target_ibat;
-	int		fg_poff_vbat;
-	int		jt_en;
-	int		jt_hw_sw;
-	int		jt_temp_h;
-	int		jt_temp_l;
-	int		jt_vfchg_h;
-	int		jt_vfchg_l;
-	int		jt_ichg_h;
-	int		jt_ichg_l;
-
-	int 	chg_complete_rd_flag;
-	int 	chg_complete_rd_cnt;
-	int		chg_complete_tm_ov_flag;
-	int		chg_complete_sleep_flag;
-	int		chg_old_dsoc;
-
-	int 		num;
-	};
-
-struct power_supply powerac;
-struct power_supply powerusb;
-
-int g_full_flag;
-int charger_irq;
-/* this value is for mfd fucntion */
-int g_soc;
-int g_fg_on_mode;
-int type_n;
-extern int dwc_otg_check_dpdm(bool wait);
-/*This is for full state*/
-static int BatteryTableFlagDef=0;
-static int BatteryTypeDef=0;
-static int Battery_Type(void)
-{
-	return BatteryTypeDef;
-}
-
-static int Battery_Table(void)
-{
-	return BatteryTableFlagDef;
-}
-
-static void ricoh619_battery_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		struct ricoh619_battery_info, monitor_work.work);
-
-	RICOH_FG_DBG("PMU: %s\n", __func__);
-	power_supply_changed(&info->battery);
-	queue_delayed_work(info->monitor_wqueue, &info->monitor_work,
-			   info->monitor_time);
-}
-
-#ifdef ENABLE_FUEL_GAUGE_FUNCTION
-static int measure_vbatt_FG(struct ricoh619_battery_info *info, int *data);
-static int measure_Ibatt_FG(struct ricoh619_battery_info *info, int *data);
-static int calc_capacity(struct ricoh619_battery_info *info);
-static int calc_capacity_2(struct ricoh619_battery_info *info);
-static int get_OCV_init_Data(struct ricoh619_battery_info *info, int index);
-static int get_OCV_voltage(struct ricoh619_battery_info *info, int index);
-static int get_check_fuel_gauge_reg(struct ricoh619_battery_info *info,
-					 int Reg_h, int Reg_l, int enable_bit);
-static int calc_capacity_in_period(struct ricoh619_battery_info *info,
-				 int *cc_cap, bool *is_charging, bool cc_rst);
-//static int get_charge_priority(struct ricoh619_battery_info *info, bool *data);
-//static int set_charge_priority(struct ricoh619_battery_info *info, bool *data);
-static int get_power_supply_status(struct ricoh619_battery_info *info);
-static int get_power_supply_Android_status(struct ricoh619_battery_info *info);
-static int measure_vsys_ADC(struct ricoh619_battery_info *info, int *data);
-static int Calc_Linear_Interpolation(int x0, int y0, int x1, int y1, int y);
-static int get_battery_temp(struct ricoh619_battery_info *info);
-static int get_battery_temp_2(struct ricoh619_battery_info *info);
-static int check_jeita_status(struct ricoh619_battery_info *info, bool *is_jeita_updated);
-static void ricoh619_scaling_OCV_table(struct ricoh619_battery_info *info, int cutoff_vol, int full_vol, int *start_per, int *end_per);
-//static int ricoh619_Check_OCV_Offset(struct ricoh619_battery_info *info);
-
-static int calc_ocv(struct ricoh619_battery_info *info)
-{
-	int Vbat = 0;
-	int Ibat = 0;
-	int ret;
-	int ocv;
-
-	ret = measure_vbatt_FG(info, &Vbat);
-	ret = measure_Ibatt_FG(info, &Ibat);
-
-	ocv = Vbat - Ibat * info->soca->Rbat;
-
-	return ocv;
-}
-
-#if 0
-static int set_Rlow(struct ricoh619_battery_info *info)
-{
-	int err;
-	int Rbat_low_max;
-	uint8_t val;
-	int Vocv;
-	int temp;
-
-	if (info->soca->Rbat == 0)
-			info->soca->Rbat = get_OCV_init_Data(info, 12) * 1000 / 512
-							 * 5000 / 4095;
-	
-	Vocv = calc_ocv(info);
-	Rbat_low_max = info->soca->Rbat * 1.5;
-
-	if (Vocv < get_OCV_voltage(info,3))
-	{
-		info->soca->R_low = Calc_Linear_Interpolation(info->soca->Rbat,get_OCV_voltage(info,3),
-			Rbat_low_max, get_OCV_voltage(info,0), Vocv);
-		RICOH_FG_DBG("PMU: Modify RBAT from %d to %d ", info->soca->Rbat, info->soca->R_low);
-		temp = info->soca->R_low *4095/5000*512/1000;
-		
-		val = info->soca->R_low>>8;
-		err = ricoh619_write_bank1(info->dev->parent, 0xD4, val);
-		if (err < 0) {
-			dev_err(info->dev, "batterry initialize error\n");
-			return err;
-		}
-
-		val = info->soca->R_low & 0xff;
-		err = ricoh619_write_bank1(info->dev->parent, 0xD5, val);
-		if (err < 0) {
-			dev_err(info->dev, "batterry initialize error\n");
-			return err;
-		}
-	}
-	else  info->soca->R_low = 0;
-		
-
-	return err;
-}
-
-static int Set_back_ocv_table(struct ricoh619_battery_info *info)
-{
-	int err;
-	uint8_t val;
-	int temp;
-	int i;
-	uint8_t debug_disp[22];
-
-	/* Modify back ocv table */
-
-	if (0 != info->soca->ocv_table_low[0])
-	{
-		for (i = 0 ; i < 11; i++){
-			battery_init_para[info->num][i*2 + 1] = info->soca->ocv_table_low[i];
-			battery_init_para[info->num][i*2] = info->soca->ocv_table_low[i] >> 8;
-		}
-		err = ricoh619_clr_bits(info->dev->parent, FG_CTRL_REG, 0x01);
-
-		err = ricoh619_bulk_writes_bank1(info->dev->parent,
-			BAT_INIT_TOP_REG, 22, battery_init_para[info->num]);
-
-		err = ricoh619_set_bits(info->dev->parent, FG_CTRL_REG, 0x01);
-
-		/* debug comment start*/
-		err = ricoh619_bulk_reads_bank1(info->dev->parent,
-			BAT_INIT_TOP_REG, 22, debug_disp);
-		for (i = 0; i < 11; i++){
-			RICOH_FG_DBG("PMU : %s : after OCV table %d 0x%x\n",__func__, i * 10, (debug_disp[i*2] << 8 | debug_disp[i*2+1]));
-		}
-		/* end */
-		/* clear table*/
-		for(i = 0; i < 11; i++)
-		{
-			info->soca->ocv_table_low[i] = 0;
-		}
-	}
-	
-	/* Modify back Rbat */
-	if (0!=info->soca->R_low)
-	{		
-		RICOH_FG_DBG("PMU: Modify back RBAT from %d to %d ",  info->soca->R_low,info->soca->Rbat);
-		temp = info->soca->Rbat*4095/5000*512/1000;
-		
-		val = info->soca->R_low>>8;
-		err = ricoh619_write_bank1(info->dev->parent, 0xD4, val);
-		if (err < 0) {
-			dev_err(info->dev, "batterry initialize error\n");
-			return err;
-		}
-
-		val = info->soca->R_low & 0xff;
-		err = ricoh619_write_bank1(info->dev->parent, 0xD5, val);
-		if (err < 0) {
-			dev_err(info->dev, "batterry initialize error\n");
-			return err;
-		}
-
-		info->soca->R_low = 0;
-	}
-	return 0;
-}
-
-/**
-**/
-
-static int ricoh619_Check_OCV_Offset(struct ricoh619_battery_info *info)
-{
-	int ocv_table[11]; // HEX value
-	int i;
-	int temp;
-	int ret;
-	uint8_t debug_disp[22];
-	uint8_t val = 0;
-
-	RICOH_FG_DBG("PMU : %s : calc ocv %d get OCV %d\n",__func__,calc_ocv(info),get_OCV_voltage(info, RICOH619_OCV_OFFSET_BOUND));
-
-	/* check adp/usb status */
-	ret = ricoh619_read(info->dev->parent, CHGSTATE_REG, &val);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-		return ret;
-	}
-
-	val = (val & 0xC0) >> 6;
-
-	if (val != 0){ /* connect adp or usb */
-		if (calc_ocv(info) < get_OCV_voltage(info, RICOH619_OCV_OFFSET_BOUND) )
-		{
-			if(0 == info->soca->ocv_table_low[0]){
-				for (i = 0 ; i < 11; i++){
-				ocv_table[i] = (battery_init_para[info->num][i*2]<<8) | (battery_init_para[info->num][i*2+1]);
-				RICOH_FG_DBG("PMU : %s : OCV table %d 0x%x\n",__func__,i * 10, ocv_table[i]);
-				info->soca->ocv_table_low[i] = ocv_table[i];
-				}
-
-				for (i = 0 ; i < 11; i++){
-					temp = ocv_table[i] * (100 + RICOH619_OCV_OFFSET_RATIO) / 100;
-
-					battery_init_para[info->num][i*2 + 1] = temp;
-					battery_init_para[info->num][i*2] = temp >> 8;
-				}
-				ret = ricoh619_clr_bits(info->dev->parent, FG_CTRL_REG, 0x01);
-
-				ret = ricoh619_bulk_writes_bank1(info->dev->parent,
-					BAT_INIT_TOP_REG, 22, battery_init_para[info->num]);
-
-				ret = ricoh619_set_bits(info->dev->parent, FG_CTRL_REG, 0x01);
-
-				/* debug comment start*/
-				ret = ricoh619_bulk_reads_bank1(info->dev->parent,
-					BAT_INIT_TOP_REG, 22, debug_disp);
-				for (i = 0; i < 11; i++){
-					RICOH_FG_DBG("PMU : %s : after OCV table %d 0x%x\n",__func__, i * 10, (debug_disp[i*2] << 8 | debug_disp[i*2+1]));
-				}
-				/* end */
-			}
-		}
-	}
-	
-	return 0;
-}
-#endif
-static int reset_FG_process(struct ricoh619_battery_info *info)
-{
-	int err;
-
-	//err = set_Rlow(info);
-	//err = ricoh619_Check_OCV_Offset(info);
-	err = ricoh619_write(info->dev->parent,
-					 FG_CTRL_REG, 0x51);
-	info->soca->ready_fg = 0;
-	return err;
-}
-
-
-static int check_charge_status_2(struct ricoh619_battery_info *info, int displayed_soc_temp)
-{
-	if (displayed_soc_temp < 0)
-			displayed_soc_temp = 0;
-	
-	get_power_supply_status(info);
-	info->soca->soc = calc_capacity(info) * 100;
-
-	if (POWER_SUPPLY_STATUS_FULL == info->soca->chg_status) {
-		if ((info->first_pwon == 1)
-			&& (RICOH619_SOCA_START == info->soca->status)) {
-				g_full_flag = 1;
-				info->soca->soc_full = info->soca->soc;
-				info->soca->displayed_soc = 100*100;
-				info->soca->full_reset_count = 0;
-		} else {
-			if ( (displayed_soc_temp > 97*100)
-				&& (calc_ocv(info) > (get_OCV_voltage(info, 9) + (get_OCV_voltage(info, 10) - get_OCV_voltage(info, 9))*7/10)  )){
-				g_full_flag = 1;
-				info->soca->soc_full = info->soca->soc;
-				info->soca->displayed_soc = 100*100;
-				info->soca->full_reset_count = 0;
-			} else {
-				g_full_flag = 0;
-				info->soca->displayed_soc = displayed_soc_temp;
-			}
-
-		}
-	}
-	if (info->soca->Ibat_ave >= 0) {
-		if (g_full_flag == 1) {
-			info->soca->displayed_soc = 100*100;
-		} else {
-			if (info->soca->displayed_soc/100 < 99) {
-				info->soca->displayed_soc = displayed_soc_temp;
-			} else {
-				info->soca->displayed_soc = 99 * 100;
-			}
-		}
-	}
-	if (info->soca->Ibat_ave < 0) {
-		if (g_full_flag == 1) {
-			if (calc_ocv(info) < (get_OCV_voltage(info, 9) + (get_OCV_voltage(info, 10) - get_OCV_voltage(info, 9))*7/10)  ) {
-				g_full_flag = 0;
-				//info->soca->displayed_soc = 100*100;
-				info->soca->displayed_soc = displayed_soc_temp;
-			} else {
-				info->soca->displayed_soc = 100*100;
-			}
-		} else {
-			g_full_flag = 0;
-			info->soca->displayed_soc = displayed_soc_temp;
-		}
-	}
-
-	return info->soca->displayed_soc;
-}
-
-/**
-* Calculate Capacity in a period
-* - read CC_SUM & FA_CAP from Coulom Counter
-* -  and calculate Capacity.
-* @cc_cap: capacity in a period, unit 0.01%
-* @is_charging: Flag of charging current direction
-*               TRUE : charging (plus)
-*               FALSE: discharging (minus)
-* @cc_rst: reset CC_SUM or not
-*               TRUE : reset
-*               FALSE: not reset
-**/
-static int calc_capacity_in_period(struct ricoh619_battery_info *info,
-				 int *cc_cap, bool *is_charging, bool cc_rst)
-{
-	int err;
-	uint8_t 	cc_sum_reg[4];
-	uint8_t 	cc_clr[4] = {0, 0, 0, 0};
-	uint8_t 	fa_cap_reg[2];
-	uint16_t 	fa_cap;
-	uint32_t 	cc_sum;
-	int		cc_stop_flag;
-	uint8_t 	status;
-	uint8_t 	charge_state;
-	int 		Ocv;
-	uint32_t 	cc_cap_temp;
-	uint32_t 	cc_cap_min;
-	int		cc_cap_res;
-
-	*is_charging = true;	/* currrent state initialize -> charging */
-
-	if (info->entry_factory_mode)
-		return 0;
-
-	//check need charge stop or not
-	/* get  power supply status */
-	err = ricoh619_read(info->dev->parent, CHGSTATE_REG, &status);
-	if (err < 0)
-		goto out;
-	charge_state = (status & 0x1F);
-	Ocv = calc_ocv(info);
-	if (charge_state == CHG_STATE_CHG_COMPLETE) {
-		/* Check CHG status is complete or not */
-		cc_stop_flag = 0;
-	} else if (calc_capacity(info) == 100) {
-		/* Check HW soc is 100 or not */
-		cc_stop_flag = 0;
-	} else if (Ocv/1000 < get_OCV_voltage(info, 9)) {
-		/* Check VBAT is high level or not */
-		cc_stop_flag = 0;
-	} else {
-		cc_stop_flag = 1;
-	}
-
-	if (cc_stop_flag == 1)
-	{
-		/* Disable Charging/Completion Interrupt */
-		err = ricoh619_set_bits(info->dev->parent,
-						RICOH619_INT_MSK_CHGSTS1, 0x01);
-		if (err < 0)
-			goto out;
-
-		/* disable charging */
-		err = ricoh619_clr_bits(info->dev->parent, RICOH619_CHG_CTL1, 0x03);
-		if (err < 0)
-			goto out;
-	}
-
-	/* CC_pause enter */
-	err = ricoh619_write(info->dev->parent, CC_CTRL_REG, 0x01);
-	if (err < 0)
-		goto out;
-
-	/* Read CC_SUM */
-	err = ricoh619_bulk_reads(info->dev->parent,
-					CC_SUMREG3_REG, 4, cc_sum_reg);
-	if (err < 0)
-		goto out;
-
-	if (cc_rst == true) {
-		/* CC_SUM <- 0 */
-		err = ricoh619_bulk_writes(info->dev->parent,
-						CC_SUMREG3_REG, 4, cc_clr);
-		if (err < 0)
-			goto out;
-	}
-
-	/* CC_pause exist */
-	err = ricoh619_write(info->dev->parent, CC_CTRL_REG, 0);
-	if (err < 0)
-		goto out;
-	if (cc_stop_flag == 1)
-	{
-	
-		/* Enable charging */
-		err = ricoh619_set_bits(info->dev->parent, RICOH619_CHG_CTL1, 0x03);
-		if (err < 0)
-			goto out;
-
-		udelay(1000);
-
-		/* Clear Charging Interrupt status */
-		err = ricoh619_clr_bits(info->dev->parent,
-					RICOH619_INT_IR_CHGSTS1, 0x01);
-		if (err < 0)
-			goto out;
-
-		/* ricoh619_read(info->dev->parent, RICOH619_INT_IR_CHGSTS1, &val);
-		RICOH_FG_DBG("INT_IR_CHGSTS1 = 0x%x\n",val); */
-
-		/* Enable Charging Interrupt */
-		err = ricoh619_clr_bits(info->dev->parent,
-						RICOH619_INT_MSK_CHGSTS1, 0x01);
-		if (err < 0)
-			goto out;
-	}
-	/* Read FA_CAP */
-	err = ricoh619_bulk_reads(info->dev->parent,
-				 FA_CAP_H_REG, 2, fa_cap_reg);
-	if (err < 0)
-		goto out;
-
-	/* fa_cap = *(uint16_t*)fa_cap_reg & 0x7fff; */
-	fa_cap = (fa_cap_reg[0] << 8 | fa_cap_reg[1]) & 0x7fff;
-
-	/* cc_sum = *(uint32_t*)cc_sum_reg; */
-	cc_sum = cc_sum_reg[0] << 24 | cc_sum_reg[1] << 16 |
-				cc_sum_reg[2] << 8 | cc_sum_reg[3];
-
-	/* calculation  two's complement of CC_SUM */
-	if (cc_sum & 0x80000000) {
-		cc_sum = (cc_sum^0xffffffff)+0x01;
-		*is_charging = false;		/* discharge */
-	}
-	/* (CC_SUM x 10000)/3600/FA_CAP */
-	*cc_cap = cc_sum*25/9/fa_cap;		/* unit is 0.01% */
-
-	//////////////////////////////////////////////////////////////////	
-	cc_cap_min = fa_cap*3600/100/100/100;	/* Unit is 0.0001% */
-	cc_cap_temp = cc_sum / cc_cap_min;
-		
-	cc_cap_res = cc_cap_temp % 100;
-	
-	RICOH_FG_DBG("PMU: cc_sum = %d: cc_cap_res= %d: \n", cc_sum, cc_cap_res);
-	
-	
-	if(*is_charging) {
-		info->soca->cc_cap_offset += cc_cap_res;
-		if (info->soca->cc_cap_offset >= 100) {
-			*cc_cap += 1;
-			info->soca->cc_cap_offset %= 100;
-		}
-	} else {
-		info->soca->cc_cap_offset -= cc_cap_res;
-		if (info->soca->cc_cap_offset <= -100) {
-			*cc_cap += 1;
-			info->soca->cc_cap_offset %= 100;
-		}
-	}
-	RICOH_FG_DBG("PMU: cc_cap_offset= %d: \n", info->soca->cc_cap_offset);
-	
-	//////////////////////////////////////////////////////////////////
-	return 0;
-out:
-	dev_err(info->dev, "Error !!-----\n");
-	return err;
-}
-/**
-* Calculate target using capacity
-**/
-static int get_target_use_cap(struct ricoh619_battery_info *info)
-{
-	int i,j;
-	int ocv_table[11];
-	int temp;
-//	int Target_Cutoff_Vol = 0;
-	int Ocv_ZeroPer_now;
-	int Ibat_now;
-	int fa_cap,use_cap;
-	int FA_CAP_now;
-	int start_per = 0;
-	int RE_CAP_now;
-	int CC_OnePer_step;
-	int Ibat_min;
-
-//	int Ocv_now;
-	int Ocv_now_table;
-//	int soc_per;
-//	int use_cap_now;
-	int Rsys_now;
-
-	/* get const value */
-	Ibat_min = -1 * info->soca->target_ibat;
-	if (info->soca->Ibat_ave > Ibat_min) /* I bat is minus */
-	{
-		Ibat_now = Ibat_min;
-	} else {
-		Ibat_now = info->soca->Ibat_ave;
-	}
-	fa_cap = get_check_fuel_gauge_reg(info, FA_CAP_H_REG, FA_CAP_L_REG,
-								0x7fff);
-	use_cap = fa_cap - info->soca->re_cap_old;
-
-	/* get OCV table % */
-	for (i = 0; i <= 10; i = i+1) {
-		temp = (battery_init_para[info->num][i*2]<<8)
-			 | (battery_init_para[info->num][i*2+1]);
-		/* conversion unit 1 Unit is 1.22mv (5000/4095 mv) */
-		temp = ((temp * 50000 * 10 / 4095) + 5) / 10;
-		ocv_table[i] = temp;
-		RICOH_FG_DBG("PMU : %s : ocv_table %d is %d v\n",__func__, i, ocv_table[i]);
-	}
-
-	/* Find out Current OCV */
-	i = info->soca->soc/1000;
-	j = info->soca->soc - info->soca->soc/1000*1000;
-	Ocv_now_table = ocv_table[i]*100+(ocv_table[i+1]-ocv_table[i])*j/10;
-
-	Rsys_now = (info->soca->Vsys_ave - Ocv_now_table) / info->soca->Ibat_ave;
-	if (((abs(info->soca->soc - info->soca->displayed_soc)) > 10)
-		&& (info->soca->Ibat_ave > -250)) {
-		if (Rsys_now < 0)
-			Rsys_now = max(-info->soca->Rbat, Rsys_now);
-		else
-			Rsys_now = min(info->soca->Rbat, Rsys_now);
-	}
-
-	Ocv_ZeroPer_now = info->soca->target_vsys * 1000 - Ibat_now * Rsys_now;
-
-	RICOH_FG_DBG("PMU: -------  Ocv_now_table= %d: Rsys_now= %d =======\n",
-	       Ocv_now_table, Rsys_now);
-
-	RICOH_FG_DBG("PMU: -------  Rsys= %d: cutoff_ocv= %d: Ocv_ZeroPer_now= %d =======\n",
-	       info->soca->Rsys, info->soca->cutoff_ocv, Ocv_ZeroPer_now);
-
-	/* get FA_CAP_now */
-
-	
-	for (i = 1; i < 11; i++) {
-		RICOH_FG_DBG("PMU : %s : ocv_table %d is %d v Ocv_ZerPernow is %d\n",__func__, i, ocv_table[i],(Ocv_ZeroPer_now / 100));
-		if (ocv_table[i] >= Ocv_ZeroPer_now / 100) {
-			/* unit is 0.001% */
-			start_per = Calc_Linear_Interpolation(
-				(i-1)*1000, ocv_table[i-1], i*1000,
-				 ocv_table[i], (Ocv_ZeroPer_now / 100));
-			i = 11;
-		}
-	}
-
-	start_per = max(0, start_per);
-
-	FA_CAP_now = fa_cap * ((10000 - start_per) / 100 ) / 100;
-
-	RICOH_FG_DBG("PMU: -------Ocv_ZeroPer_now= %d: start_per= %d =======\n",
-		Ocv_ZeroPer_now, start_per);
-
-	/* get RE_CAP_now */
-	RE_CAP_now = FA_CAP_now - use_cap;
-	
-	if (RE_CAP_now < RE_CAP_GO_DOWN) {
-		info->soca->hurry_up_flg = 1;
-	} else if (info->soca->Vsys_ave < info->soca->target_vsys*1000) {
-		info->soca->hurry_up_flg = 1;
-	} else if (info->fg_poff_vbat != 0) {
-		if (info->soca->Vbat_ave < info->fg_poff_vbat*1000) {
-			info->soca->hurry_up_flg = 1;
-		} else {
-			info->soca->hurry_up_flg = 0;
-		}
-	} else {
-		info->soca->hurry_up_flg = 0;
-	}
-
-	/* get CC_OnePer_step */
-	if (info->soca->displayed_soc > 0) { /* avoid divide-by-0 */
-		CC_OnePer_step = RE_CAP_now / (info->soca->displayed_soc / 100 + 1);
-	} else {
-		CC_OnePer_step = 0;
-	}
-	/* get info->soca->target_use_cap */
-	info->soca->target_use_cap = use_cap + CC_OnePer_step;
-	
-	RICOH_FG_DBG("PMU: ------- FA_CAP_now= %d: RE_CAP_now= %d: CC_OnePer_step= %d: target_use_cap= %d: hurry_up_flg= %d -------\n",
-	       FA_CAP_now, RE_CAP_now, CC_OnePer_step, info->soca->target_use_cap, info->soca->hurry_up_flg);
-	
-	return 0;
-}
-#ifdef ENABLE_OCV_TABLE_CALIB
-/**
-* Calibration OCV Table
-* - Update the value of VBAT on 100% in OCV table 
-*    if battery is Full charged.
-* - int vbat_ocv <- unit is uV
-**/
-static int calib_ocvTable(struct ricoh619_battery_info *info, int vbat_ocv)
-{
-	int ret;
-	int cutoff_ocv;
-	int i;
-	int ocv100_new;
-	int start_per = 0;
-	int end_per = 0;
-	
-	RICOH_FG_DBG("PMU: %s\n", __func__);
-	
-	if (info->soca->Ibat_ave > RICOH619_REL1_SEL_VALUE) {
-		RICOH_FG_DBG("PMU: %s IBAT > 64mA -- Not Calibration --\n", __func__);
-		return 0;
-	}
-	
-	if (vbat_ocv < info->soca->OCV100_max) {
-		if (vbat_ocv < info->soca->OCV100_min)
-			ocv100_new = info->soca->OCV100_min;
-		else
-			ocv100_new = vbat_ocv;
-	} else {
-		ocv100_new = info->soca->OCV100_max;
-	}
-	RICOH_FG_DBG("PMU : %s :max %d min %d current %d\n",__func__,info->soca->OCV100_max,info->soca->OCV100_min,vbat_ocv);
-	RICOH_FG_DBG("PMU : %s : New OCV 100% = 0x%x\n",__func__,ocv100_new);
-	
-	/* FG_En Off */
-	ret = ricoh619_clr_bits(info->dev->parent, FG_CTRL_REG, 0x01);
-	if (ret < 0) {
-		dev_err("PMU: %s Error in FG_En OFF\n", __func__);
-		goto err;
-	}
-
-
-	//cutoff_ocv = (battery_init_para[info->num][0]<<8) | (battery_init_para[info->num][1]);
-	cutoff_ocv = get_OCV_voltage(info, 0);
-
-	info->soca->ocv_table_def[10] = info->soca->OCV100_max;
-
-	ricoh619_scaling_OCV_table(info, cutoff_ocv/1000, ocv100_new/1000, &start_per, &end_per);
-
-	ret = ricoh619_bulk_writes_bank1(info->dev->parent,
-				BAT_INIT_TOP_REG, 22, battery_init_para[info->num]);
-	if (ret < 0) {
-		dev_err(info->dev, "batterry initialize error\n");
-		goto err;
-	}
-
-	for (i = 0; i <= 10; i = i+1) {
-		info->soca->ocv_table[i] = get_OCV_voltage(info, i);
-		RICOH_FG_DBG("PMU: %s : * %d0%% voltage = %d uV\n",
-				 __func__, i, info->soca->ocv_table[i]);
-	}
-	
-	/* FG_En on & Reset*/
-	ret = reset_FG_process(info);
-	if (ret < 0) {
-		dev_err("PMU: %s Error in FG_En On & Reset\n", __func__);
-		goto err;
-	}
-
-	RICOH_FG_DBG("PMU: %s Exit \n", __func__);
-	return 0;
-err:
-	return ret;
-
-}
-#endif
-
-static void ricoh619_displayed_work(struct work_struct *work)
-{
-	int err;
-	uint8_t val;
-	uint8_t val2;
-	int soc_round;
-	int last_soc_round;
-	int last_disp_round;
-	int displayed_soc_temp;
-	int disp_dec;
-	int cc_cap = 0;
-	bool is_charging = true;
-	int re_cap,fa_cap,use_cap;
-	bool is_jeita_updated;
-	uint8_t reg_val;
-	int delay_flag = 0;
-	int Vbat = 0;
-	int Ibat = 0;
-	int Vsys = 0;
-	int temp_ocv;
-	int fc_delta = 0;
-
-	struct ricoh619_battery_info *info = container_of(work,
-	struct ricoh619_battery_info, displayed_work.work);
-
-	if (info->entry_factory_mode) {
-		info->soca->status = RICOH619_SOCA_STABLE;
-		info->soca->displayed_soc = -EINVAL;
-		info->soca->ready_fg = 0;
-		return;
-	}
-
-	mutex_lock(&info->lock);
-	
-	is_jeita_updated = false;
-
-	if ((RICOH619_SOCA_START == info->soca->status)
-		 || (RICOH619_SOCA_STABLE == info->soca->status)
-		 || (RICOH619_SOCA_FULL == info->soca->status))
-		info->soca->ready_fg = 1;
-
-	/* judge Full state or Moni Vsys state */
-	if ((RICOH619_SOCA_DISP == info->soca->status)
-		 || (RICOH619_SOCA_STABLE == info->soca->status))
-	{
-		/* caluc 95% ocv */
-		temp_ocv = get_OCV_voltage(info, 10) -
-					(get_OCV_voltage(info, 10) - get_OCV_voltage(info, 9))/2;
-		
-		if(g_full_flag == 1){	/* for issue 1 solution start*/
-			info->soca->status = RICOH619_SOCA_FULL;
-		}else if ((POWER_SUPPLY_STATUS_FULL == info->soca->chg_status)
-			&& (calc_ocv(info) > temp_ocv)) {
-			info->soca->status = RICOH619_SOCA_FULL;
-			g_full_flag = 0;
-		} else if (info->soca->Ibat_ave >= -20) {
-			/* for issue1 solution end */
-			/* check Full state or not*/
-			if ((calc_ocv(info) > (get_OCV_voltage(info, 9) + (get_OCV_voltage(info, 10) - get_OCV_voltage(info, 9))*7/10))
-				|| (POWER_SUPPLY_STATUS_FULL == info->soca->chg_status)
-				|| (info->soca->displayed_soc > 9850))
-			{
-				info->soca->status = RICOH619_SOCA_FULL;
-				g_full_flag = 0;
-			} else if ((calc_ocv(info) > (get_OCV_voltage(info, 9)))
-				&& (info->soca->Ibat_ave < 300))
-			{
-				info->soca->status = RICOH619_SOCA_FULL;
-				g_full_flag = 0;
-			}
-		} else { /* dis-charging */
-			if (info->soca->displayed_soc/100 < RICOH619_ENTER_LOW_VOL) {
-				info->soca->target_use_cap = 0;
-				info->soca->status = RICOH619_SOCA_LOW_VOL;
-			}
-		}
-	}
-
-	if (RICOH619_SOCA_STABLE == info->soca->status) {
-		info->soca->soc = calc_capacity_2(info);
-		info->soca->soc_delta = info->soca->soc - info->soca->last_soc;
-
-		if (info->soca->soc_delta >= -100 && info->soca->soc_delta <= 100) {
-			info->soca->displayed_soc = info->soca->soc;
-		} else {
-			info->soca->status = RICOH619_SOCA_DISP;
-		}
-		info->soca->last_soc = info->soca->soc;
-		info->soca->soc_delta = 0;
-	} else if (RICOH619_SOCA_FULL == info->soca->status) {
-		err = check_jeita_status(info, &is_jeita_updated);
-		if (err < 0) {
-			dev_err(info->dev, "Error in updating JEITA %d\n", err);
-			goto end_flow;
-		}
-		info->soca->soc = calc_capacity(info) * 100;
-		info->soca->last_soc = calc_capacity_2(info);	/* for DISP */
-
-		if (info->soca->Ibat_ave >= -20) { /* charging */
-			if (0 == info->soca->jt_limit) {
-				if (g_full_flag == 1) {
-					
-					if (POWER_SUPPLY_STATUS_FULL == info->soca->chg_status) {
-						if(info->soca->full_reset_count < RICOH619_UPDATE_COUNT_FULL_RESET) {
-							info->soca->full_reset_count++;
-						} else if (info->soca->full_reset_count < (RICOH619_UPDATE_COUNT_FULL_RESET + 1)) {
-							err = reset_FG_process(info);
-							if (err < 0)
-								dev_err(info->dev, "Error in writing the control register\n");
-							info->soca->full_reset_count++;
-							goto end_flow;
-						} else if(info->soca->full_reset_count < (RICOH619_UPDATE_COUNT_FULL_RESET + 2)) {
-							info->soca->full_reset_count++;
-							info->soca->fc_cap = 0;
-							info->soca->soc_full = info->soca->soc;
-						}
-					} else {
-						if(info->soca->fc_cap < -1 * 200) {
-							g_full_flag = 0;
-							info->soca->displayed_soc = 99 * 100;
-						}
-						info->soca->full_reset_count = 0;
-					}
-					
-
-					info->soca->chg_cmp_times = 0;
-					err = calc_capacity_in_period(info, &cc_cap, &is_charging, true);
-					if (err < 0)
-					dev_err(info->dev, "Read cc_sum Error !!-----\n");
-
-					fc_delta = (is_charging == true) ? cc_cap : -cc_cap;
-
-					info->soca->fc_cap = info->soca->fc_cap + fc_delta;
-
-					if (g_full_flag == 1){
-						info->soca->displayed_soc = 100*100;
-					}
-				} else {
-					if (calc_ocv(info) < (get_OCV_voltage(info, 8))) { /* fail safe*/
-						g_full_flag = 0;
-						info->soca->status = RICOH619_SOCA_DISP;
-						info->soca->soc_delta = 0;
-					} else if ((POWER_SUPPLY_STATUS_FULL == info->soca->chg_status) 
-						&& (info->soca->displayed_soc >= 9890)){
-						if(info->soca->chg_cmp_times > RICOH619_FULL_WAIT_TIME) {
-							info->soca->displayed_soc = 100*100;
-							g_full_flag = 1;
-							info->soca->full_reset_count = 0;
-							info->soca->soc_full = info->soca->soc;
-							info->soca->fc_cap = 0;
-#ifdef ENABLE_OCV_TABLE_CALIB
-							err = calib_ocvTable(info,calc_ocv(info));
-							if (err < 0)
-								dev_err(info->dev, "Calibration OCV Error !!\n");
-#endif
-						} else {
-							info->soca->chg_cmp_times++;
-						}
-					} else {
-						fa_cap = get_check_fuel_gauge_reg(info, FA_CAP_H_REG, FA_CAP_L_REG,
-							0x7fff);
-						
-						if (info->soca->displayed_soc >= 9950) {
-							if((info->soca->soc_full - info->soca->soc) < 200) {
-								goto end_flow;
-							}
-						}
-						info->soca->chg_cmp_times = 0;
-
-						err = calc_capacity_in_period(info, &cc_cap, &is_charging, true);
-						if (err < 0)
-						dev_err(info->dev, "Read cc_sum Error !!-----\n");
-						info->soca->cc_delta
-							 = (is_charging == true) ? cc_cap : -cc_cap;
-
-						if((POWER_SUPPLY_STATUS_FULL == info->soca->chg_status)
-						//	|| (info->soca->Ibat_ave > 200))
-						|| (info->soca->Ibat_ave < info->ch_icchg*50 + 100) || (info->soca->displayed_soc<9700))
-						{
-							info->soca->displayed_soc += 13 * 3000 / fa_cap;
-						}
-						else {
-							info->soca->displayed_soc
-						       = info->soca->displayed_soc + info->soca->cc_delta*8/10;
-						}
-						
-						info->soca->displayed_soc
-							 = min(10000, info->soca->displayed_soc);
-						info->soca->displayed_soc = max(0, info->soca->displayed_soc);
-
-						if (info->soca->displayed_soc >= 9890) {
-							info->soca->displayed_soc = 99 * 100;
-						}
-					}
-				}
-			} else {
-				info->soca->full_reset_count = 0;
-			}
-		} else { /* discharging */
-			if (info->soca->displayed_soc >= 9950) {
-				if (info->soca->Ibat_ave <= -1 * RICOH619_REL1_SEL_VALUE) {
-					if ((calc_ocv(info) < (get_OCV_voltage(info, 9) + (get_OCV_voltage(info, 10) - get_OCV_voltage(info, 9))*3/10))
-						|| ((info->soca->soc_full - info->soca->soc) > 200)) {
-
-						g_full_flag = 0;
-						info->soca->full_reset_count = 0;
-						info->soca->displayed_soc = 100 * 100;
-						info->soca->status = RICOH619_SOCA_DISP;
-						info->soca->last_soc = info->soca->soc;
-						info->soca->soc_delta = 0;
-					} else {
-						info->soca->displayed_soc = 100 * 100;
-					}
-				} else { /* into relaxation state */
-					ricoh619_read(info->dev->parent, CHGSTATE_REG, &reg_val);
-					if (reg_val & 0xc0) {
-						info->soca->displayed_soc = 100 * 100;
-					} else {
-						g_full_flag = 0;
-						info->soca->full_reset_count = 0;
-						info->soca->displayed_soc = 100 * 100;
-						info->soca->status = RICOH619_SOCA_DISP;
-						info->soca->last_soc = info->soca->soc;
-						info->soca->soc_delta = 0;
-					}
-				}
-			} else {
-				g_full_flag = 0;
-				info->soca->status = RICOH619_SOCA_DISP;
-				info->soca->soc_delta = 0;
-				info->soca->full_reset_count = 0;
-				info->soca->last_soc = info->soca->soc;
-			}
-		}
-	} else if (RICOH619_SOCA_LOW_VOL == info->soca->status) {
-		if(info->soca->Ibat_ave >= 0) {
-			info->soca->soc = calc_capacity(info) * 100;
-			info->soca->status = RICOH619_SOCA_DISP;
-			info->soca->last_soc = info->soca->soc;
-			info->soca->soc_delta = 0;
-		} else {
-			re_cap = get_check_fuel_gauge_reg(info, RE_CAP_H_REG, RE_CAP_L_REG,
-								0x7fff);
-			fa_cap = get_check_fuel_gauge_reg(info, FA_CAP_H_REG, FA_CAP_L_REG,
-								0x7fff);
-			use_cap = fa_cap - re_cap;
-			
-			if (info->soca->target_use_cap == 0) {
-				info->soca->re_cap_old = re_cap;
-				get_target_use_cap(info);
-			}
-			
-			if(use_cap >= info->soca->target_use_cap) {
-				info->soca->displayed_soc = info->soca->displayed_soc - 100;
-				info->soca->displayed_soc = max(0, info->soca->displayed_soc);
-				info->soca->re_cap_old = re_cap;
-			} else if (info->soca->hurry_up_flg == 1) {
-				info->soca->displayed_soc = info->soca->displayed_soc - 100;
-				info->soca->displayed_soc = max(0, info->soca->displayed_soc);
-				info->soca->re_cap_old = re_cap;
-			}
-			get_target_use_cap(info);
-			info->soca->soc = calc_capacity(info) * 100;
-		}
-	}
-	else if (RICOH619_SOCA_DISP == info->soca->status) {
-
-		info->soca->soc = calc_capacity_2(info);
-
-		soc_round = (info->soca->soc + 50) / 100;
-		last_soc_round = (info->soca->last_soc + 50) / 100;
-		last_disp_round = (info->soca->displayed_soc + 50) / 100;
-
-		info->soca->soc_delta =
-			info->soca->soc_delta + (info->soca->soc - info->soca->last_soc);
-
-		info->soca->last_soc = info->soca->soc;
-		/* six case */
-		if (last_disp_round == soc_round) {
-			/* if SOC == DISPLAY move to stable */
-			info->soca->displayed_soc = info->soca->soc ;
-			info->soca->status = RICOH619_SOCA_STABLE;
-			delay_flag = 1;
-		} else if (info->soca->Ibat_ave > 0) {
-			if ((0 == info->soca->jt_limit) || 
-			(POWER_SUPPLY_STATUS_FULL != info->soca->chg_status)) {
-				/* Charge */
-				if (last_disp_round < soc_round) {
-					/* Case 1 : Charge, Display < SOC */
-					if (info->soca->soc_delta >= 100) {
-						info->soca->displayed_soc
-							= last_disp_round * 100 + 50;
-	 					info->soca->soc_delta -= 100;
-						if (info->soca->soc_delta >= 100)
-		 					delay_flag = 1;
-					} else {
-						info->soca->displayed_soc += 25;
-						disp_dec = info->soca->displayed_soc % 100;
-						if ((50 <= disp_dec) && (disp_dec <= 74))
-							info->soca->soc_delta = 0;
-					}
-					if ((info->soca->displayed_soc + 50)/100
-								 >= soc_round) {
-						info->soca->displayed_soc
-							= info->soca->soc ;
-						info->soca->status
-							= RICOH619_SOCA_STABLE;
-						delay_flag = 1;
-					}
-				} else if (last_disp_round > soc_round) {
-					/* Case 2 : Charge, Display > SOC */
-					if (info->soca->soc_delta >= 300) {
-						info->soca->displayed_soc += 100;
-						info->soca->soc_delta -= 300;
-					}
-					if ((info->soca->displayed_soc + 50)/100
-								 <= soc_round) {
-						info->soca->displayed_soc
-							= info->soca->soc ;
-						info->soca->status
-						= RICOH619_SOCA_STABLE;
-						delay_flag = 1;
-					}
-				}
-			} else {
-				info->soca->soc_delta = 0;
-			}
-		} else {
-			/* Dis-Charge */
-			if (last_disp_round > soc_round) {
-				/* Case 3 : Dis-Charge, Display > SOC */
-				if (info->soca->soc_delta <= -100) {
-					info->soca->displayed_soc
-						= last_disp_round * 100 - 75;
-					info->soca->soc_delta += 100;
-					if (info->soca->soc_delta <= -100)
-						delay_flag = 1;
-				} else {
-					info->soca->displayed_soc -= 25;
-					disp_dec = info->soca->displayed_soc % 100;
-					if ((25 <= disp_dec) && (disp_dec <= 49))
-						info->soca->soc_delta = 0;
-				}
-				if ((info->soca->displayed_soc + 50)/100
-							 <= soc_round) {
-					info->soca->displayed_soc
-						= info->soca->soc ;
-					info->soca->status
-						= RICOH619_SOCA_STABLE;
-					delay_flag = 1;
-				}
-			} else if (last_disp_round < soc_round) {
-				/* Case 4 : Dis-Charge, Display < SOC */
-				if (info->soca->soc_delta <= -300) {
-					info->soca->displayed_soc -= 100;
-					info->soca->soc_delta += 300;
-				}
-				if ((info->soca->displayed_soc + 50)/100
-							 >= soc_round) {
-					info->soca->displayed_soc
-						= info->soca->soc ;
-					info->soca->status
-						= RICOH619_SOCA_STABLE;
-					delay_flag = 1;
-				}
-			}
-		}
-	} else if (RICOH619_SOCA_UNSTABLE == info->soca->status) {
-		/* caluc 95% ocv */
-		temp_ocv = get_OCV_voltage(info, 10) -
-					(get_OCV_voltage(info, 10) - get_OCV_voltage(info, 9))/2;
-		
-		if(g_full_flag == 1){	/* for issue 1 solution start*/
-			info->soca->status = RICOH619_SOCA_FULL;
-			err = reset_FG_process(info);
-			if (err < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-			
-			goto end_flow;
-		}else if ((POWER_SUPPLY_STATUS_FULL == info->soca->chg_status)
-			&& (calc_ocv(info) > temp_ocv)) {
-			info->soca->status = RICOH619_SOCA_FULL;
-			g_full_flag = 0;
-			err = reset_FG_process(info);
-			if (err < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-			goto end_flow;
-		} else if (info->soca->Ibat_ave >= -20) {
-			/* for issue1 solution end */
-			/* check Full state or not*/
-			if ((calc_ocv(info) > (get_OCV_voltage(info, 9) + (get_OCV_voltage(info, 10) - get_OCV_voltage(info, 9))*7/10))
-				|| (POWER_SUPPLY_STATUS_FULL == info->soca->chg_status)
-				|| (info->soca->displayed_soc > 9850))
-			{
-				info->soca->status = RICOH619_SOCA_FULL;
-				g_full_flag = 0;
-				err = reset_FG_process(info);
-				if (err < 0)
-					dev_err(info->dev, "Error in writing the control register\n");
-				goto end_flow;
-			} else if ((calc_ocv(info) > (get_OCV_voltage(info, 9)))
-				&& (info->soca->Ibat_ave < 300))
-			{
-				info->soca->status = RICOH619_SOCA_FULL;
-				g_full_flag = 0;
-				err = reset_FG_process(info);
-				if (err < 0)
-					dev_err(info->dev, "Error in writing the control register\n");				
-				goto end_flow;
-			}
-		}
-
-		err = ricoh619_read(info->dev->parent, PSWR_REG, &val);
-		val &= 0x7f;
-		info->soca->soc = val * 100;
-		if (err < 0) {
-			dev_err(info->dev,
-				 "Error in reading PSWR_REG %d\n", err);
-			info->soca->soc
-				 = calc_capacity(info) * 100;
-		}
-
-		err = calc_capacity_in_period(info, &cc_cap,
-						 &is_charging, false);
-		if (err < 0)
-			dev_err(info->dev, "Read cc_sum Error !!-----\n");
-
-		info->soca->cc_delta
-			 = (is_charging == true) ? cc_cap : -cc_cap;
-
-		displayed_soc_temp
-		       = info->soca->soc + info->soca->cc_delta;
-		if (displayed_soc_temp < 0)
-			displayed_soc_temp = 0;
-		displayed_soc_temp
-			 = min(9850, displayed_soc_temp);
-		displayed_soc_temp = max(0, displayed_soc_temp);
-
-		info->soca->displayed_soc = displayed_soc_temp;
-
-	} else if (RICOH619_SOCA_FG_RESET == info->soca->status) {
-		/* No update */
-	} else if (RICOH619_SOCA_START == info->soca->status) {
-
-		err = measure_Ibatt_FG(info, &Ibat);
-		err = measure_vbatt_FG(info, &Vbat);
-		err = measure_vsys_ADC(info, &Vsys);
-
-		info->soca->Ibat_ave = Ibat;
-		info->soca->Vbat_ave = Vbat;
-		info->soca->Vsys_ave = Vsys;
-
-		err = check_jeita_status(info, &is_jeita_updated);
-		is_jeita_updated = false;
-		if (err < 0) {
-			dev_err(info->dev, "Error in updating JEITA %d\n", err);
-		}
-		err = ricoh619_read(info->dev->parent, PSWR_REG, &val);
-		val &= 0x7f;
-		if (info->first_pwon) {
-			info->soca->soc = calc_capacity(info) * 100;
-			val = (info->soca->soc + 50)/100;
-			val &= 0x7f;
-			err = ricoh619_write(info->dev->parent, PSWR_REG, val);
-			if (err < 0)
-				dev_err(info->dev, "Error in writing PSWR_REG\n");
-			g_soc = val;
-
-			if ((info->soca->soc == 0) && (calc_ocv(info)
-					< get_OCV_voltage(info, 0))) {
-				info->soca->displayed_soc = 0;
-				info->soca->status = RICOH619_SOCA_ZERO;
-			} else {
-				if (0 == info->soca->jt_limit) {
-					check_charge_status_2(info, info->soca->soc);
-				} else {
-					info->soca->displayed_soc = info->soca->soc;
-				}
-				if (Ibat < 0) {
-					if (info->soca->displayed_soc < 300) {
-						info->soca->target_use_cap = 0;
-						info->soca->status = RICOH619_SOCA_LOW_VOL;
-					} else {
-						if ((info->fg_poff_vbat != 0)
-						      && (Vbat < info->fg_poff_vbat * 1000) ){
-							  info->soca->target_use_cap = 0;
-							  info->soca->status = RICOH619_SOCA_LOW_VOL;
-						  } else { 
-							  info->soca->status = RICOH619_SOCA_UNSTABLE;
-						  }
-					}
-				} else {
-					info->soca->status = RICOH619_SOCA_UNSTABLE;
-				}
-			}
-		} else if (g_fg_on_mode && (val == 0x7f)) {
-			info->soca->soc = calc_capacity(info) * 100;
-			if ((info->soca->soc == 0) && (calc_ocv(info)
-					< get_OCV_voltage(info, 0))) {
-				info->soca->displayed_soc = 0;
-				info->soca->status = RICOH619_SOCA_ZERO;
-			} else {
-				if (0 == info->soca->jt_limit) {
-					check_charge_status_2(info, info->soca->soc);
-				} else {
-					info->soca->displayed_soc = info->soca->soc;
-				}
-				info->soca->last_soc = info->soca->soc;
-				info->soca->status = RICOH619_SOCA_STABLE;
-			}
-		} else {
-			info->soca->soc = val * 100;
-			if (err < 0) {
-				dev_err(info->dev,
-					 "Error in reading PSWR_REG %d\n", err);
-				info->soca->soc
-					 = calc_capacity(info) * 100;
-			}
-
-			err = calc_capacity_in_period(info, &cc_cap,
-							 &is_charging, false);
-			if (err < 0)
-				dev_err(info->dev, "Read cc_sum Error !!-----\n");
-
-			info->soca->cc_delta
-				 = (is_charging == true) ? cc_cap : -cc_cap;
-			if (calc_ocv(info) < get_OCV_voltage(info, 0)) {
-				info->soca->displayed_soc = 0;
-				info->soca->status = RICOH619_SOCA_ZERO;
-			} else {
-				displayed_soc_temp
-				       = info->soca->soc + info->soca->cc_delta;
-				if (displayed_soc_temp < 0)
-					displayed_soc_temp = 0;
-				displayed_soc_temp
-					 = min(10000, displayed_soc_temp);
-				displayed_soc_temp = max(0, displayed_soc_temp);
-				if (0 == info->soca->jt_limit) {
-					check_charge_status_2(info, displayed_soc_temp);
-				} else {
-					info->soca->displayed_soc = displayed_soc_temp;
-				}
-				info->soca->last_soc = calc_capacity(info) * 100;
-				if (Ibat < 0) {
-					if (info->soca->displayed_soc < 300) {
-						info->soca->target_use_cap = 0;
-						info->soca->status = RICOH619_SOCA_LOW_VOL;
-					} else {
-						if ((info->fg_poff_vbat != 0)
-						      && (Vbat < info->fg_poff_vbat * 1000)){
-							  info->soca->target_use_cap = 0;
-							  info->soca->status = RICOH619_SOCA_LOW_VOL;
-						  } else { 
-							  info->soca->status = RICOH619_SOCA_UNSTABLE;
-						  }
-					}
-				} else {
-					if(info->soca->displayed_soc >= 9850)
-					{
-						info->soca->displayed_soc = 10000;
-						info->chg_complete_tm_ov_flag = 1;
-					}
-					info->soca->status = RICOH619_SOCA_UNSTABLE;
-				}
-			}
-		}
-	} else if (RICOH619_SOCA_ZERO == info->soca->status) {
-		if (calc_ocv(info) > get_OCV_voltage(info, 0)) {
-			err = reset_FG_process(info);
-			if (err < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-			info->soca->last_soc = calc_capacity_2(info);
-			info->soca->status = RICOH619_SOCA_STABLE;
-		}
-		info->soca->displayed_soc = 0;
-	}
-end_flow:
-	/* keep DSOC = 1 when Vbat is over 3.4V*/
-	if( info->fg_poff_vbat != 0) {
-		if (info->soca->zero_flg == 1) {
-			if(info->soca->Ibat_ave >= 0) {
-				info->soca->zero_flg = 0;
-			}
-			info->soca->displayed_soc = 0;
-		} else if (info->soca->displayed_soc < 50) {
-			if (info->soca->Vbat_ave < 2000*1000) { /* error value */
-				info->soca->displayed_soc = 100;
-			} else if (info->soca->Vbat_ave < info->fg_poff_vbat*1000) {
-				info->soca->displayed_soc = 0;
-				info->soca->zero_flg = 1;
-			} else {
-				info->soca->displayed_soc = 100;
-			}
-		}
-	}
-
-	if (g_fg_on_mode
-		 && (info->soca->status == RICOH619_SOCA_STABLE)) {
-		err = ricoh619_write(info->dev->parent, PSWR_REG, 0x7f);
-		if (err < 0)
-			dev_err(info->dev, "Error in writing PSWR_REG\n");
-		g_soc = 0x7F;
-		err = calc_capacity_in_period(info, &cc_cap,
-							&is_charging, true);
-		if (err < 0)
-			dev_err(info->dev, "Read cc_sum Error !!-----\n");
-
-	} else if (RICOH619_SOCA_UNSTABLE != info->soca->status) {
-		if ((info->soca->displayed_soc + 50) / 100 <= 1) {
-			val = 1;
-		} else {
-			val = (info->soca->displayed_soc + 50)/100;
-			val &= 0x7f;
-		}
-		err = ricoh619_write(info->dev->parent, PSWR_REG, val);
-		if (err < 0)
-			dev_err(info->dev, "Error in writing PSWR_REG\n");
-
-		g_soc = val;
-
-		err = calc_capacity_in_period(info, &cc_cap,
-							 &is_charging, true);
-		if (err < 0)
-			dev_err(info->dev, "Read cc_sum Error !!-----\n");
-	}
-	
-	RICOH_FG_DBG("PMU: ------- STATUS= %d: IBAT= %d: VSYS= %d: VBAT= %d: DSOC= %d: RSOC= %d: -------\n",
-	       info->soca->status, info->soca->Ibat_ave, info->soca->Vsys_ave, info->soca->Vbat_ave,
-	info->soca->displayed_soc, info->soca->soc);
-
-#ifdef DISABLE_CHARGER_TIMER
-	/* clear charger timer */
-	if ( info->soca->chg_status == POWER_SUPPLY_STATUS_CHARGING ) {
-		err = ricoh619_read(info->dev->parent, TIMSET_REG, &val);
-		if (err < 0)
-			dev_err(info->dev,
-			"Error in read TIMSET_REG%d\n", err);
-		/* to check bit 0-1 */
-		val2 = val & 0x03;
-
-		if (val2 == 0x02){
-			/* set rapid timer 240 -> 300 */
-			err = ricoh619_set_bits(info->dev->parent, TIMSET_REG, 0x03);
-			if (err < 0) {
-				dev_err(info->dev, "Error in writing the control register\n");
-			}
-		} else {
-			/* set rapid timer 300 -> 240 */
-			err = ricoh619_clr_bits(info->dev->parent, TIMSET_REG, 0x01);
-			err = ricoh619_set_bits(info->dev->parent, TIMSET_REG, 0x02);
-			if (err < 0) {
-				dev_err(info->dev, "Error in writing the control register\n");
-			}
-		}
-	}
-#endif
-
-	if (0 == info->soca->ready_fg)
-		queue_delayed_work(info->monitor_wqueue, &info->displayed_work,
-					 RICOH619_FG_RESET_TIME * HZ);
-	else if (delay_flag == 1)
-		queue_delayed_work(info->monitor_wqueue, &info->displayed_work,
-					 RICOH619_DELAY_TIME * HZ);
-	else if (RICOH619_SOCA_DISP == info->soca->status)
-		queue_delayed_work(info->monitor_wqueue, &info->displayed_work,
-					 RICOH619_DISPLAY_UPDATE_TIME * HZ);
-	else if (info->soca->hurry_up_flg == 1)
-		queue_delayed_work(info->monitor_wqueue, &info->displayed_work,
-					 RICOH619_LOW_VOL_DOWN_TIME * HZ);
-	else
-		queue_delayed_work(info->monitor_wqueue, &info->displayed_work,
-					 RICOH619_DISPLAY_UPDATE_TIME * HZ);
-
-	mutex_unlock(&info->lock);
-
-	if((true == is_jeita_updated)
-	|| (info->soca->last_displayed_soc/100 != (info->soca->displayed_soc+50)/100))
-		power_supply_changed(&info->battery);
-
-	info->soca->last_displayed_soc = info->soca->displayed_soc+50;
-
-	if ((info->soca->displayed_soc >= 9850) && (info->soca->Ibat_ave > -20) && (info->capacity < 100)
-		&& (info->soca->chg_status == POWER_SUPPLY_STATUS_CHARGING))
-	{
-		if(info->chg_complete_rd_flag == 0)
-		{
-			info->chg_complete_rd_flag = 1;
-			info->chg_complete_rd_cnt = 0;
-			queue_delayed_work(info->monitor_wqueue, &info->charge_complete_ready, 0);
-		}
-	}
-	else
-	{
-		info->chg_complete_rd_flag = 0;
-	}
-
-	if(info->chg_complete_tm_ov_flag == 1)
-	{
-		if(info->soca->displayed_soc < 9850 || info->soca->Ibat_ave < -20)
-		{
-			info->chg_complete_tm_ov_flag = 0;
-			power_supply_changed(&info->battery);
-		}
-	}
-	return;
-}
-
-static void ricoh619_stable_charge_countdown_work(struct work_struct *work)
-{
-	int ret;
-	int max = 0;
-	int min = 100;
-	int i;
-	struct ricoh619_battery_info *info = container_of(work,
-		struct ricoh619_battery_info, charge_stable_work.work);
-
-	if (info->entry_factory_mode)
-		return;
-
-	mutex_lock(&info->lock);
-	if (RICOH619_SOCA_FG_RESET == info->soca->status)
-		info->soca->ready_fg = 1;
-
-	if (2 <= info->soca->stable_count) {
-		if (3 == info->soca->stable_count
-			&& RICOH619_SOCA_FG_RESET == info->soca->status) {
-			ret = reset_FG_process(info);
-			if (ret < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-		}
-		info->soca->stable_count = info->soca->stable_count - 1;
-		queue_delayed_work(info->monitor_wqueue,
-					 &info->charge_stable_work,
-					 RICOH619_FG_STABLE_TIME * HZ / 10);
-	} else if (0 >= info->soca->stable_count) {
-		/* Finished queue, ignore */
-	} else if (1 == info->soca->stable_count) {
-		if (RICOH619_SOCA_UNSTABLE == info->soca->status) {
-			/* Judge if FG need reset or Not */
-			info->soca->soc = calc_capacity(info) * 100;
-			if (info->chg_ctr != 0) {
-				queue_delayed_work(info->monitor_wqueue,
-					 &info->charge_stable_work,
-					 RICOH619_FG_STABLE_TIME * HZ / 10);
-				mutex_unlock(&info->lock);
-				return;
-			}
-			/* Do reset setting */
-			ret = reset_FG_process(info);
-			if (ret < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-
-			info->soca->status = RICOH619_SOCA_FG_RESET;
-
-			/* Delay for addition Reset Time (6s) */
-			queue_delayed_work(info->monitor_wqueue,
-					 &info->charge_stable_work,
-					 RICOH619_FG_RESET_TIME*HZ);
-		} else if (RICOH619_SOCA_FG_RESET == info->soca->status) {
-			info->soca->reset_soc[2] = info->soca->reset_soc[1];
-			info->soca->reset_soc[1] = info->soca->reset_soc[0];
-			info->soca->reset_soc[0] = calc_capacity(info) * 100;
-			info->soca->reset_count++;
-
-			if (info->soca->reset_count > 10) {
-				/* Reset finished; */
-				info->soca->soc = info->soca->reset_soc[0];
-				info->soca->stable_count = 0;
-				goto adjust;
-			}
-
-			for (i = 0; i < 3; i++) {
-				if (max < info->soca->reset_soc[i]/100)
-					max = info->soca->reset_soc[i]/100;
-				if (min > info->soca->reset_soc[i]/100)
-					min = info->soca->reset_soc[i]/100;
-			}
-
-			if ((info->soca->reset_count > 3) && ((max - min)
-					< RICOH619_MAX_RESET_SOC_DIFF)) {
-				/* Reset finished; */
-				info->soca->soc = info->soca->reset_soc[0];
-				info->soca->stable_count = 0;
-				goto adjust;
-			} else {
-				/* Do reset setting */
-				ret = reset_FG_process(info);
-				if (ret < 0)
-					dev_err(info->dev, "Error in writing the control register\n");
-
-				/* Delay for addition Reset Time (6s) */
-				queue_delayed_work(info->monitor_wqueue,
-						 &info->charge_stable_work,
-						 RICOH619_FG_RESET_TIME*HZ);
-			}
-		/* Finished queue From now, select FG as result; */
-		} else if (RICOH619_SOCA_START == info->soca->status) {
-			/* Normal condition */
-		} else { /* other state ZERO/DISP/STABLE */
-			info->soca->stable_count = 0;
-		}
-
-		mutex_unlock(&info->lock);
-		return;
-
-adjust:
-		info->soca->last_soc = info->soca->soc;
-		info->soca->status = RICOH619_SOCA_DISP;
-		info->soca->soc_delta = 0;
-
-	}
-	mutex_unlock(&info->lock);
-	return;
-}
-
-static void ricoh619_charge_monitor_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		struct ricoh619_battery_info, charge_monitor_work.work);
-
-	get_power_supply_status(info);
-
-	if (POWER_SUPPLY_STATUS_DISCHARGING == info->soca->chg_status
-		|| POWER_SUPPLY_STATUS_NOT_CHARGING == info->soca->chg_status) {
-		switch (info->soca->dischg_state) {
-		case	0:
-			info->soca->dischg_state = 1;
-			break;
-		case	1:
-			info->soca->dischg_state = 2;
-			break;
-	
-		case	2:
-		default:
-			break;
-		}
-	} else {
-		info->soca->dischg_state = 0;
-	}
-
-	queue_delayed_work(info->monitor_wqueue, &info->charge_monitor_work,
-					 RICOH619_CHARGE_MONITOR_TIME * HZ);
-
-	return;
-}
-
-static void ricoh619_get_charge_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		struct ricoh619_battery_info, get_charge_work.work);
-
-	int Vbat_temp, Vsys_temp, Ibat_temp;
-	int Vbat_sort[RICOH619_GET_CHARGE_NUM];
-	int Vsys_sort[RICOH619_GET_CHARGE_NUM];
-	int Ibat_sort[RICOH619_GET_CHARGE_NUM];
-	int i, j;
-	int ret;
-
-	mutex_lock(&info->lock);
-
-	for (i = RICOH619_GET_CHARGE_NUM-1; i > 0; i--) {
-		if (0 == info->soca->chg_count) {
-			info->soca->Vbat[i] = 0;
-			info->soca->Vsys[i] = 0;
-			info->soca->Ibat[i] = 0;
-		} else {
-			info->soca->Vbat[i] = info->soca->Vbat[i-1];
-			info->soca->Vsys[i] = info->soca->Vsys[i-1];
-			info->soca->Ibat[i] = info->soca->Ibat[i-1];
-		}
-	}
-
-	ret = measure_vbatt_FG(info, &info->soca->Vbat[0]);
-	ret = measure_vsys_ADC(info, &info->soca->Vsys[0]);
-	ret = measure_Ibatt_FG(info, &info->soca->Ibat[0]);
-
-	info->soca->chg_count++;
-
-	if (RICOH619_GET_CHARGE_NUM != info->soca->chg_count) {
-		queue_delayed_work(info->monitor_wqueue, &info->get_charge_work,
-					 RICOH619_CHARGE_CALC_TIME * HZ);
-		mutex_unlock(&info->lock);
-		return ;
-	}
-
-	for (i = 0; i < RICOH619_GET_CHARGE_NUM; i++) {
-		Vbat_sort[i] = info->soca->Vbat[i];
-		Vsys_sort[i] = info->soca->Vsys[i];
-		Ibat_sort[i] = info->soca->Ibat[i];
-	}
-
-	Vbat_temp = 0;
-	Vsys_temp = 0;
-	Ibat_temp = 0;
-	for (i = 0; i < RICOH619_GET_CHARGE_NUM - 1; i++) {
-		for (j = RICOH619_GET_CHARGE_NUM - 1; j > i; j--) {
-			if (Vbat_sort[j - 1] > Vbat_sort[j]) {
-				Vbat_temp = Vbat_sort[j];
-				Vbat_sort[j] = Vbat_sort[j - 1];
-				Vbat_sort[j - 1] = Vbat_temp;
-			}
-			if (Vsys_sort[j - 1] > Vsys_sort[j]) {
-				Vsys_temp = Vsys_sort[j];
-				Vsys_sort[j] = Vsys_sort[j - 1];
-				Vsys_sort[j - 1] = Vsys_temp;
-			}
-			if (Ibat_sort[j - 1] > Ibat_sort[j]) {
-				Ibat_temp = Ibat_sort[j];
-				Ibat_sort[j] = Ibat_sort[j - 1];
-				Ibat_sort[j - 1] = Ibat_temp;
-			}
-		}
-	}
-
-	Vbat_temp = 0;
-	Vsys_temp = 0;
-	Ibat_temp = 0;
-	for (i = 3; i < RICOH619_GET_CHARGE_NUM-3; i++) {
-		Vbat_temp = Vbat_temp + Vbat_sort[i];
-		Vsys_temp = Vsys_temp + Vsys_sort[i];
-		Ibat_temp = Ibat_temp + Ibat_sort[i];
-	}
-	Vbat_temp = Vbat_temp / (RICOH619_GET_CHARGE_NUM - 6);
-	Vsys_temp = Vsys_temp / (RICOH619_GET_CHARGE_NUM - 6);
-	Ibat_temp = Ibat_temp / (RICOH619_GET_CHARGE_NUM - 6);
-
-	if (0 == info->soca->chg_count) {
-		queue_delayed_work(info->monitor_wqueue, &info->get_charge_work,
-				 RICOH619_CHARGE_UPDATE_TIME * HZ);
-		mutex_unlock(&info->lock);
-		return;
-	} else {
-		info->soca->Vbat_ave = Vbat_temp;
-		info->soca->Vsys_ave = Vsys_temp;
-		info->soca->Ibat_ave = Ibat_temp;
-	}
-
-	info->soca->chg_count = 0;
-	queue_delayed_work(info->monitor_wqueue, &info->get_charge_work,
-				 RICOH619_CHARGE_UPDATE_TIME * HZ);
-	mutex_unlock(&info->lock);
-	return;
-}
-
-/* Initial setting of FuelGauge SOCA function */
-static int ricoh619_init_fgsoca(struct ricoh619_battery_info *info)
-{
-	int i;
-	int err;
-	uint8_t val;
-	int cc_cap = 0;
-	bool is_charging = true;
-
-	for (i = 0; i <= 10; i = i+1) {
-		info->soca->ocv_table[i] = get_OCV_voltage(info, i);
-		RICOH_FG_DBG("PMU: %s : * %d0%% voltage = %d uV\n",
-				 __func__, i, info->soca->ocv_table[i]);
-	}
-
-	for (i = 0; i < 3; i = i+1)
-		info->soca->reset_soc[i] = 0;
-	info->soca->reset_count = 0;
-
-	if (info->first_pwon) {
-
-		err = ricoh619_read(info->dev->parent, CHGISET_REG, &val);
-		if (err < 0)
-			dev_err(info->dev,
-			"Error in read CHGISET_REG%d\n", err);
-
-		err = ricoh619_write(info->dev->parent, CHGISET_REG, 0);
-		if (err < 0)
-			dev_err(info->dev,
-			"Error in writing CHGISET_REG%d\n", err);
-		msleep(1000);
-
-		if (!info->entry_factory_mode) {
-			err = ricoh619_write(info->dev->parent,
-							FG_CTRL_REG, 0x51);
-			if (err < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-		}
-
-		err = calc_capacity_in_period(info, &cc_cap, &is_charging, true);
-
-		msleep(6000);
-
-		err = ricoh619_write(info->dev->parent, CHGISET_REG, val);
-		if (err < 0)
-			dev_err(info->dev,
-			"Error in writing CHGISET_REG%d\n", err);
-	}
-	
-	/* Rbat : Transfer */
-	info->soca->Rbat = get_OCV_init_Data(info, 12) * 1000 / 512
-							 * 5000 / 4095;
-	info->soca->n_cap = get_OCV_init_Data(info, 11);
-
-
-	info->soca->displayed_soc = 0;
-	info->soca->last_displayed_soc = 0;
-	info->soca->suspend_soc = 0;
-	info->soca->ready_fg = 0;
-	info->soca->soc_delta = 0;
-	info->soca->full_reset_count = 0;
-	info->soca->soc_full = 0;
-	info->soca->fc_cap = 0;
-	info->soca->status = RICOH619_SOCA_START;
-	/* stable count down 11->2, 1: reset; 0: Finished; */
-	info->soca->stable_count = 11;
-	info->soca->chg_cmp_times = 0;
-	info->soca->dischg_state = 0;
-	info->soca->Vbat_ave = 0;
-	info->soca->Vbat_old = 0;
-	info->soca->Vsys_ave = 0;
-	info->soca->Ibat_ave = 0;
-	info->soca->chg_count = 0;
-	info->soca->target_use_cap = 0;
-	info->soca->hurry_up_flg = 0;
-	info->soca->re_cap_old = 0;
-	info->soca->jt_limit = 0;
-	info->soca->zero_flg = 0;
-	info->soca->cc_cap_offset = 0;
-
-	for (i = 0; i < 11; i++) {
-		info->soca->ocv_table_low[i] = 0;
-	}
-
-	for (i = 0; i < RICOH619_GET_CHARGE_NUM; i++) {
-		info->soca->Vbat[i] = 0;
-		info->soca->Vsys[i] = 0;
-		info->soca->Ibat[i] = 0;
-	}
-
-	g_full_flag = 0;
-	
-#ifdef ENABLE_FG_KEEP_ON_MODE
-	g_fg_on_mode = 1;
-#else
-	g_fg_on_mode = 0;
-#endif
-
-	/* Start first Display job */
-	queue_delayed_work(info->monitor_wqueue, &info->displayed_work,
-						   RICOH619_FG_RESET_TIME*HZ);
-
-	/* Start first Waiting stable job */
-	queue_delayed_work(info->monitor_wqueue, &info->charge_stable_work,
-		   RICOH619_FG_STABLE_TIME*HZ/10);
-
-	queue_delayed_work(info->monitor_wqueue, &info->charge_monitor_work,
-					 RICOH619_CHARGE_MONITOR_TIME * HZ);
-
-	queue_delayed_work(info->monitor_wqueue, &info->get_charge_work,
-					 RICOH619_CHARGE_MONITOR_TIME * HZ);
-	if (info->jt_en) {
-		if (info->jt_hw_sw) {
-			/* Enable JEITA function supported by H/W */
-			err = ricoh619_set_bits(info->dev->parent, CHGCTL1_REG, 0x04);
-			if (err < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-		} else {
-		 	/* Disable JEITA function supported by H/W */
-			err = ricoh619_clr_bits(info->dev->parent, CHGCTL1_REG, 0x04);
-			if (err < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-			queue_delayed_work(info->monitor_wqueue, &info->jeita_work,
-						 	 RICOH619_FG_RESET_TIME * HZ);
-		}
-	} else {
-		/* Disable JEITA function supported by H/W */
-		err = ricoh619_clr_bits(info->dev->parent, CHGCTL1_REG, 0x04);
-		if (err < 0)
-			dev_err(info->dev, "Error in writing the control register\n");
-	}
-
-	RICOH_FG_DBG("PMU: %s : * Rbat = %d mOhm   n_cap = %d mAH\n",
-			 __func__, info->soca->Rbat, info->soca->n_cap);
-	return 1;
-}
-#endif
-
-static void ricoh619_charging_complete_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		struct ricoh619_battery_info, charge_complete_ready.work);
-
-	uint8_t time_ov_flag;
-	RICOH_FG_DBG("PMU: %s\n", __func__);
-	RICOH_FG_DBG("info->chg_complete_rd_cnt = %d\n", info->chg_complete_rd_cnt);
-	RICOH_FG_DBG("info->chg_complete_rd_flag = %d\n", info->chg_complete_rd_flag);
-	RICOH_FG_DBG("info->chg_complete_tm_ov_flag = %d\n", info->chg_complete_tm_ov_flag);
-	
-	if(info->chg_complete_rd_flag == 1)
-	{
-		// start chg 99per to 100per timer
-		time_ov_flag = 0;
-		info->chg_complete_rd_flag = 2;
-		info->chg_complete_tm_ov_flag = 0;
-	}
-	else
-	{
-		if(info->capacity == 100)
-		{
-			// battery arriver to 100% earlier than time ov
-			time_ov_flag = 1;
-			info->chg_complete_rd_cnt = 0;
-			info->chg_complete_tm_ov_flag = 1;
-		}
-		else if(info->chg_complete_rd_cnt > RICOH619_TIME_CHG_COUNT)
-		{
-			// chg timer ov before cap arrive to 100%
-			time_ov_flag = 1;
-			info->chg_complete_tm_ov_flag = 1;
-			info->chg_complete_rd_cnt = 0;
-			info->soca->status = RICOH619_SOCA_FULL;
-			power_supply_changed(&info->battery);
-		}
-		else
-		{
-			time_ov_flag = 0;
-			info->chg_complete_tm_ov_flag = 0;
-		}
-	}
-
-	if ((time_ov_flag == 0) && (info->soca->chg_status == POWER_SUPPLY_STATUS_CHARGING))
-	{
-		info->chg_complete_rd_cnt++;
-		queue_delayed_work(info->monitor_wqueue, &info->charge_complete_ready, 
-			RICOH619_TIME_CHG_STEP);
-	}
-	else
-	{
-		info->chg_complete_rd_flag = 0;
-	}
-
-	RICOH_FG_DBG("PMU2: %s return\n", __func__);
-	RICOH_FG_DBG("info->chg_complete_rd_cnt = %d\n", info->chg_complete_rd_cnt);
-	RICOH_FG_DBG("info->chg_complete_rd_flag = %d\n", info->chg_complete_rd_flag);
-	RICOH_FG_DBG("info->chg_complete_tm_ov_flag = %d\n", info->chg_complete_tm_ov_flag);
-	RICOH_FG_DBG("time_ov_flag = %d\n", time_ov_flag);
-
-}
-static void ricoh619_changed_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		struct ricoh619_battery_info, changed_work.work);
-
-	RICOH_FG_DBG("PMU: %s\n", __func__);
-	power_supply_changed(&info->battery);
-
-	return;
-}
-
-static int check_jeita_status(struct ricoh619_battery_info *info, bool *is_jeita_updated)
-/*  JEITA Parameter settings
-*
-*          VCHG  
-*            |     
-* jt_vfchg_h~+~~~~~~~~~~~~~~~~~~~+
-*            |                   |
-* jt_vfchg_l-| - - - - - - - - - +~~~~~~~~~~+
-*            |    Charge area    +          |               
-*  -------0--+-------------------+----------+--- Temp
-*            !                   +
-*          ICHG     
-*            |                   +
-*  jt_ichg_h-+ - -+~~~~~~~~~~~~~~+~~~~~~~~~~+
-*            +    |              +          |
-*  jt_ichg_l-+~~~~+   Charge area           |
-*            |    +              +          |
-*         0--+----+--------------+----------+--- Temp
-*            0   jt_temp_l      jt_temp_h   55
-*/
-{
-	int temp;
-	int err = 0;
-	int vfchg;
-	uint8_t chgiset_org;
-	uint8_t batset2_org;
-	uint8_t set_vchg_h, set_vchg_l;
-	uint8_t set_ichg_h, set_ichg_l;
-
-	*is_jeita_updated = false;
-	
-	/* No execute if JEITA disabled */
-	if (!info->jt_en || info->jt_hw_sw)
-		return 0;
-
-	/* Check FG Reset */
-	if (info->soca->ready_fg) {
-		temp = get_battery_temp_2(info) / 10;
-	} else {
-		RICOH_FG_DBG(KERN_INFO "JEITA: %s *** cannot update by resetting FG ******\n", __func__);
-		goto out;
-	}
-
-	/* Read BATSET2 */
-	err = ricoh619_read(info->dev->parent, BATSET2_REG, &batset2_org);
-	if (err < 0) {
-		dev_err(info->dev, "Error in readng the battery setting register\n");
-		goto out;
-	}
-	vfchg = (batset2_org & 0x70) >> 4;
-	batset2_org &= 0x8F;
-	
-	/* Read CHGISET */
-	err = ricoh619_read(info->dev->parent, CHGISET_REG, &chgiset_org);
-	if (err < 0) {
-		dev_err(info->dev, "Error in readng the chrage setting register\n");
-		goto out;
-	}
-	chgiset_org &= 0xC0;
-
-	set_ichg_h = (uint8_t)(chgiset_org | info->jt_ichg_h);
-	set_ichg_l = (uint8_t)(chgiset_org | info->jt_ichg_l);
-		
-	set_vchg_h = (uint8_t)((info->jt_vfchg_h << 4) | batset2_org);
-	set_vchg_l = (uint8_t)((info->jt_vfchg_l << 4) | batset2_org);
-
-	RICOH_FG_DBG(KERN_INFO "PMU: %s *** Temperature: %d, vfchg: %d, SW status: %d, chg_status: %d ******\n",
-		 __func__, temp, vfchg, info->soca->status, info->soca->chg_status);
-
-	if (temp <= 0 || 55 <= temp) {
-		/* 1st and 5th temperature ranges (~0, 55~) */
-		RICOH_FG_DBG(KERN_INFO "PMU: %s *** Temp(%d) is out of 0-55 ******\n", __func__, temp);
-		err = ricoh619_clr_bits(info->dev->parent, CHGCTL1_REG, 0x03);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the control register\n");
-			goto out;
-		}
-		info->soca->jt_limit = 0;
-		*is_jeita_updated = true;
-	} else if (temp < info->jt_temp_l) {
-		/* 2nd temperature range (0~12) */
-		if (vfchg != info->jt_vfchg_h) {
-			RICOH_FG_DBG(KERN_INFO "PMU: %s *** 0<Temp<12, update to vfchg=%d ******\n", 
-									__func__, info->jt_vfchg_h);
-			err = ricoh619_clr_bits(info->dev->parent, CHGCTL1_REG, 0x03);
-			if (err < 0) {
-				dev_err(info->dev, "Error in writing the control register\n");
-				goto out;
-			}
-
-			/* set VFCHG/VRCHG */
-			err = ricoh619_write(info->dev->parent,
-							 BATSET2_REG, set_vchg_h);
-			if (err < 0) {
-				dev_err(info->dev, "Error in writing the battery setting register\n");
-				goto out;
-			}
-			info->soca->jt_limit = 0;
-			*is_jeita_updated = true;
-		} else
-			RICOH_FG_DBG(KERN_INFO "PMU: %s *** 0<Temp<50, already set vfchg=%d, so no need to update ******\n",
-					__func__, info->jt_vfchg_h);
-
-		/* set ICHG */
-		err = ricoh619_write(info->dev->parent, CHGISET_REG, set_ichg_l);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the battery setting register\n");
-			goto out;
-		}
-		err = ricoh619_set_bits(info->dev->parent, CHGCTL1_REG, 0x03);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the control register\n");
-			goto out;
-		}
-	} else if (temp < info->jt_temp_h) {
-		/* 3rd temperature range (12~50) */
-		if (vfchg != info->jt_vfchg_h) {
-			RICOH_FG_DBG(KERN_INFO "PMU: %s *** 12<Temp<50, update to vfchg==%d ******\n", __func__, info->jt_vfchg_h);
-
-			err = ricoh619_clr_bits(info->dev->parent, CHGCTL1_REG, 0x03);
-			if (err < 0) {
-				dev_err(info->dev, "Error in writing the control register\n");
-				goto out;
-			}
-			/* set VFCHG/VRCHG */
-			err = ricoh619_write(info->dev->parent,
-							 BATSET2_REG, set_vchg_h);
-			if (err < 0) {
-				dev_err(info->dev, "Error in writing the battery setting register\n");
-				goto out;
-			}
-			info->soca->jt_limit = 0;
-			*is_jeita_updated = true;
-		} else
-			RICOH_FG_DBG(KERN_INFO "PMU: %s *** 12<Temp<50, already set vfchg==%d, so no need to update ******\n", 
-					__func__, info->jt_vfchg_h);
-		
-		/* set ICHG */
-		err = ricoh619_write(info->dev->parent, CHGISET_REG, set_ichg_h);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the battery setting register\n");
-			goto out;
-		}
-		err = ricoh619_set_bits(info->dev->parent, CHGCTL1_REG, 0x03);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the control register\n");
-			goto out;
-		}
-	} else if (temp < 55) {
-		/* 4th temperature range (50~55) */
-		if (vfchg != info->jt_vfchg_l) {
-			RICOH_FG_DBG(KERN_INFO "PMU: %s *** 50<Temp<55, update to vfchg==%d ******\n", __func__, info->jt_vfchg_l);
-			
-			err = ricoh619_clr_bits(info->dev->parent, CHGCTL1_REG, 0x03);
-			if (err < 0) {
-				dev_err(info->dev, "Error in writing the control register\n");
-				goto out;
-			}
-			/* set VFCHG/VRCHG */
-			err = ricoh619_write(info->dev->parent,
-							 BATSET2_REG, set_vchg_l);
-			if (err < 0) {
-				dev_err(info->dev, "Error in writing the battery setting register\n");
-				goto out;
-			}
-			info->soca->jt_limit = 1;
-			*is_jeita_updated = true;
-		} else
-			RICOH_FG_DBG(KERN_INFO "JEITA: %s *** 50<Temp<55, already set vfchg==%d, so no need to update ******\n", 
-					__func__, info->jt_vfchg_l);
-
-		/* set ICHG */
-		err = ricoh619_write(info->dev->parent, CHGISET_REG, set_ichg_h);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the battery setting register\n");
-			goto out;
-		}
-		err = ricoh619_set_bits(info->dev->parent, CHGCTL1_REG, 0x03);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the control register\n");
-			goto out;
-		}
-	}
-
-	get_power_supply_status(info);
-	RICOH_FG_DBG(KERN_INFO "PMU: %s *** Hope updating value in this timing after checking jeita, chg_status: %d, is_jeita_updated: %d ******\n",
-		 __func__, info->soca->chg_status, *is_jeita_updated);
-
-	return 0;
-	
-out:
-	RICOH_FG_DBG(KERN_INFO "PMU: %s ERROR ******\n", __func__);
-	return err;
-}
-
-static void ricoh619_jeita_work(struct work_struct *work)
-{
-	int ret;
-	bool is_jeita_updated = false;
-	struct ricoh619_battery_info *info = container_of(work,
-		struct ricoh619_battery_info, jeita_work.work);
-
-	mutex_lock(&info->lock);
-
-	ret = check_jeita_status(info, &is_jeita_updated);
-	if (0 == ret) {
-		queue_delayed_work(info->monitor_wqueue, &info->jeita_work,
-					 RICOH619_JEITA_UPDATE_TIME * HZ);
-	} else {
-		RICOH_FG_DBG(KERN_INFO "PMU: %s *** Call check_jeita_status() in jeita_work, err:%d ******\n", 
-							__func__, ret);
-		queue_delayed_work(info->monitor_wqueue, &info->jeita_work,
-					 RICOH619_FG_RESET_TIME * HZ);
-	}
-
-	mutex_unlock(&info->lock);
-
-	if(true == is_jeita_updated)
-		power_supply_changed(&info->battery);
-
-	return;
-}
-
-#ifdef ENABLE_FACTORY_MODE
-/*------------------------------------------------------*/
-/* Factory Mode						*/
-/*    Check Battery exist or not			*/
-/*    If not, disabled Rapid to Complete State change	*/
-/*------------------------------------------------------*/
-static int ricoh619_factory_mode(struct ricoh619_battery_info *info)
-{
-	int ret = 0;
-	uint8_t val = 0;
-
-	ret = ricoh619_read(info->dev->parent, RICOH619_INT_MON_CHGCTR, &val);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-		return ret;
-	}
-	if (!(val & 0x01)) /* No Adapter connected */
-		return ret;
-
-	/* Rapid to Complete State change disable */
-	ret = ricoh619_set_bits(info->dev->parent, RICOH619_CHG_CTL1, 0x40);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in writing the control register\n");
-		return ret;
-	}
-
-	/* Wait 1s for checking Charging State */
-	queue_delayed_work(info->factory_mode_wqueue, &info->factory_mode_work,
-			 1*HZ);
-
-	return ret;
-}
-
-static void check_charging_state_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		struct ricoh619_battery_info, factory_mode_work.work);
-
-	int ret = 0;
-	uint8_t val = 0;
-	int chargeCurrent = 0;
-
-	ret = ricoh619_read(info->dev->parent, CHGSTATE_REG, &val);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-		return;
-	}
-
-
-	chargeCurrent = get_check_fuel_gauge_reg(info, CC_AVERAGE1_REG,
-						 CC_AVERAGE0_REG, 0x3fff);
-	if (chargeCurrent < 0) {
-		dev_err(info->dev, "Error in reading the FG register\n");
-		return;
-	}
-
-	/* Repid State && Charge Current about 0mA */
-	if (((chargeCurrent >= 0x3ffc && chargeCurrent <= 0x3fff)
-		|| chargeCurrent < 0x05) && val == 0x43) {
-		RICOH_FG_DBG("PMU:%s --- No battery !! Enter Factory mode ---\n"
-				, __func__);
-		info->entry_factory_mode = true;
-		/* clear FG_ACC bit */
-		ret = ricoh619_clr_bits(info->dev->parent, RICOH619_FG_CTRL, 0x10);
-		if (ret < 0)
-			dev_err(info->dev, "Error in writing FG_CTRL\n");
-		
-		return;	/* Factory Mode */
-	}
-
-	/* Return Normal Mode --> Rapid to Complete State change enable */
-	ret = ricoh619_clr_bits(info->dev->parent, RICOH619_CHG_CTL1, 0x40);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in writing the control register\n");
-		return;
-	}
-	RICOH_FG_DBG("PMU:%s --- Battery exist !! Return Normal mode ---0x%2x\n"
-			, __func__, val);
-
-	return;
-}
-#endif /* ENABLE_FACTORY_MODE */
-
-static int Calc_Linear_Interpolation(int x0, int y0, int x1, int y1, int y)
-{
-	int	alpha;
-	int x;
-
-	alpha = (y - y0)*100 / (y1 - y0);
-
-	x = ((100 - alpha) * x0 + alpha * x1) / 100;
-
-	return x;
-}
-
-static void ricoh619_scaling_OCV_table(struct ricoh619_battery_info *info, int cutoff_vol, int full_vol, int *start_per, int *end_per)
-{
-	int		i, j;
-	int		temp;
-	int		percent_step;
-	int		OCV_percent_new[11];
-
-	/* get ocv table. this table is calculated by Apprication */
-	//RICOH_FG_DBG("PMU : %s : original table\n",__func__);
-	for (i = 0; i <= 10; i = i+1) {
-		RICOH_FG_DBG(KERN_INFO "PMU: %s : %d0%% voltage = %d uV\n",
-				 __func__, i, info->soca->ocv_table_def[i]);
-	}
-	//RICOH_FG_DBG("PMU: %s : cutoff_vol %d full_vol %d\n",
-	//			 __func__, cutoff_vol,full_vol);
-
-	/* Check Start % */
-	if (info->soca->ocv_table_def[0] > cutoff_vol * 1000) {
-		*start_per = 0;
-		RICOH_FG_DBG("PMU : %s : setting value of cuttoff_vol(%d) is out of range(%d) \n",__func__, cutoff_vol, info->soca->ocv_table_def[0]);
-	} else {
-		for (i = 1; i < 11; i++) {
-			if (info->soca->ocv_table_def[i] >= cutoff_vol * 1000) {
-				/* unit is 0.001% */
-				*start_per = Calc_Linear_Interpolation(
-					(i-1)*1000, info->soca->ocv_table_def[i-1], i*1000,
-					info->soca->ocv_table_def[i], (cutoff_vol * 1000));
-				break;
-			}
-		}
-	}
-
-	/* Check End % */
-	for (i = 1; i < 11; i++) {
-		if (info->soca->ocv_table_def[i] >= full_vol * 1000) {
-			/* unit is 0.001% */
-			*end_per = Calc_Linear_Interpolation(
-				(i-1)*1000, info->soca->ocv_table_def[i-1], i*1000,
-				 info->soca->ocv_table_def[i], (full_vol * 1000));
-			break;
-		}
-	}
-
-	/* calc new ocv percent */
-	percent_step = ( *end_per - *start_per) / 10;
-	//RICOH_FG_DBG("PMU : %s : percent_step is %d end per is %d start per is %d\n",__func__, percent_step, *end_per, *start_per);
-
-	for (i = 0; i < 11; i++) {
-		OCV_percent_new[i]
-			 = *start_per + percent_step*(i - 0);
-	}
-
-	/* calc new ocv voltage */
-	for (i = 0; i < 11; i++) {
-		for (j = 1; j < 11; j++) {
-			if (1000*j >= OCV_percent_new[i]) {
-				temp = Calc_Linear_Interpolation(
-					info->soca->ocv_table_def[j-1], (j-1)*1000,
-					info->soca->ocv_table_def[j] , j*1000,
-					 OCV_percent_new[i]);
-
-				temp = ( (temp/1000) * 4095 ) / 5000;
-
-				battery_init_para[info->num][i*2 + 1] = temp;
-				battery_init_para[info->num][i*2] = temp >> 8;
-
-				break;
-			}
-		}
-	}
-	RICOH_FG_DBG("PMU : %s : new table\n",__func__);
-	for (i = 0; i <= 10; i = i+1) {
-		temp = (battery_init_para[info->num][i*2]<<8)
-			 | (battery_init_para[info->num][i*2+1]);
-		/* conversion unit 1 Unit is 1.22mv (5000/4095 mv) */
-		temp = ((temp * 50000 * 10 / 4095) + 5) / 10;
-		RICOH_FG_DBG("PMU : %s : ocv_table %d is %d v\n",__func__, i, temp);
-	}
-
-}
-
-static int ricoh619_set_OCV_table(struct ricoh619_battery_info *info)
-{
-	int		ret = 0;
-	int		i;
-	int		full_ocv;
-	int		available_cap;
-	int		available_cap_ori;
-	int		temp;
-	int		temp1;
-	int		start_per = 0;
-	int		end_per = 0;
-	int		Rbat;
-	int		Ibat_min;
-	uint8_t val;
-	uint8_t val2;
-	uint8_t val_temp;
-
-
-	//get ocv table 
-	for (i = 0; i <= 10; i = i+1) {
-		info->soca->ocv_table_def[i] = get_OCV_voltage(info, i);
-		RICOH_FG_DBG(KERN_INFO "PMU: %s : %d0%% voltage = %d uV\n",
-			 __func__, i, info->soca->ocv_table_def[i]);
-	}
-
-	temp =  (battery_init_para[info->num][24]<<8) | (battery_init_para[info->num][25]);
-	Rbat = temp * 1000 / 512 * 5000 / 4095;
-	info->soca->Rsys = Rbat + 55;
-
-	if ((info->fg_target_ibat == 0) || (info->fg_target_vsys == 0)) {	/* normal version */
-
-		temp =  (battery_init_para[info->num][22]<<8) | (battery_init_para[info->num][23]);
-		//fa_cap = get_check_fuel_gauge_reg(info, FA_CAP_H_REG, FA_CAP_L_REG,
-		//				0x7fff);
-
-		info->soca->target_ibat = temp*2/10; /* calc 0.2C*/
-		temp1 =  (battery_init_para[info->num][0]<<8) | (battery_init_para[info->num][1]);
-
-		info->soca->target_vsys = temp1 + ( info->soca->target_ibat * info->soca->Rsys ) / 1000;
-		
-
-	} else {
-		info->soca->target_ibat = info->fg_target_ibat;
-		/* calc min vsys value */
-		temp1 =  (battery_init_para[info->num][0]<<8) | (battery_init_para[info->num][1]);
-		temp = temp1 + ( info->soca->target_ibat * info->soca->Rsys ) / 1000;
-		if( temp < info->fg_target_vsys) {
-			info->soca->target_vsys = info->fg_target_vsys;
-		} else {
-			info->soca->target_vsys = temp;
-			RICOH_FG_DBG("PMU : %s : setting value of target vsys(%d) is out of range(%d)\n",__func__, info->fg_target_vsys, temp);
-		}
-	}
-
-	//for debug
-	RICOH_FG_DBG("PMU : %s : target_vsys is %d target_ibat is %d\n",__func__,info->soca->target_vsys,info->soca->target_ibat);
-	
-	if ((info->soca->target_ibat == 0) || (info->soca->target_vsys == 0)) {	/* normal version */
-	} else {	/*Slice cutoff voltage version. */
-
-		Ibat_min = -1 * info->soca->target_ibat;
-		info->soca->cutoff_ocv = info->soca->target_vsys - Ibat_min * info->soca->Rsys / 1000;
-		
-		full_ocv = (battery_init_para[info->num][20]<<8) | (battery_init_para[info->num][21]);
-		full_ocv = full_ocv * 5000 / 4095;
-
-		ricoh619_scaling_OCV_table(info, info->soca->cutoff_ocv, full_ocv, &start_per, &end_per);
-
-		/* calc available capacity */
-		/* get avilable capacity */
-		/* battery_init_para23-24 is designe capacity */
-		available_cap = (battery_init_para[info->num][22]<<8)
-					 | (battery_init_para[info->num][23]);
-
-		available_cap = available_cap
-			 * ((10000 - start_per) / 100) / 100 ;
-
-
-		battery_init_para[info->num][23] =  available_cap;
-		battery_init_para[info->num][22] =  available_cap >> 8;
-
-	}
-	ret = ricoh619_clr_bits(info->dev->parent, FG_CTRL_REG, 0x01);
-	if (ret < 0) {
-		dev_err(info->dev, "error in FG_En off\n");
-		goto err;
-	}
-	/////////////////////////////////
-	ret = ricoh619_read_bank1(info->dev->parent, 0xDC, &val);
-	if (ret < 0) {
-		dev_err(info->dev, "batterry initialize error\n");
-		goto err;
-	}
-
-	val_temp = val;
-	val	&= 0x0F; //clear bit 4-7
-	val	|= 0x10; //set bit 4
-	
-	ret = ricoh619_write_bank1(info->dev->parent, 0xDC, val);
-	if (ret < 0) {
-		dev_err(info->dev, "batterry initialize error\n");
-		goto err;
-	}
-	
-	ret = ricoh619_read_bank1(info->dev->parent, 0xDC, &val2);
-	if (ret < 0) {
-		dev_err(info->dev, "batterry initialize error\n");
-		goto err;
-	}
-
-	ret = ricoh619_write_bank1(info->dev->parent, 0xDC, val_temp);
-	if (ret < 0) {
-		dev_err(info->dev, "batterry initialize error\n");
-		goto err;
-	}
-
-	RICOH_FG_DBG("PMU : %s : original 0x%x, before 0x%x, after 0x%x\n",__func__, val_temp, val, val2);
-	
-	if (val != val2) {
-		ret = ricoh619_bulk_writes_bank1(info->dev->parent,
-				BAT_INIT_TOP_REG, 30, battery_init_para[info->num]);
-		if (ret < 0) {
-			dev_err(info->dev, "batterry initialize error\n");
-			goto err;
-		}
-	} else {
-		ret = ricoh619_read_bank1(info->dev->parent, 0xD2, &val);
-		if (ret < 0) {
-		dev_err(info->dev, "batterry initialize error\n");
-		goto err;
-		}
-	
-		ret = ricoh619_read_bank1(info->dev->parent, 0xD3, &val2);
-		if (ret < 0) {
-			dev_err(info->dev, "batterry initialize error\n");
-			goto err;
-		}
-		
-		available_cap_ori = val2 + (val << 8);
-		available_cap = battery_init_para[info->num][23]
-						+ (battery_init_para[info->num][22] << 8);
-
-		if (available_cap_ori == available_cap) {
-			ret = ricoh619_bulk_writes_bank1(info->dev->parent,
-				BAT_INIT_TOP_REG, 22, battery_init_para[info->num]);
-			if (ret < 0) {
-				dev_err(info->dev, "batterry initialize error\n");
-				return ret;
-			}
-			
-			for (i = 0; i < 6; i++) {
-				ret = ricoh619_write_bank1(info->dev->parent, 0xD4+i, battery_init_para[info->num][24+i]);
-				if (ret < 0) {
-					dev_err(info->dev, "batterry initialize error\n");
-					return ret;
-				}
-			}
-		} else {
-			ret = ricoh619_bulk_writes_bank1(info->dev->parent,
-				BAT_INIT_TOP_REG, 30, battery_init_para[info->num]);
-			if (ret < 0) {
-				dev_err(info->dev, "batterry initialize error\n");
-				goto err;
-			}
-		}
-	}
-
-	////////////////////////////////
-
-	return 0;
-err:
-	return ret;
-}
-
-/* Initial setting of battery */
-static int ricoh619_init_battery(struct ricoh619_battery_info *info)
-{
-	int ret = 0;
-	uint8_t val;
-	uint8_t val2;
-	/* Need to implement initial setting of batery and error */
-	/* -------------------------- */
-#ifdef ENABLE_FUEL_GAUGE_FUNCTION
-
-	/* set relaxation state */
-	if (RICOH619_REL1_SEL_VALUE > 240)
-		val = 0x0F;
-	else
-		val = RICOH619_REL1_SEL_VALUE / 16 ;
-
-	/* set relaxation state */
-	if (RICOH619_REL2_SEL_VALUE > 120)
-		val2 = 0x0F;
-	else
-		val2 = RICOH619_REL2_SEL_VALUE / 8 ;
-
-	val =  val + (val2 << 4);
-
-	ret = ricoh619_write_bank1(info->dev->parent, BAT_REL_SEL_REG, val);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in writing BAT_REL_SEL_REG\n");
-		return ret;
-	}
-
-	ret = ricoh619_read_bank1(info->dev->parent, BAT_REL_SEL_REG, &val);
-	RICOH_FG_DBG("PMU: -------  BAT_REL_SEL= %xh: =======\n",
-		val);
-
-	ret = ricoh619_write_bank1(info->dev->parent, BAT_TA_SEL_REG, 0x00);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in writing BAT_TA_SEL_REG\n");
-		return ret;
-	}
-
-//	ret = ricoh619_read(info->dev->parent, FG_CTRL_REG, &val);
-//	if (ret < 0) {
-//		dev_err(info->dev, "Error in reading the control register\n");
-//		return ret;
-//	}
-
-//	val = (val & 0x10) >> 4;
-//	info->first_pwon = (val == 0) ? 1 : 0;
-	ret = ricoh619_read(info->dev->parent, PSWR_REG, &val);
-	if (ret < 0) {
-		dev_err(info->dev,"Error in reading PSWR_REG %d\n", ret);
-		return ret;
-	}
-	info->first_pwon = (val == 0) ? 1 : 0;
-	g_soc = val & 0x7f;
-	
-	ret = ricoh619_set_OCV_table(info);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in writing the OCV Tabler\n");
-		return ret;
-	}
-
-	ret = ricoh619_write(info->dev->parent, FG_CTRL_REG, 0x11);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in writing the control register\n");
-		return ret;
-	}
-
-#endif
-
-	ret = ricoh619_write(info->dev->parent, VINDAC_REG, 0x03);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in writing the control register\n");
-		return ret;
-	}
-
-	if (info->alarm_vol_mv < 2700 || info->alarm_vol_mv > 3400) {
-		dev_err(info->dev, "alarm_vol_mv is out of range!\n");
-		return -1;
-	}
-
-	return ret;
-}
-
-/* Initial setting of charger */
-static int ricoh619_init_charger(struct ricoh619_battery_info *info)
-{
-	int err;
-	uint8_t val;
-	uint8_t val2;
-	uint8_t val3;
-	int charge_status;
-	int	vfchg_val;
-	int	icchg_val;
-	int	rbat;
-	int	temp;
-
-	info->chg_ctr = 0;
-	info->chg_stat1 = 0;
-
-	err = ricoh619_set_bits(info->dev->parent, RICOH619_PWR_FUNC, 0x20);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing the PWR FUNC register\n");
-		goto free_device;
-	}
-
-	charge_status = get_power_supply_status(info);
-
-	if (charge_status != POWER_SUPPLY_STATUS_FULL)
-	{
-		/* Disable charging */
-		err = ricoh619_clr_bits(info->dev->parent,CHGCTL1_REG, 0x03);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the control register\n");
-			goto free_device;
-		}
-	}
-
-	//debug messeage
-	err = ricoh619_read(info->dev->parent, REGISET1_REG,&val);
-	RICOH_FG_DBG("PMU : %s : before REGISET1_REG (0x%x) is 0x%x info->ch_ilim_adp is 0x%x\n",__func__,REGISET1_REG,val,info->ch_ilim_adp);
-
-	/* REGISET1:(0xB6) setting */
-	if ((info->ch_ilim_adp != 0xFF) || (info->ch_ilim_adp <= 0x1D)) {
-		val = info->ch_ilim_adp;
-
-		err = ricoh619_write(info->dev->parent, REGISET1_REG,val);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing REGISET1_REG %d\n",
-										 err);
-			goto free_device;
-		}
-	}
-
-	//debug messeage
-	err = ricoh619_read(info->dev->parent, REGISET1_REG,&val);
-	RICOH_FG_DBG("PMU : %s : after REGISET1_REG (0x%x) is 0x%x info->ch_ilim_adp is 0x%x\n",__func__,REGISET1_REG,val,info->ch_ilim_adp);
-	
-		//debug messeage
-	err = ricoh619_read(info->dev->parent, REGISET2_REG,&val);
-	RICOH_FG_DBG("PMU : %s : before REGISET2_REG (0x%x) is 0x%x info->ch_ilim_usb is 0x%x\n",__func__,REGISET2_REG,val,info->ch_ilim_usb);
-
-	/* REGISET2:(0xB7) setting */
-	err = ricoh619_read(info->dev->parent, REGISET2_REG, &val);
-	if (err < 0) {
-		dev_err(info->dev,
-	 	"Error in read REGISET2_REG %d\n", err);
-		goto free_device;
-	}
-	
-	if ((info->ch_ilim_usb != 0xFF) || (info->ch_ilim_usb <= 0x1D)) {
-		val2 = info->ch_ilim_usb;
-	} else {/* Keep OTP value */
-		val2 = (val & 0x1F);
-	}
-
-		/* keep bit 5-7 */
-	val &= 0xE0;
-	
-	val = val + val2;
-	
-	err = ricoh619_write(info->dev->parent, REGISET2_REG,val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing REGISET2_REG %d\n",
-									 err);
-		goto free_device;
-	}
-
-		//debug messeage
-	err = ricoh619_read(info->dev->parent, REGISET2_REG,&val);
-	RICOH_FG_DBG("PMU : %s : after REGISET2_REG (0x%x) is 0x%x info->ch_ilim_usb is 0x%x\n",__func__,REGISET2_REG,val,info->ch_ilim_usb);
-
-	/* CHGISET_REG(0xB8) setting */
-		//debug messeage
-	err = ricoh619_read(info->dev->parent, CHGISET_REG,&val);
-	RICOH_FG_DBG("PMU : %s : before CHGISET_REG (0x%x) is 0x%x info->ch_ichg is 0x%x info->ch_icchg is 0x%x\n",__func__,CHGISET_REG,val,info->ch_ichg,info->ch_icchg);
-
-	err = ricoh619_read(info->dev->parent, CHGISET_REG, &val);
-	if (err < 0) {
-		dev_err(info->dev,
-	 	"Error in read CHGISET_REG %d\n", err);
-		goto free_device;
-	}
-
-		/* Define Current settings value for charging (bit 4~0)*/
-	if ((info->ch_ichg != 0xFF) || (info->ch_ichg <= 0x1D)) {
-		val2 = info->ch_ichg;
-	} else { /* Keep OTP value */
-		val2 = (val & 0x1F);
-	}
-
-		/* Define Current settings at the charge completion (bit 7~6)*/
-	if ((info->ch_icchg != 0xFF) || (info->ch_icchg <= 0x03)) {
-		val3 = info->ch_icchg << 6;
-	} else { /* Keep OTP value */
-		val3 = (val & 0xC0);
-	}
-
-	val = val2 + val3;
-
-	err = ricoh619_write(info->dev->parent, CHGISET_REG, val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing CHGISET_REG %d\n",
-									 err);
-		goto free_device;
-	}
-
-		//debug messeage
-	err = ricoh619_read(info->dev->parent, CHGISET_REG,&val);
-	RICOH_FG_DBG("PMU : %s : after CHGISET_REG (0x%x) is 0x%x info->ch_ichg is 0x%x info->ch_icchg is 0x%x\n",__func__,CHGISET_REG,val,info->ch_ichg,info->ch_icchg);
-
-		//debug messeage
-	err = ricoh619_read(info->dev->parent, BATSET1_REG,&val);
-	RICOH_FG_DBG("PMU : %s : before BATSET1_REG (0x%x) is 0x%x info->ch_vbatovset is 0x%x\n",__func__,BATSET1_REG,val,info->ch_vbatovset);
-	
-	/* BATSET1_REG(0xBA) setting */
-	err = ricoh619_read(info->dev->parent, BATSET1_REG, &val);
-	if (err < 0) {
-		dev_err(info->dev,
-	 	"Error in read BATSET1 register %d\n", err);
-		goto free_device;
-	}
-
-		/* Define Battery overvoltage  (bit 4)*/
-	if ((info->ch_vbatovset != 0xFF) || (info->ch_vbatovset <= 0x1)) {
-		val2 = info->ch_vbatovset;
-		val2 = val2 << 4;
-	} else { /* Keep OTP value */
-		val2 = (val & 0x10);
-	}
-	
-		/* keep bit 0-3 and bit 5-7 */
-	val = (val & 0xEF);
-	
-	val = val + val2;
-
-	err = ricoh619_write(info->dev->parent, BATSET1_REG, val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing BAT1_REG %d\n",
-									 err);
-		goto free_device;
-	}
-		//debug messeage
-	err = ricoh619_read(info->dev->parent, BATSET1_REG,&val);
-	RICOH_FG_DBG("PMU : %s : after BATSET1_REG (0x%x) is 0x%x info->ch_vbatovset is 0x%x\n",__func__,BATSET1_REG,val,info->ch_vbatovset);
-	
-		//debug messeage
-	err = ricoh619_read(info->dev->parent, BATSET2_REG,&val);
-	RICOH_FG_DBG("PMU : %s : before BATSET2_REG (0x%x) is 0x%x info->ch_vrchg is 0x%x info->ch_vfchg is 0x%x \n",__func__,BATSET2_REG,val,info->ch_vrchg,info->ch_vfchg);
-
-	
-	/* BATSET2_REG(0xBB) setting */
-	err = ricoh619_read(info->dev->parent, BATSET2_REG, &val);
-	if (err < 0) {
-		dev_err(info->dev,
-	 	"Error in read BATSET2 register %d\n", err);
-		goto free_device;
-	}
-
-		/* Define Re-charging voltage (bit 2~0)*/
-	if ((info->ch_vrchg != 0xFF) || (info->ch_vrchg <= 0x04)) {
-		val2 = info->ch_vrchg;
-	} else { /* Keep OTP value */
-		val2 = (val & 0x07);
-	}
-
-		/* Define FULL charging voltage (bit 6~4)*/
-	if ((info->ch_vfchg != 0xFF) || (info->ch_vfchg <= 0x04)) {
-		val3 = info->ch_vfchg;
-		val3 = val3 << 4;
-	} else {	/* Keep OTP value */
-		val3 = (val & 0x70);
-	}
-
-		/* keep bit 3 and bit 7 */
-	val = (val & 0x88);
-	
-	val = val + val2 + val3;
-
-	err = ricoh619_write(info->dev->parent, BATSET2_REG, val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing RICOH619_RE_CHARGE_VOLTAGE %d\n",
-									 err);
-		goto free_device;
-	}
-
-		//debug messeage
-	err = ricoh619_read(info->dev->parent, BATSET2_REG,&val);
-	RICOH_FG_DBG("PMU : %s : after BATSET2_REG (0x%x) is 0x%x info->ch_vrchg is 0x%x info->ch_vfchg is 0x%x  \n",__func__,BATSET2_REG,val,info->ch_vrchg,info->ch_vfchg);
-
-	/* Set rising edge setting ([1:0]=01b)for INT in charging */
-	/*  and rising edge setting ([3:2]=01b)for charge completion */
-	err = ricoh619_read(info->dev->parent, RICOH619_CHG_STAT_DETMOD1, &val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in reading CHG_STAT_DETMOD1 %d\n",
-								 err);
-		goto free_device;
-	}
-	val &= 0xf0;
-	val |= 0x05;
-	err = ricoh619_write(info->dev->parent, RICOH619_CHG_STAT_DETMOD1, val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing CHG_STAT_DETMOD1 %d\n",
-								 err);
-		goto free_device;
-	}
-
-	/* Unmask In charging/charge completion */
-	err = ricoh619_write(info->dev->parent, RICOH619_INT_MSK_CHGSTS1, 0xfc);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing INT_MSK_CHGSTS1 %d\n",
-								 err);
-		goto free_device;
-	}
-
-	/* Set both edge for VUSB([3:2]=11b)/VADP([1:0]=11b) detect */
-	err = ricoh619_read(info->dev->parent, RICOH619_CHG_CTRL_DETMOD1, &val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in reading CHG_CTRL_DETMOD1 %d\n",
-								 err);
-		goto free_device;
-	}
-	val &= 0xf0;
-	val |= 0x0f;
-	err = ricoh619_write(info->dev->parent, RICOH619_CHG_CTRL_DETMOD1, val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing CHG_CTRL_DETMOD1 %d\n",
-								 err);
-		goto free_device;
-	}
-
-	/* Unmask In VUSB/VADP completion */
-	err = ricoh619_write(info->dev->parent, RICOH619_INT_MSK_CHGCTR, 0xfc);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing INT_MSK_CHGSTS1 %d\n",
-									 err);
-		goto free_device;
-	}
-	
-	if (charge_status != POWER_SUPPLY_STATUS_FULL)
-	{
-		/* Enable charging */
-		err = ricoh619_set_bits(info->dev->parent,CHGCTL1_REG, 0x03);
-		if (err < 0) {
-			dev_err(info->dev, "Error in writing the control register\n");
-			goto free_device;
-		}
-	}
-	/* get OCV100_min, OCV100_min*/
-	temp = (battery_init_para[info->num][24]<<8) | (battery_init_para[info->num][25]);
-	rbat = temp * 1000 / 512 * 5000 / 4095;
-	
-	/* get vfchg value */
-	err = ricoh619_read(info->dev->parent, BATSET2_REG, &val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in reading the batset2reg\n");
-		goto free_device;
-	}
-	val &= 0x70;
-	val2 = val >> 4;
-	if (val2 <= 3) {
-		vfchg_val = 4050 + val2 * 50;
-	} else {
-		vfchg_val = 4350;
-	}
-	RICOH_FG_DBG("PMU : %s : test test val %d, val2 %d vfchg %d\n", __func__, val, val2, vfchg_val);
-
-	/* get  value */
-	err = ricoh619_read(info->dev->parent, CHGISET_REG, &val);
-	if (err < 0) {
-		dev_err(info->dev, "Error in reading the chgisetreg\n");
-		goto free_device;
-	}
-	val &= 0xC0;
-	val2 = val >> 6;
-	icchg_val = 50 + val2 * 50;
-	RICOH_FG_DBG("PMU : %s : test test val %d, val2 %d icchg %d\n", __func__, val, val2, icchg_val);
-
-	info->soca->OCV100_min = ( vfchg_val * 99 / 100 - (icchg_val * (rbat +20))/1000 - 20 ) * 1000;
-	info->soca->OCV100_max = ( vfchg_val * 101 / 100 - (icchg_val * (rbat +20))/1000 + 20 ) * 1000;
-	
-	RICOH_FG_DBG("PMU : %s : 100 min %d, 100 max %d vfchg %d icchg %d rbat %d\n",__func__,
-	info->soca->OCV100_min,info->soca->OCV100_max,vfchg_val,icchg_val,rbat);
-
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-	/* Set ADRQ=00 to stop ADC */
-	ricoh619_write(info->dev->parent, RICOH619_ADC_CNT3, 0x0);
-	/* Enable VSYS threshold Low interrupt */
-	ricoh619_write(info->dev->parent, RICOH619_INT_EN_ADC1, 0x10);
-	/* Set ADC auto conversion interval 250ms */
-	ricoh619_write(info->dev->parent, RICOH619_ADC_CNT2, 0x0);
-	/* Enable VSYS pin conversion in auto-ADC */
-//	ricoh619_write(info->dev->parent, RICOH619_ADC_CNT1, 0x10);
-	ricoh619_write(info->dev->parent, RICOH619_ADC_CNT1, 0x16);
-	/* Set VSYS threshold low voltage value = (voltage(V)*255)/(3*2.5) */
-	val = info->alarm_vol_mv * 255 / 7500;
-	ricoh619_write(info->dev->parent, RICOH619_ADC_VSYS_THL, val);
-	/* Start auto-mode & average 4-time conversion mode for ADC */
-	ricoh619_write(info->dev->parent, RICOH619_ADC_CNT3, 0x28);
-	/* Enable master ADC INT */
-	ricoh619_set_bits(info->dev->parent, RICOH619_INTC_INTEN, ADC_INT);
-#endif
-
-free_device:
-	return err;
-}
-
-
-static int get_power_supply_status(struct ricoh619_battery_info *info)
-{
-	uint8_t status;
-	uint8_t supply_state;
-	uint8_t charge_state;
-	int ret = 0;
-
-	/* get  power supply status */
-	ret = ricoh619_read(info->dev->parent, CHGSTATE_REG, &status);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-		return ret;
-	}
-
-	charge_state = (status & 0x1F);
-	supply_state = ((status & 0xC0) >> 6);
-
-	if (info->entry_factory_mode)
-			return POWER_SUPPLY_STATUS_NOT_CHARGING;
-
-	if (supply_state == SUPPLY_STATE_BAT) {
-		info->soca->chg_status = POWER_SUPPLY_STATUS_DISCHARGING;
-	} else {
-		switch (charge_state) {
-		case	CHG_STATE_CHG_OFF:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_DISCHARGING;
-				break;
-		case	CHG_STATE_CHG_READY_VADP:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-		case	CHG_STATE_CHG_TRICKLE:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_CHARGING;
-				break;
-		case	CHG_STATE_CHG_RAPID:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_CHARGING;
-				break;
-		case	CHG_STATE_CHG_COMPLETE:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_FULL;
-				break;
-		case	CHG_STATE_SUSPEND:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_DISCHARGING;
-				break;
-		case	CHG_STATE_VCHG_OVER_VOL:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_DISCHARGING;
-				break;
-		case	CHG_STATE_BAT_ERROR:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-		case	CHG_STATE_NO_BAT:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-		case	CHG_STATE_BAT_OVER_VOL:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-		case	CHG_STATE_BAT_TEMP_ERR:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-		case	CHG_STATE_DIE_ERR:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-		case	CHG_STATE_DIE_SHUTDOWN:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_DISCHARGING;
-				break;
-		case	CHG_STATE_NO_BAT2:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-		case	CHG_STATE_CHG_READY_VUSB:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-		default:
-				info->soca->chg_status
-					= POWER_SUPPLY_STATUS_UNKNOWN;
-				break;
-		}
-	}
-
-	return info->soca->chg_status;
-}
-
-static int get_power_supply_Android_status(struct ricoh619_battery_info *info)
-{
-
-	get_power_supply_status(info);
-
-	/* get  power supply status */
-	if (info->entry_factory_mode)
-			return POWER_SUPPLY_STATUS_NOT_CHARGING;
-
-	switch (info->soca->chg_status) {
-		case	POWER_SUPPLY_STATUS_UNKNOWN:
-				return POWER_SUPPLY_STATUS_UNKNOWN;
-				break;
-
-		case	POWER_SUPPLY_STATUS_NOT_CHARGING:
-				return POWER_SUPPLY_STATUS_NOT_CHARGING;
-				break;
-
-		case	POWER_SUPPLY_STATUS_DISCHARGING:
-				return POWER_SUPPLY_STATUS_DISCHARGING;
-				break;
-
-		case	POWER_SUPPLY_STATUS_CHARGING:
-				return POWER_SUPPLY_STATUS_CHARGING;
-				break;
-
-		case	POWER_SUPPLY_STATUS_FULL:
-				if(info->soca->displayed_soc == 100 * 100) {
-					return POWER_SUPPLY_STATUS_FULL;
-				} else {
-					return POWER_SUPPLY_STATUS_CHARGING;
-				}
-				break;
-		default:
-				return POWER_SUPPLY_STATUS_UNKNOWN;
-				break;
-	}
-
-	return POWER_SUPPLY_STATUS_UNKNOWN;
-}
-extern struct ricoh619 *g_ricoh619;
-static void charger_irq_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info
-		 = container_of(work, struct ricoh619_battery_info, irq_work);
-	int ret = 0;
-	uint8_t reg_val;
-	RICOH_FG_DBG("PMU:%s In\n", __func__);
-
-	power_supply_changed(&info->battery);
-	power_supply_changed(&powerac);
-	power_supply_changed(&powerusb);
-
-//	mutex_lock(&info->lock);
-	
-	if (info->chg_stat1 & 0x01) {
-		ricoh619_read(info->dev->parent, CHGSTATE_REG, &reg_val);
-		if (reg_val & 0x40) { /* USE ADP */	
-			#ifdef SUPPORT_USB_CONNECT_TO_ADP
-				int i;
-				for(i =0;i<60;i++){
-				RICOH_FG_DBG("PMU:%s usb det dwc_otg_check_dpdm =%d\n", __func__,dwc_otg_check_dpdm(0));
-				if(2 == dwc_otg_check_dpdm(0)){
-				/* set adp limit current 2A */
-				ricoh619_write(info->dev->parent, REGISET1_REG, 0x16);
-				/* set charge current 2A */
-				ricoh619_write(info->dev->parent, CHGISET_REG, 0xD3); 
-				}
-				else {
-				/* set adp limit current 500ma */
-				ricoh619_write(info->dev->parent, REGISET1_REG, 0x04);
-				/* set charge current 500ma */
-				ricoh619_write(info->dev->parent, CHGISET_REG, 0xc4); 
-				}
-				
-				power_supply_changed(&info->battery);
-				power_supply_changed(&powerac);
-				power_supply_changed(&powerusb);
-				msleep(100);
-				}
-			#else //support adp and usb chag
-			if (gpio_is_valid(g_ricoh619->dc_det)){
-				ret = gpio_request(g_ricoh619->dc_det, "ricoh619_dc_det");
-				if (ret < 0) {
-					RICOH_FG_DBG("Failed to request gpio %d with ret:""%d\n",g_ricoh619->dc_det, ret);
-				}
-				gpio_direction_input(g_ricoh619->dc_det);
-				ret = gpio_get_value(g_ricoh619->dc_det);
-
-				if (ret ==0){
-					/* set adp limit current 2A */
-					ricoh619_write(info->dev->parent, REGISET1_REG, 0x16);
-					/* set charge current 2A */
-					ricoh619_write(info->dev->parent, CHGISET_REG, 0xD3);
- 				}
-				else {
-					/* set adp limit current 500ma */
-					ricoh619_write(info->dev->parent, REGISET1_REG, 0x04);
-					/* set charge current 500ma */
-					ricoh619_write(info->dev->parent, CHGISET_REG, 0xc4); 
-				}
-				gpio_free(g_ricoh619->dc_det);
-			}
-			else{
-				/* set adp limit current 2A */
-				ricoh619_write(info->dev->parent, REGISET1_REG, 0x16);
-				/* set charge current 2A */
-				ricoh619_write(info->dev->parent, CHGISET_REG, 0xD3); 
-			}
-			#endif
-		} else if (reg_val & 0x80) { /* USE ONLY USB */
-			queue_work(info->usb_workqueue, &info->usb_irq_work);
-		}
-	}
-	info->chg_ctr = 0;
-	info->chg_stat1 = 0;
-	
-	/* Enable Interrupt for VADP/USB */
-	ret = ricoh619_write(info->dev->parent, RICOH619_INT_MSK_CHGCTR, 0xfc);
-	if (ret < 0)
-		dev_err(info->dev,
-			 "%s(): Error in enable charger mask INT %d\n",
-			 __func__, ret);
-
-	/* Enable Interrupt for Charging & complete */
-	ret = ricoh619_write(info->dev->parent, RICOH619_INT_MSK_CHGSTS1, 0xfc);
-	if (ret < 0)
-		dev_err(info->dev,
-			 "%s(): Error in enable charger mask INT %d\n",
-			 __func__, ret);
-
-//	mutex_unlock(&info->lock);
-	RICOH_FG_DBG("PMU:%s Out\n", __func__);
-}
-
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-static void low_battery_irq_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		 struct ricoh619_battery_info, low_battery_work.work);
-
-	int ret = 0;
-
-	RICOH_FG_DBG("PMU:%s In\n", __func__);
-
-	power_supply_changed(&info->battery);
-
-	/* Enable VADP threshold Low interrupt */
-	ricoh619_write(info->dev->parent, RICOH619_INT_EN_ADC1, 0x10);
-	if (ret < 0)
-		dev_err(info->dev,
-			 "%s(): Error in enable adc mask INT %d\n",
-			 __func__, ret);
-}
-#endif
-
-
-static void ricoh619_usb_charge_det(void)
-{
-	struct ricoh619 *ricoh619 = g_ricoh619;
-	ricoh619_set_bits(ricoh619->dev,REGISET2_REG,(1 << 7));  //set usb limit current  when SDP or other mode
-	RICOH_FG_DBG("PMU:%s usb det dwc_otg_check_dpdm =%d\n", __func__,dwc_otg_check_dpdm(0));
-	if(2 == dwc_otg_check_dpdm(0)){
-	ricoh619_write(ricoh619->dev,REGISET2_REG,0x16);  //set usb limit current  2A
-	ricoh619_write(ricoh619->dev,CHGISET_REG,0xD3);  //set charge current  2A
-	}
-	else {
-	ricoh619_write(ricoh619->dev,REGISET2_REG,0x04);  //set usb limit current  500ma
-	ricoh619_write(ricoh619->dev,CHGISET_REG,0xC4);  //set charge current	500ma
-	}
-	power_supply_changed(&powerac);
-	power_supply_changed(&powerusb);
-}
-
-static void usb_det_irq_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		 struct ricoh619_battery_info, usb_irq_work);
-	int ret = 0;
-	uint8_t sts;
-
-	RICOH_FG_DBG("PMU:%s In\n", __func__);
-
-	power_supply_changed(&info->battery);
-	power_supply_changed(&powerac);
-	power_supply_changed(&powerusb);
-
-	mutex_lock(&info->lock);
-
-	/* Enable Interrupt for VUSB */
-	ret = ricoh619_clr_bits(info->dev->parent,
-					 RICOH619_INT_MSK_CHGCTR, 0x02);
-	if (ret < 0)
-		dev_err(info->dev,
-			 "%s(): Error in enable charger mask INT %d\n",
-			 __func__, ret);
-
-	mutex_unlock(&info->lock);
-	ret = ricoh619_read(info->dev->parent, RICOH619_INT_MON_CHGCTR, &sts);
-	if (ret < 0)
-		dev_err(info->dev, "Error in reading the control register\n");
-
-	sts &= 0x02;
-	if (sts)
-		ricoh619_usb_charge_det();
-	
-	RICOH_FG_DBG("PMU:%s Out\n", __func__);
-}
-
-static irqreturn_t charger_in_isr(int irq, void *battery_info)
-{
-	struct ricoh619_battery_info *info = battery_info;
-	RICOH_FG_DBG("PMU:%s\n", __func__); 
-
-	info->chg_stat1 |= 0x01;
-
-	queue_work(info->workqueue, &info->irq_work);
-//	rk_send_wakeup_key();
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t charger_complete_isr(int irq, void *battery_info)
-{
-	struct ricoh619_battery_info *info = battery_info;
-	RICOH_FG_DBG("PMU:%s\n", __func__);
-
-	info->chg_stat1 |= 0x02;
-	queue_work(info->workqueue, &info->irq_work);
-//	rk_send_wakeup_key();
-	
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t charger_usb_isr(int irq, void *battery_info)
-{
-	struct ricoh619_battery_info *info = battery_info;
-	RICOH_FG_DBG("PMU:%s\n", __func__);
-
-	info->chg_ctr |= 0x02;
-	
-	queue_work(info->workqueue, &info->irq_work);
-	
-	info->soca->dischg_state = 0;
-	info->soca->chg_count = 0;
-
-//	queue_work(info->usb_workqueue, &info->usb_irq_work);
-	rk_send_wakeup_key(); 
-	 
-	if (RICOH619_SOCA_UNSTABLE == info->soca->status
-		|| RICOH619_SOCA_FG_RESET == info->soca->status)
-		info->soca->stable_count = 11;
-	
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t charger_adp_isr(int irq, void *battery_info)
-{
-	struct ricoh619_battery_info *info = battery_info;
-	RICOH_FG_DBG("PMU:%s\n", __func__);
-
-	info->chg_ctr |= 0x01;
-	queue_work(info->workqueue, &info->irq_work);
-	rk_send_wakeup_key(); 
-
-	info->soca->dischg_state = 0;
-	info->soca->chg_count = 0;
-	if (RICOH619_SOCA_UNSTABLE == info->soca->status
-		|| RICOH619_SOCA_FG_RESET == info->soca->status)
-		info->soca->stable_count = 11;
-
-	return IRQ_HANDLED;
-}
-
-
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-/*************************************************************/
-/* for Detecting Low Battery                                 */
-/*************************************************************/
-
-static irqreturn_t adc_vsysl_isr(int irq, void *battery_info)
-{
-
-	struct ricoh619_battery_info *info = battery_info;
-
-#if 1
-	RICOH_FG_DBG("PMU:%s\n", __func__);
-
-	queue_delayed_work(info->monitor_wqueue, &info->low_battery_work,
-					LOW_BATTERY_DETECTION_TIME*HZ);
-
-#endif
-
-	RICOH_FG_DBG("PMU:%s\n", __func__);
-//	ricoh619_write(info->dev->parent, RICOH619_INT_EN_ADC1, 0x10);
-	rk_send_wakeup_key(); 
-
-	return IRQ_HANDLED;
-}
-#endif
-#ifdef RICOH619_VADP_DROP_WORK
-static void vadp_drop_irq_work(struct work_struct *work)
-{
-	struct ricoh619_battery_info *info = container_of(work,
-		 struct ricoh619_battery_info, vadp_drop_work.work);
-
-	int ret = 0;
-	uint8_t data[6];
-	u16 reg[2];
-
-	RICOH_FG_DBG("PMU vadp_drop_work:%s In\n", __func__);
-	mutex_lock(&info->lock);	
-	ret = ricoh619_read(info->dev->parent, 0x6a, &data[0]);
-	ret = ricoh619_read(info->dev->parent, 0x6b, &data[1]);
-	ret = ricoh619_read(info->dev->parent, 0x6c, &data[2]);
-	ret = ricoh619_read(info->dev->parent, 0x6d, &data[3]);
-	ret = ricoh619_read(info->dev->parent, CHGSTATE_REG,&data[4]);
-	reg[0]= (data[0]<<4) |data[1];
-	reg[1]= (data[2]<<4) |data[3];
-
-//	printk("PMU vadp_drop:%s In %08x %08x %08x %08x %08x %08x %d\n", __func__,data[0],data[1],data[2],data[3],reg[0],reg[1],ret);	
-	if ((2*(reg[0] +82)) > 3*reg[1]){
-		ricoh619_write(info->dev->parent, 0xb3, 0x28);
-//		printk("PMU vadp_drop charger disable:%s In  %08x %08x\n", __func__,reg[0],reg[1]); 
-	}
-	else if(data[4] & 0xc0){
-		ret = ricoh619_read(info->dev->parent, 0xb3, &data[5]);
-//		 printk("PMU charger is disabled:%s data[4]= %08x data[5]=%08x\n", __func__,data[4],data[5]);
-		if(((data[5] & 0x03) ==0)|| ((data[5] & 0x08)==0)){
-			ricoh619_write(info->dev->parent, 0xb3, 0x23);
-			 ret = ricoh619_read(info->dev->parent, 0xb3, &data[5]);
-//			printk("PMU charger enable:%s data[4]= %08x data[5]=%08x\n", __func__,data[4],data[5]);
-		}
-	}
-	power_supply_changed(&info->battery);
-	power_supply_changed(&powerac);
-	power_supply_changed(&powerusb);
-	mutex_unlock(&info->lock);
-	queue_delayed_work(info->monitor_wqueue, &info->vadp_drop_work,3*HZ);
-
-}
-#endif
-/*
- * Get Charger Priority
- * - get higher-priority between VADP and VUSB
- * @ data: higher-priority is stored
- *         true : VUSB
- *         false: VADP
- */
- /*
-static int get_charge_priority(struct ricoh619_battery_info *info, bool *data)
-{
-	int ret = 0;
-	uint8_t val = 0;
-
-	ret = ricoh619_read(info->dev->parent, CHGCTL1_REG, &val);
-	val = val >> 7;
-	*data = (bool)val;
-
-	return ret;
-}
-*/
-
-/*
- * Set Charger Priority
- * - set higher-priority between VADP and VUSB
- * - data: higher-priority is stored
- *         true : VUSB
- *         false: VADP
- */
- /*
-static int set_charge_priority(struct ricoh619_battery_info *info, bool *data)
-{
-	int ret = 0;
-	uint8_t val = 0x80;
-
-	if (*data == 1)
-		ret = ricoh619_set_bits(info->dev->parent, CHGCTL1_REG, val);
-	else
-		ret = ricoh619_clr_bits(info->dev->parent, CHGCTL1_REG, val);
-
-	return ret;
-}
-*/
-#ifdef	ENABLE_FUEL_GAUGE_FUNCTION
-static int get_check_fuel_gauge_reg(struct ricoh619_battery_info *info,
-					 int Reg_h, int Reg_l, int enable_bit)
-{
-	uint8_t get_data_h, get_data_l;
-	int old_data, current_data;
-	int i;
-	int ret = 0;
-
-	old_data = 0;
-
-	for (i = 0; i < 5 ; i++) {
-		ret = ricoh619_read(info->dev->parent, Reg_h, &get_data_h);
-		if (ret < 0) {
-			dev_err(info->dev, "Error in reading the control register\n");
-			return ret;
-		}
-
-		ret = ricoh619_read(info->dev->parent, Reg_l, &get_data_l);
-		if (ret < 0) {
-			dev_err(info->dev, "Error in reading the control register\n");
-			return ret;
-		}
-
-		current_data = ((get_data_h & 0xff) << 8) | (get_data_l & 0xff);
-		current_data = (current_data & enable_bit);
-
-		if (current_data == old_data)
-			return current_data;
-		else
-			old_data = current_data;
-	}
-
-	return current_data;
-}
-
-static int calc_capacity(struct ricoh619_battery_info *info)
-{
-	uint8_t capacity;
-	int temp;
-	int ret = 0;
-	int nt;
-	int temperature;
-
-	temperature = get_battery_temp_2(info) / 10; /* unit 0.1 degree -> 1 degree */
-
-	if (temperature >= 25) {
-		nt = 0;
-	} else if (temperature >= 5) {
-		nt = (25 - temperature) * RICOH619_TAH_SEL2 * 625 / 100;
-	} else {
-		nt = (625  + (5 - temperature) * RICOH619_TAL_SEL2 * 625 / 100);
-	}
-
-	/* get remaining battery capacity from fuel gauge */
-	ret = ricoh619_read(info->dev->parent, SOC_REG, &capacity);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-		return ret;
-	}
-
-	temp = capacity * 100 * 100 / (10000 - nt);
-
-	temp = min(100, temp);
-	temp = max(0, temp);
-	
-	return temp;		/* Unit is 1% */
-}
-
-static int calc_capacity_2(struct ricoh619_battery_info *info)
-{
-	uint8_t val;
-	long capacity;
-	int re_cap, fa_cap;
-	int temp;
-	int ret = 0;
-	int nt;
-	int temperature;
-
-	temperature = get_battery_temp_2(info) / 10; /* unit 0.1 degree -> 1 degree */
-
-	if (temperature >= 25) {
-		nt = 0;
-	} else if (temperature >= 5) {
-		nt = (25 - temperature) * RICOH619_TAH_SEL2 * 625 / 100;
-	} else {
-		nt = (625  + (5 - temperature) * RICOH619_TAL_SEL2 * 625 / 100);
-	}
-
-	re_cap = get_check_fuel_gauge_reg(info, RE_CAP_H_REG, RE_CAP_L_REG,
-						0x7fff);
-	fa_cap = get_check_fuel_gauge_reg(info, FA_CAP_H_REG, FA_CAP_L_REG,
-						0x7fff);
-
-	if (fa_cap != 0) {
-		capacity = ((long)re_cap * 100 * 100 / fa_cap);
-		capacity = (long)(min(10000, (int)capacity));
-		capacity = (long)(max(0, (int)capacity));
-	} else {
-		ret = ricoh619_read(info->dev->parent, SOC_REG, &val);
-		if (ret < 0) {
-			dev_err(info->dev, "Error in reading the control register\n");
-			return ret;
-		}
-		capacity = (long)val * 100;
-	}
-	
-
-	temp = (int)(capacity * 100 * 100 / (10000 - nt));
-
-	temp = min(10000, temp);
-	temp = max(0, temp);
-
-	return temp;		/* Unit is 0.01% */
-}
-
-static int get_battery_temp(struct ricoh619_battery_info *info)
-{
-	int ret = 0;
-	int sign_bit;
-
-	ret = get_check_fuel_gauge_reg(info, TEMP_1_REG, TEMP_2_REG, 0x0fff);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the fuel gauge control register\n");
-		return ret;
-	}
-
-	/* bit3 of 0xED(TEMP_1) is sign_bit */
-	sign_bit = ((ret & 0x0800) >> 11);
-
-	ret = (ret & 0x07ff);
-
-	if (sign_bit == 0)	/* positive value part */
-		/* conversion unit */
-		/* 1 unit is 0.0625 degree and retun unit
-		 * should be 0.1 degree,
-		 */
-		ret = ret * 625  / 1000;
-	else {	/*negative value part */
-		ret = (~ret + 1) & 0x7ff;
-		ret = -1 * ret * 625 / 1000;
-	}
-
-	return ret;
-}
-
-static int get_battery_temp_2(struct ricoh619_battery_info *info)
-{
-	uint8_t reg_buff[2];
-	long temp, temp_off, temp_gain;
-	bool temp_sign, temp_off_sign, temp_gain_sign;
-	int Vsns = 0;
-	int Iout = 0;
-	int Vthm, Rthm;
-	int reg_val = 0;
-	int new_temp;
-	long R_ln1, R_ln2;
-	int ret = 0;
-
-	/* Calculate TEMP */
-	ret = get_check_fuel_gauge_reg(info, TEMP_1_REG, TEMP_2_REG, 0x0fff);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the fuel gauge register\n");
-		goto out;
-	}
-
-	reg_val = ret;
-	temp_sign = (reg_val & 0x0800) >> 11;
-	reg_val = (reg_val & 0x07ff);
-
-	if (temp_sign == 0)	/* positive value part */
-		/* the unit is 0.0001 degree */
-		temp = (long)reg_val * 625;
-	else {	/*negative value part */
-		reg_val = (~reg_val + 1) & 0x7ff;
-		temp = -1 * (long)reg_val * 625;
-	}
-
-	/* Calculate TEMP_OFF */
-	ret = ricoh619_bulk_reads_bank1(info->dev->parent,
-					TEMP_OFF_H_REG, 2, reg_buff);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the fuel gauge register\n");
-		goto out;
-	}
-
-	reg_val = reg_buff[0] << 8 | reg_buff[1];
-	temp_off_sign = (reg_val & 0x0800) >> 11;
-	reg_val = (reg_val & 0x07ff);
-
-	if (temp_off_sign == 0)	/* positive value part */
-		/* the unit is 0.0001 degree */
-		temp_off = (long)reg_val * 625;
-	else {	/*negative value part */
-		reg_val = (~reg_val + 1) & 0x7ff;
-		temp_off = -1 * (long)reg_val * 625;
-	}
-
-	/* Calculate TEMP_GAIN */
-	ret = ricoh619_bulk_reads_bank1(info->dev->parent,
-					TEMP_GAIN_H_REG, 2, reg_buff);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the fuel gauge register\n");
-		goto out;
-	}
-
-	reg_val = reg_buff[0] << 8 | reg_buff[1];
-	temp_gain_sign = (reg_val & 0x0800) >> 11;
-	reg_val = (reg_val & 0x07ff);
-
-	if (temp_gain_sign == 0)	/* positive value part */
-		/* 1 unit is 0.000488281. the result is 0.01 */
-		temp_gain = (long)reg_val * 488281 / 100000;
-	else {	/*negative value part */
-		reg_val = (~reg_val + 1) & 0x7ff;
-		temp_gain = -1 * (long)reg_val * 488281 / 100000;
-	}
-
-	/* Calculate VTHM */
-	if (0 != temp_gain)
-		Vthm = (int)((temp - temp_off) / 4095 * 2500 / temp_gain);
-	else {
-		RICOH_FG_DBG("PMU %s Skip to compensate temperature\n", __func__);
-		goto out;
-	}
-
-	ret = measure_Ibatt_FG(info, &Iout);
-	Vsns = Iout * 2 / 100;
-
-	if (temp < -120000) {
-		/* Low Temperature */
-		if (0 != (2500 - Vthm)) {
-			Rthm = 10 * 10 * (Vthm - Vsns) / (2500 - Vthm);
-		} else {
-			RICOH_FG_DBG("PMU %s Skip to compensate temperature\n", __func__);
-			goto out;
-		}
-
-		R_ln1 = Rthm / 10;
-		R_ln2 =  (R_ln1 * R_ln1 * R_ln1 * R_ln1 * R_ln1 / 100000
-			- R_ln1 * R_ln1 * R_ln1 * R_ln1 * 2 / 100
-			+ R_ln1 * R_ln1 * R_ln1 * 11
-			- R_ln1 * R_ln1 * 2980
-			+ R_ln1 * 449800
-			- 784000) / 10000;
-
-		/* the unit of new_temp is 0.1 degree */
-		new_temp = (int)((100 * 1000 * B_VALUE / (R_ln2 + B_VALUE * 100 * 1000 / 29815) - 27315) / 10);
-		RICOH_FG_DBG("PMU %s low temperature %d\n", __func__, new_temp/10);  
-	} else if (temp > 520000) {
-		/* High Temperature */
-		if (0 != (2500 - Vthm)) {
-			Rthm = 100 * 10 * (Vthm - Vsns) / (2500 - Vthm);
-		} else {
-			RICOH_FG_DBG("PMU %s Skip to compensate temperature\n", __func__);
-			goto out;
-		}
-		RICOH_FG_DBG("PMU %s [Rthm] Rthm %d[ohm]\n", __func__, Rthm);
-
-		R_ln1 = Rthm / 10;
-		R_ln2 =  (R_ln1 * R_ln1 * R_ln1 * R_ln1 * R_ln1 / 100000 * 15652 / 100
-			- R_ln1 * R_ln1 * R_ln1 * R_ln1 / 1000 * 23103 / 100
-			+ R_ln1 * R_ln1 * R_ln1 * 1298 / 100
-			- R_ln1 * R_ln1 * 35089 / 100
-			+ R_ln1 * 50334 / 10
-			- 48569) / 100;
-		/* the unit of new_temp is 0.1 degree */
-		new_temp = (int)((100 * 100 * B_VALUE / (R_ln2 + B_VALUE * 100 * 100 / 29815) - 27315) / 10);
-		RICOH_FG_DBG("PMU %s high temperature %d\n", __func__, new_temp/10);  
-	} else {
-		/* the unit of new_temp is 0.1 degree */
-		new_temp = temp / 1000;
-	}
-
-	return new_temp;
-
-out:
-	new_temp = get_battery_temp(info);
-	return new_temp;
-}
-#if 0
-static int get_time_to_empty(struct ricoh619_battery_info *info)
-{
-	int ret = 0;
-
-	ret = get_check_fuel_gauge_reg(info, TT_EMPTY_H_REG, TT_EMPTY_L_REG,
-								0xffff);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the fuel gauge control register\n");
-		return ret;
-	}
-
-	/* conversion unit */
-	/* 1unit is 1miniute and return nnit should be 1 second */
-	ret = ret * 60;
-
-	return ret;
-}
-
-static int get_time_to_full(struct ricoh619_battery_info *info)
-{
-	int ret = 0;
-
-	ret = get_check_fuel_gauge_reg(info, TT_FULL_H_REG, TT_FULL_L_REG,
-								0xffff);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the fuel gauge control register\n");
-		return ret;
-	}
-
-	ret = ret * 60;
-
-	return  ret;
-}
-#endif
-/* battery voltage is get from Fuel gauge */
-static int measure_vbatt_FG(struct ricoh619_battery_info *info, int *data)
-{
-	int ret = 0;
-
-	if(info->soca->ready_fg == 1) {
-		ret = get_check_fuel_gauge_reg(info, VOLTAGE_1_REG, VOLTAGE_2_REG,
-									0x0fff);
-		if (ret < 0) {
-			dev_err(info->dev, "Error in reading the fuel gauge control register\n");
-			return ret;
-		}
-
-		*data = ret;
-		/* conversion unit 1 Unit is 1.22mv (5000/4095 mv) */
-		*data = *data * 50000 / 4095;
-		/* return unit should be 1uV */
-		*data = *data * 100;
-		info->soca->Vbat_old = *data;
-	} else {
-		*data = info->soca->Vbat_old;
-	}
-
-	return ret;
-}
-
-static int measure_Ibatt_FG(struct ricoh619_battery_info *info, int *data)
-{
-	int ret = 0;
-
-	ret =  get_check_fuel_gauge_reg(info, CC_AVERAGE1_REG,
-						 CC_AVERAGE0_REG, 0x3fff);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the fuel gauge control register\n");
-		return ret;
-	}
-
-	*data = (ret > 0x1fff) ? (ret - 0x4000) : ret;
-	return ret;
-}
-
-static int get_OCV_init_Data(struct ricoh619_battery_info *info, int index)
-{
-	int ret = 0;
-	ret =  (battery_init_para[info->num][index*2]<<8) | (battery_init_para[info->num][index*2+1]);
-	return ret;
-}
-
-static int get_OCV_voltage(struct ricoh619_battery_info *info, int index)
-{
-	int ret = 0;
-	ret =  get_OCV_init_Data(info, index);
-	/* conversion unit 1 Unit is 1.22mv (5000/4095 mv) */
-	ret = ret * 50000 / 4095;
-	/* return unit should be 1uV */
-	ret = ret * 100;
-	return ret;
-}
-
-#else
-/* battery voltage is get from ADC */
-static int measure_vbatt_ADC(struct ricoh619_battery_info *info, int *data)
-{
-	int	i;
-	uint8_t data_l = 0, data_h = 0;
-	int ret;
-
-	/* ADC interrupt enable */
-	ret = ricoh619_set_bits(info->dev->parent, INTEN_REG, 0x08);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in setting the control register bit\n");
-		goto err;
-	}
-
-	/* enable interrupt request of single mode */
-	ret = ricoh619_set_bits(info->dev->parent, EN_ADCIR3_REG, 0x01);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in setting the control register bit\n");
-		goto err;
-	}
-
-	/* single request */
-	ret = ricoh619_write(info->dev->parent, ADCCNT3_REG, 0x10);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in writing the control register\n");
-		goto err;
-	}
-
-	for (i = 0; i < 5; i++) {
-	usleep(1000);
-		RICOH_FG_DBG("ADC conversion times: %d\n", i);
-		/* read completed flag of ADC */
-		ret = ricoh619_read(info->dev->parent, EN_ADCIR3_REG, &data_h);
-		if (ret < 0) {
-			dev_err(info->dev, "Error in reading the control register\n");
-			goto err;
-		}
-
-		if (data_h & 0x01)
-			goto	done;
-	}
-
-	dev_err(info->dev, "ADC conversion too long!\n");
-	goto err;
-
-done:
-	ret = ricoh619_read(info->dev->parent, VBATDATAH_REG, &data_h);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-		goto err;
-	}
-
-	ret = ricoh619_read(info->dev->parent, VBATDATAL_REG, &data_l);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-		goto err;
-	}
-
-	*data = ((data_h & 0xff) << 4) | (data_l & 0x0f);
-	/* conversion unit 1 Unit is 1.22mv (5000/4095 mv) */
-	*data = *data * 5000 / 4095;
-	/* return unit should be 1uV */
-	*data = *data * 1000;
-
-	return 0;
-
-err:
-	return -1;
-} 
-#endif
-
-static int measure_vsys_ADC(struct ricoh619_battery_info *info, int *data)
-{
-	uint8_t data_l = 0, data_h = 0;
-	int ret;
-
-	ret = ricoh619_read(info->dev->parent, VSYSDATAH_REG, &data_h);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-	}
-
-	ret = ricoh619_read(info->dev->parent, VSYSDATAL_REG, &data_l);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in reading the control register\n");
-	}
-
-	*data = ((data_h & 0xff) << 4) | (data_l & 0x0f);
-	*data = *data * 1000 * 3 * 5 / 2 / 4095;
-	/* return unit should be 1uV */
-	*data = *data * 1000;
-
-	return 0;
-}
-/*
-static void ricoh619_external_power_changed(struct power_supply *psy)
-{
-	struct ricoh619_battery_info *info;
-
-	info = container_of(psy, struct ricoh619_battery_info, battery);
-	queue_delayed_work(info->monitor_wqueue,
-			   &info->changed_work, HZ / 2);
-	return;
-}
-*/
-
-static int ricoh619_batt_get_prop(struct power_supply *psy,
-				enum power_supply_property psp,
-				union power_supply_propval *val)
-{
-	struct ricoh619_battery_info *info = dev_get_drvdata(psy->dev->parent);
-	int data = 0;
-	int ret = 0;
-	uint8_t status;
-
-	mutex_lock(&info->lock);
-
-	switch (psp) {
-
-	case POWER_SUPPLY_PROP_ONLINE:
-		ret = ricoh619_read(info->dev->parent, CHGSTATE_REG, &status);
-		if (ret < 0) {
-			dev_err(info->dev, "Error in reading the control register\n");
-			mutex_unlock(&info->lock);
-			return ret;
-		}
-		#ifdef SUPPORT_USB_CONNECT_TO_ADP
-			if (psy->type == POWER_SUPPLY_TYPE_MAINS){
-				if((2 == dwc_otg_check_dpdm(0)) && (status & 0x40))
-					val->intval =1;
-				else 
-					val->intval =0;
-			}
-			else if (psy->type == POWER_SUPPLY_TYPE_USB){
-				if((1 == dwc_otg_check_dpdm(0)) && (status & 0x40))
-					val->intval =1;
-				else 
-					val->intval =0;
-			}
-		#else
-			if (psy->type == POWER_SUPPLY_TYPE_MAINS)
-				val->intval = (status & 0x40 ? 1 : 0);
-			else if (psy->type == POWER_SUPPLY_TYPE_USB)
-				val->intval = (status & 0x80 ? 1 : 0);
-		#endif
-		break;
-	/* this setting is same as battery driver of 584 */
-	case POWER_SUPPLY_PROP_STATUS:
-		if(info->chg_complete_tm_ov_flag == 0)
-		{
-			ret = get_power_supply_Android_status(info);
-			val->intval = ret;
-			info->status = ret;
-			/* RICOH_FG_DBG("Power Supply Status is %d\n",
-							info->status); */
-		}
-		else
-		{
-			val->intval = POWER_SUPPLY_STATUS_FULL;
-		}
-		break;
-
-	/* this setting is same as battery driver of 584 */
-	case POWER_SUPPLY_PROP_PRESENT:
-	//	val->intval = info->present;
-		val->intval = 1;
-		break;
-
-	/* current voltage is get from fuel gauge */
-	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-		/* return real vbatt Voltage */
-#ifdef	ENABLE_FUEL_GAUGE_FUNCTION
-		if (info->soca->ready_fg)
-			ret = measure_vbatt_FG(info, &data);
-		else {
-			//val->intval = -EINVAL;
-			data = info->cur_voltage * 1000;
-			 RICOH_FG_DBG( "battery voltage is not ready\n"); 
-		}
-#else
-		ret = measure_vbatt_ADC(info, &data);
-#endif
-		val->intval = data;
-		/* convert unit uV -> mV */
-		info->cur_voltage = data / 1000;
-		
-		RICOH_FG_DBG( "battery voltage is %d mV\n",
-						info->cur_voltage);
-		break;
-
-#ifdef	ENABLE_FUEL_GAUGE_FUNCTION
-	/* current battery capacity is get from fuel gauge */
-	case POWER_SUPPLY_PROP_CAPACITY:
-		if (info->entry_factory_mode){
-			val->intval = 100;
-			info->capacity = 100;
-		} else if ((info->soca->displayed_soc < 0) || (info->cur_voltage == 0)) {
-			val->intval = 50;
-			info->capacity = 50;
-		} else {
-			if(info->chg_complete_tm_ov_flag == 1)
-			{
-				info->capacity = 100;
-				val->intval = info->capacity;
-			}
-			else
-			{
-				info->capacity = (info->soca->displayed_soc + 50)/100;
-				val->intval = info->capacity;
-			}
-		}
-		RICOH_FG_DBG("battery capacity is %d%%\n", info->capacity); 
-		break;
-
-	/* current temperature of battery */
-	case POWER_SUPPLY_PROP_TEMP:
-		if (info->soca->ready_fg) {
-			ret = 0;
-			val->intval = get_battery_temp_2(info);
-			info->battery_temp = val->intval/10;
-			RICOH_FG_DBG( "battery temperature is %d degree\n", info->battery_temp);
-		} else {
-			val->intval = info->battery_temp * 10;
-			/* RICOH_FG_DBG("battery temperature is not ready\n"); */
-		}
-		break;
-
-	#if 0
-	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
-		if (info->soca->ready_fg) {
-			ret = get_time_to_empty(info);
-			val->intval = ret;
-			info->time_to_empty = ret/60;
-			RICOH_FG_DBG("time of empty battery is %d minutes\n", info->time_to_empty);
-		} else {
-			//val->intval = -EINVAL;
-			val->intval = info->time_to_empty * 60;
-			RICOH_FG_DBG("time of empty battery is %d minutes\n", info->time_to_empty);
-			/* RICOH_FG_DBG( "time of empty battery is not ready\n"); */
-		}
-		break;
-
-	 case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
-		if (info->soca->ready_fg) {
-			ret = get_time_to_full(info);
-			val->intval = ret;
-			info->time_to_full = ret/60;
-			RICOH_FG_DBG( "time of full battery is %d minutes\n", info->time_to_full);
-		} else {
-			//val->intval = -EINVAL;
-			val->intval = info->time_to_full * 60;
-			RICOH_FG_DBG( "time of full battery is %d minutes\n", info->time_to_full);
-			/* RICOH_FG_DBG("time of full battery is not ready\n"); */
-		}
-		break;
-
-	#endif
-#endif
-	 case POWER_SUPPLY_PROP_TECHNOLOGY:
-		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
-		ret = 0;
-		break;
-
-	case POWER_SUPPLY_PROP_HEALTH:
-		val->intval = POWER_SUPPLY_HEALTH_GOOD;
-		ret = 0;
-		break;
-	case POWER_SUPPLY_PROP_CURRENT_AVG:
- 		measure_Ibatt_FG(info, &data);
-		//RICOH_FG_DBG("average current xxxxxxxxxxxxxx %d \n", data);
-		break;
-	default:
-		mutex_unlock(&info->lock);
-		return -ENODEV;
-	}
-
-	mutex_unlock(&info->lock);
-
-	return ret;
-}
-
-static enum power_supply_property ricoh619_batt_props[] = {
-	POWER_SUPPLY_PROP_STATUS,
-	POWER_SUPPLY_PROP_PRESENT,
-	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-	POWER_SUPPLY_PROP_CURRENT_AVG,
-
-#ifdef	ENABLE_FUEL_GAUGE_FUNCTION
-	POWER_SUPPLY_PROP_CAPACITY,
-	POWER_SUPPLY_PROP_TEMP,
-	//POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
-	//POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
-#endif
-	POWER_SUPPLY_PROP_TECHNOLOGY,
-	POWER_SUPPLY_PROP_HEALTH,
-};
-
-static enum power_supply_property ricoh619_power_props[] = {
-	POWER_SUPPLY_PROP_ONLINE,
-};
-
-struct power_supply	powerac = {
-		.name = "acpwr",
-		.type = POWER_SUPPLY_TYPE_MAINS,
-		.properties = ricoh619_power_props,
-		.num_properties = ARRAY_SIZE(ricoh619_power_props),
-		.get_property = ricoh619_batt_get_prop,
-};
-
-struct power_supply	powerusb = {
-		.name = "usbpwr",
-		.type = POWER_SUPPLY_TYPE_USB,
-		.properties = ricoh619_power_props,
-		.num_properties = ARRAY_SIZE(ricoh619_power_props),
-		.get_property = ricoh619_batt_get_prop,
-};
-
-#ifdef CONFIG_OF
-static struct ricoh619_battery_platform_data *
-ricoh619_battery_dt_init(struct platform_device *pdev)
-{
-	struct device_node *nproot = pdev->dev.parent->of_node;
-	struct device_node *np;
-	struct ricoh619_battery_platform_data *pdata;
-
-	if (!nproot)
-		return pdev->dev.platform_data;
-
-	np = of_find_node_by_name(nproot, "battery");
-	if (!np) {
-		dev_err(&pdev->dev, "failed to find battery node\n");
-		return NULL;
-	}
-
-	pdata = devm_kzalloc(&pdev->dev,
-			sizeof(struct ricoh619_battery_platform_data),
-			GFP_KERNEL);
-
-	of_property_read_u32(np, "ricoh,monitor-time", &pdata->monitor_time);
-	of_property_read_u32(np, "ricoh,alarm-vol-mv", &pdata->alarm_vol_mv);
-
-	/* check rage of b,.attery type */
-	type_n = Battery_Type();
-	RICOH_FG_DBG("%s type_n=%d\n", __func__, type_n);
-
-	switch (type_n) {
-	case (0):
-		of_property_read_u32(np, "ricoh,ch-vfchg", &pdata->type[0].ch_vfchg);
-		of_property_read_u32(np, "ricoh,ch-vrchg", &pdata->type[0].ch_vrchg);
-		of_property_read_u32(np, "ricoh,ch-vbatovset", &pdata->type[0].ch_vbatovset);
-		of_property_read_u32(np, "ricoh,ch-ichg", &pdata->type[0].ch_ichg);
-		of_property_read_u32(np, "ricoh,ch-ilim-adp", &pdata->type[0].ch_ilim_adp);
-		of_property_read_u32(np, "ricoh,ch-ilim-usb", &pdata->type[0].ch_ilim_usb);
-		of_property_read_u32(np, "ricoh,ch-icchg", &pdata->type[0].ch_icchg);
-		of_property_read_u32(np, "ricoh,fg-target-vsys", &pdata->type[0].fg_target_vsys);
-		of_property_read_u32(np, "ricoh,fg-target-ibat", &pdata->type[0].fg_target_ibat);
-		of_property_read_u32(np, "ricoh,fg-poff-vbat", &pdata->type[0].fg_poff_vbat);
-		of_property_read_u32(np, "ricoh,jt-en", &pdata->type[0].jt_en);
-		of_property_read_u32(np, "ricoh,jt-hw-sw", &pdata->type[0].jt_hw_sw);
-		of_property_read_u32(np, "ricoh,jt-temp-h", &pdata->type[0].jt_temp_h);
-		of_property_read_u32(np, "ricoh,jt-temp-l", &pdata->type[0].jt_temp_l);
-		of_property_read_u32(np, "ricoh,jt-vfchg-h", &pdata->type[0].jt_vfchg_h);
-		of_property_read_u32(np, "ricoh,jt-vfchg-l", &pdata->type[0].jt_vfchg_l);
-		of_property_read_u32(np, "ricoh,jt-ichg-h", &pdata->type[0].jt_ichg_h);
-		of_property_read_u32(np, "ricoh,jt-ichg-l", &pdata->type[0].jt_ichg_l);
-		break;
-#if 0
-	case (1):
-		of_property_read_u32(np, "ricoh,ch-vfchg-1", &pdata->type[1].ch_vfchg);
-		of_property_read_u32(np, "ricoh,ch-vrchg-1", &pdata->type[1].ch_vrchg);
-		of_property_read_u32(np, "ricoh,ch-vbatovset-1", &pdata->type[1].ch_vbatovset);
-		of_property_read_u32(np, "ricoh,ch-ichg-1", &pdata->type[1].ch_ichg);
-		of_property_read_u32(np, "ricoh,ch-ilim-adp-1", &pdata->type[1].ch_ilim_adp);
-		of_property_read_u32(np, "ricoh,ch-ilim-usb-1", &pdata->type[1].ch_ilim_usb);
-		of_property_read_u32(np, "ricoh,ch-icchg-1", &pdata->type[1].ch_icchg);
-		of_property_read_u32(np, "ricoh,fg-target-vsys-1", &pdata->type[1].fg_target_vsys);
-		of_property_read_u32(np, "ricoh,fg-target-ibat-1", &pdata->type[1].fg_target_ibat);
-		of_property_read_u32(np, "ricoh,fg-poff-vbat-1", &pdata->type[1].fg_poff_vbat);
-		of_property_read_u32(np, "ricoh,jt-en-1", &pdata->type[1].jt_en);
-		of_property_read_u32(np, "ricoh,jt-hw-sw-1", &pdata->type[1].jt_hw_sw);
-		of_property_read_u32(np, "ricoh,jt-temp-h-1", &pdata->type[1].jt_temp_h);
-		of_property_read_u32(np, "ricoh,jt-temp-l-1", &pdata->type[1].jt_temp_l);
-		of_property_read_u32(np, "ricoh,jt-vfchg-h-1", &pdata->type[1].jt_vfchg_h);
-		of_property_read_u32(np, "ricoh,jt-vfchg-l-1", &pdata->type[1].jt_vfchg_l);
-		of_property_read_u32(np, "ricoh,jt-ichg-h-1", &pdata->type[1].jt_ichg_h);
-		of_property_read_u32(np, "ricoh,jt-ichg-l-1", &pdata->type[1].jt_ichg_l);
-		break;
-#endif
-	default:
-		of_node_put(np);
-		return 0;
-	}
-
-	of_node_put(np);
-
-	return pdata;
-}
-#else
-static struct ricoh619_battery_platform_data *
-ricoh619_battery_dt_init(struct platform_device *pdev)
-{
-	return pdev->dev.platform_data;
-}
-#endif
-
-static int ricoh619_battery_probe(struct platform_device *pdev)
-{
-	struct ricoh619_battery_info *info;
-	struct ricoh619_battery_platform_data *pdata;
-	struct ricoh619 *ricoh619 = dev_get_drvdata(pdev->dev.parent);
-	int ret, temp;
-
-	RICOH_FG_DBG(KERN_INFO "PMU: %s : version is %s\n", __func__,RICOH619_BATTERY_VERSION);
-
-	pdata = ricoh619_battery_dt_init(pdev);
-	if (!pdata) {
-		dev_err(&pdev->dev, "platform data isn't assigned to "
-			"power supply\n");
-		return -EINVAL;
-	}
-	info = devm_kzalloc(ricoh619->dev,sizeof(struct ricoh619_battery_info), GFP_KERNEL);
-	if (!info)
-		return -ENOMEM;
-	info->soca = devm_kzalloc(ricoh619->dev,sizeof(struct ricoh619_soca_info), GFP_KERNEL);
-		if (!info->soca)
-			return -ENOMEM;
-
-	info->dev = &pdev->dev;
-	info->status = POWER_SUPPLY_STATUS_CHARGING;
-	info->monitor_time = pdata->monitor_time * HZ;
-	info->alarm_vol_mv = pdata->alarm_vol_mv;
-
-	/* check rage of battery num */
-	info->num = Battery_Table();
-	temp = sizeof(battery_init_para)/(sizeof(uint8_t)*32);
-	if(info->num >= (sizeof(battery_init_para)/(sizeof(uint8_t)*32)))
-	{
-		RICOH_FG_DBG("%s : Battery num is out of range\n", __func__);
-		info->num = 0;
-	}
-	RICOH_FG_DBG("%s info->num=%d,temp is %d\n", __func__, info->num,temp);
-
-	/* these valuse are set in platform */
-	info->ch_vfchg = pdata->type[type_n].ch_vfchg;
-	info->ch_vrchg = pdata->type[type_n].ch_vrchg;
-	info->ch_vbatovset = pdata->type[type_n].ch_vbatovset;
-	info->ch_ichg = pdata->type[type_n].ch_ichg;
-	info->ch_ilim_adp = pdata->type[type_n].ch_ilim_adp;
-	info->ch_ilim_usb = pdata->type[type_n].ch_ilim_usb;
-	info->ch_icchg = pdata->type[type_n].ch_icchg;
-	info->fg_target_vsys = pdata->type[type_n].fg_target_vsys;
-	info->fg_target_ibat = pdata->type[type_n].fg_target_ibat;
-	info->fg_poff_vbat = pdata->type[type_n].fg_poff_vbat;
-	info->jt_en = pdata->type[type_n].jt_en;
-	info->jt_hw_sw = pdata->type[type_n].jt_hw_sw;
-	info->jt_temp_h = pdata->type[type_n].jt_temp_h;
-	info->jt_temp_l = pdata->type[type_n].jt_temp_l;
-	info->jt_vfchg_h = pdata->type[type_n].jt_vfchg_h;
-	info->jt_vfchg_l = pdata->type[type_n].jt_vfchg_l;
-	info->jt_ichg_h = pdata->type[type_n].jt_ichg_h;
-	info->jt_ichg_l = pdata->type[type_n].jt_ichg_l;
-
-	info->adc_vdd_mv = ADC_VDD_MV;		/* 2800; */
-	info->min_voltage = MIN_VOLTAGE;	/* 3100; */
-	info->max_voltage = MAX_VOLTAGE;	/* 4200; */
-	info->delay = 500;
-	info->entry_factory_mode = false;
-
-	info->chg_complete_rd_flag = 0;
-	info->chg_complete_rd_cnt = 0;
-	info->chg_complete_tm_ov_flag = 0;
-	info->chg_complete_sleep_flag = 0;
-
-	mutex_init(&info->lock);
-	platform_set_drvdata(pdev, info);
-
-	info->battery.name = "battery";
-	info->battery.type = POWER_SUPPLY_TYPE_BATTERY;
-	info->battery.properties = ricoh619_batt_props;
-	info->battery.num_properties = ARRAY_SIZE(ricoh619_batt_props);
-	info->battery.get_property = ricoh619_batt_get_prop;
-	info->battery.set_property = NULL;
-/*	info->battery.external_power_changed
-		 = ricoh619_external_power_changed; */
-
-	/* Disable Charger/ADC interrupt */
-	ret = ricoh619_clr_bits(info->dev->parent, RICOH619_INTC_INTEN,
-							 CHG_INT | ADC_INT);
-	if (ret<0)
-		goto out;
-
-	ret = ricoh619_init_battery(info);
-	if (ret<0)
-		goto out;
-/*
-#ifdef ENABLE_FACTORY_MODE
-	info->factory_mode_wqueue
-		= create_singlethread_workqueue("ricoh619_factory_mode");
-	INIT_DEFERRABLE_WORK(&info->factory_mode_work,
-					 check_charging_state_work);
-
-	ret = ricoh619_factory_mode(info);
-	if (ret<0)
-		goto out;
-
-#endif
-*/
-	ret = power_supply_register(&pdev->dev, &info->battery);
-
-	if (ret<0)
-		info->battery.dev->parent = &pdev->dev;
-
-	ret = power_supply_register(&pdev->dev, &powerac);
-	ret = power_supply_register(&pdev->dev, &powerusb);
-
-	info->monitor_wqueue
-		= create_singlethread_workqueue("ricoh619_battery_monitor");
-
-	info->workqueue = create_singlethread_workqueue("rc5t619_charger_in");
-	INIT_WORK(&info->irq_work, charger_irq_work);
-
-	info->usb_workqueue
-		= create_singlethread_workqueue("rc5t619_usb_det");
-	INIT_WORK(&info->usb_irq_work, usb_det_irq_work);
-
-	INIT_DEFERRABLE_WORK(&info->monitor_work,
-					 ricoh619_battery_work);
-	INIT_DEFERRABLE_WORK(&info->displayed_work,
-					 ricoh619_displayed_work);
-	INIT_DEFERRABLE_WORK(&info->charge_stable_work,
-					 ricoh619_stable_charge_countdown_work);
-	INIT_DEFERRABLE_WORK(&info->charge_monitor_work,
-					 ricoh619_charge_monitor_work);
-	INIT_DEFERRABLE_WORK(&info->get_charge_work,
-					 ricoh619_get_charge_work);
-	INIT_DEFERRABLE_WORK(&info->jeita_work, ricoh619_jeita_work);
-	INIT_DELAYED_WORK(&info->changed_work, ricoh619_changed_work);
-
-	INIT_DELAYED_WORK(&info->charge_complete_ready, ricoh619_charging_complete_work);
-
-	/* Charger IRQ workqueue settings */
-
-	ret = request_threaded_irq( irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_FONCHGINT),NULL, charger_in_isr, IRQF_ONESHOT,
-						"rc5t619_charger_in", info);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Can't get CHG_INT IRQ for chrager: %d\n",ret);
-		goto out;
-	}
-
-	ret = request_threaded_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_FCHGCMPINT),NULL, charger_complete_isr,
-					IRQF_ONESHOT, "rc5t619_charger_comp",info);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Can't get CHG_COMP IRQ for chrager: %d\n",ret);
-		goto out;
-	}
-
-	ret = request_threaded_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_FVUSBDETSINT) ,NULL, charger_usb_isr, IRQF_ONESHOT,
-						"rc5t619_usb_det", info);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Can't get USB_DET IRQ for chrager: %d\n",ret);
-		goto out;
-	}
-
-	ret = request_threaded_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_FVADPDETSINT),NULL, charger_adp_isr, IRQF_ONESHOT,
-						"rc5t619_adp_det", info);
-	if (ret < 0) {
-		dev_err(&pdev->dev,
-			"Can't get ADP_DET IRQ for chrager: %d\n", ret);
-		goto out;
-	}
-
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-	ret = request_threaded_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_VSYSLIR) ,NULL, adc_vsysl_isr, IRQF_ONESHOT,
-						"rc5t619_adc_vsysl", info);
-	if (ret < 0) {
-		dev_err(&pdev->dev,
-			"Can't get ADC_VSYSL IRQ for chrager: %d\n", ret);
-		goto out;
-	}
-	INIT_DEFERRABLE_WORK(&info->low_battery_work,
-					 low_battery_irq_work);
-#endif
-#ifdef RICOH619_VADP_DROP_WORK
-	INIT_DEFERRABLE_WORK(&info->vadp_drop_work,vadp_drop_irq_work);
-	queue_delayed_work(info->monitor_wqueue, &info->vadp_drop_work,0);
-#endif
-	/* Charger init and IRQ setting */
-	ret = ricoh619_init_charger(info);
-	if (ret<0)
-		goto out;
-
-#ifdef	ENABLE_FUEL_GAUGE_FUNCTION
-	ret = ricoh619_init_fgsoca(info);
-#endif
-	queue_delayed_work(info->monitor_wqueue, &info->monitor_work,
-					RICOH619_MONITOR_START_TIME*HZ);
-
-	/* Enable Charger/ADC interrupt */
-	ricoh619_set_bits(info->dev->parent, RICOH619_INTC_INTEN, CHG_INT | ADC_INT);
-
-	return 0;
-
-out:
-	return ret;
-}
-
-static int ricoh619_battery_remove(struct platform_device *pdev)
-{
-	struct ricoh619_battery_info *info = platform_get_drvdata(pdev);
-	struct ricoh619 *ricoh619 = dev_get_drvdata(pdev->dev.parent);
-	uint8_t val;
-	int ret;
-	int err;
-	int cc_cap = 0;
-	bool is_charging = true;
-#ifdef ENABLE_FUEL_GAUGE_FUNCTION
-	if (g_fg_on_mode
-		 && (info->soca->status == RICOH619_SOCA_STABLE)) {
-		err = ricoh619_write(info->dev->parent, PSWR_REG, 0x7f);
-		if (err < 0)
-			dev_err(info->dev, "Error in writing PSWR_REG\n");
-		g_soc = 0x7f;
-	} else if (info->soca->status != RICOH619_SOCA_START
-		&& info->soca->status != RICOH619_SOCA_UNSTABLE) {
-		if (info->soca->displayed_soc <= 0) {
-			val = 1;
-		} else {
-			val = (info->soca->displayed_soc + 50)/100;
-			val &= 0x7f;
-		}
-		ret = ricoh619_write(info->dev->parent, PSWR_REG, val);
-		if (ret < 0)
-			dev_err(info->dev, "Error in writing PSWR_REG\n");
-
-		g_soc = val;
-
-		ret = calc_capacity_in_period(info, &cc_cap,
-							 &is_charging, true);
-		if (ret < 0)
-			dev_err(info->dev, "Read cc_sum Error !!-----\n");
-	}
-
-	if (g_fg_on_mode == 0) {
-		ret = ricoh619_clr_bits(info->dev->parent,
-					 FG_CTRL_REG, 0x01);
-		if (ret < 0)
-			dev_err(info->dev, "Error in clr FG EN\n");
-	}
-	
-	/* set rapid timer 300 min */
-	err = ricoh619_set_bits(info->dev->parent, TIMSET_REG, 0x03);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing the control register\n");
-	}
-
-	if(info->capacity == 100)
-	{
-		ret = ricoh619_write(info->dev->parent, PSWR_REG, 100);
-		if (ret < 0)
-			dev_err(info->dev, "Error in writing PSWR_REG\n");
-	}
-	
-	free_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_FONCHGINT), &info);
-	free_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_FCHGCMPINT), &info);
-	free_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_FVUSBDETSINT), &info);
-	free_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_FVADPDETSINT) , &info);
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-	free_irq(irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_VSYSLIR), &info);
-#endif
-
-	cancel_delayed_work(&info->monitor_work);
-	cancel_delayed_work(&info->charge_stable_work);
-	cancel_delayed_work(&info->charge_monitor_work);
-	cancel_delayed_work(&info->get_charge_work);
-	cancel_delayed_work(&info->displayed_work);
-#endif
-	cancel_delayed_work(&info->changed_work);
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-	cancel_delayed_work(&info->low_battery_work);
-#endif
-#ifdef RICOH619_VADP_DROP_WORK
-	cancel_delayed_work(&info->vadp_drop_work);
-#endif
-#ifdef ENABLE_FACTORY_MODE
-	cancel_delayed_work(&info->factory_mode_work);
-#endif
-	cancel_delayed_work(&info->jeita_work);
-	cancel_delayed_work(&info->charge_complete_ready);
-	
-	cancel_work_sync(&info->irq_work);
-	cancel_work_sync(&info->usb_irq_work);
-
-	flush_workqueue(info->monitor_wqueue);
-	flush_workqueue(info->workqueue);
-	flush_workqueue(info->usb_workqueue);
-#ifdef ENABLE_FACTORY_MODE
-	flush_workqueue(info->factory_mode_wqueue);
-#endif
-	destroy_workqueue(info->monitor_wqueue);
-	destroy_workqueue(info->workqueue);
-	destroy_workqueue(info->usb_workqueue);
-#ifdef ENABLE_FACTORY_MODE
-	destroy_workqueue(info->factory_mode_wqueue);
-#endif
-
-	power_supply_unregister(&info->battery);
-	platform_set_drvdata(pdev, NULL);
-	return 0;
-}
-
-#ifdef CONFIG_PM
-struct timeval  ts_suspend;
-static int ricoh619_battery_suspend(struct device *dev)
-{
-	struct ricoh619_battery_info *info = dev_get_drvdata(dev);
-	uint8_t val;
-	int ret;
-	int err;
-	int cc_cap = 0;
-	bool is_charging = true;
-	int displayed_soc_temp;
-	do_gettimeofday(&ts_suspend);
-
-	if (g_fg_on_mode
-		 && (info->soca->status == RICOH619_SOCA_STABLE)) {
-		err = ricoh619_write(info->dev->parent, PSWR_REG, 0x7f);
-		if (err < 0)
-			dev_err(info->dev, "Error in writing PSWR_REG\n");
-		 g_soc = 0x7F;
-		info->soca->suspend_soc = info->soca->displayed_soc;
-		ret = calc_capacity_in_period(info, &cc_cap,
-							 &is_charging, true);
-		if (ret < 0)
-			dev_err(info->dev, "Read cc_sum Error !!-----\n");
-
-	} else if (info->soca->status != RICOH619_SOCA_START
-		&& info->soca->status != RICOH619_SOCA_UNSTABLE) {
-		if (info->soca->displayed_soc <= 0) {
-			val = 1;
-		} else {
-			val = (info->soca->displayed_soc + 50)/100;
-			val &= 0x7f;
-		}
-		ret = ricoh619_write(info->dev->parent, PSWR_REG, val);
-		if (ret < 0)
-			dev_err(info->dev, "Error in writing PSWR_REG\n");
-
-		g_soc = val;
-
-		ret = calc_capacity_in_period(info, &cc_cap,
-							 &is_charging, true);
-		if (ret < 0)
-			dev_err(info->dev, "Read cc_sum Error !!-----\n");
-			
-		if (info->soca->status != RICOH619_SOCA_STABLE) {
-			info->soca->cc_delta
-				 = (is_charging == true) ? cc_cap : -cc_cap;
-
-			displayed_soc_temp
-			       = info->soca->displayed_soc + info->soca->cc_delta;
-			displayed_soc_temp = min(10000, displayed_soc_temp);
-			displayed_soc_temp = max(0, displayed_soc_temp);
-			info->soca->displayed_soc = displayed_soc_temp;
-		}
-		info->soca->suspend_soc = info->soca->displayed_soc;
-					
-	} else if (info->soca->status == RICOH619_SOCA_START
-		|| info->soca->status == RICOH619_SOCA_UNSTABLE) {
-
-		ret = ricoh619_read(info->dev->parent, PSWR_REG, &val);
-		if (ret < 0)
-			dev_err(info->dev, "Error in reading the pswr register\n");
-		val &= 0x7f;
-
-		info->soca->suspend_soc = val * 100;
-	}
-
-	if (info->soca->status == RICOH619_SOCA_DISP
-		|| info->soca->status == RICOH619_SOCA_STABLE
-		|| info->soca->status == RICOH619_SOCA_FULL) {
-		info->soca->soc = calc_capacity_2(info);
-		info->soca->soc_delta =
-			info->soca->soc_delta + (info->soca->soc - info->soca->last_soc);
-
-	} else {
-		info->soca->soc_delta = 0;
-	}
-
-	if (info->soca->status == RICOH619_SOCA_STABLE
-		|| info->soca->status == RICOH619_SOCA_FULL)
-		info->soca->status = RICOH619_SOCA_DISP;
-	/* set rapid timer 300 min */
-	err = ricoh619_set_bits(info->dev->parent, TIMSET_REG, 0x03);
-	if (err < 0) {
-		dev_err(info->dev, "Error in writing the control register\n");
-	}
-
-//	disable_irq(charger_irq + RICOH619_IRQ_FONCHGINT);
-//	disable_irq(charger_irq + RICOH619_IRQ_FCHGCMPINT);
-//	disable_irq(charger_irq + RICOH619_IRQ_FVUSBDETSINT);
-//	disable_irq(charger_irq + RICOH619_IRQ_FVADPDETSINT);
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-//	disable_irq(charger_irq + RICOH619_IRQ_VSYSLIR);
-#endif
-#if 0
-	flush_delayed_work(&info->monitor_work);
-	flush_delayed_work(&info->displayed_work);
-	flush_delayed_work(&info->charge_stable_work);
-	flush_delayed_work(&info->charge_monitor_work);
-	flush_delayed_work(&info->get_charge_work);
-	flush_delayed_work(&info->changed_work);
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-	flush_delayed_work(&info->low_battery_work);
-#endif
-	flush_delayed_work(&info->factory_mode_work);
-	flush_delayed_work(&info->jeita_work);
-#ifdef RICOH619_VADP_DROP_WORK
-	flush_delayed_work(&info->vadp_drop_work);
-#endif
-	
-//	flush_work(&info->irq_work);
-//	flush_work(&info->usb_irq_work);
-#else
-	cancel_delayed_work(&info->monitor_work);
-	cancel_delayed_work(&info->displayed_work);
-	cancel_delayed_work(&info->charge_stable_work);
-	cancel_delayed_work(&info->charge_monitor_work);
-	cancel_delayed_work(&info->get_charge_work);
-	cancel_delayed_work(&info->changed_work);
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-	cancel_delayed_work(&info->low_battery_work);
-#endif
-/*	cancel_delayed_work(&info->charge_complete_ready);*/
-#ifdef ENABLE_FACTORY_MODE
-	cancel_delayed_work(&info->factory_mode_work);
-#endif
-	cancel_delayed_work(&info->jeita_work);
-#ifdef RICOH619_VADP_DROP_WORK
-	cancel_delayed_work(&info->vadp_drop_work);
-#endif
-/*	info->chg_complete_rd_cnt = 0;*/
-/*	info->chg_complete_rd_flag = 0;*/
-
-	if(info->capacity == 100)
-	{
-		ret = ricoh619_write(info->dev->parent, PSWR_REG, 100);
-		if (ret < 0)
-			dev_err(info->dev, "Error in writing PSWR_REG\n");
-		if(info->chg_complete_tm_ov_flag != 1)
-		{
-			info->chg_complete_tm_ov_flag = 0;
-			info->chg_complete_sleep_flag = 1;
-		}
-	}
-//	flush_work(&info->irq_work);
-//	flush_work(&info->usb_irq_work);
-#endif
-
-	return 0;
-}
-
-static int ricoh619_battery_resume(struct device *dev)
-{
-	struct ricoh619_battery_info *info = dev_get_drvdata(dev);
-	uint8_t val;
-	int ret;
-	int displayed_soc_temp;
-	int cc_cap = 0;
-	bool is_charging = true;
-	bool is_jeita_updated;
-	int i;
-	int err;
-	struct rtc_time tm;
-	struct timespec tv = {
-			.tv_nsec = NSEC_PER_SEC >> 1,
-	};
-	struct rtc_device *rtc = rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);
-
-	err = rtc_read_time(rtc, &tm);
-	if (err) {
-			dev_err(rtc->dev.parent,
-					"hctosys: unable to read the hardware clock\n");	
-	}
-
-	err = rtc_valid_tm(&tm);
-	if (err) {
-			dev_err(rtc->dev.parent,
-					"hctosys: invalid date/time\n");
-	}
-
-	rtc_tm_to_time(&tm, &tv.tv_sec);
-	
-	/*printk("suspend time: %d sec\n", ts_suspend.tv_sec);*/
-	/*printk("resume  time: %d sec\n", tv.tv_sec);*/
-
-	if(info->chg_complete_rd_flag == 2){
-		printk("chg_complete_rd_cnt suspend: %d\n", info->chg_complete_rd_cnt);
-		info->chg_complete_rd_cnt += (tv.tv_sec - ts_suspend.tv_sec);
-		printk("chg_complete_rd_cnt resume: %d\n", info->chg_complete_rd_cnt);
-		flush_work(&info->charge_complete_ready.work);
-	}
-
-	RICOH_FG_DBG(KERN_INFO "PMU: %s: \n", __func__);
-
-	ret = check_jeita_status(info, &is_jeita_updated);
-	if (ret < 0) {
-		dev_err(info->dev, "Error in updating JEITA %d\n", ret);
-	}
-
-	if (info->entry_factory_mode) {
-		info->soca->displayed_soc = -EINVAL;
-	} else if (RICOH619_SOCA_ZERO == info->soca->status) {
-		if (calc_ocv(info) > get_OCV_voltage(info, 0)) {
-			RICOH_FG_DBG(KERN_INFO "PMU: %s: RICOH619_SOCA_ZERO if ()...\n", __func__);
-			ret = ricoh619_read(info->dev->parent, PSWR_REG, &val);
-			val &= 0x7f;
-			info->soca->soc = val * 100;
-			if (ret < 0) {
-				dev_err(info->dev,
-					 "Error in reading PSWR_REG %d\n", ret);
-				info->soca->soc
-					 = calc_capacity(info) * 100;
-			}
-
-			ret = calc_capacity_in_period(info, &cc_cap,
-							 &is_charging, true);
-			if (ret < 0)
-				dev_err(info->dev, "Read cc_sum Error !!-----\n");
-
-			info->soca->cc_delta
-				 = (is_charging == true) ? cc_cap : -cc_cap;
-
-			displayed_soc_temp
-				 = info->soca->soc + info->soca->cc_delta;
-			if (displayed_soc_temp < 0)
-				displayed_soc_temp = 0;
-			displayed_soc_temp = min(10000, displayed_soc_temp);
-			displayed_soc_temp = max(0, displayed_soc_temp);
-			info->soca->displayed_soc = displayed_soc_temp;
-
-			ret = reset_FG_process(info);
-
-			if (ret < 0)
-				dev_err(info->dev, "Error in writing the control register\n");
-			info->soca->status = RICOH619_SOCA_FG_RESET;
-
-		} else {
-			RICOH_FG_DBG(KERN_INFO "PMU: %s: RICOH619_SOCA_ZERO else()...\n", __func__);
-			/*info->soca->displayed_soc = 0;*/
-			info->soca->displayed_soc  = info->soca->suspend_soc;
-		}
-	} else {
-		info->soca->soc = info->soca->suspend_soc;
-
-		if (RICOH619_SOCA_START == info->soca->status
-			|| RICOH619_SOCA_UNSTABLE == info->soca->status) {
-			ret = calc_capacity_in_period(info, &cc_cap,
-							 &is_charging, false);
-		} else { 
-			ret = calc_capacity_in_period(info, &cc_cap,
-							 &is_charging, true);
-		}
-
-		if (ret < 0)
-			dev_err(info->dev, "Read cc_sum Error !!-----\n");
-
-		info->soca->cc_delta = (is_charging == true) ? cc_cap : -cc_cap;
-
-		displayed_soc_temp = info->soca->soc + info->soca->cc_delta;
-		if (info->soca->zero_flg == 1) {
-			if((info->soca->Ibat_ave >= 0) 
-			|| (displayed_soc_temp >= 100)){
-				info->soca->zero_flg = 0;
-			} else {
-				displayed_soc_temp = 0;
-			}
-		} else if (displayed_soc_temp < 100) {
-			/* keep DSOC = 1 when Vbat is over 3.4V*/
-			if( info->fg_poff_vbat != 0) {
-				if (info->soca->Vbat_ave < 2000*1000) { /* error value */
-					displayed_soc_temp = 100;
-				} else if (info->soca->Vbat_ave < info->fg_poff_vbat*1000) {
-					displayed_soc_temp = 0;
-					info->soca->zero_flg = 1;
-				} else {
-					displayed_soc_temp = 100;
-				}
-			}
-		}
-		displayed_soc_temp = min(10000, displayed_soc_temp);
-		displayed_soc_temp = max(0, displayed_soc_temp);
-
-		if (0 == info->soca->jt_limit) {
-			check_charge_status_2(info, displayed_soc_temp);
-		} else {
-			info->soca->displayed_soc = displayed_soc_temp;
-		}
-
-		if (RICOH619_SOCA_DISP == info->soca->status) {
-			info->soca->last_soc = calc_capacity_2(info);
-		}
-	}
-
-	ret = measure_vbatt_FG(info, &info->soca->Vbat_ave);
-	ret = measure_vsys_ADC(info, &info->soca->Vsys_ave);
-	ret = measure_Ibatt_FG(info, &info->soca->Ibat_ave);
-
-	if(info->chg_complete_sleep_flag == 1)
-	{
-		info->chg_complete_tm_ov_flag = 1;
-		info->chg_complete_sleep_flag = 0;
-	}
-
-	power_supply_changed(&info->battery);
-	queue_delayed_work(info->monitor_wqueue, &info->displayed_work, HZ);
-
-	if (RICOH619_SOCA_UNSTABLE == info->soca->status) {
-		info->soca->stable_count = 10;
-		queue_delayed_work(info->monitor_wqueue,
-					 &info->charge_stable_work,
-					 RICOH619_FG_STABLE_TIME*HZ/10);
-	} else if (RICOH619_SOCA_FG_RESET == info->soca->status) {
-		info->soca->stable_count = 1;
-
-		for (i = 0; i < 3; i = i+1)
-			info->soca->reset_soc[i] = 0;
-		info->soca->reset_count = 0;
-
-		queue_delayed_work(info->monitor_wqueue,
-					 &info->charge_stable_work,
-					 RICOH619_FG_RESET_TIME*HZ);
-	}
-
-	queue_delayed_work(info->monitor_wqueue, &info->monitor_work,
-						 info->monitor_time);
-
-	queue_delayed_work(info->monitor_wqueue, &info->charge_monitor_work,
-					 RICOH619_CHARGE_RESUME_TIME * HZ);
-
-	info->soca->chg_count = 0;
-	queue_delayed_work(info->monitor_wqueue, &info->get_charge_work,
-					 RICOH619_CHARGE_RESUME_TIME * HZ);
-	#ifdef RICOH619_VADP_DROP_WORK
-	queue_delayed_work(info->monitor_wqueue, &info->vadp_drop_work,1 * HZ);
-	#endif
-	if (info->jt_en) {
-		if (!info->jt_hw_sw) {
-			queue_delayed_work(info->monitor_wqueue, &info->jeita_work,
-					 RICOH619_JEITA_UPDATE_TIME * HZ);
-		}
-	}
-//	ricoh619_write(info->dev->parent, 0x9d, 0x00);
-//	enable_irq(charger_irq + RICOH619_IRQ_FONCHGINT);
-//	enable_irq(charger_irq + RICOH619_IRQ_FCHGCMPINT);
-//	enable_irq(charger_irq + RICOH619_IRQ_FVUSBDETSINT);
-//	enable_irq(charger_irq + RICOH619_IRQ_FVADPDETSINT);
-#ifdef ENABLE_LOW_BATTERY_DETECTION
-//	enable_irq(charger_irq + RICOH619_IRQ_VSYSLIR);
-#endif
-	ricoh619_write(info->dev->parent, 0x9d, 0x4d);
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id ricoh619_battery_dt_match[] = {
-	{ .compatible = "ricoh,ricoh619-battery", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ricoh619_battery_dt_match);
-#endif
-
-
-static const struct dev_pm_ops ricoh619_battery_pm_ops = {
-	.suspend	= ricoh619_battery_suspend,
-	.resume		= ricoh619_battery_resume,
-};
-#endif
-
-static struct platform_driver ricoh619_battery_driver = {
-	.driver	= {
-				.name	= "ricoh619-battery",
-				.owner	= THIS_MODULE,
-				.of_match_table = of_match_ptr(ricoh619_battery_dt_match),
-#ifdef CONFIG_PM
-				.pm	= &ricoh619_battery_pm_ops,
-#endif
-	},
-	.probe	= ricoh619_battery_probe,
-	.remove	= ricoh619_battery_remove,
-};
-
-static int __init ricoh619_battery_init(void)
-{
-	RICOH_FG_DBG("PMU: %s\n", __func__);
-	return platform_driver_register(&ricoh619_battery_driver);
-}
-fs_initcall_sync(ricoh619_battery_init);
-
-static void __exit ricoh619_battery_exit(void)
-{
-	platform_driver_unregister(&ricoh619_battery_driver);
-}
-module_exit(ricoh619_battery_exit);
-
-MODULE_DESCRIPTION("RICOH619 Battery driver");
-MODULE_ALIAS("platform:ricoh619-battery");
-MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/ricoh619-regulator.c b/drivers/regulator/ricoh619-regulator.c
deleted file mode 100755
index 4efadc34e25d..000000000000
--- a/drivers/regulator/ricoh619-regulator.c
+++ /dev/null
@@ -1,690 +0,0 @@
-/*
- * drivers/regulator/ricoh619-regulator.c
- *
- * Regulator driver for RICOH619 power management chip.
- *
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * Based on code
- *	Copyright (C) 2011 NVIDIA Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
- 
-/*#define DEBUG			1*/
-/*#define VERBOSE_DEBUG		1*/
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/driver.h>
-#include <linux/regulator/machine.h>
-#include <linux/mfd/ricoh619.h>
-#include <linux/regulator/ricoh619-regulator.h>
-#include <linux/of.h>
-#include <linux/regulator/of_regulator.h>
-
-struct ricoh619_regulator {
-	int		id;
-	int		sleep_id;
-	/* Regulator register address.*/
-	u8		reg_en_reg;
-	u8		en_bit;
-	u8		reg_disc_reg;
-	u8		disc_bit;
-	u8		vout_reg;
-	u8		vout_mask;
-	u8		vout_reg_cache;
-	u8		sleep_reg;
-	u8		eco_reg;
-	u8		eco_bit;
-	u8		eco_slp_reg;
-	u8		eco_slp_bit;
-
-	/* chip constraints on regulator behavior */
-	int			min_uV;
-	int			max_uV;
-	int			step_uV;
-	int			nsteps;
-
-	/* regulator specific turn-on delay */
-	u16			delay;
-
-	/* used by regulator core */
-	struct regulator_desc	desc;
-
-	/* Device */
-	struct device		*dev;
-};
-
-//static unsigned int ricoh619_suspend_status = 0;
-
-static inline struct device *to_ricoh619_dev(struct regulator_dev *rdev)
-{
-	return rdev_get_dev(rdev)->parent->parent;
-}
-/*
-static int ricoh619_regulator_enable_time(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-
-	return ri->delay;
-}
-*/
-static int ricoh619_reg_is_enabled(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	uint8_t control;
-	int ret;
-
-	ret = ricoh619_read(parent, ri->reg_en_reg, &control);
-	if (ret < 0) {
-		dev_err(&rdev->dev, "Error in reading the control register\n");
-		return ret;
-	}
-	return (((control >> ri->en_bit) & 1) == 1);
-}
-
-static int ricoh619_reg_enable(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-	ret = ricoh619_set_bits(parent, ri->reg_en_reg, (1 << ri->en_bit));
-	if (ret < 0) {
-		dev_err(&rdev->dev, "Error in updating the STATE register\n");
-		return ret;
-	}
-	udelay(ri->delay);
-	return ret;
-}
-
-static int ricoh619_reg_disable(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-	ret = ricoh619_clr_bits(parent, ri->reg_en_reg, (1 << ri->en_bit));
-	if (ret < 0)
-		dev_err(&rdev->dev, "Error in updating the STATE register\n");
-
-	return ret;
-}
-
-static int ricoh619_list_voltage(struct regulator_dev *rdev, unsigned index)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-
-	return ri->min_uV + (ri->step_uV * index);
-}
-
-static int __ricoh619_set_s_voltage(struct device *parent,
-		struct ricoh619_regulator *ri, int min_uV, int max_uV)
-{
-	int vsel;
-	int ret;
-
-	if ((min_uV < ri->min_uV) || (max_uV > ri->max_uV))
-		return -EDOM;
-
-	vsel = (min_uV - ri->min_uV + ri->step_uV - 1)/ri->step_uV;
-	if (vsel > ri->nsteps)
-		return -EDOM;
-
-	ret = ricoh619_update(parent, ri->sleep_reg, vsel, ri->vout_mask);
-	if (ret < 0)
-		dev_err(ri->dev, "Error in writing the sleep register\n");
-	return ret;
-}
-
-static int __ricoh619_set_voltage(struct device *parent,
-		struct ricoh619_regulator *ri, int min_uV, int max_uV,
-		unsigned *selector)
-{
-	int vsel;
-	int ret;
-	uint8_t vout_val;
-
-	if ((min_uV < ri->min_uV) || (max_uV > ri->max_uV))
-		return -EDOM;
-
-	vsel = (min_uV - ri->min_uV + ri->step_uV - 1)/ri->step_uV;
-	if (vsel > ri->nsteps)
-		return -EDOM;
-
-	if (selector)
-		*selector = vsel;
-
-	vout_val = (ri->vout_reg_cache & ~ri->vout_mask) |
-				(vsel & ri->vout_mask);
-	ret = ricoh619_write(parent, ri->vout_reg, vout_val);
-	if (ret < 0)
-		dev_err(ri->dev, "Error in writing the Voltage register\n");
-	else
-		ri->vout_reg_cache = vout_val;
-
-	return ret;
-}
-
-static int ricoh619_set_voltage(struct regulator_dev *rdev,
-		int min_uV, int max_uV, unsigned *selector)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-
-//	if(ricoh619_suspend_status)
-//		return -EBUSY;
-
-	return __ricoh619_set_voltage(parent, ri, min_uV, max_uV, selector);
-}
-
-static int ricoh619_set_suspend_voltage(struct regulator_dev *rdev,
-		int uV)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-
-	return __ricoh619_set_s_voltage(parent, ri, uV, uV);
-}
-
-static int ricoh619_get_voltage(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	uint8_t vsel;
-	int ret;
-
-	ret = ricoh619_read(parent, ri->vout_reg, &vsel);
-	return ricoh619_list_voltage(rdev,vsel);
-}
-
- int ricoh619_regulator_enable_eco_mode(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-
-	ret = ricoh619_set_bits(parent, ri->eco_reg, (1 << ri->eco_bit));
-	if (ret < 0)
-		dev_err(&rdev->dev, "Error Enable LDO eco mode\n");
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_regulator_enable_eco_mode);
-
-int ricoh619_regulator_disable_eco_mode(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-
-	ret = ricoh619_clr_bits(parent, ri->eco_reg, (1 << ri->eco_bit));
-	if (ret < 0)
-		dev_err(&rdev->dev, "Error Disable LDO eco mode\n");
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_regulator_disable_eco_mode);
-
-int ricoh619_regulator_enable_eco_slp_mode(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-
-	ret = ricoh619_set_bits(parent, ri->eco_slp_reg, (1 << ri->eco_slp_bit));
-	if (ret < 0)
-		dev_err(&rdev->dev, "Error Enable LDO eco mode in d during sleep\n");
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_regulator_enable_eco_slp_mode);
-
-int ricoh619_regulator_disable_eco_slp_mode(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-
-	ret = ricoh619_clr_bits(parent, ri->eco_slp_reg, (1 << ri->eco_slp_bit));
-	if (ret < 0)
-		dev_err(&rdev->dev, "Error Enable LDO eco mode in d during sleep\n");
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ricoh619_regulator_disable_eco_slp_mode);
-
-static unsigned int ricoh619_dcdc_get_mode(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-	uint8_t control;
-	u8 mask = 0x30;
-	
-	ret = ricoh619_read(parent, ri->reg_en_reg,&control);
-        if (ret < 0) {
-                return ret;
-        }
-	control=(control & mask) >> 4;
-	switch (control) {
-	case 1:
-		return REGULATOR_MODE_FAST;
-	case 0:
-		return REGULATOR_MODE_NORMAL;
-	case 2:
-		return REGULATOR_MODE_STANDBY;
-	case 3:
-		return REGULATOR_MODE_NORMAL;
-	default:
-		return -1;
-	}
-
-}
-static int ricoh619_dcdc_set_mode(struct regulator_dev *rdev, unsigned int mode)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-	uint8_t control;
-	
-	ret = ricoh619_read(parent, ri->reg_en_reg,&control);
-	switch(mode)
-	{
-	case REGULATOR_MODE_FAST:
-		return ricoh619_write(parent, ri->reg_en_reg, ((control & 0xcf) | 0x10));
-	case REGULATOR_MODE_NORMAL:
-		return ricoh619_write(parent, ri->reg_en_reg, (control & 0xcf));
-	case REGULATOR_MODE_STANDBY:
-		return ricoh619_write(parent, ri->reg_en_reg, ((control & 0xcf) | 0x20));	
-	default:
-		printk("error:pmu_619 only powersave pwm psm mode\n");
-		return -EINVAL;
-	}
-	
-
-}
-
-static int ricoh619_dcdc_set_voltage_time_sel(struct regulator_dev *rdev,   unsigned int old_selector,
-				     unsigned int new_selector)
-{
-	int old_volt, new_volt;
-	
-	old_volt = ricoh619_list_voltage(rdev, old_selector);
-	if (old_volt < 0)
-		return old_volt;
-	
-	new_volt = ricoh619_list_voltage(rdev, new_selector);
-	if (new_volt < 0)
-		return new_volt;
-
-	return DIV_ROUND_UP(abs(old_volt - new_volt)*2, 14000);
-}
-static int ricoh619_dcdc_set_suspend_mode(struct regulator_dev *rdev, unsigned int mode)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-	uint8_t control;
-	
-	ret = ricoh619_read(parent, ri->reg_en_reg,&control);
-	switch(mode)
-	{
-	case REGULATOR_MODE_FAST:
-		return ricoh619_write(parent, ri->reg_en_reg, ((control & 0x3f) | 0x40));
-	case REGULATOR_MODE_NORMAL:
-		return ricoh619_write(parent, ri->reg_en_reg, (control & 0x3f));
-	case REGULATOR_MODE_STANDBY:
-		return ricoh619_write(parent, ri->reg_en_reg, ((control & 0x3f) | 0x80));	
-	default:
-		printk("error:pmu_619 only powersave pwm psm mode\n");
-		return -EINVAL;
-	}
-	
-
-}
-static int ricoh619_reg_suspend_enable(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-	ret = ricoh619_set_bits(parent, (0x16 + ri->id), (0xf << 0));
-	if (ret < 0) {
-		dev_err(&rdev->dev, "Error in updating the STATE register\n");
-		return ret;
-	}
-	udelay(ri->delay);
-	return ret;
-}
-
-static int ricoh619_reg_suspend_disable(struct regulator_dev *rdev)
-{
-	struct ricoh619_regulator *ri = rdev_get_drvdata(rdev);
-	struct device *parent = to_ricoh619_dev(rdev);
-	int ret;
-	ret = ricoh619_clr_bits(parent, (0x16 + ri->id), (0xf <<0));
-	if (ret < 0)
-		dev_err(&rdev->dev, "Error in updating the STATE register\n");
-
-	return ret;
-}
-
-static struct regulator_ops ricoh619_ops = {
-	.list_voltage			= ricoh619_list_voltage,
-	.set_voltage			= ricoh619_set_voltage,
-	.get_voltage			= ricoh619_get_voltage,
-	.set_suspend_voltage = ricoh619_set_suspend_voltage,
-	.set_voltage_time_sel = ricoh619_dcdc_set_voltage_time_sel,
-	.get_mode = ricoh619_dcdc_get_mode,
-	.set_mode = ricoh619_dcdc_set_mode,
-	.enable				= ricoh619_reg_enable,
-	.disable				= ricoh619_reg_disable,
-	.set_suspend_mode = ricoh619_dcdc_set_suspend_mode,
-	.set_suspend_enable				= ricoh619_reg_suspend_enable,
-	.set_suspend_disable				= ricoh619_reg_suspend_disable,
-	.is_enabled			= ricoh619_reg_is_enabled,
-};
-
-#define RICOH619_REG(_id, _en_reg, _en_bit, _disc_reg, _disc_bit, _vout_reg, \
-		_vout_mask, _ds_reg, _min_uv, _max_uv, _step_uV, _nsteps,    \
-		_ops, _delay, _eco_reg, _eco_bit, _eco_slp_reg, _eco_slp_bit)		\
-{								\
-	.reg_en_reg	= _en_reg,				\
-	.en_bit		= _en_bit,				\
-	.reg_disc_reg	= _disc_reg,				\
-	.disc_bit	= _disc_bit,				\
-	.vout_reg	= _vout_reg,				\
-	.vout_mask	= _vout_mask,				\
-	.sleep_reg	= _ds_reg,				\
-	.min_uV		= _min_uv,			\
-	.max_uV		= _max_uv ,			\
-	.step_uV	= _step_uV,				\
-	.nsteps		= _nsteps,				\
-	.delay		= _delay,				\
-	.id		= RICOH619_ID_##_id,			\
-	.sleep_id	= RICOH619_DS_##_id,			\
-	.eco_reg			=  _eco_reg,				\
-	.eco_bit			=  _eco_bit,				\
-	.eco_slp_reg		=  _eco_slp_reg,				\
-	.eco_slp_bit		=  _eco_slp_bit,				\
-	.desc = {						\
-		.name = ricoh619_rails(_id),			\
-		.id = RICOH619_ID_##_id,			\
-		.n_voltages = _nsteps,				\
-		.ops = &_ops,					\
-		.type = REGULATOR_VOLTAGE,			\
-		.owner = THIS_MODULE,				\
-	},							\
-}
-
-static struct ricoh619_regulator ricoh619_regulator_data[] = {
-  	RICOH619_REG(DC1, 0x2C, 0, 0x2C, 1, 0x36, 0xFF, 0x3B,
-			600000, 3500000, 12500, 0xE8, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(DC2, 0x2E, 0, 0x2E, 1, 0x37, 0xFF, 0x3C,
-			600000, 3500000, 12500, 0xE8, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(DC3, 0x30, 0, 0x30, 1, 0x38, 0xFF, 0x3D,
-			600000, 3500000, 12500, 0xE8, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(DC4, 0x32, 0, 0x32, 1, 0x39, 0xFF, 0x3E,
-			600000, 3500000, 12500, 0xE8, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(DC5, 0x34, 0, 0x34, 1, 0x3A, 0xFF, 0x3F,
-			600000, 3500000, 12500, 0xE8, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-			
-  	RICOH619_REG(LDO1, 0x44, 0, 0x46, 0, 0x4C, 0x7F, 0x58,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x48, 0, 0x4A, 0),
-
-	RICOH619_REG(LDO2, 0x44, 1, 0x46, 1, 0x4D, 0x7F, 0x59,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x48, 1, 0x4A, 1),
-
-  	RICOH619_REG(LDO3, 0x44, 2, 0x46, 2, 0x4E, 0x7F, 0x5A,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x48, 2, 0x4A, 2),
-
-  	RICOH619_REG(LDO4, 0x44, 3, 0x46, 3, 0x4F, 0x7F, 0x5B,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x48, 3, 0x4A, 3),
-
-  	RICOH619_REG(LDO5, 0x44, 4, 0x46, 4, 0x50, 0x7F, 0x5C,
-			600000, 3500000, 25000, 0x74, ricoh619_ops, 500,
-			0x48, 4, 0x4A, 4),
-
-  	RICOH619_REG(LDO6, 0x44, 5, 0x46, 5, 0x51, 0x7F, 0x5D,
-			600000, 3500000, 25000, 0x74, ricoh619_ops, 500,
-			0x48, 5, 0x4A, 5),
-
-  	RICOH619_REG(LDO7, 0x44, 6, 0x46, 6, 0x52, 0x7F, 0x5E,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(LDO8, 0x44, 7, 0x46, 7, 0x53, 0x7F, 0x5F,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(LDO9, 0x45, 0, 0x47, 0, 0x54, 0x7F, 0x60,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(LDO10, 0x45, 1, 0x47, 1, 0x55, 0x7F, 0x61,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(LDORTC1, 0x45, 4, 0x00, 0, 0x56, 0x7F, 0x00,
-			1700000, 3500000, 25000, 0x48, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-
-  	RICOH619_REG(LDORTC2, 0x45, 5, 0x00, 0, 0x57, 0x7F, 0x00,
-			900000, 3500000, 25000, 0x68, ricoh619_ops, 500,
-			0x00, 0, 0x00, 0),
-};
-
-static inline struct ricoh619_regulator *find_regulator_info(int id)
-{
-	struct ricoh619_regulator *ri;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ricoh619_regulator_data); i++) {
-		ri = &ricoh619_regulator_data[i];
-		if (ri->desc.id == id)
-			return ri;
-	}
-	return NULL;
-}
-#if 0
-static int ricoh619_regulator_preinit(struct device *parent,
-		struct ricoh619_regulator *ri,
-		struct ricoh619_regulator_platform_data *ricoh619_pdata)
-{
-	int ret = 0;
-
-	if (!ricoh619_pdata->init_apply)
-		return 0;
-/*
-	if (ricoh619_pdata->init_uV >= 0) {
-		ret = __ricoh619_set_voltage(parent, ri,
-				ricoh619_pdata->init_uV,
-				ricoh619_pdata->init_uV, 0);
-		if (ret < 0) {
-			dev_err(ri->dev, "Not able to initialize voltage %d "
-				"for rail %d err %d\n", ricoh619_pdata->init_uV,
-				ri->desc.id, ret);
-			return ret;
-		}
-	}
-*/
-	if (ricoh619_pdata->init_enable)
-		ret = ricoh619_set_bits(parent, ri->reg_en_reg,
-							(1 << ri->en_bit));
-	else
-		ret = ricoh619_clr_bits(parent, ri->reg_en_reg,
-							(1 << ri->en_bit));
-	if (ret < 0)
-		dev_err(ri->dev, "Not able to %s rail %d err %d\n",
-			(ricoh619_pdata->init_enable) ? "enable" : "disable",
-			ri->desc.id, ret);
-
-	return ret;
-}
-#endif
-static inline int ricoh619_cache_regulator_register(struct device *parent,
-	struct ricoh619_regulator *ri)
-{
-	ri->vout_reg_cache = 0;
-	return ricoh619_read(parent, ri->vout_reg, &ri->vout_reg_cache);
-}
-
-#ifdef CONFIG_OF
-static struct of_regulator_match ricoh619_regulator_matches[] = {
-	{ .name	= "ricoh619_dc1",},
-	{ .name = "ricoh619_dc2",},
-	{ .name = "ricoh619_dc3",},
-	{ .name = "ricoh619_dc4",},
-	{ .name = "ricoh619_dc5",},
-	{ .name = "ricoh619_ldo1",},
-	{ .name = "ricoh619_ldo2",},
-	{ .name = "ricoh619_ldo3",},
-	{ .name = "ricoh619_ldo4",},
-	{ .name = "ricoh619_ldo5",},
-	{ .name = "ricoh619_ldo6",},
-	{ .name = "ricoh619_ldo7",},
-	{ .name = "ricoh619_ldo8",},
-	{ .name = "ricoh619_ldo9",},
-	{ .name = "ricoh619_ldo10",},
-	{ .name = "ricoh619_ldortc1",},
-	{ .name = "ricoh619_ldortc2",},
-};
-#endif
-
-#ifdef CONFIG_OF
-static int ricoh619_regulator_dt_init(struct platform_device *pdev,
-				    struct regulator_config *config,
-				    int regidx)
-{
-	struct device_node *nproot, *np;
-	int rcount;
-	nproot = of_node_get(pdev->dev.parent->of_node);
-	if (!nproot)
-		return -ENODEV;
-	np = of_find_node_by_name(nproot, "regulators");
-	if (!np) {
-		dev_err(&pdev->dev, "failed to find regulators node\n");
-		return -ENODEV;
-	}
-
-	rcount = of_regulator_match(&pdev->dev, np,
-				&ricoh619_regulator_matches[regidx], 1);
-	of_node_put(np);
-	if (rcount < 0)
-		return -ENODEV;
-	config->init_data = ricoh619_regulator_matches[regidx].init_data;
-	config->of_node = ricoh619_regulator_matches[regidx].of_node;
-
-	return 0;
-}
-#else
-#define ricoh619_regulator_dt_init(x, y, z)	(-1)
-#endif
-
-static int ricoh619_regulator_probe(struct platform_device *pdev)
-{
-	struct ricoh619_regulator *ri = NULL;
-	struct regulator_dev *rdev;
-	struct regulator_config config = { };
-	int err,id=0;
-	
-	rdev = devm_kzalloc(&pdev->dev, RICOH619_NUM_REGULATOR *
-				sizeof(*rdev), GFP_KERNEL);
-	if (!rdev) {
-		dev_err(&pdev->dev, "Mmemory alloc failed\n");
-		return -ENOMEM;
-	}
-
-	for (id = 0; id < RICOH619_NUM_REGULATOR; ++id) {
-
-	ri = find_regulator_info(id);
-	if (!ri) {
-		dev_err(&pdev->dev, "invalid regulator ID specified\n");
-		err = -EINVAL;
-	}
-
-	ri->dev = &pdev->dev;
-	config.dev = &pdev->dev;
-	config.driver_data = ri;
-
-	config.of_node = ricoh619_regulator_matches[id].of_node;
-
-	err = ricoh619_regulator_dt_init(pdev, &config, id);
-	if (err < 0) {
-		dev_err(&pdev->dev, "failed to regulator dt init\n");
-	}
-
-	rdev = regulator_register(&ri->desc, &config);
-	if (IS_ERR_OR_NULL(rdev)) {
-		dev_err(&pdev->dev, "failed to register regulator %s\n",
-				ri->desc.name);
-		return PTR_ERR(rdev);
-	}
-	}
-
-	platform_set_drvdata(pdev, rdev);
-	return 0;
-}
-
-static int ricoh619_regulator_remove(struct platform_device *pdev)
-{
-	struct regulator_dev *rdev = platform_get_drvdata(pdev);
-
-	regulator_unregister(rdev);
-	return 0;
-}
-
-static struct platform_driver ricoh619_regulator_driver = {
-	.driver	= {
-		.name	= "ricoh619-regulator",
-		.owner	= THIS_MODULE,
-	},
-	.probe		= ricoh619_regulator_probe,
-	.remove		= ricoh619_regulator_remove,
-};
-
-static int __init ricoh619_regulator_init(void)
-{
-
-	return platform_driver_register(&ricoh619_regulator_driver);
-}
-subsys_initcall_sync(ricoh619_regulator_init);
-
-static void __exit ricoh619_regulator_exit(void)
-{
-	platform_driver_unregister(&ricoh619_regulator_driver);
-}
-module_exit(ricoh619_regulator_exit);
-
-MODULE_DESCRIPTION("RICOH619 regulator driver");
-MODULE_ALIAS("platform:ricoh619-regulator");
-MODULE_AUTHOR("zhangqing <zhangqing@rock-chips.com>");
-MODULE_LICENSE("GPL");
diff --git a/drivers/rtc/rtc-ricoh619.c b/drivers/rtc/rtc-ricoh619.c
deleted file mode 100755
index 603fa1303b0e..000000000000
--- a/drivers/rtc/rtc-ricoh619.c
+++ /dev/null
@@ -1,845 +0,0 @@
-/*
- * drivers/rtc/rtc-ricoh619.c
- *
- * Real time clock driver for RICOH RC5T619 power management chip.
- *
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * Based on code
- *  Copyright (C) 2011 NVIDIA Corporation
- *
- * this program is free software; you can redistribute it and/or modify
- * it under the terms of the gnu general public license as published by
- * the free software foundation; either version 2 of the license, or
- * (at your option) any later version.
- *
- * this program is distributed in the hope that it will be useful, but without
- * any warranty; without even the implied warranty of merchantability or
- * fitness for a particular purpose.  see the gnu general public license for
- * more details.
- *
- * you should have received a copy of the gnu general public license
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-/* #define debug		1 */
-/* #define verbose_debug	1 */
-
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mfd/ricoh619.h>
-#include <linux/rtc/rtc-ricoh619.h>
-#include <linux/platform_device.h>
-#include <linux/rtc.h>
-#include <linux/slab.h>
-#include <linux/irqdomain.h>
-
-
-struct ricoh619_rtc {
-	int			irq;
-	struct rtc_device	*rtc;
-	bool		irq_en;
-};
-
-static int ricoh619_read_regs(struct device *dev, int reg, int len,
-	uint8_t *val)
-{
-	int ret;
-
-	ret = ricoh619_bulk_reads(dev->parent, reg, len, val);
-	if (ret < 0) {
-		dev_err(dev->parent, "\n %s failed reading from 0x%02x\n",
-			__func__, reg);
-		WARN_ON(1);
-	}
-	return ret;
-}
-
-static int ricoh619_write_regs(struct device *dev, int reg, int len,
-	uint8_t *val)
-{
-	int ret;
-	ret = ricoh619_bulk_writes(dev->parent, reg, len, val);
-	if (ret < 0) {
-		dev_err(dev->parent, "\n %s failed writing\n", __func__);
-		WARN_ON(1);
-	}
-
-	return ret;
-}
-
-// 0=OK, -EINVAL= FAIL
-static int ricoh619_rtc_valid_tm(struct device *dev, struct rtc_time *tm)
-{
-	if (tm->tm_year > 199 || tm->tm_year < 70
-		|| tm->tm_mon > 11 || tm->tm_mon < 0
-		|| tm->tm_mday < 1
-		|| tm->tm_mday > rtc_month_days(tm->tm_mon, tm->tm_year + os_ref_year)
-		|| tm->tm_hour >= 24 || tm->tm_hour < 0
-		|| tm->tm_min < 0 || tm->tm_min >= 60
-		|| tm->tm_sec < 0 || tm->tm_sec >= 60	
-		) 
-	{
-		dev_err(dev->parent, "PMU: %s *** Returning error due to time, %d/%d/%d %d:%d:%d *****\n",
-			__func__, tm->tm_mon, tm->tm_mday, tm->tm_year, tm->tm_hour, tm->tm_min, tm->tm_sec);
-
-		return -EINVAL;
-	}
-	
-	return 0;
-}
-
-static u8 dec2bcd(u8 dec)
-{
-	return ((dec/10)<<4)+(dec%10);
-}
-
-static u8 bcd2dec(u8 bcd)
-{
-	return (bcd >> 4)*10+(bcd & 0xf);
-}
-
-static void convert_bcd_to_decimal(u8 *buf, u8 len)
-{
-	int i = 0;
-	for (i = 0; i < len; i++)
-		buf[i] = bcd2dec(buf[i]);
-}
-
-static void convert_decimal_to_bcd(u8 *buf, u8 len)
-{
-	int i = 0;
-	for (i = 0; i < len; i++)
-		buf[i] = dec2bcd(buf[i]);
-}
-
-static void print_time(struct device *dev, struct rtc_time *tm)
-{
-	dev_info(dev, "PMU: %s *** rtc-time : %d/%d/%d %d:%d:%d *****\n",
-		__func__, (tm->tm_mon), tm->tm_mday, (tm->tm_year + os_ref_year), tm->tm_hour, tm->tm_min,tm->tm_sec);
-}
-
-static int ricoh619_rtc_periodic_disable(struct device *dev)
-{
-	int err;
-	uint8_t reg_data;
-
-	// disable function
-	err = ricoh619_read_regs(dev, rtc_ctrl1, 1, &reg_data);
-	if(err < 0)
-	{
-		dev_err(dev->parent, "read rtc_ctrl1 error=0x%x\n", err);
-		return err;
-	}
-	reg_data &= 0xf8;
-	err = ricoh619_write_regs(dev, rtc_ctrl1, 1, &reg_data);
-	if(err < 0)
-	{
-		dev_err(dev->parent, "read rtc_ctrl1 error=0x%x\n", err);
-		return err;
-	}
-
-	// clear alarm flag and CTFG
-	err = ricoh619_read_regs(dev, rtc_ctrl2, 1, &reg_data);
-	if(err < 0)
-	{
-		dev_err(dev->parent, "read rtc_ctrl2 error=0x%x\n", err);
-		return err;
-	}
-	reg_data &= ~0x85;// 1000-0101
-	err = ricoh619_write_regs(dev, rtc_ctrl2, 1, &reg_data);
-	if(err < 0)
-	{
-		dev_err(dev->parent, "read rtc_ctrl2 error=0x%x\n", err);
-		return err;
-	}
-
-	return 0;
-}
-
-static int ricoh619_rtc_clk_adjust(struct device *dev, uint8_t clk)
-{
-	return ricoh619_write_regs(dev, rtc_adjust, 1, &clk);
-}
-
-static int ricoh619_rtc_Pon_get_clr(struct device *dev, uint8_t *Pon_f)
-{
-	int err;
-	uint8_t reg_data;
-	
-	err = ricoh619_read_regs(dev, rtc_ctrl2,1,&reg_data);
-	if(err < 0)
-	{
-		dev_err(dev->parent, "rtc_ctrl1 read err=0x%x\n", err);
-		return err;
-	}
-//	printk("%s,PON=1 -- CTRL2=0x%x\n", __func__, reg_data);
-	
-	if(reg_data & 0x10)
-	{
-		*Pon_f = 1;
-		//clear VDET PON
-		reg_data &= ~0x5b;// 0101-1011
-		reg_data |= 0x20; // 0010-0000
-		err = ricoh619_write_regs(dev, rtc_ctrl2, 1,&reg_data);
-		if(err < 0)
-		{
-			dev_err(dev->parent, "rtc_ctrl1 write err=0x%x\n", err);
-		}
-	}
-	else
-	{
-		*Pon_f = 0;
-	}
-	
-
-	return err;
-}
-
-// 0-12hour, 1-24hour
-/*
-static int ricoh619_rtc_hour_mode_get(struct device *dev, uint8_t *mode)
-{
-	int err;
-
-	err = ricoh619_read_regs(dev, rtc_ctrl1, 1, mode);
-	if(err < 0)
-		dev_err(dev->parent, "read rtc ctrl1 error\n");
-
-	if(*mode & 0x20)
-		*mode = 1;
-	else
-		*mode = 0;
-	
-	return err;
-}
-*/
-// 0-12hour, 1-24hour
-static int ricoh619_rtc_hour_mode_set(struct device *dev, int mode)
-{
-	uint8_t reg_data;
-	int err;
-
-	err = ricoh619_read_regs(dev, rtc_ctrl1, 1, &reg_data);
-	if(err < 0)
-	{
-		dev_err(dev->parent, "read rtc_ctrl1 error\n");
-		return err;
-	}
-	if(mode == 0)
-		reg_data &= 0xDF;
-	else
-		reg_data |= 0x20;
-	err = ricoh619_write_regs(dev, rtc_ctrl1, 1, &reg_data);
-	if(err < 0)
-	{
-		dev_err(dev->parent, "write rtc_ctrl1 error\n");
-	}
-
-	return err;
-}
-
-
-static int ricoh619_rtc_read_time(struct device *dev, struct rtc_time *tm)
-{
-	u8 buff[7];
-	int err;
-	int cent_flag;
-
-	err = ricoh619_read_regs(dev, rtc_seconds_reg, sizeof(buff), buff);
-		
-	if (err < 0) {
-		dev_err(dev->parent, "PMU: %s *** failed to read time *****\n", __func__);
-		return err;
-	}
-	
-	if (buff[5] & 0x80)
-		cent_flag = 1;
-	else
-		cent_flag = 0;
-
-	buff[5] = buff[5]&0x1f; //bit5 19_20
-	convert_bcd_to_decimal(buff, sizeof(buff));	
-		
-	tm->tm_sec  = buff[0];
-	tm->tm_min  = buff[1];
-	tm->tm_hour = buff[2];	//bit5 PA_H20
-	tm->tm_wday = buff[3];
-	tm->tm_mday = buff[4];
-	tm->tm_mon  = buff[5];  //for print
-	tm->tm_year = buff[6] + 100 * cent_flag;
-	print_time(dev, tm);	//for print
-	tm->tm_mon  = buff[5] - 1;  //back to system 0-11 
-
-//	printk(KERN_INFO "PMU: %s year=%d mon=%d day=% hour=%d min =%d sec=%d\n", __func__,
-//	tm->tm_year,tm->tm_mon	,tm->tm_mday,tm->tm_hour,tm->tm_min,tm->tm_sec );
-
-	return 0;
-}
-
-static int ricoh619_rtc_set_time(struct device *dev, struct rtc_time *tm)
-{
-	u8 buff[7];
-	int err;
-	int cent_flag;
-
-//	printk(KERN_INFO "PMU: %s year=%d mon=%d day=% hour=%d min =%d sec=%d\n", __func__,
-//	tm->tm_year,tm->tm_mon	,tm->tm_mday,tm->tm_hour,tm->tm_min,tm->tm_sec );
-
-	if(ricoh619_rtc_valid_tm(dev, tm) != 0)
-	{
-		return -EINVAL;
-	}
-
-	if (tm->tm_year >= 100)
-		cent_flag = 1;
-	else
-		cent_flag = 0;
-
-	tm->tm_mon = tm->tm_mon + 1;
-	buff[0] = tm->tm_sec;
-	buff[1] = tm->tm_min;
-	buff[2] = tm->tm_hour;
-	buff[3] = tm->tm_wday;
-	buff[4] = tm->tm_mday;
-	buff[5] = tm->tm_mon; //system set 0-11
-	buff[6] = tm->tm_year - 100 * cent_flag;
-	print_time(dev, tm);	// RTC_TEST
-
-	convert_decimal_to_bcd(buff, sizeof(buff));
-	
-	if (1 == cent_flag)
-		buff[5] |= 0x80;
-
-	err = ricoh619_write_regs(dev, rtc_seconds_reg, sizeof(buff), buff);
-	if (err < 0) {
-		dev_err(dev->parent, "\n failed to program new time\n");
-		return err;
-	}
-
-	return 0;
-}
-
-static int ricoh619_rtc_alarm_is_enabled(struct device *dev,  uint8_t *enabled)
-{
-	int err;
-	uint8_t reg_data;
-
-	err = 0;
-	err = ricoh619_read_regs(dev, rtc_ctrl1,1,&reg_data);
-	if(err<0)
-	{
-		dev_err(dev->parent, "read rtc_ctrl1 error 0x%x\n", err);
-		*enabled = 0;
-	}
-	else
-	{
-		if(reg_data & 0x40)
-			*enabled = 1;
-		else
-			*enabled = 0;
-	}
-	return err;
-}
-
-// 0-disable, 1-enable
-static int ricoh619_rtc_alarm_enable(struct device *dev, unsigned int enabled)
-{
-	struct ricoh619_rtc *rtc = dev_get_drvdata(dev);
-	int err;
-	uint8_t reg_data;
-
-//	printk(KERN_INFO "PMU: %s :%d\n", __func__,enabled);	
-	
-	err = 0;
-	if(enabled)
-	{
-		rtc->irq_en = 1;
-		err = ricoh619_read_regs(dev, rtc_ctrl1, 1,&reg_data);
-		if(err < 0)
-		{
-			dev_err(dev->parent, "read rtc_ctrl1 error =%d\n", err);
-			goto ERR;
-		}
-		reg_data |= 0x40;// set DALE
-		err = ricoh619_write_regs(dev, rtc_ctrl1, 1,&reg_data);
-		if(dev < 0)
-			dev_err(dev->parent, "write rtc_ctrl1 error =%d\n", err);
-	}
-	else
-	{
-		rtc->irq_en = 0;
-		err = ricoh619_read_regs(dev, rtc_ctrl1, 1,&reg_data);
-		if(err < 0)
-		{
-			dev_err(dev->parent, "read rtc_ctrl1 error =%d\n", err);
-			goto ERR;
-		}
-		reg_data &= 0xbf;// clear DALE
-		err = ricoh619_write_regs(dev, rtc_ctrl1, 1,&reg_data);
-		if(dev < 0)
-			dev_err(dev->parent, "write rtc_ctrl1 error =%d\n", err);
-	}
-
-ERR:
-	return err;
-}
-
-static int ricoh619_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
-{
-	u8 buff[6];
-	u8 buff_cent;
-	int err;
-	int cent_flag;
-	unsigned char enabled_flag;
-
-//	printk(KERN_INFO "PMU: %s\n", __func__);
-
-	err = 0;
-
-	alrm->time.tm_sec  = 0;
-	alrm->time.tm_min  = 0;
-	alrm->time.tm_hour = 0;
-	alrm->time.tm_mday = 0;
-	alrm->time.tm_mon  = 0;
-	alrm->time.tm_year = 0;
-	alrm->enabled = 0;
-
-	err = ricoh619_read_regs(dev, rtc_month_reg, 1, &buff_cent);
-	if (err < 0) {
-		dev_err(dev->parent, "PMU: %s *** failed to read time *****\n", __func__);
-		return err;
-	}
-	if (buff_cent & 0x80)
-		cent_flag = 1;
-	else
-		cent_flag = 0;
-
-	err = ricoh619_read_regs(dev, rtc_alarm_y_sec, sizeof(buff), buff);
-	if(err <0)
-	{
-		dev_err(dev->parent, "RTC: %s *** read rtc_alarm timer error =%d\n", __func__, err);
-		return err;
-	}
-	
-	err = ricoh619_read_regs(dev, rtc_ctrl1, 1,&enabled_flag);
-	if(err<0)
-	{
-		dev_err(dev->parent, "RTC: %s *** read rtc_enable flag error =%d\n", __func__, err);
-		return err;
-	}
-	if(enabled_flag & 0x40)
-		enabled_flag = 1;
-	else
-		enabled_flag = 0;
-	
-	buff[3] &= ~0x80;	/* clear DAL_EXT */
-
-	buff[3] = buff[3]&0x3f;
-	convert_bcd_to_decimal(buff, sizeof(buff));
-	
-	alrm->time.tm_sec  = buff[0];
-	alrm->time.tm_min  = buff[1];
-	alrm->time.tm_hour = buff[2];
-	alrm->time.tm_mday = buff[3];
-	alrm->time.tm_mon = buff[4];// for print
-	alrm->time.tm_year = buff[5] + 100 * cent_flag;
-	dev_info(dev, "PMU: read alarm: %d/%d/%d %d:%d:%d *****\n",
-		(alrm->time.tm_mon), alrm->time.tm_mday, (alrm->time.tm_year + os_ref_year), alrm->time.tm_hour, alrm->time.tm_min,alrm->time.tm_sec);
-	alrm->time.tm_mon  = buff[4] - 1;
-	alrm->enabled = enabled_flag;
-
-	return 0;
-}
-
-static int ricoh619_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
-{
-	struct ricoh619_rtc *rtc = dev_get_drvdata(dev);
-	u8 buff[6];
-	int err;
-	int cent_flag;
-
-//	printk(KERN_INFO "PMU: %s\n", __func__);
-	err = 0;
-	ricoh619_rtc_alarm_enable(dev, 0);
-	if (rtc->irq == -1)
-	{
-		err = -EIO;
-		goto ERR;
-	}
-	
-	if(alrm->enabled== 0)
-		return 0;
-	
-	if (alrm->time.tm_year >= 100)
-		cent_flag = 1;
-	else
-		cent_flag = 0;
-
-	alrm->time.tm_mon += 1;
-	print_time(dev->parent, &alrm->time);
-	buff[0] = alrm->time.tm_sec;
-	buff[1] = alrm->time.tm_min;
-	buff[2] = alrm->time.tm_hour;
-	buff[3] = alrm->time.tm_mday;
-	buff[4] = alrm->time.tm_mon;
-//	buff[5] = alrm->time.tm_year - rtc_year_offset;
-	buff[5] = alrm->time.tm_year - 100 * cent_flag;
-	convert_decimal_to_bcd(buff, sizeof(buff));
-	buff[3] |= 0x80;	/* set DAL_EXT */
-	err = ricoh619_write_regs(dev, rtc_alarm_y_sec, sizeof(buff), buff);
-	if (err<0) {
-		dev_err(dev->parent, "\n unable to set alarm\n");
-		err = -EBUSY;
-		goto ERR;
-	}
-
-	ricoh619_rtc_alarm_enable(dev, alrm->enabled);
-	
-ERR:
-	return err;
-}
-
-static const struct rtc_class_ops ricoh619_rtc_ops = {
-	.read_time	= ricoh619_rtc_read_time,
-	.set_time	= ricoh619_rtc_set_time,
-	.set_alarm	= ricoh619_rtc_set_alarm,
-	.read_alarm	= ricoh619_rtc_read_alarm,
-	.alarm_irq_enable = ricoh619_rtc_alarm_enable,
-};
-
-static int ricoh619_rtc_alarm_flag_clr(struct device *dev)
-{
-	int err;
-	uint8_t reg_data;
-
-	/* clear alarm-D status bits.*/
-	err = ricoh619_read_regs(dev, rtc_ctrl2, 1, &reg_data);
-	if (err<0)
-		dev_err(dev->parent, "unable to read rtc_ctrl2 reg\n");
-
-	/* to clear alarm-D flag, and set adjustment parameter */
-	reg_data &= ~0x81;
-	err = ricoh619_write_regs(dev, rtc_ctrl2, 1, &reg_data);
-	if (err<0)
-		dev_err(dev->parent, "unable to program rtc_status reg\n");
-	return err;
-}
-static irqreturn_t ricoh619_rtc_irq(int irq, void *data)
-{
-	struct device *dev = data;
-	struct ricoh619_rtc *rtc = dev_get_drvdata(dev);
-
-//	printk(KERN_INFO "PMU: %s\n", __func__);
-
-	ricoh619_rtc_alarm_flag_clr(dev);
-
-	rtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);
-	return IRQ_HANDLED;
-}
-
-#ifdef CONFIG_OF
-static struct ricoh619_rtc_platform_data *ricoh619_rtc_dt_init(struct platform_device *pdev)
-{
-	struct device_node *nproot = pdev->dev.parent->of_node;
-	struct device_node *np;
-	struct ricoh619_rtc_platform_data *pdata;
-
-	if (!nproot)
-		return pdev->dev.platform_data;
-
-	np = of_find_node_by_name(nproot, "rtc");
-	if (!np) {
-		dev_err(&pdev->dev, "failed to find rtc node\n");
-		return NULL;
-	}
-
-	pdata = devm_kzalloc(&pdev->dev,
-			sizeof(struct ricoh619_rtc_platform_data),
-			GFP_KERNEL);
-
-	of_property_read_u32(np, "ricoh,rtc-tm-year", &pdata->time.tm_year);
-	of_property_read_u32(np, "ricoh,rtc-tm-month", &pdata->time.tm_mon);
-	of_property_read_u32(np, "ricoh,rtc-tm-mday", &pdata->time.tm_mday);
-	of_property_read_u32(np, "ricoh,rtc-tm-hour", &pdata->time.tm_hour);
-	of_property_read_u32(np, "ricoh,rtc-tm-min", &pdata->time.tm_min);
-	of_property_read_u32(np, "ricoh,rtc-tm-sec", &pdata->time.tm_sec);
-	of_node_put(np);
-
-	return pdata;
-}
-#else
-static struct ricoh619_rtc_platform_data *
-ricoh619_rtc_dt_init(struct platform_device *pdev)
-{
-	return pdev->dev.platform_data;
-}
-#endif
-
-static int ricoh619_rtc_probe(struct platform_device *pdev)
-{
-	struct ricoh619_rtc_platform_data *pdata;
-	struct ricoh619 *ricoh619 = dev_get_drvdata(pdev->dev.parent);
-	struct ricoh619_rtc *rtc;
-	struct rtc_time tm;
-	uint8_t Pon_flag,Alarm_flag;
-	int err;
-	uint8_t buff[6];
-
-//	printk(KERN_INFO "******PMU RTC: Version 2014-01-01 REDS!******\n");
-
-	pdata = ricoh619_rtc_dt_init(pdev);
-	if (!pdata) {
-		dev_err(&pdev->dev, "platform data isn't assigned to "
-			"rtc\n");
-		return -EINVAL;
-	}
-	 printk("%s,line=%d\n", __func__,__LINE__);
-
-	rtc = devm_kzalloc(ricoh619->dev,sizeof(*rtc), GFP_KERNEL);
-	if(IS_ERR(rtc))
-	{
-		err = PTR_ERR(rtc);
-		dev_err(&pdev->dev, "no enough memory for ricoh619_rtc using\n");
-		return -ENOMEM;
-	}
-	
-	dev_set_drvdata(&pdev->dev, rtc);
-	if(IS_ERR(rtc->rtc)) 
-	{
-		err = PTR_ERR(rtc->rtc);
-		goto fail;
-	}
-	
-	rtc->irq  = irq_create_mapping(ricoh619->irq_domain, RICOH619_IRQ_DALE);
-	if(rtc->irq  < 0)
-	{
-		dev_err(&pdev->dev, "\n no irq specified, wakeup is disabled\n");
-		rtc->irq = -1;
-		rtc->irq_en = 0;
-	}
-	else
-		rtc->irq_en = 1;
-	//get interrupt flag
-	err = ricoh619_rtc_alarm_is_enabled(&pdev->dev, &Alarm_flag);
-	if (err<0)
-	{
-		dev_err(&pdev->dev, "5T619 RTC: Disable alarm interrupt error\n");
-		goto fail;
-
-	}
-
-	// get PON flag
-	err = ricoh619_rtc_Pon_get_clr(&pdev->dev, &Pon_flag);
-	if (err<0)
-	{
-		dev_err(&pdev->dev, "5T619 RTC: get PON flag error\n");
-		goto fail;
-	}
-
-	// disable rtc periodic function
-	err = ricoh619_rtc_periodic_disable(&pdev->dev);
-	if (err<0)
-	{
-		dev_err(&pdev->dev, "5T619 RTC: disable rtc periodic int error\n");
-		goto fail;
-	}
-
-	// clearing RTC Adjust register
-	err = ricoh619_rtc_clk_adjust(&pdev->dev, 0);
-	if (err<0)
-	{
-		dev_err(&pdev->dev, "unable to program rtc_adjust reg\n");
-		err = -EBUSY;
-		goto fail;
-	}
-
-	//disable interrupt
-	err = ricoh619_rtc_alarm_enable(&pdev->dev, 0);
-	if (err<0)
-	{
-		dev_err(&pdev->dev, "5T619 RTC: Disable alarm interrupt error\n");
-		goto fail;
-	}
-		
-	// PON=1
-	if(Pon_flag) 
-	{
-		Alarm_flag = 0;
-		// clear int flag
-		err = ricoh619_rtc_alarm_flag_clr(&pdev->dev);
-		if (err<0)
-		{
-			dev_err(&pdev->dev, "5T619 RTC: Pon=1 clear alarm flag error\n");
-			goto fail;
-		}
-
-		// using 24h-mode
-		err = ricoh619_rtc_hour_mode_set(&pdev->dev,1);
-		if (err<0)
-		{
-			dev_err(&pdev->dev, "5T619 RTC: Pon=1 set 24h-mode error\n");
-			goto fail;
-		}
-		
-		// setting the default year
-//		printk(KERN_INFO "PMU: %s Set default time\n", __func__);
-		
-		pdata->time.tm_sec=0;
-		pdata->time.tm_min=0;
-		pdata->time.tm_hour=0;
-		pdata->time.tm_wday=6;
-		pdata->time.tm_mday=1;
-		pdata->time.tm_mon=1;
-		pdata->time.tm_year=2012;
-		pdata->time.tm_year -= os_ref_year;
-		if(ricoh619_rtc_valid_tm(&pdev->dev, &(pdata->time)) == 0)
-		{
-			tm.tm_sec   = pdata->time.tm_sec;
-			tm.tm_min  = pdata->time.tm_min;
-			tm.tm_hour = pdata->time.tm_hour;
-			tm.tm_wday= pdata->time.tm_wday;
-			tm.tm_mday= pdata->time.tm_mday;
-			tm.tm_mon  = pdata->time.tm_mon-1;
-			tm.tm_year = pdata->time.tm_year;
-		}
-		else
-		{
-			// using the ricoh default time instead of board default time
-			dev_err(&pdev->dev, "board rtc default is erro\n");
-			tm.tm_sec  = 0;
-			tm.tm_min  = 0;
-			tm.tm_hour = 0;
-			tm.tm_wday = 4;
-			tm.tm_mday = 1;
-			tm.tm_mon  = 0;
-			tm.tm_year = 70;
-		}
-
-		// set default alarm time 
-		if (tm.tm_year >= 100)
-			buff[5] = tm.tm_year-100-1;
-		else
-			buff[5] = tm.tm_year-1;
-		buff[0] = tm.tm_sec;
-		buff[1] = tm.tm_min;
-		buff[2] = tm.tm_hour;
-		buff[3] = tm.tm_mday;
-		buff[4] = tm.tm_mon +1;
-		
-		err = ricoh619_rtc_set_time(&pdev->dev, &tm);
-		if (err<0)
-		{
-			dev_err(&pdev->dev, "5t619 RTC:\n failed to set time\n");
-			goto fail;
-		}
-
-		convert_decimal_to_bcd(buff, sizeof(buff));
-		buff[3] |= 0x80;	/* set DAL_EXT */
-
-		err = ricoh619_write_regs(&pdev->dev, rtc_alarm_y_sec, sizeof(buff), buff);
-		if (err<0)
-			printk( "\n unable to set alarm\n");
-
-	}
-
-	device_init_wakeup(&pdev->dev, 1);
-	
-//	printk(KERN_INFO "PMU: %s register rtc device \n", __func__);
-	rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
-				       &ricoh619_rtc_ops, THIS_MODULE);
-
-	// set interrupt and enable it
-	if(rtc->irq != -1) {
-		err = devm_request_threaded_irq(&pdev->dev,rtc->irq, NULL, ricoh619_rtc_irq,
-					IRQF_ONESHOT, "rtc_ricoh619", &pdev->dev);
-		if (err<0)
-		{
-			dev_err(&pdev->dev, "request IRQ:%d fail\n", rtc->irq);
-			rtc->irq = -1;
-			err = ricoh619_rtc_alarm_enable(&pdev->dev, 0);
-			if (err<0)
-			{
-				dev_err(&pdev->dev, "5T619 RTC: enable rtc alarm error\n");
-				goto fail;
-			}
-		}
-		else{
-			// enable wake  
-			enable_irq_wake(rtc->irq);
-			// enable alarm_d
-			err = ricoh619_rtc_alarm_enable(&pdev->dev, Alarm_flag);
-			if (err<0)
-			{
-				dev_err(&pdev->dev, "failed rtc setup\n");
-				err = -EBUSY;
-				goto fail;
-			}
-		}
-	}
-	else
-	{
-		// system don't want to using alarm interrupt, so close it
-		err = ricoh619_rtc_alarm_enable(&pdev->dev, 0);
-		if (err<0)
-		{
-			dev_err(&pdev->dev, "5T619 RTC: Disable rtc alarm error\n");
-			goto fail;
-		}
-		dev_err(&pdev->dev, "ricoh619 interrupt is disabled\n");
-	}
-	printk(KERN_INFO "RICOH619 RTC Register Success\n");
-	
-	ricoh619_read_regs(&pdev->dev, rtc_ctrl1, 1,&buff[0]);
-	ricoh619_read_regs(&pdev->dev, rtc_ctrl2, 1,&buff[1]);
-//	printk(KERN_INFO "0xAE:%x 0xAF:%x\n",buff[0],buff[1]);
-	return 0;
-
-fail:
-	return err;
-}
-
-static int ricoh619_rtc_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id ricoh619_rtc_dt_match[] = {
-	{ .compatible = "ricoh,ricoh619-rtc", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ricoh619_rtc_dt_match);
-#endif
-
-static struct platform_driver ricoh619_rtc_driver = {
-	.driver	= {
-		.name	= "ricoh619-rtc",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(ricoh619_rtc_dt_match),
-	},
-	.probe	= ricoh619_rtc_probe,
-	.remove	= ricoh619_rtc_remove,
-};
-
-static int __init ricoh619_rtc_init(void)
-{
-	return platform_driver_register(&ricoh619_rtc_driver);
-}
-subsys_initcall_sync(ricoh619_rtc_init);
-
-static void __exit ricoh619_rtc_exit(void)
-{
-	platform_driver_unregister(&ricoh619_rtc_driver);
-}
-module_exit(ricoh619_rtc_exit);
-
-MODULE_DESCRIPTION("RICOH RICOH619 RTC driver");
-MODULE_ALIAS("platform:rtc_ricoh619");
-MODULE_AUTHOR("zhangqing <zhangqing@rock-chips.com>");
-MODULE_LICENSE("GPL");
-
diff --git a/include/linux/mfd/ricoh619.h b/include/linux/mfd/ricoh619.h
deleted file mode 100755
index 8dae94cfc3a7..000000000000
--- a/include/linux/mfd/ricoh619.h
+++ /dev/null
@@ -1,378 +0,0 @@
-/* 
- * include/linux/mfd/ricoh619.h
- *
- * Core driver interface to access RICOH RC5T619 power management chip.
- *
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * Based on code
- *	Copyright (C) 2011 NVIDIA Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
- */
-
-#ifndef __LINUX_MFD_RICOH619_H
-#define __LINUX_MFD_RICOH619_H
-
-#include <linux/mutex.h>
-#include <linux/types.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-
-/* Maximum number of main interrupts */
-#define MAX_INTERRUPT_MASKS	13
-#define MAX_MAIN_INTERRUPT	7
-#define MAX_GPEDGE_REG		2
-
-/* Power control register */
-#define RICOH619_PWR_WD			0x0B
-#define RICOH619_PWR_WD_COUNT		0x0C
-#define RICOH619_PWR_FUNC		0x0D
-#define RICOH619_PWR_SLP_CNT		0x0E
-#define RICOH619_PWR_REP_CNT		0x0F
-#define RICOH619_PWR_ON_TIMSET		0x10
-#define RICOH619_PWR_NOE_TIMSET		0x11
-#define RICOH619_PWR_IRSEL		0x15
-
-/* Interrupt enable register */
-#define RICOH619_INT_EN_SYS		0x12
-#define RICOH619_INT_EN_DCDC		0x40
-#define RICOH619_INT_EN_RTC		0xAE
-#define RICOH619_INT_EN_ADC1		0x88
-#define RICOH619_INT_EN_ADC2		0x89
-#define RICOH619_INT_EN_ADC3		0x8A
-#define RICOH619_INT_EN_GPIO		0x94
-#define RICOH619_INT_EN_GPIO2		0x94 // dummy
-#define RICOH619_INT_MSK_CHGCTR		0xBE
-#define RICOH619_INT_MSK_CHGSTS1	0xBF
-#define RICOH619_INT_MSK_CHGSTS2	0xC0
-#define RICOH619_INT_MSK_CHGERR		0xC1
-#define RICOH619_INT_MSK_CHGEXTIF	0xD1
-
-/* Interrupt select register */
-#define RICOH619_PWR_IRSEL			0x15
-#define RICOH619_CHG_CTRL_DETMOD1	0xCA
-#define RICOH619_CHG_CTRL_DETMOD2	0xCB
-#define RICOH619_CHG_STAT_DETMOD1	0xCC
-#define RICOH619_CHG_STAT_DETMOD2	0xCD
-#define RICOH619_CHG_STAT_DETMOD3	0xCE
-
-
-/* interrupt status registers (monitor regs)*/
-#define RICOH619_INTC_INTPOL		0x9C
-#define RICOH619_INTC_INTEN		0x9D
-#define RICOH619_INTC_INTMON		0x9E
-
-#define RICOH619_INT_MON_SYS		0x14
-#define RICOH619_INT_MON_DCDC		0x42
-#define RICOH619_INT_MON_RTC		0xAF
-
-#define RICOH619_INT_MON_CHGCTR		0xC6
-#define RICOH619_INT_MON_CHGSTS1	0xC7
-#define RICOH619_INT_MON_CHGSTS2	0xC8
-#define RICOH619_INT_MON_CHGERR		0xC9
-#define RICOH619_INT_MON_CHGEXTIF	0xD3
-
-/* interrupt clearing registers */
-#define RICOH619_INT_IR_SYS		0x13
-#define RICOH619_INT_IR_DCDC		0x41
-#define RICOH619_INT_IR_RTC		0xAF
-#define RICOH619_INT_IR_ADCL		0x8C
-#define RICOH619_INT_IR_ADCH		0x8D
-#define RICOH619_INT_IR_ADCEND		0x8E
-#define RICOH619_INT_IR_GPIOR		0x95
-#define RICOH619_INT_IR_GPIOF		0x96
-#define RICOH619_INT_IR_CHGCTR		0xC2
-#define RICOH619_INT_IR_CHGSTS1		0xC3
-#define RICOH619_INT_IR_CHGSTS2		0xC4
-#define RICOH619_INT_IR_CHGERR		0xC5
-#define RICOH619_INT_IR_CHGEXTIF	0xD2
-
-/* GPIO register base address */
-#define RICOH619_GPIO_IOSEL		0x90
-#define RICOH619_GPIO_IOOUT		0x91
-#define RICOH619_GPIO_GPEDGE1		0x92
-#define RICOH619_GPIO_GPEDGE2		0x93
-//#define RICOH619_GPIO_EN_GPIR		0x94
-//#define RICOH619_GPIO_IR_GPR		0x95
-//#define RICOH619_GPIO_IR_GPF		0x96
-#define RICOH619_GPIO_MON_IOIN		0x97
-#define RICOH619_GPIO_LED_FUNC		0x98
-
-#define RICOH619_REG_BANKSEL		0xFF
-
-/* Charger Control register */
-#define RICOH619_CHG_CTL1		0xB3
-#define	TIMSET_REG			0xB9
-
-/* ADC Control register */
-#define RICOH619_ADC_CNT1		0x64
-#define RICOH619_ADC_CNT2		0x65
-#define RICOH619_ADC_CNT3		0x66
-#define RICOH619_ADC_VADP_THL		0x7C
-#define RICOH619_ADC_VSYS_THL		0x80
-
-#define	RICOH619_FG_CTRL		0xE0
-#define	RICOH619_PSWR			0x07
-
-#define RICOH_DC1_SLOT 0x16
-#define RICOH_DC2_SLOT 0x17
-#define RICOH_DC3_SLOT 0x18
-#define RICOH_DC4_SLOT 0x19
-#define RICOH_DC5_SLOT 0x1a
-
-#define RICOH_LDO1_SLOT 0x1b
-#define RICOH_LDO2_SLOT 0x1c
-#define RICOH_LDO3_SLOT 0x1d
-#define RICOH_LDO4_SLOT 0x1e
-#define RICOH_LDO5_SLOT 0x1f
-#define RICOH_LDO6_SLOT 0x20
-#define RICOH_LDO7_SLOT 0x21
-#define RICOH_LDO8_SLOT 0x22
-#define RICOH_LDO9_SLOT 0x23
-#define RICOH_LDO10_SLOT 0x24
-
-#define 	RICOH619_NUM_REGULATOR 17
-
-/* RICOH619 IRQ definitions */
-enum {
-	RICOH619_IRQ_POWER_ON,
-	RICOH619_IRQ_EXTIN,
-	RICOH619_IRQ_PRE_VINDT,
-	RICOH619_IRQ_PREOT,
-	RICOH619_IRQ_POWER_OFF,
-	RICOH619_IRQ_NOE_OFF,
-	RICOH619_IRQ_WD,
-	RICOH619_IRQ_CLK_STP,
-
-	RICOH619_IRQ_DC1LIM,
-	RICOH619_IRQ_DC2LIM,
-	RICOH619_IRQ_DC3LIM,
-	RICOH619_IRQ_DC4LIM,
-	RICOH619_IRQ_DC5LIM,
-
-	RICOH619_IRQ_ILIMLIR,
-	RICOH619_IRQ_VBATLIR,
-	RICOH619_IRQ_VADPLIR,
-	RICOH619_IRQ_VUSBLIR,
-	RICOH619_IRQ_VSYSLIR,
-	RICOH619_IRQ_VTHMLIR,
-	RICOH619_IRQ_AIN1LIR,
-	RICOH619_IRQ_AIN0LIR,
-	
-	RICOH619_IRQ_ILIMHIR,
-	RICOH619_IRQ_VBATHIR,
-	RICOH619_IRQ_VADPHIR,
-	RICOH619_IRQ_VUSBHIR,
-	RICOH619_IRQ_VSYSHIR,
-	RICOH619_IRQ_VTHMHIR,
-	RICOH619_IRQ_AIN1HIR,
-	RICOH619_IRQ_AIN0HIR,
-
-	RICOH619_IRQ_ADC_ENDIR,
-
-	RICOH619_IRQ_GPIO0,
-	RICOH619_IRQ_GPIO1,
-	RICOH619_IRQ_GPIO2,
-	RICOH619_IRQ_GPIO3,
-	RICOH619_IRQ_GPIO4,
-
-	RICOH619_IRQ_CTC,
-	RICOH619_IRQ_DALE,
-
-	RICOH619_IRQ_FVADPDETSINT,
-	RICOH619_IRQ_FVUSBDETSINT,
-	RICOH619_IRQ_FVADPLVSINT,
-	RICOH619_IRQ_FVUSBLVSINT,
-	RICOH619_IRQ_FWVADPSINT,
-	RICOH619_IRQ_FWVUSBSINT,
-
-	RICOH619_IRQ_FONCHGINT,
-	RICOH619_IRQ_FCHGCMPINT,
-	RICOH619_IRQ_FBATOPENINT,
-	RICOH619_IRQ_FSLPMODEINT,
-	RICOH619_IRQ_FBTEMPJTA1INT,
-	RICOH619_IRQ_FBTEMPJTA2INT,
-	RICOH619_IRQ_FBTEMPJTA3INT,
-	RICOH619_IRQ_FBTEMPJTA4INT,
-
-	RICOH619_IRQ_FCURTERMINT,
-	RICOH619_IRQ_FVOLTERMINT,
-	RICOH619_IRQ_FICRVSINT,
-	RICOH619_IRQ_FPOOR_CHGCURINT,
-	RICOH619_IRQ_FOSCFDETINT1,
-	RICOH619_IRQ_FOSCFDETINT2,
-	RICOH619_IRQ_FOSCFDETINT3,
-	RICOH619_IRQ_FOSCMDETINT,
-
-	RICOH619_IRQ_FDIEOFFINT,
-	RICOH619_IRQ_FDIEERRINT,
-	RICOH619_IRQ_FBTEMPERRINT,
-	RICOH619_IRQ_FVBATOVINT,
-	RICOH619_IRQ_FTTIMOVINT,
-	RICOH619_IRQ_FRTIMOVINT,
-	RICOH619_IRQ_FVADPOVSINT,
-	RICOH619_IRQ_FVUSBOVSINT,
-
-	RICOH619_IRQ_FGCDET,
-	RICOH619_IRQ_FPCDET,
-	RICOH619_IRQ_FWARN_ADP,
-
-	/* Should be last entry */
-	RICOH619_NR_IRQS,
-};
-
-/* Ricoh619 gpio definitions */
-enum {
-	RICOH619_GPIO0,
-	RICOH619_GPIO1,
-	RICOH619_GPIO2,
-	RICOH619_GPIO3,
-	RICOH619_GPIO4,
-
-	RICOH619_NR_GPIO,
-};
-
-enum ricoh619_sleep_control_id {
-	RICOH619_DS_DC1,
-	RICOH619_DS_DC2,
-	RICOH619_DS_DC3,
-	RICOH619_DS_DC4,
-	RICOH619_DS_DC5,
-	RICOH619_DS_LDO1,
-	RICOH619_DS_LDO2,
-	RICOH619_DS_LDO3,
-	RICOH619_DS_LDO4,
-	RICOH619_DS_LDO5,
-	RICOH619_DS_LDO6,
-	RICOH619_DS_LDO7,
-	RICOH619_DS_LDO8,
-	RICOH619_DS_LDO9,
-	RICOH619_DS_LDO10,
-	RICOH619_DS_LDORTC1,
-	RICOH619_DS_LDORTC2,
-	RICOH619_DS_PSO0,
-	RICOH619_DS_PSO1,
-	RICOH619_DS_PSO2,
-	RICOH619_DS_PSO3,
-	RICOH619_DS_PSO4,
-};
-
-
-struct ricoh619_subdev_info {
-	int		id;
-	const char	*name;
-	void		*platform_data;
-};
-
-/*
-struct ricoh619_rtc_platform_data {
-	int irq;
-	struct rtc_time time;
-};
-*/
-
-struct ricoh619_gpio_init_data {
-	unsigned output_mode_en:1; 	/* Enable output mode during init */
-	unsigned output_val:1;  	/* Output value if it is in output mode */
-	unsigned init_apply:1;  	/* Apply init data on configuring gpios*/
-	unsigned led_mode:1;  		/* Select LED mode during init */
-	unsigned led_func:1;  		/* Set LED function if LED mode is 1 */
-};
-
-struct ricoh619 {
-	struct device		*dev;
-	struct i2c_client	*client;
-	struct mutex		io_lock;
-	int			gpio_base;
-	struct gpio_chip	gpio_chip;
-	int			irq_base;
-//	struct irq_chip		irq_chip;
-	int			chip_irq;
-	struct mutex		irq_lock;
-	unsigned long		group_irq_en[MAX_MAIN_INTERRUPT];
-
-	/* For main interrupt bits in INTC */
-	u8			intc_inten_cache;
-	u8			intc_inten_reg;
-
-	/* For group interrupt bits and address */
-	u8			irq_en_cache[MAX_INTERRUPT_MASKS];
-	u8			irq_en_reg[MAX_INTERRUPT_MASKS];
-
-	/* For gpio edge */
-	u8			gpedge_cache[MAX_GPEDGE_REG];
-	u8			gpedge_reg[MAX_GPEDGE_REG];
-
-	int			bank_num;
-	struct irq_domain *irq_domain;
-	int dc_det;
-};
-
-struct ricoh619_platform_data {
-	int		num_subdevs;
-	struct	ricoh619_subdev_info *subdevs;
-	int (*init_port)(int irq_num); // Init GPIO for IRQ pin
-	int		gpio_base;
-	int		irq_base;
-	struct ricoh619_gpio_init_data *gpio_init_data;
-	int num_gpioinit_data;
-	bool enable_shutdown_pin;
-	bool pm_off;
-	struct regulator_init_data *reg_init_data[RICOH619_NUM_REGULATOR];
-	int irq_gpio;
-	int pmic_sleep_gpio; /* */
-	int dc_det; 
-	bool pmic_sleep;
-};
-
-/* ==================================== */
-/* RICOH619 Power_Key device data	*/
-/* ==================================== */
-struct ricoh619_pwrkey_platform_data {
-	int irq;
-	unsigned  delay_ms;
-};
-extern int ricoh619_pwrkey_wakeup;
-extern struct ricoh619 *g_ricoh619;
-/* ==================================== */
-/* RICOH619 battery device data	*/
-/* ==================================== */
-extern int g_soc;
-extern int g_fg_on_mode;
-
-extern int ricoh619_read(struct device *dev, uint8_t reg, uint8_t *val);
-extern int ricoh619_read_bank1(struct device *dev, uint8_t reg, uint8_t *val);
-extern int ricoh619_bulk_reads(struct device *dev, u8 reg, u8 count,
-								uint8_t *val);
-extern int ricoh619_bulk_reads_bank1(struct device *dev, u8 reg, u8 count,
-								uint8_t *val);
-extern int ricoh619_write(struct device *dev, u8 reg, uint8_t val);
-extern int ricoh619_write_bank1(struct device *dev, u8 reg, uint8_t val);
-extern int ricoh619_bulk_writes(struct device *dev, u8 reg, u8 count,
-								uint8_t *val);
-extern int ricoh619_bulk_writes_bank1(struct device *dev, u8 reg, u8 count,
-								uint8_t *val);
-extern int ricoh619_set_bits(struct device *dev, u8 reg, uint8_t bit_mask);
-extern int ricoh619_clr_bits(struct device *dev, u8 reg, uint8_t bit_mask);
-extern int ricoh619_update(struct device *dev, u8 reg, uint8_t val,
-								uint8_t mask);
-extern int ricoh619_update_bank1(struct device *dev, u8 reg, uint8_t val,
-								uint8_t mask);
-extern int ricoh619_irq_init(struct ricoh619 *ricoh619, int irq, struct ricoh619_platform_data *pdata);
-extern int ricoh619_irq_exit(struct ricoh619 *ricoh619);
-
-#endif
diff --git a/include/linux/power/ricoh619_battery.h b/include/linux/power/ricoh619_battery.h
deleted file mode 100755
index 01b85a414e02..000000000000
--- a/include/linux/power/ricoh619_battery.h
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * include/linux/power/ricoh619_battery.h
- *
- * RICOH RC5T619 Charger Driver
- * 
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-#ifndef __LINUX_POWER_RICOH619_H_
-#define __LINUX_POWER_RICOH619_H_
-
-/* #include <linux/power_supply.h> */
-/* #include <linux/types.h> */
-
-#if 0
-#define RICOH_FG_DBG(fmt, args...) printk( "RICOH_FG_DBG:\t"fmt, ##args)
-#else
-#define RICOH_FG_DBG(fmt, args...) {while(0);}
-#endif
-
-/* Defined battery information */
-#define	ADC_VDD_MV	2800
-#define	MIN_VOLTAGE	3100
-#define	MAX_VOLTAGE	4200
-#define	B_VALUE		3435
-
-/* 619 Register information */
-/* bank 0 */
-#define PSWR_REG		0x07
-#define VINDAC_REG		0x03
-/* for ADC */
-#define	INTEN_REG		0x9D
-#define	EN_ADCIR3_REG		0x8A
-#define	ADCCNT3_REG		0x66
-#define	VBATDATAH_REG		0x6A
-#define	VBATDATAL_REG		0x6B
-#define	VSYSDATAH_REG		0x70
-#define	VSYSDATAL_REG		0x71
-
-#define CHGCTL1_REG		0xB3
-#define	REGISET1_REG		0xB6
-#define	REGISET2_REG		0xB7
-#define	CHGISET_REG		0xB8
-#define	TIMSET_REG		0xB9
-#define	BATSET1_REG		0xBA
-#define	BATSET2_REG		0xBB
-
-#define CHGSTATE_REG		0xBD
-
-#define	FG_CTRL_REG		0xE0
-#define	SOC_REG			0xE1
-#define	RE_CAP_H_REG		0xE2
-#define	RE_CAP_L_REG		0xE3
-#define	FA_CAP_H_REG		0xE4
-#define	FA_CAP_L_REG		0xE5
-#define	TT_EMPTY_H_REG		0xE7
-#define	TT_EMPTY_L_REG		0xE8
-#define	TT_FULL_H_REG		0xE9
-#define	TT_FULL_L_REG		0xEA
-#define	VOLTAGE_1_REG		0xEB
-#define	VOLTAGE_2_REG		0xEC
-#define	TEMP_1_REG		0xED
-#define	TEMP_2_REG		0xEE
-
-#define	CC_CTRL_REG		0xEF
-#define	CC_SUMREG3_REG		0xF3
-#define	CC_SUMREG2_REG		0xF4
-#define	CC_SUMREG1_REG		0xF5
-#define	CC_SUMREG0_REG		0xF6
-#define	CC_AVERAGE1_REG		0xFB
-#define	CC_AVERAGE0_REG		0xFC
-
-/* bank 1 */
-/* Top address for battery initial setting */
-#define	BAT_INIT_TOP_REG	0xBC
-#define	TEMP_GAIN_H_REG		0xD6
-#define	TEMP_OFF_H_REG		0xD8
-#define	BAT_REL_SEL_REG		0xDA
-#define	BAT_TA_SEL_REG		0xDB
-/**************************/
-
-/* detailed status in CHGSTATE (0xBD) */
-enum ChargeState {
-	CHG_STATE_CHG_OFF = 0,
-	CHG_STATE_CHG_READY_VADP,
-	CHG_STATE_CHG_TRICKLE,
-	CHG_STATE_CHG_RAPID,
-	CHG_STATE_CHG_COMPLETE,
-	CHG_STATE_SUSPEND,
-	CHG_STATE_VCHG_OVER_VOL,
-	CHG_STATE_BAT_ERROR,
-	CHG_STATE_NO_BAT,
-	CHG_STATE_BAT_OVER_VOL,
-	CHG_STATE_BAT_TEMP_ERR,
-	CHG_STATE_DIE_ERR,
-	CHG_STATE_DIE_SHUTDOWN,
-	CHG_STATE_NO_BAT2,
-	CHG_STATE_CHG_READY_VUSB,
-};
-
-enum SupplyState {
-	SUPPLY_STATE_BAT = 0,
-	SUPPLY_STATE_ADP,
-	SUPPLY_STATE_USB,
-} ;
-
-struct ricoh619_battery_type_data {
-	int	ch_vfchg;
-	int	ch_vrchg;
-	int	ch_vbatovset;
-	int	ch_ichg;
-	int	ch_icchg;
-	int	ch_ilim_adp;
-	int	ch_ilim_usb;
-	int	fg_target_vsys;
-	int	fg_target_ibat;
-	int	fg_poff_vbat;
-	int	jt_en;
-	int	jt_hw_sw;
-	int	jt_temp_h;
-	int	jt_temp_l;
-	int	jt_vfchg_h;
-	int	jt_vfchg_l;
-	int	jt_ichg_h;
-	int	jt_ichg_l;
-};
-
-#define BATTERY_TYPE_NUM 1
-struct ricoh619_battery_platform_data {
-	int	irq;
-	int	alarm_vol_mv;
-	int	multiple;
-	unsigned 	monitor_time;
-	struct ricoh619_battery_type_data type[BATTERY_TYPE_NUM];
-};
-
-extern struct ricoh619 *g_ricoh619;
-
-
-#endif
diff --git a/include/linux/regulator/ricoh619-regulator.h b/include/linux/regulator/ricoh619-regulator.h
deleted file mode 100755
index 96b4cee71a8c..000000000000
--- a/include/linux/regulator/ricoh619-regulator.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * linux/regulator/ricoh619-regulator.h
- *
- * Regulator driver for RICOH619 power management chip.
- *
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * Based on code
- *	Copyright (C) 2011 NVIDIA Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
- 
-#ifndef __LINUX_REGULATOR_RICOH619_H
-#define __LINUX_REGULATOR_RICOH619_H
-
-#include <linux/regulator/machine.h>
-#include <linux/regulator/driver.h>
-
-#define ricoh619_rails(_name) "RICOH619_"#_name
-
-/* RICHOH Regulator IDs */
-enum regulator_id {
-	RICOH619_ID_DC1,
-	RICOH619_ID_DC2,	
-	RICOH619_ID_DC3,
-	RICOH619_ID_DC4,
-	RICOH619_ID_DC5,
-	RICOH619_ID_LDO1,
-	RICOH619_ID_LDO2,
-	RICOH619_ID_LDO3,
-	RICOH619_ID_LDO4,
-	RICOH619_ID_LDO5,
-	RICOH619_ID_LDO6,
-	RICOH619_ID_LDO7,
-	RICOH619_ID_LDO8,
-	RICOH619_ID_LDO9,
-	RICOH619_ID_LDO10,
-	RICOH619_ID_LDORTC1,
-	RICOH619_ID_LDORTC2,
-};
-
-struct ricoh619_regulator_platform_data {
-		struct regulator_init_data regulator;
-		int init_uV;
-		unsigned init_enable:1;
-		unsigned init_apply:1;
-		int sleep_uV;
-		int sleep_slots;
-		unsigned long ext_pwr_req;
-		unsigned long flags;
-};
-
-extern	int ricoh619_regulator_enable_eco_mode(struct regulator_dev *rdev);
-extern	int ricoh619_regulator_disable_eco_mode(struct regulator_dev *rdev);
-extern	int ricoh619_regulator_enable_eco_slp_mode(struct regulator_dev *rdev);
-extern	int ricoh619_regulator_disable_eco_slp_mode(struct regulator_dev *rdev);
-
-
-#endif
diff --git a/include/linux/rtc/rtc-ricoh619.h b/include/linux/rtc/rtc-ricoh619.h
deleted file mode 100755
index 36c20f48d818..000000000000
--- a/include/linux/rtc/rtc-ricoh619.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * include/linux/rtc/rtc-ricoh619.h
- *
- * Real time clock driver for RICOH R5T619 power management chip.
- *
- * Copyright (C) 2012-2013 RICOH COMPANY,LTD
- *
- * Based on code
- *  Copyright (C) 2011 NVIDIA Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * you should have received a copy of the gnu general public license
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-#ifndef __LINUX_RTC_RICOH619_H_
-#define __LINUX_RTC_RICOH619_H_
-
-#include <linux/rtc.h>
-
-#define rtc_ctrl1		0xAE
-#define rtc_ctrl2		0xAF
-#define rtc_seconds_reg		0xA0
-#define rtc_alarm_y_sec		0xA8
-#define rtc_adjust		0xA7
-#define rtc_month_reg		0xA5
-#define rtc_mday_reg		0xA4
-#define rtc_dal_month_reg	0xAC
-
-
-/*
-linux rtc driver refers 1900 as base year in many calculations.
-(e.g. refer drivers/rtc/rtc-lib.c)
-*/
-#define os_ref_year 1900
-
-/*
-	pmu rtc have only 2 nibbles to store year information, so using an
-	offset of 100 to set the base year as 2000 for our driver.
-*/
-
-
-
-struct ricoh619_rtc_platform_data {
-	int irq;
-	struct rtc_time time;
-};
-
-
-#endif
-- 
2.35.3

