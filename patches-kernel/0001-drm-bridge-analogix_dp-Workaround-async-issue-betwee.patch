From aceb639de988ab5b22e21e5c43ac9903af87d62e Mon Sep 17 00:00:00 2001
From: Wyon Bi <bivvy.bi@rock-chips.com>
Date: Thu, 14 Nov 2019 09:55:24 +0800
Subject: [PATCH] drm/bridge: analogix_dp: Workaround async issue between pclk
 clock and 24m clock

Background:
- EDP software register bank is on the EDP 24m clock domain;
- CPU access EDP software register bank, need to go through EDP APB
  read/write bus and EDP internal read/write bus;
- EDP APB read/write bus is on the EDP pclk clock domain;
- EDP internal read/write bus is on the EDP 24m clock domain;
- Asynchronous logic circuit is added between APB read/write bus and
  Internal read/write bus;

Issue:
There is a bug on the Asynchronous logic circuit between APB read/write
bus and Internal read/write bus; This bug will be random to cause the
following wrong control/address signals sequence happen;
- For write, maybe wrong register address is wrote in;
- For read, maybe wrong register address is read out;

Workaround:
- For CPU write EDP register operation, write any register need
following three steps,
1): Read EDP_BASE+0x00 dummy register firstly, latch the dummy
register address on Reg_Address bus, to avoid next step write to
wrong register to cause function register overrun;
2): 1st time to write the EDP register you want to operate,
to latch the real write address on Reg_Address bus;
3): 2nd time to write the EDP register you want to operate,
to make sure the data is write on the real write address;
- For CPU read EDP register operation, read any register need following
two steps,
1): 1st time to read the EDP register you want to operate, to latch
the real read address on Reg_Address bus;
2): 2nd time to read the EDP register you want to operate, to make
sure the data is read out from the real read address;

Change-Id: I4a87d3883efe94d32ccf8809edb5b9d869670d2d
Signed-off-by: Wyon Bi <bivvy.bi@rock-chips.com>
---
 .../gpu/drm/bridge/analogix/analogix_dp_reg.c | 560 +++++++++---------
 1 file changed, 289 insertions(+), 271 deletions(-)

diff --git a/drivers/gpu/drm/bridge/analogix/analogix_dp_reg.c b/drivers/gpu/drm/bridge/analogix/analogix_dp_reg.c
index 3747d0cb9374..ebb8dc7073c0 100644
--- a/drivers/gpu/drm/bridge/analogix/analogix_dp_reg.c
+++ b/drivers/gpu/drm/bridge/analogix/analogix_dp_reg.c
@@ -27,18 +27,36 @@
 #define COMMON_INT_MASK_4	(HOTPLUG_CHG | HPD_LOST | PLUG)
 #define INT_STA_MASK		INT_HPD
 
+static void analogix_dp_write(struct analogix_dp_device *dp, u32 reg, u32 val)
+{
+	if (dp->plat_data && is_rockchip(dp->plat_data->dev_type)) {
+		readl(dp->reg_base);
+		writel(val, dp->reg_base + reg);
+	}
+
+	writel(val, dp->reg_base + reg);
+}
+
+static u32 analogix_dp_read(struct analogix_dp_device *dp, u32 reg)
+{
+	if (dp->plat_data && is_rockchip(dp->plat_data->dev_type))
+		readl(dp->reg_base + reg);
+
+	return readl(dp->reg_base + reg);
+}
+
 void analogix_dp_enable_video_mute(struct analogix_dp_device *dp, bool enable)
 {
 	u32 reg;
 
 	if (enable) {
-		reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_1);
 		reg |= HDCP_VIDEO_MUTE;
-		writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);
+		analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_1, reg);
 	} else {
-		reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_1);
 		reg &= ~HDCP_VIDEO_MUTE;
-		writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);
+		analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_1, reg);
 	}
 }
 
@@ -46,9 +64,9 @@ void analogix_dp_stop_video(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_1);
 	reg &= ~VIDEO_EN;
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_1, reg);
 }
 
 void analogix_dp_lane_swap(struct analogix_dp_device *dp, bool enable)
@@ -62,7 +80,7 @@ void analogix_dp_lane_swap(struct analogix_dp_device *dp, bool enable)
 		reg = LANE3_MAP_LOGIC_LANE_3 | LANE2_MAP_LOGIC_LANE_2 |
 		      LANE1_MAP_LOGIC_LANE_1 | LANE0_MAP_LOGIC_LANE_0;
 
-	writel(reg, dp->reg_base + ANALOGIX_DP_LANE_MAP);
+	analogix_dp_write(dp, ANALOGIX_DP_LANE_MAP, reg);
 }
 
 void analogix_dp_init_analog_param(struct analogix_dp_device *dp)
@@ -70,53 +88,53 @@ void analogix_dp_init_analog_param(struct analogix_dp_device *dp)
 	u32 reg;
 
 	reg = TX_TERMINAL_CTRL_50_OHM;
-	writel(reg, dp->reg_base + ANALOGIX_DP_ANALOG_CTL_1);
+	analogix_dp_write(dp, ANALOGIX_DP_ANALOG_CTL_1, reg);
 
 	reg = SEL_24M | TX_DVDD_BIT_1_0625V;
-	writel(reg, dp->reg_base + ANALOGIX_DP_ANALOG_CTL_2);
+	analogix_dp_write(dp, ANALOGIX_DP_ANALOG_CTL_2, reg);
 
 	if (dp->plat_data && is_rockchip(dp->plat_data->dev_type)) {
 		reg = REF_CLK_24M;
 		if (dp->plat_data->dev_type == RK3288_DP)
 			reg ^= REF_CLK_MASK;
 
-		writel(reg, dp->reg_base + ANALOGIX_DP_PLL_REG_1);
-		writel(0x95, dp->reg_base + ANALOGIX_DP_PLL_REG_2);
-		writel(0x40, dp->reg_base + ANALOGIX_DP_PLL_REG_3);
-		writel(0x58, dp->reg_base + ANALOGIX_DP_PLL_REG_4);
-		writel(0x22, dp->reg_base + ANALOGIX_DP_PLL_REG_5);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_1, reg);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_2, 0x95);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_3, 0x40);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_4, 0x58);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_5, 0x22);
 	}
 
 	reg = DRIVE_DVDD_BIT_1_0625V | VCO_BIT_600_MICRO;
-	writel(reg, dp->reg_base + ANALOGIX_DP_ANALOG_CTL_3);
+	analogix_dp_write(dp, ANALOGIX_DP_ANALOG_CTL_3, reg);
 
 	reg = PD_RING_OSC | AUX_TERMINAL_CTRL_50_OHM |
 		TX_CUR1_2X | TX_CUR_16_MA;
-	writel(reg, dp->reg_base + ANALOGIX_DP_PLL_FILTER_CTL_1);
+	analogix_dp_write(dp, ANALOGIX_DP_PLL_FILTER_CTL_1, reg);
 
 	reg = CH3_AMP_400_MV | CH2_AMP_400_MV |
 		CH1_AMP_400_MV | CH0_AMP_400_MV;
-	writel(reg, dp->reg_base + ANALOGIX_DP_TX_AMP_TUNING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_TX_AMP_TUNING_CTL, reg);
 }
 
 void analogix_dp_init_interrupt(struct analogix_dp_device *dp)
 {
 	/* Set interrupt pin assertion polarity as high */
-	writel(INT_POL1 | INT_POL0, dp->reg_base + ANALOGIX_DP_INT_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_CTL, INT_POL1 | INT_POL0);
 
 	/* Clear pending regisers */
-	writel(0xff, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_1);
-	writel(0x4f, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_2);
-	writel(0xe0, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_3);
-	writel(0xe7, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_4);
-	writel(0x63, dp->reg_base + ANALOGIX_DP_INT_STA);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_1, 0xff);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_2, 0x4f);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_3, 0xe0);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_4, 0xe7);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, 0x63);
 
 	/* 0:mask,1: unmask */
-	writel(0x00, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_1);
-	writel(0x00, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_2);
-	writel(0x00, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_3);
-	writel(0x00, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);
-	writel(0x00, dp->reg_base + ANALOGIX_DP_INT_STA_MASK);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_1, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_2, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_3, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_4, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA_MASK, 0x00);
 }
 
 void analogix_dp_reset(struct analogix_dp_device *dp)
@@ -134,44 +152,44 @@ void analogix_dp_reset(struct analogix_dp_device *dp)
 			AUD_FIFO_FUNC_EN_N | AUD_FUNC_EN_N |
 			HDCP_FUNC_EN_N | SW_FUNC_EN_N;
 
-	writel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_1);
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_1, reg);
 
 	reg = SSC_FUNC_EN_N | AUX_FUNC_EN_N |
 		SERDES_FIFO_FUNC_EN_N |
 		LS_CLK_DOMAIN_FUNC_EN_N;
-	writel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_2);
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_2, reg);
 
 	usleep_range(20, 30);
 
 	analogix_dp_lane_swap(dp, 0);
 
-	writel(0x0, dp->reg_base + ANALOGIX_DP_SYS_CTL_1);
-	writel(0x40, dp->reg_base + ANALOGIX_DP_SYS_CTL_2);
-	writel(0x0, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
-	writel(0x0, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_1, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_2, 0x40);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, 0x0);
 
-	writel(0x0, dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);
-	writel(0x0, dp->reg_base + ANALOGIX_DP_HDCP_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_PKT_SEND_CTL, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_HDCP_CTL, 0x0);
 
-	writel(0x5e, dp->reg_base + ANALOGIX_DP_HPD_DEGLITCH_L);
-	writel(0x1a, dp->reg_base + ANALOGIX_DP_HPD_DEGLITCH_H);
+	analogix_dp_write(dp, ANALOGIX_DP_HPD_DEGLITCH_L, 0x5e);
+	analogix_dp_write(dp, ANALOGIX_DP_HPD_DEGLITCH_H, 0x1a);
 
-	writel(0x10, dp->reg_base + ANALOGIX_DP_LINK_DEBUG_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LINK_DEBUG_CTL, 0x10);
 
-	writel(0x0, dp->reg_base + ANALOGIX_DP_PHY_TEST);
+	analogix_dp_write(dp, ANALOGIX_DP_PHY_TEST, 0x0);
 
-	writel(0x0, dp->reg_base + ANALOGIX_DP_VIDEO_FIFO_THRD);
-	writel(0x20, dp->reg_base + ANALOGIX_DP_AUDIO_MARGIN);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_FIFO_THRD, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_AUDIO_MARGIN, 0x20);
 
-	writel(0x4, dp->reg_base + ANALOGIX_DP_M_VID_GEN_FILTER_TH);
-	writel(0x2, dp->reg_base + ANALOGIX_DP_M_AUD_GEN_FILTER_TH);
+	analogix_dp_write(dp, ANALOGIX_DP_M_VID_GEN_FILTER_TH, 0x4);
+	analogix_dp_write(dp, ANALOGIX_DP_M_AUD_GEN_FILTER_TH, 0x2);
 
-	writel(0x00000101, dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_SOC_GENERAL_CTL, 0x00000101);
 }
 
 void analogix_dp_swreset(struct analogix_dp_device *dp)
 {
-	writel(RESET_DP_TX, dp->reg_base + ANALOGIX_DP_TX_SW_RESET);
+	analogix_dp_write(dp, ANALOGIX_DP_TX_SW_RESET, RESET_DP_TX);
 }
 
 void analogix_dp_config_interrupt(struct analogix_dp_device *dp)
@@ -180,19 +198,19 @@ void analogix_dp_config_interrupt(struct analogix_dp_device *dp)
 
 	/* 0: mask, 1: unmask */
 	reg = COMMON_INT_MASK_1;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_1);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_1, reg);
 
 	reg = COMMON_INT_MASK_2;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_2);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_2, reg);
 
 	reg = COMMON_INT_MASK_3;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_3);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_3, reg);
 
 	reg = COMMON_INT_MASK_4;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_4, reg);
 
 	reg = INT_STA_MASK;
-	writel(reg, dp->reg_base + ANALOGIX_DP_INT_STA_MASK);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA_MASK, reg);
 }
 
 void analogix_dp_mute_hpd_interrupt(struct analogix_dp_device *dp)
@@ -200,13 +218,13 @@ void analogix_dp_mute_hpd_interrupt(struct analogix_dp_device *dp)
 	u32 reg;
 
 	/* 0: mask, 1: unmask */
-	reg = readl(dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_COMMON_INT_MASK_4);
 	reg &= ~COMMON_INT_MASK_4;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_4, reg);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_INT_STA_MASK);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA_MASK);
 	reg &= ~INT_STA_MASK;
-	writel(reg, dp->reg_base + ANALOGIX_DP_INT_STA_MASK);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA_MASK, reg);
 }
 
 void analogix_dp_unmute_hpd_interrupt(struct analogix_dp_device *dp)
@@ -215,17 +233,17 @@ void analogix_dp_unmute_hpd_interrupt(struct analogix_dp_device *dp)
 
 	/* 0: mask, 1: unmask */
 	reg = COMMON_INT_MASK_4;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_4, reg);
 
 	reg = INT_STA_MASK;
-	writel(reg, dp->reg_base + ANALOGIX_DP_INT_STA_MASK);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA_MASK, reg);
 }
 
 enum pll_status analogix_dp_get_pll_lock_status(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_DEBUG_CTL);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_DEBUG_CTL);
 	if (reg & PLL_LOCK)
 		return PLL_LOCKED;
 	else
@@ -243,12 +261,12 @@ void analogix_dp_set_pll_power_down(struct analogix_dp_device *dp, bool enable)
 		mask = RK_PLL_PD;
 	}
 
-	reg = readl(dp->reg_base + pd_addr);
+	reg = analogix_dp_read(dp, pd_addr);
 	if (enable)
 		reg |= mask;
 	else
 		reg &= ~mask;
-	writel(reg, dp->reg_base + pd_addr);
+	analogix_dp_write(dp, pd_addr, reg);
 }
 
 void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,
@@ -269,52 +287,52 @@ void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,
 		else
 			mask = AUX_PD;
 
-		reg = readl(dp->reg_base + phy_pd_addr);
+		reg = analogix_dp_read(dp, phy_pd_addr);
 		if (enable)
 			reg |= mask;
 		else
 			reg &= ~mask;
-		writel(reg, dp->reg_base + phy_pd_addr);
+		analogix_dp_write(dp, phy_pd_addr, reg);
 		break;
 	case CH0_BLOCK:
 		mask = CH0_PD;
-		reg = readl(dp->reg_base + phy_pd_addr);
+		reg = analogix_dp_read(dp, phy_pd_addr);
 
 		if (enable)
 			reg |= mask;
 		else
 			reg &= ~mask;
-		writel(reg, dp->reg_base + phy_pd_addr);
+		analogix_dp_write(dp, phy_pd_addr, reg);
 		break;
 	case CH1_BLOCK:
 		mask = CH1_PD;
-		reg = readl(dp->reg_base + phy_pd_addr);
+		reg = analogix_dp_read(dp, phy_pd_addr);
 
 		if (enable)
 			reg |= mask;
 		else
 			reg &= ~mask;
-		writel(reg, dp->reg_base + phy_pd_addr);
+		analogix_dp_write(dp, phy_pd_addr, reg);
 		break;
 	case CH2_BLOCK:
 		mask = CH2_PD;
-		reg = readl(dp->reg_base + phy_pd_addr);
+		reg = analogix_dp_read(dp, phy_pd_addr);
 
 		if (enable)
 			reg |= mask;
 		else
 			reg &= ~mask;
-		writel(reg, dp->reg_base + phy_pd_addr);
+		analogix_dp_write(dp, phy_pd_addr, reg);
 		break;
 	case CH3_BLOCK:
 		mask = CH3_PD;
-		reg = readl(dp->reg_base + phy_pd_addr);
+		reg = analogix_dp_read(dp, phy_pd_addr);
 
 		if (enable)
 			reg |= mask;
 		else
 			reg &= ~mask;
-		writel(reg, dp->reg_base + phy_pd_addr);
+		analogix_dp_write(dp, phy_pd_addr, reg);
 		break;
 	case ANALOG_TOTAL:
 		/*
@@ -327,29 +345,29 @@ void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,
 		else
 			mask = DP_PHY_PD;
 
-		reg = readl(dp->reg_base + phy_pd_addr);
+		reg = analogix_dp_read(dp, phy_pd_addr);
 		if (enable)
 			reg |= mask;
 		else
 			reg &= ~mask;
 
-		writel(reg, dp->reg_base + phy_pd_addr);
+		analogix_dp_write(dp, phy_pd_addr, reg);
 		if (dp->plat_data && is_rockchip(dp->plat_data->dev_type))
 			usleep_range(10, 15);
 		break;
 	case POWER_ALL:
 		if (enable) {
 			reg = DP_ALL_PD;
-			writel(reg, dp->reg_base + phy_pd_addr);
+			analogix_dp_write(dp, phy_pd_addr, reg);
 		} else {
 			reg = DP_ALL_PD;
-			writel(reg, dp->reg_base + phy_pd_addr);
+			analogix_dp_write(dp, phy_pd_addr, reg);
 			usleep_range(10, 15);
 			reg &= ~DP_INC_BG;
-			writel(reg, dp->reg_base + phy_pd_addr);
+			analogix_dp_write(dp, phy_pd_addr, reg);
 			usleep_range(10, 15);
 
-			writel(0x00, dp->reg_base + phy_pd_addr);
+			analogix_dp_write(dp, phy_pd_addr, 0x00);
 		}
 		break;
 	default:
@@ -365,11 +383,11 @@ int analogix_dp_init_analog_func(struct analogix_dp_device *dp)
 	analogix_dp_set_analog_power_down(dp, POWER_ALL, 0);
 
 	reg = PLL_LOCK_CHG;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_1);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_1, reg);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_DEBUG_CTL);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_DEBUG_CTL);
 	reg &= ~(F_PLL_LOCK | PLL_LOCK_CTRL);
-	writel(reg, dp->reg_base + ANALOGIX_DP_DEBUG_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_DEBUG_CTL, reg);
 
 	/* Power up PLL */
 	if (analogix_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {
@@ -386,10 +404,10 @@ int analogix_dp_init_analog_func(struct analogix_dp_device *dp)
 	}
 
 	/* Enable Serdes FIFO function and Link symbol clock domain module */
-	reg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_2);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_2);
 	reg &= ~(SERDES_FIFO_FUNC_EN_N | LS_CLK_DOMAIN_FUNC_EN_N
 		| AUX_FUNC_EN_N);
-	writel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_2);
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_2, reg);
 	return 0;
 }
 
@@ -401,10 +419,10 @@ void analogix_dp_clear_hotplug_interrupts(struct analogix_dp_device *dp)
 		return;
 
 	reg = HOTPLUG_CHG | HPD_LOST | PLUG;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_4);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_4, reg);
 
 	reg = INT_HPD;
-	writel(reg, dp->reg_base + ANALOGIX_DP_INT_STA);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, reg);
 }
 
 void analogix_dp_init_hpd(struct analogix_dp_device *dp)
@@ -416,18 +434,18 @@ void analogix_dp_init_hpd(struct analogix_dp_device *dp)
 
 	analogix_dp_clear_hotplug_interrupts(dp);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
 	reg &= ~(F_HPD | HPD_CTRL);
-	writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, reg);
 }
 
 void analogix_dp_force_hpd(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
-	reg = (F_HPD | HPD_CTRL);
-	writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+	reg |= (F_HPD | HPD_CTRL);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, reg);
 }
 
 enum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp)
@@ -442,7 +460,7 @@ enum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp)
 			return DP_IRQ_TYPE_HP_CABLE_OUT;
 	} else {
 		/* Parse hotplug interrupt status register */
-		reg = readl(dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_4);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_COMMON_INT_STA_4);
 
 		if (reg & PLUG)
 			return DP_IRQ_TYPE_HP_CABLE_IN;
@@ -462,9 +480,9 @@ void analogix_dp_reset_aux(struct analogix_dp_device *dp)
 	u32 reg;
 
 	/* Disable AUX channel module */
-	reg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_2);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_2);
 	reg |= AUX_FUNC_EN_N;
-	writel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_2);
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_2, reg);
 }
 
 void analogix_dp_init_aux(struct analogix_dp_device *dp)
@@ -473,7 +491,7 @@ void analogix_dp_init_aux(struct analogix_dp_device *dp)
 
 	/* Clear inerrupts related to AUX channel */
 	reg = RPLY_RECEIV | AUX_ERR;
-	writel(reg, dp->reg_base + ANALOGIX_DP_INT_STA);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, reg);
 
 	analogix_dp_set_analog_power_down(dp, AUX_BLOCK, true);
 	usleep_range(10, 11);
@@ -491,16 +509,16 @@ void analogix_dp_init_aux(struct analogix_dp_device *dp)
 	reg |= AUX_HW_RETRY_COUNT_SEL(0) |
 	       AUX_HW_RETRY_INTERVAL_600_MICROSECONDS;
 
-	writel(reg, dp->reg_base + ANALOGIX_DP_AUX_HW_RETRY_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_HW_RETRY_CTL, reg);
 
 	/* Receive AUX Channel DEFER commands equal to DEFFER_COUNT*64 */
 	reg = DEFER_CTRL_EN | DEFER_COUNT(1);
-	writel(reg, dp->reg_base + ANALOGIX_DP_AUX_CH_DEFER_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_DEFER_CTL, reg);
 
 	/* Enable AUX channel module */
-	reg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_2);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_2);
 	reg &= ~AUX_FUNC_EN_N;
-	writel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_2);
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_2, reg);
 }
 
 int analogix_dp_get_plug_in_status(struct analogix_dp_device *dp)
@@ -511,7 +529,7 @@ int analogix_dp_get_plug_in_status(struct analogix_dp_device *dp)
 		if (gpio_get_value(dp->hpd_gpio))
 			return 0;
 	} else {
-		reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
 		if (reg & HPD_STATUS)
 			return 0;
 	}
@@ -523,9 +541,9 @@ void analogix_dp_enable_sw_function(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_1);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_1);
 	reg &= ~SW_FUNC_EN_N;
-	writel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_1);
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_1, reg);
 }
 
 int analogix_dp_start_aux_transaction(struct analogix_dp_device *dp)
@@ -535,34 +553,34 @@ int analogix_dp_start_aux_transaction(struct analogix_dp_device *dp)
 	int timeout_loop = 0;
 
 	/* Enable AUX CH operation */
-	reg = readl(dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_2);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_AUX_CH_CTL_2);
 	reg |= AUX_EN;
-	writel(reg, dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_2);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_2, reg);
 
 	/* Is AUX CH command reply received? */
-	reg = readl(dp->reg_base + ANALOGIX_DP_INT_STA);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA);
 	while (!(reg & RPLY_RECEIV)) {
 		timeout_loop++;
 		if (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {
 			dev_err(dp->dev, "AUX CH command reply failed!\n");
 			return -ETIMEDOUT;
 		}
-		reg = readl(dp->reg_base + ANALOGIX_DP_INT_STA);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA);
 		usleep_range(10, 11);
 	}
 
 	/* Clear interrupt source for AUX CH command reply */
-	writel(RPLY_RECEIV, dp->reg_base + ANALOGIX_DP_INT_STA);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, RPLY_RECEIV);
 
 	/* Clear interrupt source for AUX CH access error */
-	reg = readl(dp->reg_base + ANALOGIX_DP_INT_STA);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA);
 	if (reg & AUX_ERR) {
-		writel(AUX_ERR, dp->reg_base + ANALOGIX_DP_INT_STA);
+		analogix_dp_write(dp, ANALOGIX_DP_INT_STA, AUX_ERR);
 		return -EREMOTEIO;
 	}
 
 	/* Check AUX CH error access status */
-	reg = readl(dp->reg_base + ANALOGIX_DP_AUX_CH_STA);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_AUX_CH_STA);
 	if ((reg & AUX_STATUS_MASK) != 0) {
 		dev_err(dp->dev, "AUX CH error happens: %d\n\n",
 			reg & AUX_STATUS_MASK);
@@ -583,19 +601,19 @@ int analogix_dp_write_byte_to_dpcd(struct analogix_dp_device *dp,
 	for (i = 0; i < 3; i++) {
 		/* Clear AUX CH data buffer */
 		reg = BUF_CLR;
-		writel(reg, dp->reg_base + ANALOGIX_DP_BUFFER_DATA_CTL);
+		analogix_dp_write(dp, ANALOGIX_DP_BUFFER_DATA_CTL, reg);
 
 		/* Select DPCD device address */
 		reg = AUX_ADDR_7_0(reg_addr);
-		writel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_7_0);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_7_0, reg);
 		reg = AUX_ADDR_15_8(reg_addr);
-		writel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_15_8);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_15_8, reg);
 		reg = AUX_ADDR_19_16(reg_addr);
-		writel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_19_16);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_19_16, reg);
 
 		/* Write data buffer */
 		reg = (unsigned int)data;
-		writel(reg, dp->reg_base + ANALOGIX_DP_BUF_DATA_0);
+		analogix_dp_write(dp, ANALOGIX_DP_BUF_DATA_0, reg);
 
 		/*
 		 * Set DisplayPort transaction and write 1 byte
@@ -603,7 +621,7 @@ int analogix_dp_write_byte_to_dpcd(struct analogix_dp_device *dp,
 		 * If Bit 3 is 0, I2C transaction.
 		 */
 		reg = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;
-		writel(reg, dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_1);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1, reg);
 
 		/* Start AUX transaction */
 		retval = analogix_dp_start_aux_transaction(dp);
@@ -622,14 +640,14 @@ void analogix_dp_set_link_bandwidth(struct analogix_dp_device *dp, u32 bwtype)
 
 	reg = bwtype;
 	if ((bwtype == DP_LINK_BW_2_7) || (bwtype == DP_LINK_BW_1_62))
-		writel(reg, dp->reg_base + ANALOGIX_DP_LINK_BW_SET);
+		analogix_dp_write(dp, ANALOGIX_DP_LINK_BW_SET, reg);
 }
 
 void analogix_dp_get_link_bandwidth(struct analogix_dp_device *dp, u32 *bwtype)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_LINK_BW_SET);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_LINK_BW_SET);
 	*bwtype = reg;
 }
 
@@ -638,14 +656,14 @@ void analogix_dp_set_lane_count(struct analogix_dp_device *dp, u32 count)
 	u32 reg;
 
 	reg = count;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LANE_COUNT_SET);
+	analogix_dp_write(dp, ANALOGIX_DP_LANE_COUNT_SET, reg);
 }
 
 void analogix_dp_get_lane_count(struct analogix_dp_device *dp, u32 *count)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_LANE_COUNT_SET);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_LANE_COUNT_SET);
 	*count = reg;
 }
 
@@ -655,13 +673,13 @@ void analogix_dp_enable_enhanced_mode(struct analogix_dp_device *dp,
 	u32 reg;
 
 	if (enable) {
-		reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_4);
 		reg |= ENHANCED;
-		writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, reg);
 	} else {
-		reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_4);
 		reg &= ~ENHANCED;
-		writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, reg);
 	}
 }
 
@@ -673,25 +691,25 @@ void analogix_dp_set_training_pattern(struct analogix_dp_device *dp,
 	switch (pattern) {
 	case PRBS7:
 		reg = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_PRBS7;
-		writel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
 		break;
 	case D10_2:
 		reg = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_D10_2;
-		writel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
 		break;
 	case TRAINING_PTN1:
 		reg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN1;
-		writel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
 		break;
 	case TRAINING_PTN2:
 		reg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN2;
-		writel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
 		break;
 	case DP_NONE:
 		reg = SCRAMBLING_ENABLE |
 			LINK_QUAL_PATTERN_SET_DISABLE |
 			SW_TRAINING_PATTERN_SET_NORMAL;
-		writel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
 		break;
 	default:
 		break;
@@ -703,10 +721,10 @@ void analogix_dp_set_lane0_pre_emphasis(struct analogix_dp_device *dp,
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_LN0_LINK_TRAINING_CTL);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_LN0_LINK_TRAINING_CTL);
 	reg &= ~PRE_EMPHASIS_SET_MASK;
 	reg |= level << PRE_EMPHASIS_SET_SHIFT;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LN0_LINK_TRAINING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LN0_LINK_TRAINING_CTL, reg);
 }
 
 void analogix_dp_set_lane1_pre_emphasis(struct analogix_dp_device *dp,
@@ -714,10 +732,10 @@ void analogix_dp_set_lane1_pre_emphasis(struct analogix_dp_device *dp,
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_LN1_LINK_TRAINING_CTL);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_LN1_LINK_TRAINING_CTL);
 	reg &= ~PRE_EMPHASIS_SET_MASK;
 	reg |= level << PRE_EMPHASIS_SET_SHIFT;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LN1_LINK_TRAINING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LN1_LINK_TRAINING_CTL, reg);
 }
 
 void analogix_dp_set_lane2_pre_emphasis(struct analogix_dp_device *dp,
@@ -725,10 +743,10 @@ void analogix_dp_set_lane2_pre_emphasis(struct analogix_dp_device *dp,
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_LN2_LINK_TRAINING_CTL);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_LN2_LINK_TRAINING_CTL);
 	reg &= ~PRE_EMPHASIS_SET_MASK;
 	reg |= level << PRE_EMPHASIS_SET_SHIFT;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LN2_LINK_TRAINING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LN2_LINK_TRAINING_CTL, reg);
 }
 
 void analogix_dp_set_lane3_pre_emphasis(struct analogix_dp_device *dp,
@@ -736,10 +754,10 @@ void analogix_dp_set_lane3_pre_emphasis(struct analogix_dp_device *dp,
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_LN3_LINK_TRAINING_CTL);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_LN3_LINK_TRAINING_CTL);
 	reg &= ~PRE_EMPHASIS_SET_MASK;
 	reg |= level << PRE_EMPHASIS_SET_SHIFT;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LN3_LINK_TRAINING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LN3_LINK_TRAINING_CTL, reg);
 }
 
 void analogix_dp_set_lane0_link_training(struct analogix_dp_device *dp,
@@ -748,7 +766,7 @@ void analogix_dp_set_lane0_link_training(struct analogix_dp_device *dp,
 	u32 reg;
 
 	reg = training_lane;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LN0_LINK_TRAINING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LN0_LINK_TRAINING_CTL, reg);
 }
 
 void analogix_dp_set_lane1_link_training(struct analogix_dp_device *dp,
@@ -757,7 +775,7 @@ void analogix_dp_set_lane1_link_training(struct analogix_dp_device *dp,
 	u32 reg;
 
 	reg = training_lane;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LN1_LINK_TRAINING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LN1_LINK_TRAINING_CTL, reg);
 }
 
 void analogix_dp_set_lane2_link_training(struct analogix_dp_device *dp,
@@ -766,7 +784,7 @@ void analogix_dp_set_lane2_link_training(struct analogix_dp_device *dp,
 	u32 reg;
 
 	reg = training_lane;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LN2_LINK_TRAINING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LN2_LINK_TRAINING_CTL, reg);
 }
 
 void analogix_dp_set_lane3_link_training(struct analogix_dp_device *dp,
@@ -775,42 +793,42 @@ void analogix_dp_set_lane3_link_training(struct analogix_dp_device *dp,
 	u32 reg;
 
 	reg = training_lane;
-	writel(reg, dp->reg_base + ANALOGIX_DP_LN3_LINK_TRAINING_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_LN3_LINK_TRAINING_CTL, reg);
 }
 
 u32 analogix_dp_get_lane0_link_training(struct analogix_dp_device *dp)
 {
-	return readl(dp->reg_base + ANALOGIX_DP_LN0_LINK_TRAINING_CTL);
+	return analogix_dp_read(dp, ANALOGIX_DP_LN0_LINK_TRAINING_CTL);
 }
 
 u32 analogix_dp_get_lane1_link_training(struct analogix_dp_device *dp)
 {
-	return readl(dp->reg_base + ANALOGIX_DP_LN1_LINK_TRAINING_CTL);
+	return analogix_dp_read(dp, ANALOGIX_DP_LN1_LINK_TRAINING_CTL);
 }
 
 u32 analogix_dp_get_lane2_link_training(struct analogix_dp_device *dp)
 {
-	return readl(dp->reg_base + ANALOGIX_DP_LN2_LINK_TRAINING_CTL);
+	return analogix_dp_read(dp, ANALOGIX_DP_LN2_LINK_TRAINING_CTL);
 }
 
 u32 analogix_dp_get_lane3_link_training(struct analogix_dp_device *dp)
 {
-	return readl(dp->reg_base + ANALOGIX_DP_LN3_LINK_TRAINING_CTL);
+	return analogix_dp_read(dp, ANALOGIX_DP_LN3_LINK_TRAINING_CTL);
 }
 
 void analogix_dp_reset_macro(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_PHY_TEST);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_PHY_TEST);
 	reg |= MACRO_RST;
-	writel(reg, dp->reg_base + ANALOGIX_DP_PHY_TEST);
+	analogix_dp_write(dp, ANALOGIX_DP_PHY_TEST, reg);
 
 	/* 10 us is the minimum reset time. */
 	usleep_range(10, 20);
 
 	reg &= ~MACRO_RST;
-	writel(reg, dp->reg_base + ANALOGIX_DP_PHY_TEST);
+	analogix_dp_write(dp, ANALOGIX_DP_PHY_TEST, reg);
 }
 
 void analogix_dp_init_video(struct analogix_dp_device *dp)
@@ -818,19 +836,19 @@ void analogix_dp_init_video(struct analogix_dp_device *dp)
 	u32 reg;
 
 	reg = VSYNC_DET | VID_FORMAT_CHG | VID_CLK_CHG;
-	writel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_1);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_1, reg);
 
 	reg = 0x0;
-	writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_1);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_1, reg);
 
 	reg = CHA_CRI(4) | CHA_CTRL;
-	writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_2);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_2, reg);
 
 	reg = 0x0;
-	writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, reg);
 
 	reg = VID_HRES_TH(2) | VID_VRES_TH(0);
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_8);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_8, reg);
 }
 
 void analogix_dp_set_video_color_format(struct analogix_dp_device *dp)
@@ -841,36 +859,36 @@ void analogix_dp_set_video_color_format(struct analogix_dp_device *dp)
 	reg = (dp->video_info.dynamic_range << IN_D_RANGE_SHIFT) |
 		(dp->video_info.color_depth << IN_BPC_SHIFT) |
 		(dp->video_info.color_space << IN_COLOR_F_SHIFT);
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_2);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_2, reg);
 
 	/* Set Input Color YCbCr Coefficients to ITU601 or ITU709 */
-	reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_3);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_3);
 	reg &= ~IN_YC_COEFFI_MASK;
 	if (dp->video_info.ycbcr_coeff)
 		reg |= IN_YC_COEFFI_ITU709;
 	else
 		reg |= IN_YC_COEFFI_ITU601;
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_3);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_3, reg);
 }
 
 int analogix_dp_is_slave_video_stream_clock_on(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_1);
-	writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_1);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_1);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_1, reg);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_1);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_1);
 
 	if (!(reg & DET_STA)) {
 		dev_dbg(dp->dev, "Input stream clock not detected.\n");
 		return -EINVAL;
 	}
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_2);
-	writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_2);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_2);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_2, reg);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_2);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_2);
 	dev_dbg(dp->dev, "wait SYS_CTL_2.\n");
 
 	if (reg & CHA_STA) {
@@ -888,30 +906,30 @@ void analogix_dp_set_video_cr_mn(struct analogix_dp_device *dp,
 	u32 reg;
 
 	if (type == REGISTER_M) {
-		reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_4);
 		reg |= FIX_M_VID;
-		writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, reg);
 		reg = m_value & 0xff;
-		writel(reg, dp->reg_base + ANALOGIX_DP_M_VID_0);
+		analogix_dp_write(dp, ANALOGIX_DP_M_VID_0, reg);
 		reg = (m_value >> 8) & 0xff;
-		writel(reg, dp->reg_base + ANALOGIX_DP_M_VID_1);
+		analogix_dp_write(dp, ANALOGIX_DP_M_VID_1, reg);
 		reg = (m_value >> 16) & 0xff;
-		writel(reg, dp->reg_base + ANALOGIX_DP_M_VID_2);
+		analogix_dp_write(dp, ANALOGIX_DP_M_VID_2, reg);
 
 		reg = n_value & 0xff;
-		writel(reg, dp->reg_base + ANALOGIX_DP_N_VID_0);
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_0, reg);
 		reg = (n_value >> 8) & 0xff;
-		writel(reg, dp->reg_base + ANALOGIX_DP_N_VID_1);
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_1, reg);
 		reg = (n_value >> 16) & 0xff;
-		writel(reg, dp->reg_base + ANALOGIX_DP_N_VID_2);
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_2, reg);
 	} else  {
-		reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_4);
 		reg &= ~FIX_M_VID;
-		writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, reg);
 
-		writel(0x00, dp->reg_base + ANALOGIX_DP_N_VID_0);
-		writel(0x80, dp->reg_base + ANALOGIX_DP_N_VID_1);
-		writel(0x00, dp->reg_base + ANALOGIX_DP_N_VID_2);
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_0, 0x00);
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_1, 0x80);
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_2, 0x00);
 	}
 }
 
@@ -920,13 +938,13 @@ void analogix_dp_set_video_timing_mode(struct analogix_dp_device *dp, u32 type)
 	u32 reg;
 
 	if (type == VIDEO_TIMING_FROM_CAPTURE) {
-		reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
 		reg &= ~FORMAT_SEL;
-		writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+		analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
 	} else {
-		reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
 		reg |= FORMAT_SEL;
-		writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+		analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
 	}
 }
 
@@ -935,15 +953,15 @@ void analogix_dp_enable_video_master(struct analogix_dp_device *dp, bool enable)
 	u32 reg;
 
 	if (enable) {
-		reg = readl(dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SOC_GENERAL_CTL);
 		reg &= ~VIDEO_MODE_MASK;
 		reg |= VIDEO_MASTER_MODE_EN | VIDEO_MODE_MASTER_MODE;
-		writel(reg, dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);
+		analogix_dp_write(dp, ANALOGIX_DP_SOC_GENERAL_CTL, reg);
 	} else {
-		reg = readl(dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SOC_GENERAL_CTL);
 		reg &= ~VIDEO_MODE_MASK;
 		reg |= VIDEO_MODE_SLAVE_MODE;
-		writel(reg, dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);
+		analogix_dp_write(dp, ANALOGIX_DP_SOC_GENERAL_CTL, reg);
 	}
 }
 
@@ -951,19 +969,19 @@ void analogix_dp_start_video(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_1);
 	reg |= VIDEO_EN;
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_1, reg);
 }
 
 int analogix_dp_is_video_stream_on(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
-	writel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, reg);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
 	if (!(reg & STRM_VALID)) {
 		dev_dbg(dp->dev, "Input video stream is not detected.\n");
 		return -EINVAL;
@@ -976,55 +994,55 @@ void analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_1);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_1);
 	if (dp->plat_data && is_rockchip(dp->plat_data->dev_type)) {
 		reg &= ~(RK_VID_CAP_FUNC_EN_N | RK_VID_FIFO_FUNC_EN_N);
 	} else {
 		reg &= ~(MASTER_VID_FUNC_EN_N | SLAVE_VID_FUNC_EN_N);
 		reg |= MASTER_VID_FUNC_EN_N;
 	}
-	writel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_1);
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_1, reg);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
 	reg &= ~INTERACE_SCAN_CFG;
 	reg |= (dp->video_info.interlaced << 2);
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
 	reg &= ~VSYNC_POLARITY_CFG;
 	reg |= (dp->video_info.v_sync_polarity << 1);
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
 	reg &= ~HSYNC_POLARITY_CFG;
 	reg |= (dp->video_info.h_sync_polarity << 0);
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
 
 	reg = AUDIO_MODE_SPDIF_MODE | VIDEO_MODE_SLAVE_MODE;
-	writel(reg, dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_SOC_GENERAL_CTL, reg);
 }
 
 void analogix_dp_enable_scrambling(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_TRAINING_PTN_SET);
 	reg &= ~SCRAMBLING_DISABLE;
-	writel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+	analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
 }
 
 void analogix_dp_disable_scrambling(struct analogix_dp_device *dp)
 {
 	u32 reg;
 
-	reg = readl(dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_TRAINING_PTN_SET);
 	reg |= SCRAMBLING_DISABLE;
-	writel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);
+	analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
 }
 
 void analogix_dp_enable_psr_crc(struct analogix_dp_device *dp)
 {
-	writel(PSR_VID_CRC_ENABLE, dp->reg_base + ANALOGIX_DP_CRC_CON);
+	analogix_dp_write(dp, ANALOGIX_DP_CRC_CON, PSR_VID_CRC_ENABLE);
 }
 
 static ssize_t analogix_dp_get_psr_status(struct analogix_dp_device *dp)
@@ -1048,44 +1066,44 @@ int analogix_dp_send_psr_spd(struct analogix_dp_device *dp,
 	ssize_t psr_status;
 
 	/* don't send info frame */
-	val = readl(dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);
+	val = analogix_dp_read(dp, ANALOGIX_DP_PKT_SEND_CTL);
 	val &= ~IF_EN;
-	writel(val, dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_PKT_SEND_CTL, val);
 
 	/* configure single frame update mode */
-	writel(PSR_FRAME_UP_TYPE_BURST | PSR_CRC_SEL_HARDWARE,
-	       dp->reg_base + ANALOGIX_DP_PSR_FRAME_UPDATE_CTRL);
+	analogix_dp_write(dp, ANALOGIX_DP_PSR_FRAME_UPDATE_CTRL,
+			  PSR_FRAME_UP_TYPE_BURST | PSR_CRC_SEL_HARDWARE);
 
 	/* configure VSC HB0~HB3 */
-	writel(vsc->sdp_header.HB0, dp->reg_base + ANALOGIX_DP_SPD_HB0);
-	writel(vsc->sdp_header.HB1, dp->reg_base + ANALOGIX_DP_SPD_HB1);
-	writel(vsc->sdp_header.HB2, dp->reg_base + ANALOGIX_DP_SPD_HB2);
-	writel(vsc->sdp_header.HB3, dp->reg_base + ANALOGIX_DP_SPD_HB3);
+	analogix_dp_write(dp, ANALOGIX_DP_SPD_HB0, vsc->sdp_header.HB0);
+	analogix_dp_write(dp, ANALOGIX_DP_SPD_HB1, vsc->sdp_header.HB1);
+	analogix_dp_write(dp, ANALOGIX_DP_SPD_HB2, vsc->sdp_header.HB2);
+	analogix_dp_write(dp, ANALOGIX_DP_SPD_HB3, vsc->sdp_header.HB3);
 
 	/* configure reused VSC PB0~PB3, magic number from vendor */
-	writel(0x00, dp->reg_base + ANALOGIX_DP_SPD_PB0);
-	writel(0x16, dp->reg_base + ANALOGIX_DP_SPD_PB1);
-	writel(0xCE, dp->reg_base + ANALOGIX_DP_SPD_PB2);
-	writel(0x5D, dp->reg_base + ANALOGIX_DP_SPD_PB3);
+	analogix_dp_write(dp, ANALOGIX_DP_SPD_PB0, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_SPD_PB1, 0x16);
+	analogix_dp_write(dp, ANALOGIX_DP_SPD_PB2, 0xCE);
+	analogix_dp_write(dp, ANALOGIX_DP_SPD_PB3, 0x5D);
 
 	/* configure DB0 / DB1 values */
-	writel(vsc->DB0, dp->reg_base + ANALOGIX_DP_VSC_SHADOW_DB0);
-	writel(vsc->DB1, dp->reg_base + ANALOGIX_DP_VSC_SHADOW_DB1);
+	analogix_dp_write(dp, ANALOGIX_DP_VSC_SHADOW_DB0, vsc->DB0);
+	analogix_dp_write(dp, ANALOGIX_DP_VSC_SHADOW_DB1, vsc->DB1);
 
 	/* set reuse spd inforframe */
-	val = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_3);
+	val = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_3);
 	val |= REUSE_SPD_EN;
-	writel(val, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_3);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_3, val);
 
 	/* mark info frame update */
-	val = readl(dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);
+	val = analogix_dp_read(dp, ANALOGIX_DP_PKT_SEND_CTL);
 	val = (val | IF_UP) & ~IF_EN;
-	writel(val, dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_PKT_SEND_CTL, val);
 
 	/* send info frame */
-	val = readl(dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);
+	val = analogix_dp_read(dp, ANALOGIX_DP_PKT_SEND_CTL);
 	val |= IF_EN;
-	writel(val, dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_PKT_SEND_CTL, val);
 
 	if (!blocking)
 		return 0;
@@ -1118,7 +1136,7 @@ ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
 
 	/* Clear AUX CH data buffer */
 	reg = BUF_CLR;
-	writel(reg, dp->reg_base + ANALOGIX_DP_BUFFER_DATA_CTL);
+	analogix_dp_write(dp, ANALOGIX_DP_BUFFER_DATA_CTL, reg);
 
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_I2C_WRITE:
@@ -1146,21 +1164,21 @@ ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
 	}
 
 	reg |= AUX_LENGTH(msg->size);
-	writel(reg, dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_1);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1, reg);
 
 	/* Select DPCD device address */
 	reg = AUX_ADDR_7_0(msg->address);
-	writel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_7_0);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_7_0, reg);
 	reg = AUX_ADDR_15_8(msg->address);
-	writel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_15_8);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_15_8, reg);
 	reg = AUX_ADDR_19_16(msg->address);
-	writel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_19_16);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_19_16, reg);
 
 	if (!(msg->request & DP_AUX_I2C_READ)) {
 		for (i = 0; i < msg->size; i++) {
 			reg = buffer[i];
-			writel(reg, dp->reg_base + ANALOGIX_DP_BUF_DATA_0 +
-			       4 * i);
+			analogix_dp_write(dp, ANALOGIX_DP_BUF_DATA_0 + 4 * i,
+					  reg);
 			num_transferred++;
 		}
 	}
@@ -1172,7 +1190,7 @@ ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
 	if (msg->size < 1)
 		reg |= ADDR_ONLY;
 
-	writel(reg, dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_2);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_2, reg);
 
 	ret = readx_poll_timeout(readl, dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_2,
 				 reg, !(reg & AUX_EN), 25, 500 * 1000);
@@ -1191,13 +1209,13 @@ ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
 	}
 
 	/* Clear interrupt source for AUX CH command reply */
-	writel(RPLY_RECEIV, dp->reg_base + ANALOGIX_DP_INT_STA);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, RPLY_RECEIV);
 
 	/* Clear interrupt source for AUX CH access error */
-	reg = readl(dp->reg_base + ANALOGIX_DP_INT_STA);
-	status_reg = readl(dp->reg_base + ANALOGIX_DP_AUX_CH_STA);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA);
+	status_reg = analogix_dp_read(dp, ANALOGIX_DP_AUX_CH_STA);
 	if ((reg & AUX_ERR) || (status_reg & AUX_STATUS_MASK)) {
-		writel(AUX_ERR, dp->reg_base + ANALOGIX_DP_INT_STA);
+		analogix_dp_write(dp, ANALOGIX_DP_INT_STA, AUX_ERR);
 
 		dev_warn(dp->dev, "AUX CH error happened: %#x (%d)\n",
 			 status_reg & AUX_STATUS_MASK, !!(reg & AUX_ERR));
@@ -1206,15 +1224,15 @@ ssize_t analogix_dp_transfer(struct analogix_dp_device *dp,
 
 	if (msg->request & DP_AUX_I2C_READ) {
 		for (i = 0; i < msg->size; i++) {
-			reg = readl(dp->reg_base + ANALOGIX_DP_BUF_DATA_0 +
-				    4 * i);
+			reg = analogix_dp_read(dp, ANALOGIX_DP_BUF_DATA_0 +
+					       4 * i);
 			buffer[i] = (unsigned char)reg;
 			num_transferred++;
 		}
 	}
 
 	/* Check if Rx sends defer */
-	reg = readl(dp->reg_base + ANALOGIX_DP_AUX_RX_COMM);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_AUX_RX_COMM);
 	if (reg == AUX_RX_COMM_AUX_DEFER)
 		msg->reply = DP_AUX_NATIVE_REPLY_DEFER;
 	else if (reg == AUX_RX_COMM_I2C_DEFER)
@@ -1249,40 +1267,40 @@ void analogix_dp_set_video_format(struct analogix_dp_device *dp)
 	vbp = mode->vtotal - mode->vsync_end;
 
 	/* Set Video Format Parameters */
-	writel(TOTAL_LINE_CFG_L(mode->vtotal),
-	       dp->reg_base + ANALOGIX_DP_TOTAL_LINE_CFG_L);
-	writel(TOTAL_LINE_CFG_H(mode->vtotal >> 8),
-	       dp->reg_base + ANALOGIX_DP_TOTAL_LINE_CFG_H);
-	writel(ACTIVE_LINE_CFG_L(mode->vdisplay),
-	       dp->reg_base + ANALOGIX_DP_ACTIVE_LINE_CFG_L);
-	writel(ACTIVE_LINE_CFG_H(mode->vdisplay >> 8),
-	       dp->reg_base + ANALOGIX_DP_ACTIVE_LINE_CFG_H);
-	writel(V_F_PORCH_CFG(vfp),
-	       dp->reg_base + ANALOGIX_DP_V_F_PORCH_CFG);
-	writel(V_SYNC_WIDTH_CFG(vsw),
-	       dp->reg_base + ANALOGIX_DP_V_SYNC_WIDTH_CFG);
-	writel(V_B_PORCH_CFG(vbp),
-	       dp->reg_base + ANALOGIX_DP_V_B_PORCH_CFG);
-	writel(TOTAL_PIXEL_CFG_L(mode->htotal),
-	       dp->reg_base + ANALOGIX_DP_TOTAL_PIXEL_CFG_L);
-	writel(TOTAL_PIXEL_CFG_H(mode->htotal >> 8),
-	       dp->reg_base + ANALOGIX_DP_TOTAL_PIXEL_CFG_H);
-	writel(ACTIVE_PIXEL_CFG_L(mode->hdisplay),
-	       dp->reg_base + ANALOGIX_DP_ACTIVE_PIXEL_CFG_L);
-	writel(ACTIVE_PIXEL_CFG_H(mode->hdisplay >> 8),
-	       dp->reg_base + ANALOGIX_DP_ACTIVE_PIXEL_CFG_H);
-	writel(H_F_PORCH_CFG_L(hfp),
-	       dp->reg_base + ANALOGIX_DP_H_F_PORCH_CFG_L);
-	writel(H_F_PORCH_CFG_H(hfp >> 8),
-	       dp->reg_base + ANALOGIX_DP_H_F_PORCH_CFG_H);
-	writel(H_SYNC_CFG_L(hsw),
-	       dp->reg_base + ANALOGIX_DP_H_SYNC_CFG_L);
-	writel(H_SYNC_CFG_H(hsw >> 8),
-	       dp->reg_base + ANALOGIX_DP_H_SYNC_CFG_H);
-	writel(H_B_PORCH_CFG_L(hbp),
-	       dp->reg_base + ANALOGIX_DP_H_B_PORCH_CFG_L);
-	writel(H_B_PORCH_CFG_H(hbp >> 8),
-	       dp->reg_base + ANALOGIX_DP_H_B_PORCH_CFG_H);
+	analogix_dp_write(dp, ANALOGIX_DP_TOTAL_LINE_CFG_L,
+			  TOTAL_LINE_CFG_L(mode->vtotal));
+	analogix_dp_write(dp, ANALOGIX_DP_TOTAL_LINE_CFG_H,
+			  TOTAL_LINE_CFG_H(mode->vtotal >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_ACTIVE_LINE_CFG_L,
+			  ACTIVE_LINE_CFG_L(mode->vdisplay));
+	analogix_dp_write(dp, ANALOGIX_DP_ACTIVE_LINE_CFG_H,
+			  ACTIVE_LINE_CFG_H(mode->vdisplay >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_V_F_PORCH_CFG,
+			  V_F_PORCH_CFG(vfp));
+	analogix_dp_write(dp, ANALOGIX_DP_V_SYNC_WIDTH_CFG,
+			  V_SYNC_WIDTH_CFG(vsw));
+	analogix_dp_write(dp, ANALOGIX_DP_V_B_PORCH_CFG,
+			  V_B_PORCH_CFG(vbp));
+	analogix_dp_write(dp, ANALOGIX_DP_TOTAL_PIXEL_CFG_L,
+			  TOTAL_PIXEL_CFG_L(mode->htotal));
+	analogix_dp_write(dp, ANALOGIX_DP_TOTAL_PIXEL_CFG_H,
+			  TOTAL_PIXEL_CFG_H(mode->htotal >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_ACTIVE_PIXEL_CFG_L,
+			  ACTIVE_PIXEL_CFG_L(mode->hdisplay));
+	analogix_dp_write(dp, ANALOGIX_DP_ACTIVE_PIXEL_CFG_H,
+			  ACTIVE_PIXEL_CFG_H(mode->hdisplay >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_H_F_PORCH_CFG_L,
+			  H_F_PORCH_CFG_L(hfp));
+	analogix_dp_write(dp, ANALOGIX_DP_H_F_PORCH_CFG_H,
+			  H_F_PORCH_CFG_H(hfp >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_H_SYNC_CFG_L,
+			  H_SYNC_CFG_L(hsw));
+	analogix_dp_write(dp, ANALOGIX_DP_H_SYNC_CFG_H,
+			  H_SYNC_CFG_H(hsw >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_H_B_PORCH_CFG_L,
+			  H_B_PORCH_CFG_L(hbp));
+	analogix_dp_write(dp, ANALOGIX_DP_H_B_PORCH_CFG_H,
+			  H_B_PORCH_CFG_H(hbp >> 8));
 }
 
 void analogix_dp_video_bist_enable(struct analogix_dp_device *dp)
@@ -1290,13 +1308,13 @@ void analogix_dp_video_bist_enable(struct analogix_dp_device *dp)
 	u32 reg;
 
 	/* Enable Video BIST */
-	writel(BIST_EN, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_4);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_4, BIST_EN);
 
 	/*
 	 * Note that if BIST_EN is set to 1, F_SEL must be cleared to 0
 	 * although video format information comes from registers set by user.
 	 */
-	reg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
 	reg &= ~FORMAT_SEL;
-	writel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
 }
-- 
2.35.3

