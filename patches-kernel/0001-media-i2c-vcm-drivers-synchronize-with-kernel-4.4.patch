From b1a495135bf5169108935e41e12c4e4ac4e43e62 Mon Sep 17 00:00:00 2001
From: Wang Panzhenzhuan <randy.wang@rock-chips.com>
Date: Fri, 14 Feb 2020 15:58:30 +0800
Subject: [PATCH] media: i2c: vcm drivers synchronize with kernel 4.4

vcm drivers synchronize with kernel 4.4 & fix compile error

Signed-off-by: Wang Panzhenzhuan <randy.wang@rock-chips.com>
Change-Id: I7c3650867f0f3c867790dfe017bd89ac6067c2a4
---
 drivers/media/i2c/Kconfig  |  14 +
 drivers/media/i2c/Makefile |   2 +
 drivers/media/i2c/dw9714.c | 683 ++++++++++++++++++++++++++-----
 drivers/media/i2c/fp5510.c | 810 +++++++++++++++++++++++++++++++++++++
 drivers/media/i2c/vm149c.c | 140 ++++---
 5 files changed, 1485 insertions(+), 164 deletions(-)
 create mode 100644 drivers/media/i2c/fp5510.c

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 90d0d6908bd3..0f887023b477 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -358,6 +358,20 @@ config VIDEO_DW9807_VCM
 	  capability. This is designed for linear control of
 	  voice coil motors, controlled via I2C serial interface.
 
+config VIDEO_FP5510
+	tristate "FP5510 lens voice coil support"
+	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
+	depends on VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a driver for the FP5510 camera lens voice coil.
+
+config VIDEO_VM149C
+	tristate "VM149C lens voice coil support"
+	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
+	depends on VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a driver for the VM149C camera lens voice coil.
+
 config VIDEO_SAA7110
 	tristate "Philips SAA7110 video decoder"
 	depends on VIDEO_V4L2 && I2C
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 4440cb454971..a0bc89de6b39 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -26,6 +26,8 @@ obj-$(CONFIG_VIDEO_AD5820)  += ad5820.o
 obj-$(CONFIG_VIDEO_AK7375)  += ak7375.o
 obj-$(CONFIG_VIDEO_DW9714)  += dw9714.o
 obj-$(CONFIG_VIDEO_DW9807_VCM)  += dw9807-vcm.o
+obj-$(CONFIG_VIDEO_FP5510)	+= fp5510.o
+obj-$(CONFIG_VIDEO_VM149C)	+= vm149c.o
 obj-$(CONFIG_VIDEO_ADV7170) += adv7170.o
 obj-$(CONFIG_VIDEO_ADV7175) += adv7175.o
 obj-$(CONFIG_VIDEO_ADV7180) += adv7180.o
diff --git a/drivers/media/i2c/dw9714.c b/drivers/media/i2c/dw9714.c
index 3dc2100470a1..ec006bc518aa 100644
--- a/drivers/media/i2c/dw9714.c
+++ b/drivers/media/i2c/dw9714.c
@@ -1,40 +1,135 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (c) 2015--2017 Intel Corporation.
+/*
+ * dw9714 vcm driver
+ *
+ * Copyright (C) 2019 Fuzhou Rockchip Electronics Co., Ltd.
+ */
 
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
+#include <linux/rk-camera-module.h>
+#include <linux/version.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
+#include "rk_vcm_head.h"
 
-#define DW9714_NAME		"dw9714"
-#define DW9714_MAX_FOCUS_POS	1023
-/*
- * This sets the minimum granularity for the focus positions.
- * A value of 1 gives maximum accuracy for a desired focus position
- */
-#define DW9714_FOCUS_STEPS	1
-/*
- * This acts as the minimum granularity of lens movement.
- * Keep this value power of 2, so the control steps can be
- * uniformly adjusted for gradual lens movement, with desired
- * number of control steps.
- */
-#define DW9714_CTRL_STEPS	16
-#define DW9714_CTRL_DELAY_US	1000
-/*
- * S[3:2] = 0x00, codes per step for "Linear Slope Control"
- * S[1:0] = 0x00, step period
- */
-#define DW9714_DEFAULT_S 0x0
-#define DW9714_VAL(data, s) ((data) << 4 | (s))
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x0)
+#define DW9714_NAME			"dw9714"
+
+#define DW9714_MAX_CURRENT		100U
+#define DW9714_MAX_REG			1023U
+
+#define DW9714_DEFAULT_START_CURRENT	0
+#define DW9714_DEFAULT_RATED_CURRENT	100
+#define DW9714_DEFAULT_STEP_MODE	0xd
+#define REG_NULL			0xFF
 
 /* dw9714 device structure */
 struct dw9714_device {
 	struct v4l2_ctrl_handler ctrls_vcm;
 	struct v4l2_subdev sd;
+	struct v4l2_device vdev;
 	u16 current_val;
+
+	unsigned short current_related_pos;
+	unsigned short current_lens_pos;
+	unsigned int start_current;
+	unsigned int rated_current;
+	unsigned int step;
+	unsigned int step_mode;
+	unsigned int vcm_movefull_t;
+	unsigned int dlc_enable;
+	unsigned int t_src;
+	unsigned int mclk;
+
+	struct timeval start_move_tv;
+	struct timeval end_move_tv;
+	unsigned long move_ms;
+
+	u32 module_index;
+	const char *module_facing;
+};
+
+struct TimeTabel_s {
+	unsigned int t_src;/* time of slew rate control */
+	unsigned int step00;/* S[1:0] /MCLK[1:0] step period */
+	unsigned int step01;
+	unsigned int step10;
+	unsigned int step11;
+};
+
+static const struct TimeTabel_s dw9714_lsc_time_table[] = {
+	{0b10000, 136, 272, 544, 1088},
+	{0b10001, 130, 260, 520, 1040},
+	{0b10010, 125, 250, 500, 1000},
+	{0b10011, 120, 240, 480, 960 },
+	{0b10100, 116, 232, 464, 928 },
+	{0b10101, 112, 224, 448, 896 },
+	{0b10110, 108, 216, 432, 864 },
+	{0b10111, 104, 208, 416, 832 },
+	{0b11000, 101, 202, 404, 808 },
+	{0b11001,  98, 196, 392, 784 },
+	{0b11010,  95, 190, 380, 760 },
+	{0b11011,  92, 184, 368, 736 },
+	{0b11100,  89, 178, 356, 712 },
+	{0b11101,  87, 174, 348, 696 },
+	{0b11110,  85, 170, 340, 680 },
+	{0b11111,  83, 166, 332, 664 },
+	{0b00000,  81, 162, 324, 648 },
+	{0b00001,  79, 158, 316, 632 },
+	{0b00010,  77, 155, 310, 620 },
+	{0b00011,  76, 152, 304, 608 },
+	{0b00100,  74, 149, 298, 596 },
+	{0b00101,  73, 146, 292, 584 },
+	{0b00110,  71, 143, 286, 572 },
+	{0b00111,  70, 140, 280, 560 },
+	{0b01000,  69, 138, 276, 552 },
+	{0b01001,  68, 136, 272, 544 },
+	{0b01010,  67, 134, 268, 536 },
+	{0b01011,  66, 132, 264, 528 },
+	{0b01100,  65, 131, 262, 524 },
+	{0b01101,  65, 130, 260, 520 },
+	{0b01110,  64, 129, 258, 516 },
+	{0b01111,  64, 128, 256, 512 },
+	{REG_NULL,  0, 0, 0, 0},
+};
+
+static const struct TimeTabel_s dw9714_dlc_time_table[] = {/* us */
+	{0b10000, 21250, 10630, 5310, 2660},
+	{0b10001, 20310, 10160, 5080, 2540},
+	{0b10010, 19530,  9770, 4880, 2440},
+	{0b10011, 18750,  9380, 4690, 2340},
+	{0b10100, 18130,  9060, 4530, 2270},
+	{0b10101, 17500,  8750, 4380, 2190},
+	{0b10110, 16880,  8440, 4220, 2110},
+	{0b10111, 16250,  8130, 4060, 2030},
+	{0b11000, 15780,  7890, 3950, 1970},
+	{0b11001, 15310,  7660, 3830, 1910},
+	{0b11010, 14840,  7420, 3710, 1860},
+	{0b11011, 14380,  7190, 3590, 1800},
+	{0b11100, 13910,  6950, 3480, 1740},
+	{0b11101, 13590,  6800, 3400, 1700},
+	{0b11110, 13280,  6640, 3320, 1660},
+	{0b11111, 12970,  6480, 3240, 1620},
+	{0b00000, 12660,  6330, 3160, 1580},
+	{0b00001, 12340,  6170, 3090, 1540},
+	{0b00010, 12110,  6050, 3030, 1510},
+	{0b00011, 11880,  5940, 2970, 1480},
+	{0b00100, 11640,  5820, 2910, 1460},
+	{0b00101, 11410,  5700, 2850, 1430},
+	{0b00110, 11170,  5590, 2790, 1400},
+	{0b00111, 10940,  5470, 2730, 1370},
+	{0b01000, 10780,  5390, 2700, 1350},
+	{0b01001, 10630,  5310, 2660, 1330},
+	{0b01010, 10470,  5230, 2620, 1310},
+	{0b01011, 10310,  5160, 2580, 1290},
+	{0b01100, 10230,  5120, 2560, 1280},
+	{0b01101, 10160,  5080, 2540, 1270},
+	{0b01110, 10080,  5040, 2520, 1260},
+	{0b01111, 10000,  5000, 2500, 1250},
+	{REG_NULL, 0, 0, 0, 0},
 };
 
 static inline struct dw9714_device *to_dw9714_vcm(struct v4l2_ctrl *ctrl)
@@ -47,39 +142,289 @@ static inline struct dw9714_device *sd_to_dw9714_vcm(struct v4l2_subdev *subdev)
 	return container_of(subdev, struct dw9714_device, sd);
 }
 
-static int dw9714_i2c_write(struct i2c_client *client, u16 data)
+static int dw9714_read_msg(struct i2c_client *client,
+	unsigned char *msb, unsigned char *lsb)
 {
-	int ret;
-	__be16 val = cpu_to_be16(data);
+	int ret = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	int retries;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "client->adapter NULL\n");
+		return -ENODEV;
+	}
 
-	ret = i2c_master_send(client, (const char *)&val, sizeof(val));
-	if (ret != sizeof(val)) {
-		dev_err(&client->dev, "I2C write fail\n");
-		return -EIO;
+	for (retries = 0; retries < 5; retries++) {
+		msg->addr = client->addr;
+		msg->flags = I2C_M_RD;
+		msg->len = 2;
+		msg->buf = data;
+
+		ret = i2c_transfer(client->adapter, msg, 1);
+		if (ret == 1) {
+			dev_dbg(&client->dev,
+				"%s: vcm i2c ok, addr 0x%x, data 0x%x, 0x%x\n",
+				__func__, msg->addr, data[0], data[1]);
+
+			*msb = data[0];
+			*lsb = data[1];
+			return 0;
+		}
+
+		dev_info(&client->dev,
+			"retrying I2C... %d\n", retries);
+		retries++;
+		msleep(20);
 	}
-	return 0;
+	dev_err(&client->dev,
+		"%s: i2c write to failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+static int dw9714_write_msg(struct i2c_client *client,
+	u8 msb, u8 lsb)
+{
+	int ret = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	int retries;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "client->adapter NULL\n");
+		return -ENODEV;
+	}
+
+	for (retries = 0; retries < 5; retries++) {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+
+		data[0] = msb;
+		data[1] = lsb;
+
+		ret = i2c_transfer(client->adapter, msg, 1);
+		usleep_range(50, 100);
+
+		if (ret == 1) {
+			dev_dbg(&client->dev,
+				"%s: vcm i2c ok, addr 0x%x, data 0x%x, 0x%x\n",
+				__func__, msg->addr, data[0], data[1]);
+			return 0;
+		}
+
+		dev_info(&client->dev,
+			"retrying I2C... %d\n", retries);
+		retries++;
+		msleep(20);
+	}
+	dev_err(&client->dev,
+		"i2c write to failed with error %d\n", ret);
+	return ret;
 }
 
-static int dw9714_t_focus_vcm(struct dw9714_device *dw9714_dev, u16 val)
+static unsigned int dw9714_move_time(struct dw9714_device *dev_vcm,
+	unsigned int move_pos)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dw9714_dev->sd);
+	unsigned int move_time_ms = 200;
+	unsigned int step_period_lsc = 0;
+	unsigned int step_period_dlc = 0;
+	unsigned int step_period = 0;
+	int i = 0;
+	int table_cnt = 0;
+	unsigned int step_case;
+	unsigned int codes_per_step = 1;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+
+	if (dev_vcm->dlc_enable) {
+		step_case = dev_vcm->mclk & 0x3;
+		table_cnt = sizeof(dw9714_dlc_time_table) /
+					sizeof(struct TimeTabel_s);
+		for (i = 0; i < table_cnt; i++) {
+			if (dw9714_dlc_time_table[i].t_src == dev_vcm->t_src)
+				break;
+		}
+	} else {
+		step_case = dev_vcm->step_mode & 0x3;
+		table_cnt = sizeof(dw9714_lsc_time_table) /
+					sizeof(struct TimeTabel_s);
+		for (i = 0; i < table_cnt; i++) {
+			if (dw9714_lsc_time_table[i].t_src == dev_vcm->t_src)
+				break;
+		}
+	}
 
-	dw9714_dev->current_val = val;
+	if (i >= table_cnt)
+		i = 0;
+
+	switch (step_case) {
+	case 0:
+		step_period_lsc = dw9714_lsc_time_table[i].step00;
+		step_period_dlc = dw9714_dlc_time_table[i].step00;
+		break;
+	case 1:
+		step_period_lsc = dw9714_lsc_time_table[i].step01;
+		step_period_dlc = dw9714_dlc_time_table[i].step01;
+		break;
+	case 2:
+		step_period_lsc = dw9714_lsc_time_table[i].step10;
+		step_period_dlc = dw9714_dlc_time_table[i].step10;
+		break;
+	case 3:
+		step_period_lsc = dw9714_lsc_time_table[i].step11;
+		step_period_dlc = dw9714_dlc_time_table[i].step11;
+		break;
+	default:
+		dev_err(&client->dev,
+			"%s: step_case is error %d\n",
+			__func__, step_case);
+		break;
+	}
+	codes_per_step = (dev_vcm->step_mode & 0x0c) >> 2;
+	if (codes_per_step > 1)
+		codes_per_step = 1 << (codes_per_step - 1);
 
-	return dw9714_i2c_write(client, DW9714_VAL(val, DW9714_DEFAULT_S));
+	if (dev_vcm->dlc_enable)
+		step_period = step_period_dlc;
+	else
+		step_period = step_period_lsc;
+
+	if (!codes_per_step)
+		move_time_ms = step_period * move_pos / 1000;
+	else
+		move_time_ms = step_period * move_pos / codes_per_step / 1000;
+
+	return move_time_ms;
 }
 
-static int dw9714_set_ctrl(struct v4l2_ctrl *ctrl)
+static int dw9714_get_pos(struct dw9714_device *dev_vcm,
+	unsigned int *cur_pos)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+	int ret;
+	unsigned char lsb = 0;
+	unsigned char msb = 0;
+	unsigned int abs_step;
+
+	ret = dw9714_read_msg(client, &msb, &lsb);
+	if (ret != 0)
+		goto err;
+
+	abs_step = (((unsigned int)(msb & 0x3FU)) << 4U) |
+		   (((unsigned int)lsb) >> 4U);
+	if (abs_step <= dev_vcm->start_current)
+		abs_step = VCMDRV_MAX_LOG;
+	else if ((abs_step > dev_vcm->start_current) &&
+		 (abs_step <= dev_vcm->rated_current))
+		abs_step = (dev_vcm->rated_current - abs_step) / dev_vcm->step;
+	else
+		abs_step = 0;
+
+	*cur_pos = abs_step;
+	dev_dbg(&client->dev, "%s: get position %d\n", __func__, *cur_pos);
+	return 0;
+
+err:
+	dev_err(&client->dev,
+		"%s: failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+static int dw9714_set_pos(struct dw9714_device *dev_vcm,
+	unsigned int dest_pos)
+{
+	int ret;
+	unsigned char lsb = 0;
+	unsigned char msb = 0;
+	unsigned int position = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+
+	if (dest_pos >= VCMDRV_MAX_LOG)
+		position = dev_vcm->start_current;
+	else
+		position = dev_vcm->start_current +
+			   (dev_vcm->step * (VCMDRV_MAX_LOG - dest_pos));
+
+	if (position > DW9714_MAX_REG)
+		position = DW9714_MAX_REG;
+
+	dev_vcm->current_lens_pos = position;
+	dev_vcm->current_related_pos = dest_pos;
+	msb = (0x00U | ((dev_vcm->current_lens_pos & 0x3F0U) >> 4U));
+	lsb = (((dev_vcm->current_lens_pos & 0x0FU) << 4U) |
+		dev_vcm->step_mode);
+	ret = dw9714_write_msg(client, msb, lsb);
+	if (ret != 0)
+		goto err;
+
+	return ret;
+err:
+	dev_err(&client->dev,
+		"%s: failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+static int dw9714_get_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct dw9714_device *dev_vcm = to_dw9714_vcm(ctrl);
 
 	if (ctrl->id == V4L2_CID_FOCUS_ABSOLUTE)
-		return dw9714_t_focus_vcm(dev_vcm, ctrl->val);
+		return dw9714_get_pos(dev_vcm, &ctrl->val);
 
 	return -EINVAL;
 }
 
+static int dw9714_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dw9714_device *dev_vcm = to_dw9714_vcm(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+	unsigned int dest_pos = ctrl->val;
+	int move_pos;
+	long mv_us;
+	int ret = 0;
+
+	if (ctrl->id == V4L2_CID_FOCUS_ABSOLUTE) {
+		if (dest_pos > VCMDRV_MAX_LOG) {
+			dev_info(&client->dev,
+				"%s dest_pos is error. %d > %d\n",
+				__func__, dest_pos, VCMDRV_MAX_LOG);
+			return -EINVAL;
+		}
+		/* calculate move time */
+		move_pos = dev_vcm->current_related_pos - dest_pos;
+		if (move_pos < 0)
+			move_pos = -move_pos;
+
+		ret = dw9714_set_pos(dev_vcm, dest_pos);
+
+		dev_vcm->move_ms =
+			((dev_vcm->vcm_movefull_t *
+			(uint32_t)move_pos) /
+			VCMDRV_MAX_LOG);
+		dev_dbg(&client->dev,
+			"dest_pos %d, move_ms %ld\n",
+			dest_pos, dev_vcm->move_ms);
+
+		dev_vcm->start_move_tv = ns_to_timeval(ktime_get_ns());
+		mv_us = dev_vcm->start_move_tv.tv_usec +
+				dev_vcm->move_ms * 1000;
+		if (mv_us >= 1000000) {
+			dev_vcm->end_move_tv.tv_sec =
+				dev_vcm->start_move_tv.tv_sec + 1;
+			dev_vcm->end_move_tv.tv_usec = mv_us - 1000000;
+		} else {
+			dev_vcm->end_move_tv.tv_sec =
+					dev_vcm->start_move_tv.tv_sec;
+			dev_vcm->end_move_tv.tv_usec = mv_us;
+		}
+	}
+
+	return ret;
+}
+
 static const struct v4l2_ctrl_ops dw9714_vcm_ctrl_ops = {
+	.g_volatile_ctrl = dw9714_get_ctrl,
 	.s_ctrl = dw9714_set_ctrl,
 };
 
@@ -108,11 +453,87 @@ static const struct v4l2_subdev_internal_ops dw9714_int_ops = {
 	.close = dw9714_close,
 };
 
-static const struct v4l2_subdev_ops dw9714_ops = { };
+static long dw9714_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret = 0;
+	struct rk_cam_vcm_tim *vcm_tim;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dw9714_device *dw9714_dev = sd_to_dw9714_vcm(sd);
+
+	if (cmd == RK_VIDIOC_VCM_TIMEINFO) {
+		vcm_tim = (struct rk_cam_vcm_tim *)arg;
+
+		vcm_tim->vcm_start_t.tv_sec = dw9714_dev->start_move_tv.tv_sec;
+		vcm_tim->vcm_start_t.tv_usec =
+				dw9714_dev->start_move_tv.tv_usec;
+		vcm_tim->vcm_end_t.tv_sec = dw9714_dev->end_move_tv.tv_sec;
+		vcm_tim->vcm_end_t.tv_usec = dw9714_dev->end_move_tv.tv_usec;
+
+		dev_dbg(&client->dev, "dw9714_get_move_res 0x%lx, 0x%lx, 0x%lx, 0x%lx\n",
+			vcm_tim->vcm_start_t.tv_sec,
+			vcm_tim->vcm_start_t.tv_usec,
+			vcm_tim->vcm_end_t.tv_sec,
+			vcm_tim->vcm_end_t.tv_usec);
+	} else {
+		dev_err(&client->dev,
+			"cmd 0x%x not supported\n", cmd);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long dw9714_compat_ioctl32(struct v4l2_subdev *sd,
+	unsigned int cmd, unsigned long arg)
+{
+	struct rk_cam_vcm_tim vcm_tim;
+	struct rk_cam_compat_vcm_tim compat_vcm_tim;
+	struct rk_cam_compat_vcm_tim __user *p32 = compat_ptr(arg);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	long ret;
+
+	if (cmd == RK_VIDIOC_COMPAT_VCM_TIMEINFO) {
+		ret = dw9714_ioctl(sd, RK_VIDIOC_VCM_TIMEINFO, &vcm_tim);
+		compat_vcm_tim.vcm_start_t.tv_sec = vcm_tim.vcm_start_t.tv_sec;
+		compat_vcm_tim.vcm_start_t.tv_usec =
+				vcm_tim.vcm_start_t.tv_usec;
+		compat_vcm_tim.vcm_end_t.tv_sec = vcm_tim.vcm_end_t.tv_sec;
+		compat_vcm_tim.vcm_end_t.tv_usec = vcm_tim.vcm_end_t.tv_usec;
+
+		put_user(compat_vcm_tim.vcm_start_t.tv_sec,
+			&p32->vcm_start_t.tv_sec);
+		put_user(compat_vcm_tim.vcm_start_t.tv_usec,
+			&p32->vcm_start_t.tv_usec);
+		put_user(compat_vcm_tim.vcm_end_t.tv_sec,
+			&p32->vcm_end_t.tv_sec);
+		put_user(compat_vcm_tim.vcm_end_t.tv_usec,
+			&p32->vcm_end_t.tv_usec);
+	} else {
+		dev_err(&client->dev,
+			"cmd 0x%x not supported\n", cmd);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+#endif
+
+static const struct v4l2_subdev_core_ops dw9714_core_ops = {
+	.ioctl = dw9714_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = dw9714_compat_ioctl32
+#endif
+};
+
+static const struct v4l2_subdev_ops dw9714_ops = {
+	.core = &dw9714_core_ops,
+};
 
 static void dw9714_subdev_cleanup(struct dw9714_device *dw9714_dev)
 {
-	v4l2_async_unregister_subdev(&dw9714_dev->sd);
+	v4l2_device_unregister_subdev(&dw9714_dev->sd);
+	v4l2_device_unregister(&dw9714_dev->vdev);
 	v4l2_ctrl_handler_free(&dw9714_dev->ctrls_vcm);
 	media_entity_cleanup(&dw9714_dev->sd.entity);
 }
@@ -125,7 +546,7 @@ static int dw9714_init_controls(struct dw9714_device *dev_vcm)
 	v4l2_ctrl_handler_init(hdl, 1);
 
 	v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FOCUS_ABSOLUTE,
-			  0, DW9714_MAX_FOCUS_POS, DW9714_FOCUS_STEPS, 0);
+			  0, VCMDRV_MAX_LOG, 1, VCMDRV_MAX_LOG);
 
 	if (hdl->error)
 		dev_err(dev_vcm->sd.dev, "%s fail error: 0x%x\n",
@@ -134,45 +555,146 @@ static int dw9714_init_controls(struct dw9714_device *dev_vcm)
 	return hdl->error;
 }
 
-static int dw9714_probe(struct i2c_client *client)
+static int dw9714_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
 {
+	struct device_node *np = of_node_get(client->dev.of_node);
 	struct dw9714_device *dw9714_dev;
-	int rval;
+	int ret;
+	int current_distance;
+	unsigned int start_current;
+	unsigned int rated_current;
+	unsigned int step_mode;
+	struct v4l2_subdev *sd;
+	char facing[2];
+	unsigned char data = 0x0;
+
+	dev_info(&client->dev, "probing...\n");
+	if (of_property_read_u32(np,
+		OF_CAMERA_VCMDRV_START_CURRENT,
+		(unsigned int *)&start_current)) {
+		start_current = DW9714_DEFAULT_START_CURRENT;
+		dev_info(&client->dev,
+			"could not get module %s from dts!\n",
+			OF_CAMERA_VCMDRV_START_CURRENT);
+	}
+	if (of_property_read_u32(np,
+		OF_CAMERA_VCMDRV_RATED_CURRENT,
+		(unsigned int *)&rated_current)) {
+		rated_current = DW9714_DEFAULT_RATED_CURRENT;
+		dev_info(&client->dev,
+			"could not get module %s from dts!\n",
+			OF_CAMERA_VCMDRV_RATED_CURRENT);
+	}
+	if (of_property_read_u32(np,
+		OF_CAMERA_VCMDRV_STEP_MODE,
+		(unsigned int *)&step_mode)) {
+		step_mode = DW9714_DEFAULT_STEP_MODE;
+		dev_info(&client->dev,
+			"could not get module %s from dts!\n",
+			OF_CAMERA_VCMDRV_STEP_MODE);
+	}
 
 	dw9714_dev = devm_kzalloc(&client->dev, sizeof(*dw9714_dev),
 				  GFP_KERNEL);
 	if (dw9714_dev == NULL)
 		return -ENOMEM;
 
+	ret = of_property_read_u32(np, RKMODULE_CAMERA_MODULE_INDEX,
+				   &dw9714_dev->module_index);
+	ret |= of_property_read_string(np, RKMODULE_CAMERA_MODULE_FACING,
+				       &dw9714_dev->module_facing);
+	if (ret) {
+		dev_err(&client->dev,
+			"could not get module information!\n");
+		return -EINVAL;
+	}
+
 	v4l2_i2c_subdev_init(&dw9714_dev->sd, client, &dw9714_ops);
 	dw9714_dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	dw9714_dev->sd.internal_ops = &dw9714_int_ops;
 
-	rval = dw9714_init_controls(dw9714_dev);
-	if (rval)
+	ret = dw9714_init_controls(dw9714_dev);
+	if (ret)
 		goto err_cleanup;
 
-	rval = media_entity_pads_init(&dw9714_dev->sd.entity, 0, NULL);
-	if (rval < 0)
-		goto err_cleanup;
-
-	dw9714_dev->sd.entity.function = MEDIA_ENT_F_LENS;
-
-	rval = v4l2_async_register_subdev(&dw9714_dev->sd);
-	if (rval < 0)
+	ret = media_entity_pads_init(&dw9714_dev->sd.entity, 0, NULL);
+	if (ret < 0)
 		goto err_cleanup;
 
+	sd = &dw9714_dev->sd;
+	sd->entity.function = MEDIA_ENT_F_LENS;
+
+	memset(facing, 0, sizeof(facing));
+	if (strcmp(dw9714_dev->module_facing, "back") == 0)
+		facing[0] = 'b';
+	else
+		facing[0] = 'f';
+
+	snprintf(sd->name, sizeof(sd->name), "m%02d_%s_%s %s",
+		 dw9714_dev->module_index, facing,
+		 DW9714_NAME, dev_name(sd->dev));
+	ret = v4l2_async_register_subdev(sd);
+	if (ret)
+		dev_err(&client->dev, "v4l2 async register subdev failed\n");
+
+	current_distance = rated_current - start_current;
+	current_distance = current_distance * DW9714_MAX_REG /
+						DW9714_MAX_CURRENT;
+	dw9714_dev->step = (current_distance + (VCMDRV_MAX_LOG - 1)) /
+						VCMDRV_MAX_LOG;
+	dw9714_dev->start_current = start_current * DW9714_MAX_REG /
+						DW9714_MAX_CURRENT;
+	dw9714_dev->rated_current = dw9714_dev->start_current +
+						VCMDRV_MAX_LOG *
+						dw9714_dev->step;
+	dw9714_dev->step_mode     = step_mode;
+	dw9714_dev->move_ms       = 0;
+	dw9714_dev->current_related_pos = VCMDRV_MAX_LOG;
+	dw9714_dev->start_move_tv = ns_to_timeval(ktime_get_ns());
+	dw9714_dev->end_move_tv = ns_to_timeval(ktime_get_ns());
+
+	dw9714_dev->dlc_enable = 0;
+	dw9714_dev->mclk = 0;
+	dw9714_dev->t_src = 0x0;
+
+	ret = dw9714_write_msg(client, 0xEC, 0xA3);
+	if (ret != 0)
+		dev_err(&client->dev,
+			"%s: failed with error %d\n", __func__, ret);
+
+	data = (dw9714_dev->mclk & 0x3) | 0x04 |
+			((dw9714_dev->dlc_enable << 0x3) & 0x08);
+	ret = dw9714_write_msg(client, 0xA1, data);
+	if (ret != 0)
+		dev_err(&client->dev,
+			"%s: failed with error %d\n", __func__, ret);
+
+	data = (dw9714_dev->t_src << 0x5) & 0xf8;
+	ret = dw9714_write_msg(client, 0xF2, data);
+	if (ret != 0)
+		dev_err(&client->dev,
+			"%s: failed with error %d\n", __func__, ret);
+
+	ret = dw9714_write_msg(client, 0xDC, 0x51);
+	if (ret != 0)
+		dev_err(&client->dev,
+			"%s: failed with error %d\n", __func__, ret);
+
+	dw9714_dev->vcm_movefull_t =
+		dw9714_move_time(dw9714_dev, DW9714_MAX_REG);
 	pm_runtime_set_active(&client->dev);
 	pm_runtime_enable(&client->dev);
 	pm_runtime_idle(&client->dev);
 
+	dev_info(&client->dev, "probing successful\n");
+
 	return 0;
 
 err_cleanup:
-	v4l2_ctrl_handler_free(&dw9714_dev->ctrls_vcm);
-	media_entity_cleanup(&dw9714_dev->sd.entity);
-	dev_err(&client->dev, "Probe failed: %d\n", rval);
-	return rval;
+	dw9714_subdev_cleanup(dw9714_dev);
+	dev_err(&client->dev, "Probe failed: %d\n", ret);
+	return ret;
 }
 
 static int dw9714_remove(struct i2c_client *client)
@@ -186,53 +708,13 @@ static int dw9714_remove(struct i2c_client *client)
 	return 0;
 }
 
-/*
- * This function sets the vcm position, so it consumes least current
- * The lens position is gradually moved in units of DW9714_CTRL_STEPS,
- * to make the movements smoothly.
- */
 static int __maybe_unused dw9714_vcm_suspend(struct device *dev)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct dw9714_device *dw9714_dev = sd_to_dw9714_vcm(sd);
-	int ret, val;
-
-	for (val = dw9714_dev->current_val & ~(DW9714_CTRL_STEPS - 1);
-	     val >= 0; val -= DW9714_CTRL_STEPS) {
-		ret = dw9714_i2c_write(client,
-				       DW9714_VAL(val, DW9714_DEFAULT_S));
-		if (ret)
-			dev_err_once(dev, "%s I2C failure: %d", __func__, ret);
-		usleep_range(DW9714_CTRL_DELAY_US, DW9714_CTRL_DELAY_US + 10);
-	}
 	return 0;
 }
 
-/*
- * This function sets the vcm position to the value set by the user
- * through v4l2_ctrl_ops s_ctrl handler
- * The lens position is gradually moved in units of DW9714_CTRL_STEPS,
- * to make the movements smoothly.
- */
-static int  __maybe_unused dw9714_vcm_resume(struct device *dev)
+static int __maybe_unused dw9714_vcm_resume(struct device *dev)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct dw9714_device *dw9714_dev = sd_to_dw9714_vcm(sd);
-	int ret, val;
-
-	for (val = dw9714_dev->current_val % DW9714_CTRL_STEPS;
-	     val < dw9714_dev->current_val + DW9714_CTRL_STEPS - 1;
-	     val += DW9714_CTRL_STEPS) {
-		ret = dw9714_i2c_write(client,
-				       DW9714_VAL(val, DW9714_DEFAULT_S));
-		if (ret)
-			dev_err_ratelimited(dev, "%s I2C failure: %d",
-						__func__, ret);
-		usleep_range(DW9714_CTRL_DELAY_US, DW9714_CTRL_DELAY_US + 10);
-	}
-
 	return 0;
 }
 
@@ -259,17 +741,12 @@ static struct i2c_driver dw9714_i2c_driver = {
 		.pm = &dw9714_pm_ops,
 		.of_match_table = dw9714_of_table,
 	},
-	.probe_new = dw9714_probe,
-	.remove = dw9714_remove,
+	.probe = &dw9714_probe,
+	.remove = &dw9714_remove,
 	.id_table = dw9714_id_table,
 };
 
 module_i2c_driver(dw9714_i2c_driver);
 
-MODULE_AUTHOR("Tianshu Qiu <tian.shu.qiu@intel.com>");
-MODULE_AUTHOR("Jian Xu Zheng <jian.xu.zheng@intel.com>");
-MODULE_AUTHOR("Yuning Pu <yuning.pu@intel.com>");
-MODULE_AUTHOR("Jouni Ukkonen <jouni.ukkonen@intel.com>");
-MODULE_AUTHOR("Tommi Franttila <tommi.franttila@intel.com>");
 MODULE_DESCRIPTION("DW9714 VCM driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/fp5510.c b/drivers/media/i2c/fp5510.c
new file mode 100644
index 000000000000..e4172e046518
--- /dev/null
+++ b/drivers/media/i2c/fp5510.c
@@ -0,0 +1,810 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * fp5510 vcm driver
+ *
+ * Copyright (C) 2019 Fuzhou Rockchip Electronics Co., Ltd.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/rk-camera-module.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include "rk_vcm_head.h"
+#include <linux/gpio/consumer.h>
+
+#define DRIVER_VERSION	KERNEL_VERSION(0, 0x01, 0x0)
+#define FP5510_NAME			"fp5510"
+
+#define FP5510_MAX_CURRENT		100U
+#define FP5510_MAX_REG			1023U
+
+#define FP5510_DEFAULT_START_CURRENT	0
+#define FP5510_DEFAULT_RATED_CURRENT	100
+#define FP5510_DEFAULT_STEP_MODE	0xd
+#define REG_NULL			0xFF
+#define ENABLE				0x1
+#define DISABLE				0x0
+/* fp5510 device structure */
+struct fp5510_device {
+	struct v4l2_ctrl_handler ctrls_vcm;
+	struct v4l2_subdev sd;
+	struct v4l2_device vdev;
+	u16 current_val;
+	struct gpio_desc *pwdn_gpio;
+
+	unsigned short current_related_pos;
+	unsigned short current_lens_pos;
+	unsigned int start_current;
+	unsigned int rated_current;
+	unsigned int step;
+	unsigned int step_mode;
+	unsigned int vcm_movefull_t;
+	unsigned int esc_enable;
+	unsigned int tsc_enable;
+	unsigned int t_src;
+	unsigned int mclk;
+
+	struct timeval start_move_tv;
+	struct timeval end_move_tv;
+	unsigned long move_ms;
+
+	u32 module_index;
+	const char *module_facing;
+};
+
+struct TimeTabel_s {
+	unsigned int t_src;/* time of slew rate control */
+	unsigned int step00;/* S[1:0] /MCLK[1:0] step period */
+	unsigned int step01;
+	unsigned int step10;
+	unsigned int step11;
+};
+
+static const struct TimeTabel_s fp5510_lsc_time_table[] = {
+	{0b10000, 136, 272, 544, 1088},
+	{0b10001, 130, 260, 520, 1040},
+	{0b10010, 125, 250, 500, 1000},
+	{0b10011, 120, 240, 480, 960 },
+	{0b10100, 116, 232, 464, 928 },
+	{0b10101, 112, 224, 448, 896 },
+	{0b10110, 108, 216, 432, 864 },
+	{0b10111, 104, 208, 416, 832 },
+	{0b11000, 101, 202, 404, 808 },
+	{0b11001,  98, 196, 392, 784 },
+	{0b11010,  95, 190, 380, 760 },
+	{0b11011,  92, 184, 368, 736 },
+	{0b11100,  89, 178, 356, 712 },
+	{0b11101,  87, 174, 348, 696 },
+	{0b11110,  85, 170, 340, 680 },
+	{0b11111,  83, 166, 332, 664 },
+	{0b00000,  81, 162, 324, 648 },
+	{0b00001,  79, 158, 316, 632 },
+	{0b00010,  77, 155, 310, 620 },
+	{0b00011,  76, 152, 304, 608 },
+	{0b00100,  74, 149, 298, 596 },
+	{0b00101,  73, 146, 292, 584 },
+	{0b00110,  71, 143, 286, 572 },
+	{0b00111,  70, 140, 280, 560 },
+	{0b01000,  69, 138, 276, 552 },
+	{0b01001,  68, 136, 272, 544 },
+	{0b01010,  67, 134, 268, 536 },
+	{0b01011,  66, 132, 264, 528 },
+	{0b01100,  65, 131, 262, 524 },
+	{0b01101,  65, 130, 260, 520 },
+	{0b01110,  64, 129, 258, 516 },
+	{0b01111,  64, 128, 256, 512 },
+	{REG_NULL,  0, 0, 0, 0},
+};
+
+static const struct TimeTabel_s fp5510_dlc_time_table[] = {/* us */
+	{0b10000, 21250, 10630, 5310, 2660},
+	{0b10001, 20310, 10160, 5080, 2540},
+	{0b10010, 19530,  9770, 4880, 2440},
+	{0b10011, 18750,  9380, 4690, 2340},
+	{0b10100, 18130,  9060, 4530, 2270},
+	{0b10101, 17500,  8750, 4380, 2190},
+	{0b10110, 16880,  8440, 4220, 2110},
+	{0b10111, 16250,  8130, 4060, 2030},
+	{0b11000, 15780,  7890, 3950, 1970},
+	{0b11001, 15310,  7660, 3830, 1910},
+	{0b11010, 14840,  7420, 3710, 1860},
+	{0b11011, 14380,  7190, 3590, 1800},
+	{0b11100, 13910,  6950, 3480, 1740},
+	{0b11101, 13590,  6800, 3400, 1700},
+	{0b11110, 13280,  6640, 3320, 1660},
+	{0b11111, 12970,  6480, 3240, 1620},
+	{0b00000, 12660,  6330, 3160, 1580},
+	{0b00001, 12340,  6170, 3090, 1540},
+	{0b00010, 12110,  6050, 3030, 1510},
+	{0b00011, 11880,  5940, 2970, 1480},
+	{0b00100, 11640,  5820, 2910, 1460},
+	{0b00101, 11410,  5700, 2850, 1430},
+	{0b00110, 11170,  5590, 2790, 1400},
+	{0b00111, 10940,  5470, 2730, 1370},
+	{0b01000, 10780,  5390, 2700, 1350},
+	{0b01001, 10630,  5310, 2660, 1330},
+	{0b01010, 10470,  5230, 2620, 1310},
+	{0b01011, 10310,  5160, 2580, 1290},
+	{0b01100, 10230,  5120, 2560, 1280},
+	{0b01101, 10160,  5080, 2540, 1270},
+	{0b01110, 10080,  5040, 2520, 1260},
+	{0b01111, 10000,  5000, 2500, 1250},
+	{REG_NULL, 0, 0, 0, 0},
+};
+
+static inline struct fp5510_device *to_fp5510_vcm(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl->handler, struct fp5510_device, ctrls_vcm);
+}
+
+static inline struct fp5510_device *sd_to_fp5510_vcm(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct fp5510_device, sd);
+}
+
+static int __fp5510_power_on(struct fp5510_device *dev_vcm)
+{
+	if (!IS_ERR(dev_vcm->pwdn_gpio)) {
+		gpiod_set_value_cansleep(dev_vcm->pwdn_gpio, 1);
+		dev_err(dev_vcm->sd.dev, "power on success!\n");
+	}
+
+	return 0;
+}
+
+static int __fp5510_power_off(struct fp5510_device *dev_vcm)
+{
+	if (!IS_ERR(dev_vcm->pwdn_gpio)) {
+		gpiod_set_value_cansleep(dev_vcm->pwdn_gpio, 0);
+		dev_err(dev_vcm->sd.dev, "power off success!\n");
+	}
+
+	return 0;
+}
+
+static int fp5510_read_msg(struct i2c_client *client,
+	unsigned char *msb, unsigned char *lsb)
+{
+	int ret = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	int retries;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "client->adapter NULL\n");
+		return -ENODEV;
+	}
+
+	for (retries = 0; retries < 5; retries++) {
+		msg->addr = client->addr;
+		msg->flags = I2C_M_RD;
+		msg->len = 2;
+		msg->buf = data;
+
+		ret = i2c_transfer(client->adapter, msg, 1);
+		if (ret == 1) {
+			dev_dbg(&client->dev,
+				"%s: vcm i2c ok, addr 0x%x, data 0x%x, 0x%x\n",
+				__func__, msg->addr, data[0], data[1]);
+
+			*msb = data[0];
+			*lsb = data[1];
+			return 0;
+		}
+
+		dev_info(&client->dev,
+			"retrying I2C... %d\n", retries);
+		retries++;
+		msleep(20);
+	}
+	dev_err(&client->dev,
+		"%s: i2c write to failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+static int fp5510_write_msg(struct i2c_client *client,
+	u8 msb, u8 lsb)
+{
+	int ret = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	int retries;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "client->adapter NULL\n");
+		return -ENODEV;
+	}
+
+	for (retries = 0; retries < 5; retries++) {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+
+		data[0] = msb;
+		data[1] = lsb;
+
+		ret = i2c_transfer(client->adapter, msg, 1);
+
+		if (ret == 1) {
+			dev_dbg(&client->dev,
+				"%s: vcm i2c ok, addr 0x%x, data 0x%x, 0x%x\n",
+				__func__, msg->addr, data[0], data[1]);
+			return 0;
+		}
+
+		dev_info(&client->dev,
+			"retrying I2C... %d\n", retries);
+		retries++;
+		msleep(20);
+	}
+	dev_err(&client->dev,
+		"i2c write to failed with error %d msb:%d lsb:%d\n",
+		ret, msb, lsb);
+	return ret;
+}
+
+static unsigned int fp5510_move_time(struct fp5510_device *dev_vcm,
+	unsigned int move_pos)
+{
+	unsigned int move_time_ms = 200;
+	unsigned int step_period_lsc = 0;
+	unsigned int step_period_dlc = 0;
+	unsigned int step_period = 0;
+	int i = 0;
+	int table_cnt = 0;
+	unsigned int step_case;
+	unsigned int codes_per_step = 1;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+
+	if (dev_vcm->esc_enable == ENABLE ||
+		dev_vcm->tsc_enable == ENABLE) {
+		step_case = dev_vcm->mclk & 0x3;
+		table_cnt = sizeof(fp5510_dlc_time_table) /
+					sizeof(struct TimeTabel_s);
+		for (i = 0; i < table_cnt; i++) {
+			if (fp5510_dlc_time_table[i].t_src == dev_vcm->t_src)
+				break;
+		}
+	} else {
+		step_case = dev_vcm->step_mode & 0x3;
+		table_cnt = sizeof(fp5510_lsc_time_table) /
+					sizeof(struct TimeTabel_s);
+		for (i = 0; i < table_cnt; i++) {
+			if (fp5510_lsc_time_table[i].t_src == dev_vcm->t_src)
+				break;
+		}
+	}
+
+	if (i >= table_cnt)
+		i = 0;
+
+	switch (step_case) {
+	case 0:
+		step_period_lsc = fp5510_lsc_time_table[i].step00;
+		step_period_dlc = fp5510_dlc_time_table[i].step00;
+		break;
+	case 1:
+		step_period_lsc = fp5510_lsc_time_table[i].step01;
+		step_period_dlc = fp5510_dlc_time_table[i].step01;
+		break;
+	case 2:
+		step_period_lsc = fp5510_lsc_time_table[i].step10;
+		step_period_dlc = fp5510_dlc_time_table[i].step10;
+		break;
+	case 3:
+		step_period_lsc = fp5510_lsc_time_table[i].step11;
+		step_period_dlc = fp5510_dlc_time_table[i].step11;
+		break;
+	default:
+		dev_err(&client->dev,
+			"%s: step_case is error %d\n",
+			__func__, step_case);
+		break;
+	}
+	codes_per_step = (dev_vcm->step_mode & 0x0c) >> 2;
+	if (codes_per_step > 1)
+		codes_per_step = 1 << (codes_per_step - 1);
+
+	if (dev_vcm->esc_enable == ENABLE || dev_vcm->tsc_enable == ENABLE)
+		step_period = step_period_dlc;
+	else
+		step_period = step_period_lsc;
+
+	if (dev_vcm->tsc_enable == ENABLE) {
+		move_time_ms = step_period * move_pos / 1000;
+	} else if (dev_vcm->esc_enable == ENABLE) {
+		move_time_ms = step_period * 2 * move_pos / 1000;
+	} else {
+		if (!codes_per_step)
+			move_time_ms = step_period * move_pos / 1000;
+		else
+			move_time_ms = step_period * move_pos /
+				codes_per_step / 1000;
+	}
+
+	return move_time_ms;
+}
+
+static int fp5510_get_pos(struct fp5510_device *dev_vcm,
+	unsigned int *cur_pos)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+	int ret;
+	unsigned char lsb = 0;
+	unsigned char msb = 0;
+	unsigned int abs_step;
+
+	ret = fp5510_read_msg(client, &msb, &lsb);
+	if (ret != 0)
+		goto err;
+
+	abs_step = (((unsigned int)(msb & 0x3FU)) << 4U) |
+		   (((unsigned int)lsb) >> 4U);
+	if (abs_step <= dev_vcm->start_current)
+		abs_step = VCMDRV_MAX_LOG;
+	else if ((abs_step > dev_vcm->start_current) &&
+		 (abs_step <= dev_vcm->rated_current))
+		abs_step = (dev_vcm->rated_current - abs_step) / dev_vcm->step;
+	else
+		abs_step = 0;
+
+	*cur_pos = abs_step;
+	dev_dbg(&client->dev, "%s: get position %d\n", __func__, *cur_pos);
+	return 0;
+
+err:
+	dev_err(&client->dev,
+		"%s: failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+static int fp5510_set_pos(struct fp5510_device *dev_vcm,
+	unsigned int dest_pos)
+{
+	int ret;
+	unsigned char lsb = 0;
+	unsigned char msb = 0;
+	unsigned int position;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+
+	if (dest_pos >= VCMDRV_MAX_LOG)
+		position = dev_vcm->start_current;
+	else
+		position = dev_vcm->start_current +
+			   (dev_vcm->step * (VCMDRV_MAX_LOG - dest_pos));
+
+	if (position > FP5510_MAX_REG)
+		position = FP5510_MAX_REG;
+
+	dev_vcm->current_lens_pos = position;
+	dev_vcm->current_related_pos = dest_pos;
+	msb = (0x00U | ((dev_vcm->current_lens_pos & 0x3F0U) >> 4U));
+	lsb = (((dev_vcm->current_lens_pos & 0x0FU) << 4U) |
+		dev_vcm->step_mode);
+	ret = fp5510_write_msg(client, msb, lsb);
+	if (ret != 0)
+		goto err;
+
+	return ret;
+err:
+	dev_err(&client->dev,
+		"%s: failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+static int fp5510_get_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct fp5510_device *dev_vcm = to_fp5510_vcm(ctrl);
+
+	if (ctrl->id == V4L2_CID_FOCUS_ABSOLUTE)
+		return fp5510_get_pos(dev_vcm, &ctrl->val);
+
+	return -EINVAL;
+}
+
+static int fp5510_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct fp5510_device *dev_vcm = to_fp5510_vcm(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
+	unsigned int dest_pos = ctrl->val;
+	int move_pos;
+	long mv_us;
+	int ret = 0;
+
+	if (ctrl->id == V4L2_CID_FOCUS_ABSOLUTE) {
+		if (dest_pos > VCMDRV_MAX_LOG) {
+			dev_info(&client->dev,
+				"%s dest_pos is error. %d > %d\n",
+				__func__, dest_pos, VCMDRV_MAX_LOG);
+			return -EINVAL;
+		}
+			/* calculate move time */
+		move_pos = dev_vcm->current_related_pos - dest_pos;
+		if (move_pos < 0)
+			move_pos = -move_pos;
+
+		ret = fp5510_set_pos(dev_vcm, dest_pos);
+
+		dev_vcm->move_ms =
+			((dev_vcm->vcm_movefull_t *
+			(uint32_t)move_pos) /
+			VCMDRV_MAX_LOG);
+
+		dev_vcm->start_move_tv = ns_to_timeval(ktime_get_ns());
+		mv_us = dev_vcm->start_move_tv.tv_usec +
+				dev_vcm->move_ms * 1000;
+		if (mv_us >= 1000000) {
+			dev_vcm->end_move_tv.tv_sec =
+				dev_vcm->start_move_tv.tv_sec + 1;
+			dev_vcm->end_move_tv.tv_usec = mv_us - 1000000;
+		} else {
+			dev_vcm->end_move_tv.tv_sec =
+					dev_vcm->start_move_tv.tv_sec;
+			dev_vcm->end_move_tv.tv_usec = mv_us;
+		}
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops fp5510_vcm_ctrl_ops = {
+	.g_volatile_ctrl = fp5510_get_ctrl,
+	.s_ctrl = fp5510_set_ctrl,
+};
+
+static int fp5510_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	int rval;
+
+	rval = pm_runtime_get_sync(sd->dev);
+	if (rval < 0) {
+		pm_runtime_put_noidle(sd->dev);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int fp5510_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	pm_runtime_put(sd->dev);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops fp5510_int_ops = {
+	.open = fp5510_open,
+	.close = fp5510_close,
+};
+
+static long fp5510_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret = 0;
+	struct rk_cam_vcm_tim *vcm_tim;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct fp5510_device *fp5510_dev = sd_to_fp5510_vcm(sd);
+
+	if (cmd == RK_VIDIOC_VCM_TIMEINFO) {
+		vcm_tim = (struct rk_cam_vcm_tim *)arg;
+
+		vcm_tim->vcm_start_t.tv_sec = fp5510_dev->start_move_tv.tv_sec;
+		vcm_tim->vcm_start_t.tv_usec =
+				fp5510_dev->start_move_tv.tv_usec;
+		vcm_tim->vcm_end_t.tv_sec = fp5510_dev->end_move_tv.tv_sec;
+		vcm_tim->vcm_end_t.tv_usec = fp5510_dev->end_move_tv.tv_usec;
+
+		dev_dbg(&client->dev, "fp5510_get_move_res 0x%lx, 0x%lx, 0x%lx, 0x%lx\n",
+			vcm_tim->vcm_start_t.tv_sec,
+			vcm_tim->vcm_start_t.tv_usec,
+			vcm_tim->vcm_end_t.tv_sec,
+			vcm_tim->vcm_end_t.tv_usec);
+	} else {
+		dev_err(&client->dev,
+			"cmd 0x%x not supported\n", cmd);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long fp5510_compat_ioctl32(struct v4l2_subdev *sd,
+	unsigned int cmd, unsigned long arg)
+{
+	struct rk_cam_vcm_tim vcm_tim;
+	struct rk_cam_compat_vcm_tim compat_vcm_tim;
+	struct rk_cam_compat_vcm_tim __user *p32 = compat_ptr(arg);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	long ret;
+
+	if (cmd == RK_VIDIOC_COMPAT_VCM_TIMEINFO) {
+		ret = fp5510_ioctl(sd, RK_VIDIOC_VCM_TIMEINFO, &vcm_tim);
+		compat_vcm_tim.vcm_start_t.tv_sec = vcm_tim.vcm_start_t.tv_sec;
+		compat_vcm_tim.vcm_start_t.tv_usec =
+				vcm_tim.vcm_start_t.tv_usec;
+		compat_vcm_tim.vcm_end_t.tv_sec = vcm_tim.vcm_end_t.tv_sec;
+		compat_vcm_tim.vcm_end_t.tv_usec = vcm_tim.vcm_end_t.tv_usec;
+
+		put_user(compat_vcm_tim.vcm_start_t.tv_sec,
+			&p32->vcm_start_t.tv_sec);
+		put_user(compat_vcm_tim.vcm_start_t.tv_usec,
+			&p32->vcm_start_t.tv_usec);
+		put_user(compat_vcm_tim.vcm_end_t.tv_sec,
+			&p32->vcm_end_t.tv_sec);
+		put_user(compat_vcm_tim.vcm_end_t.tv_usec,
+			&p32->vcm_end_t.tv_usec);
+	} else {
+		dev_err(&client->dev,
+			"cmd 0x%x not supported\n", cmd);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+#endif
+
+static const struct v4l2_subdev_core_ops fp5510_core_ops = {
+	.ioctl = fp5510_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = fp5510_compat_ioctl32
+#endif
+};
+
+static const struct v4l2_subdev_ops fp5510_ops = {
+	.core = &fp5510_core_ops,
+};
+
+static void fp5510_subdev_cleanup(struct fp5510_device *fp5510_dev)
+{
+	v4l2_device_unregister_subdev(&fp5510_dev->sd);
+	v4l2_device_unregister(&fp5510_dev->vdev);
+	v4l2_ctrl_handler_free(&fp5510_dev->ctrls_vcm);
+	media_entity_cleanup(&fp5510_dev->sd.entity);
+}
+
+static int fp5510_init_controls(struct fp5510_device *dev_vcm)
+{
+	struct v4l2_ctrl_handler *hdl = &dev_vcm->ctrls_vcm;
+	const struct v4l2_ctrl_ops *ops = &fp5510_vcm_ctrl_ops;
+
+	v4l2_ctrl_handler_init(hdl, 1);
+
+	v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FOCUS_ABSOLUTE,
+			  0, VCMDRV_MAX_LOG, 1, VCMDRV_MAX_LOG);
+
+	if (hdl->error)
+		dev_err(dev_vcm->sd.dev, "%s fail error: 0x%x\n",
+			__func__, hdl->error);
+	dev_vcm->sd.ctrl_handler = hdl;
+	return hdl->error;
+}
+
+static int fp5510_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device_node *np = of_node_get(client->dev.of_node);
+	struct fp5510_device *fp5510_dev;
+	struct device *dev = &client->dev;
+	int ret;
+	int current_distance;
+	unsigned int start_current;
+	unsigned int rated_current;
+	unsigned int step_mode;
+	struct v4l2_subdev *sd;
+	char facing[2];
+	unsigned char data = 0x0;
+
+	dev_info(&client->dev, "probing...\n");
+	if (of_property_read_u32(np,
+		OF_CAMERA_VCMDRV_START_CURRENT,
+		(unsigned int *)&start_current)) {
+		start_current = FP5510_DEFAULT_START_CURRENT;
+		dev_info(&client->dev,
+			"could not get module %s from dts!\n",
+			OF_CAMERA_VCMDRV_START_CURRENT);
+	}
+	if (of_property_read_u32(np,
+		OF_CAMERA_VCMDRV_RATED_CURRENT,
+		(unsigned int *)&rated_current)) {
+		rated_current = FP5510_DEFAULT_RATED_CURRENT;
+		dev_info(&client->dev,
+			"could not get module %s from dts!\n",
+			OF_CAMERA_VCMDRV_RATED_CURRENT);
+	}
+	if (of_property_read_u32(np,
+		OF_CAMERA_VCMDRV_STEP_MODE,
+		(unsigned int *)&step_mode)) {
+		step_mode = FP5510_DEFAULT_STEP_MODE;
+		dev_info(&client->dev,
+			"could not get module %s from dts!\n",
+			OF_CAMERA_VCMDRV_STEP_MODE);
+	}
+
+	fp5510_dev = devm_kzalloc(&client->dev, sizeof(*fp5510_dev),
+				  GFP_KERNEL);
+	if (!fp5510_dev)
+		return -ENOMEM;
+
+	ret = of_property_read_u32(np, RKMODULE_CAMERA_MODULE_INDEX,
+				   &fp5510_dev->module_index);
+	ret |= of_property_read_string(np, RKMODULE_CAMERA_MODULE_FACING,
+				       &fp5510_dev->module_facing);
+	if (ret) {
+		dev_err(&client->dev,
+			"could not get module information!\n");
+		return -EINVAL;
+	}
+
+	v4l2_i2c_subdev_init(&fp5510_dev->sd, client, &fp5510_ops);
+
+	fp5510_dev->pwdn_gpio = devm_gpiod_get(dev, "pwdn", GPIOD_OUT_HIGH);
+	if (IS_ERR(fp5510_dev->pwdn_gpio))
+		dev_warn(dev, "Failed to get pwdn-gpios\n");
+
+	fp5510_dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	fp5510_dev->sd.internal_ops = &fp5510_int_ops;
+
+	ret = fp5510_init_controls(fp5510_dev);
+	if (ret)
+		goto err_cleanup;
+
+	__fp5510_power_on(fp5510_dev);
+
+	ret = media_entity_pads_init(&fp5510_dev->sd.entity, 0, NULL);
+	if (ret < 0)
+		goto err_cleanup;
+
+	sd = &fp5510_dev->sd;
+	sd->entity.function = MEDIA_ENT_F_LENS;
+
+	memset(facing, 0, sizeof(facing));
+	if (strcmp(fp5510_dev->module_facing, "back") == 0)
+		facing[0] = 'b';
+	else
+		facing[0] = 'f';
+
+	snprintf(sd->name, sizeof(sd->name), "m%02d_%s_%s %s",
+		 fp5510_dev->module_index, facing,
+		 FP5510_NAME, dev_name(sd->dev));
+	ret = v4l2_async_register_subdev(sd);
+	if (ret)
+		dev_err(&client->dev, "v4l2 async register subdev failed\n");
+
+	current_distance = rated_current - start_current;
+	current_distance = current_distance * FP5510_MAX_REG /
+						FP5510_MAX_CURRENT;
+	fp5510_dev->step = (current_distance + (VCMDRV_MAX_LOG - 1)) /
+						VCMDRV_MAX_LOG;
+	fp5510_dev->start_current = start_current * FP5510_MAX_REG /
+						FP5510_MAX_CURRENT;
+	fp5510_dev->rated_current = fp5510_dev->start_current +
+						VCMDRV_MAX_LOG *
+						fp5510_dev->step;
+	fp5510_dev->step_mode     = step_mode;
+	fp5510_dev->move_ms       = 0;
+	fp5510_dev->current_related_pos = VCMDRV_MAX_LOG;
+	fp5510_dev->start_move_tv = ns_to_timeval(ktime_get_ns());
+	fp5510_dev->end_move_tv = ns_to_timeval(ktime_get_ns());
+	/*
+	 * Note:
+	 * 1. At ESC mode, ESC code=1 and TSC must be equal 0.
+	 * 2. If ESC code=1 and TSC code=1, it get the TSC mode.
+	 */
+	fp5510_dev->esc_enable = DISABLE;
+	fp5510_dev->tsc_enable = DISABLE;
+	fp5510_dev->mclk = 0;
+	fp5510_dev->t_src = 0x0;
+
+	ret = fp5510_write_msg(client, 0xEC, 0xA3);
+	if (ret != 0)
+		dev_err(&client->dev,
+			"%s: failed with error %d\n", __func__, ret);
+
+	data = (fp5510_dev->mclk & 0x3) | 0x04 |
+			(((fp5510_dev->tsc_enable << 0x3) |
+			(fp5510_dev->esc_enable << 0x4)) & 0x18);
+	ret = fp5510_write_msg(client, 0xA1, data);
+	if (ret != 0)
+		dev_err(&client->dev,
+			"%s: failed with error %d\n", __func__, ret);
+
+	data = (fp5510_dev->t_src << 0x3) & 0xf8;
+	ret = fp5510_write_msg(client, 0xF2, data);
+	if (ret != 0)
+		dev_err(&client->dev,
+			"%s: failed with error %d\n", __func__, ret);
+
+	ret = fp5510_write_msg(client, 0xDC, 0x51);
+	if (ret != 0)
+		dev_err(&client->dev,
+			"%s: failed with error %d\n", __func__, ret);
+
+	fp5510_dev->vcm_movefull_t =
+		fp5510_move_time(fp5510_dev, FP5510_MAX_REG);
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	dev_info(&client->dev, "probing successful\n");
+
+	return 0;
+
+err_cleanup:
+	fp5510_subdev_cleanup(fp5510_dev);
+	dev_err(&client->dev, "Probe failed: %d\n", ret);
+	return ret;
+}
+
+static int fp5510_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct fp5510_device *fp5510_dev = sd_to_fp5510_vcm(sd);
+
+	pm_runtime_disable(&client->dev);
+	fp5510_subdev_cleanup(fp5510_dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		__fp5510_power_off(fp5510_dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	return 0;
+}
+
+static int fp5510_vcm_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct fp5510_device *fp5510_dev = sd_to_fp5510_vcm(sd);
+
+	__fp5510_power_on(fp5510_dev);
+
+	return 0;
+}
+
+static int fp5510_vcm_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct fp5510_device *fp5510_dev = sd_to_fp5510_vcm(sd);
+
+	__fp5510_power_off(fp5510_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id fp5510_id_table[] = {
+	{ FP5510_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, fp5510_id_table);
+
+static const struct of_device_id fp5510_of_table[] = {
+	{ .compatible = "fitipower,fp5510" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, fp5510_of_table);
+
+static const struct dev_pm_ops fp5510_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(fp5510_vcm_suspend, fp5510_vcm_resume)
+	SET_RUNTIME_PM_OPS(fp5510_vcm_suspend, fp5510_vcm_resume, NULL)
+};
+
+static struct i2c_driver fp5510_i2c_driver = {
+	.driver = {
+		.name = FP5510_NAME,
+		.pm = &fp5510_pm_ops,
+		.of_match_table = fp5510_of_table,
+	},
+	.probe = &fp5510_probe,
+	.remove = &fp5510_remove,
+	.id_table = fp5510_id_table,
+};
+
+module_i2c_driver(fp5510_i2c_driver);
+
+MODULE_DESCRIPTION("FP5510 VCM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/vm149c.c b/drivers/media/i2c/vm149c.c
index e9403de9d06e..fac8a06d318e 100644
--- a/drivers/media/i2c/vm149c.c
+++ b/drivers/media/i2c/vm149c.c
@@ -5,10 +5,13 @@
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
+#include <linux/rk-camera-module.h>
+#include <linux/version.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include "rk_vcm_head.h"
 
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x0)
 #define VM149C_NAME			"vm149c"
 
 #define VM149C_MAX_CURRENT		100U
@@ -36,6 +39,9 @@ struct vm149c_device {
 	struct timeval start_move_tv;
 	struct timeval end_move_tv;
 	unsigned long move_ms;
+
+	u32 module_index;
+	const char *module_facing;
 };
 
 static inline struct vm149c_device *to_vm149c_vcm(struct v4l2_ctrl *ctrl)
@@ -139,13 +145,13 @@ static int vm149c_get_pos(
 	unsigned int *cur_pos)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
-	int ret;
-	unsigned char lsb;
-	unsigned char msb;
-	unsigned int abs_step;
+	int ret = 0;
+	unsigned char lsb = 0;
+	unsigned char msb = 0;
+	unsigned int abs_step = 0;
 
 	ret = vm149c_read_msg(client, &msb, &lsb);
-	if (IS_ERR_VALUE(ret))
+	if (ret != 0)
 		goto err;
 
 	abs_step = (((unsigned int)(msb & 0x3FU)) << 4U) |
@@ -172,10 +178,10 @@ static int vm149c_set_pos(
 	struct vm149c_device *dev_vcm,
 	unsigned int dest_pos)
 {
-	int ret;
-	unsigned char lsb;
-	unsigned char msb;
-	unsigned int position;
+	int ret = 0;
+	unsigned char lsb = 0;
+	unsigned char msb = 0;
+	unsigned int position = 0;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev_vcm->sd);
 
 	if (dest_pos >= VCMDRV_MAX_LOG)
@@ -193,7 +199,7 @@ static int vm149c_set_pos(
 	lsb = (((dev_vcm->current_lens_pos & 0x0FU) << 4U) |
 		dev_vcm->step_mode);
 	ret = vm149c_write_msg(client, msb, lsb);
-	if (IS_ERR_VALUE(ret))
+	if (ret != 0)
 		goto err;
 
 	return ret;
@@ -228,28 +234,32 @@ static int vm149c_set_ctrl(struct v4l2_ctrl *ctrl)
 				"%s dest_pos is error. %d > %d\n",
 				__func__, dest_pos, VCMDRV_MAX_LOG);
 			return -EINVAL;
+		}
+		/* calculate move time */
+		move_pos = dev_vcm->current_related_pos - dest_pos;
+		if (move_pos < 0)
+			move_pos = -move_pos;
+
+		ret = vm149c_set_pos(dev_vcm, dest_pos);
+
+		dev_vcm->move_ms =
+			((dev_vcm->vcm_movefull_t *
+			(uint32_t)move_pos) /
+			VCMDRV_MAX_LOG);
+		dev_dbg(&client->dev, "dest_pos %d, move_ms %ld\n",
+				dest_pos, dev_vcm->move_ms);
+
+		dev_vcm->start_move_tv = ns_to_timeval(ktime_get_ns());
+		mv_us = dev_vcm->start_move_tv.tv_usec +
+				dev_vcm->move_ms * 1000;
+		if (mv_us >= 1000000) {
+			dev_vcm->end_move_tv.tv_sec =
+					dev_vcm->start_move_tv.tv_sec + 1;
+			dev_vcm->end_move_tv.tv_usec = mv_us - 1000000;
 		} else {
-			/* calculate move time */
-			move_pos = dev_vcm->current_related_pos - dest_pos;
-			if (move_pos < 0)
-				move_pos = -move_pos;
-
-			ret = vm149c_set_pos(dev_vcm, dest_pos);
-
-			dev_vcm->move_ms =
-				((dev_vcm->vcm_movefull_t * (uint32_t)move_pos) / VCMDRV_MAX_LOG);
-			dev_dbg(&client->dev,
-				"dest_pos %d, move_ms %ld\n", dest_pos, dev_vcm->move_ms);
-
-			dev_vcm->start_move_tv = ns_to_timeval(ktime_get_ns());
-			mv_us = dev_vcm->start_move_tv.tv_usec + dev_vcm->move_ms * 1000;
-			if (mv_us >= 1000000) {
-				dev_vcm->end_move_tv.tv_sec = dev_vcm->start_move_tv.tv_sec + 1;
-				dev_vcm->end_move_tv.tv_usec = mv_us - 1000000;
-			} else {
-				dev_vcm->end_move_tv.tv_sec = dev_vcm->start_move_tv.tv_sec;
-				dev_vcm->end_move_tv.tv_usec = mv_us;
-			}
+			dev_vcm->end_move_tv.tv_sec =
+					dev_vcm->start_move_tv.tv_sec;
+			dev_vcm->end_move_tv.tv_usec = mv_us;
 		}
 	}
 
@@ -382,36 +392,40 @@ static int vm149c_init_controls(struct vm149c_device *dev_vcm)
 static int vm149c_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
+	struct device_node *np = of_node_get(client->dev.of_node);
 	struct vm149c_device *vm149c_dev;
 	int ret;
 	int current_distance;
-	struct device_node *np = of_node_get(client->dev.of_node);
 	unsigned int start_current;
 	unsigned int rated_current;
 	unsigned int step_mode;
+	struct v4l2_subdev *sd;
+	char facing[2];
 
 	dev_info(&client->dev, "probing...\n");
-	if (of_property_read_u32(
-		np,
-		OF_CAMERA_VCMDRV_START_CURRENT,
+	dev_info(&client->dev, "driver version: %02x.%02x.%02x",
+		DRIVER_VERSION >> 16,
+		(DRIVER_VERSION & 0xff00) >> 8,
+		DRIVER_VERSION & 0x00ff);
+
+	if (of_property_read_u32(np,
+		 OF_CAMERA_VCMDRV_START_CURRENT,
 		(unsigned int *)&start_current)) {
 		start_current = VM149C_DEFAULT_START_CURRENT;
 		dev_info(&client->dev,
 			"could not get module %s from dts!\n",
 			OF_CAMERA_VCMDRV_START_CURRENT);
 	}
-	if (of_property_read_u32(
-		np,
-		OF_CAMERA_VCMDRV_RATED_CURRENT,
+	if (of_property_read_u32(np,
+		 OF_CAMERA_VCMDRV_RATED_CURRENT,
 		(unsigned int *)&rated_current)) {
 		rated_current = VM149C_DEFAULT_RATED_CURRENT;
 		dev_info(&client->dev,
 			"could not get module %s from dts!\n",
 			OF_CAMERA_VCMDRV_RATED_CURRENT);
 	}
-	if (of_property_read_u32(
-		np,
-		OF_CAMERA_VCMDRV_STEP_MODE,
+	if (of_property_read_u32(np,
+		 OF_CAMERA_VCMDRV_STEP_MODE,
 		(unsigned int *)&step_mode)) {
 		step_mode = VM149C_DEFAULT_STEP_MODE;
 		dev_info(&client->dev,
@@ -424,6 +438,16 @@ static int vm149c_probe(struct i2c_client *client,
 	if (vm149c_dev == NULL)
 		return -ENOMEM;
 
+	ret = of_property_read_u32(np, RKMODULE_CAMERA_MODULE_INDEX,
+				   &vm149c_dev->module_index);
+	ret |= of_property_read_string(np, RKMODULE_CAMERA_MODULE_FACING,
+				       &vm149c_dev->module_facing);
+	if (ret) {
+		dev_err(&client->dev,
+			"could not get module information!\n");
+		return -EINVAL;
+	}
+
 	v4l2_i2c_subdev_init(&vm149c_dev->sd, client, &vm149c_ops);
 	vm149c_dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	vm149c_dev->sd.internal_ops = &vm149c_int_ops;
@@ -432,31 +456,25 @@ static int vm149c_probe(struct i2c_client *client,
 	if (ret)
 		goto err_cleanup;
 
-	ret = media_entity_init(&vm149c_dev->sd.entity, 0, NULL, 0);
+	ret = media_entity_pads_init(&vm149c_dev->sd.entity, 0, NULL);
 	if (ret < 0)
 		goto err_cleanup;
 
-	vm149c_dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_LENS;
+	sd = &vm149c_dev->sd;
+	sd->entity.function = MEDIA_ENT_F_LENS;
 
-	ret = v4l2_device_register(&client->dev, &vm149c_dev->vdev);
-	if (ret < 0) {
-		dev_err(&client->dev, "vm149 v4l2 device register failed, ret: %d\n", ret);
-		goto err_cleanup;
-	}
-
-	ret = v4l2_device_register_subdev(&vm149c_dev->vdev, &vm149c_dev->sd);
-	if (ret) {
-		dev_err(&client->dev, "vm149 v4l2 register subdev failed, ret: %d\n", ret);
-		goto err_cleanup;
-	} else {
-		dev_info(&client->dev, "vm149 v4l2 register subdev success\n");
-	}
+	memset(facing, 0, sizeof(facing));
+	if (strcmp(vm149c_dev->module_facing, "back") == 0)
+		facing[0] = 'b';
+	else
+		facing[0] = 'f';
 
-	ret = v4l2_device_register_subdev_nodes(&vm149c_dev->vdev);
-	if (ret < 0) {
-		dev_err(&client->dev, "vm149 v4l2 device nodesregister, ret: %d\n", ret);
-		goto err_cleanup;
-	}
+	snprintf(sd->name, sizeof(sd->name), "m%02d_%s_%s %s",
+		 vm149c_dev->module_index, facing,
+		 VM149C_NAME, dev_name(sd->dev));
+	ret = v4l2_async_register_subdev(sd);
+	if (ret)
+		dev_err(&client->dev, "v4l2 async register subdev failed\n");
 
 	current_distance = rated_current - start_current;
 	current_distance = current_distance * VM149C_MAX_REG / VM149C_MAX_CURRENT;
-- 
2.35.3

