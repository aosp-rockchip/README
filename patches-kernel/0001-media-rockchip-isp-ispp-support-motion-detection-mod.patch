From 0cb75614559ceea991039e7a772f81cea40b1219 Mon Sep 17 00:00:00 2001
From: Hu Kejun <william.hu@rock-chips.com>
Date: Tue, 29 Dec 2020 18:25:21 +0800
Subject: [PATCH] media: rockchip: isp/ispp: support motion detection mode

Signed-off-by: Hu Kejun <william.hu@rock-chips.com>
Change-Id: I76b3349d4a05f07154c2879bc35c3440778e0914
---
 drivers/media/platform/rockchip/isp/bridge.c  | 285 +++++++++++++++++-
 drivers/media/platform/rockchip/isp/bridge.h  |   5 +
 drivers/media/platform/rockchip/isp/capture.c |  16 +-
 drivers/media/platform/rockchip/isp/capture.h |   1 +
 .../media/platform/rockchip/isp/capture_v20.c | 206 +++++++++++--
 .../media/platform/rockchip/isp/capture_v2x.h |   8 +
 drivers/media/platform/rockchip/isp/common.c  |  20 +-
 drivers/media/platform/rockchip/isp/common.h  |   7 +
 drivers/media/platform/rockchip/isp/csi.c     |   1 +
 drivers/media/platform/rockchip/isp/dev.h     |   3 +
 drivers/media/platform/rockchip/isp/hw.c      |   2 +
 drivers/media/platform/rockchip/isp/hw.h      |   2 +
 .../media/platform/rockchip/isp/isp_ispp.h    |   8 +
 drivers/media/platform/rockchip/isp/rkisp.c   |  17 +-
 drivers/media/platform/rockchip/ispp/common.c |  22 ++
 drivers/media/platform/rockchip/ispp/common.h |   6 +
 drivers/media/platform/rockchip/ispp/ispp.c   |  35 ++-
 drivers/media/platform/rockchip/ispp/stream.c | 183 ++++++++++-
 drivers/media/platform/rockchip/ispp/stream.h |   5 +
 drivers/media/v4l2-core/v4l2-ioctl.c          |   1 +
 include/uapi/linux/rkisp2-config.h            |  19 ++
 include/uapi/linux/rkispp-config.h            |  26 ++
 include/uapi/linux/videodev2.h                |   1 +
 23 files changed, 832 insertions(+), 47 deletions(-)

diff --git a/drivers/media/platform/rockchip/isp/bridge.c b/drivers/media/platform/rockchip/isp/bridge.c
index db969c1d46e0..23bc8ee42aec 100644
--- a/drivers/media/platform/rockchip/isp/bridge.c
+++ b/drivers/media/platform/rockchip/isp/bridge.c
@@ -429,12 +429,93 @@ static void dump_dbg_reg(struct rkisp_bridge_device *dev, struct rkisp_ispp_reg
 	reg_buf->reg_size = offset;
 }
 
+static void rkisp_bridge_try_sendtohal(struct rkisp_device *dev)
+{
+	struct rkisp_hw_dev *hw = dev->hw_dev;
+	struct rkisp_bridge_device *br_dev = &dev->br_dev;
+	struct rkisp_ispp_buf *cur_fbcgain = dev->cur_fbcgain;
+	struct rkisp_buffer *cur_spbuf = dev->cur_spbuf;
+	struct isp2x_ispgain_buf *buf;
+	struct rkisp_bridge_buf *bdgbuf;
+	struct vb2_buffer *vb2_buf;
+	u32 *vaddr, size;
+	u64 pic_ts, gain_ts, sp_ts;
+
+	if (cur_fbcgain && cur_spbuf) {
+		if ((cur_fbcgain->frame_id == cur_spbuf->vb.sequence) &&
+		    (cur_fbcgain->index == cur_spbuf->dev_id)) {
+			vb2_buf = &cur_spbuf->vb.vb2_buf;
+			cur_fbcgain->buf_idx = vb2_buf->index;
+			buf = vb2_plane_vaddr(vb2_buf, 1);
+			buf->gain_dmaidx = cur_fbcgain->gain_dmaidx;
+			buf->mfbc_dmaidx = cur_fbcgain->mfbc_dmaidx;
+			buf->gain_size = cur_fbcgain->gain_size;
+			buf->mfbc_size = cur_fbcgain->mfbc_size;
+			buf->frame_id = cur_fbcgain->frame_id;
+			bdgbuf = to_bridge_buf(cur_fbcgain);
+			rkisp_finish_buffer(dev, &bdgbuf->dummy[GROUP_BUF_GAIN]);
+			vb2_buffer_done(&cur_spbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);
+			list_add_tail(&cur_fbcgain->list, &hw->rpt_list);
+			dev->cur_fbcgain = NULL;
+			dev->cur_spbuf = NULL;
+			v4l2_dbg(3, rkisp_debug, &br_dev->sd,
+				 "%s send mfbcgain buf to hal, frame_id %d\n",
+				 __func__, cur_fbcgain->frame_id);
+
+			bdgbuf = to_bridge_buf(cur_fbcgain);
+			vaddr = bdgbuf->dummy[GROUP_BUF_PIC].vaddr;
+			size = bdgbuf->dummy[GROUP_BUF_PIC].size;
+			pic_ts = *(u64 *)(vaddr + size / 4 - 2);
+
+			vaddr = bdgbuf->dummy[GROUP_BUF_GAIN].vaddr;
+			size = bdgbuf->dummy[GROUP_BUF_GAIN].size;
+			gain_ts = *(u64 *)(vaddr + size / 4 - 2);
+
+			size = vb2_plane_size(&cur_spbuf->vb.vb2_buf, 0);
+			vaddr = (u32 *)vb2_plane_vaddr(&cur_spbuf->vb.vb2_buf, 0);
+			sp_ts = *(u64 *)(vaddr + size / 4 - 2);
+			if (abs(pic_ts - gain_ts) > 5000000LL || abs(pic_ts - sp_ts) > 5000000LL ||
+			    abs(gain_ts - sp_ts) > 5000000LL) {
+				v4l2_info(&br_dev->sd,
+					"%s: frame %d, timestamp is not match (pic_ts %lld, gain_ts %lld, sp_ts %lld)\n",
+					__func__, cur_fbcgain->frame_id, pic_ts, gain_ts, sp_ts);
+			}
+		} else {
+			v4l2_info(&br_dev->sd,
+				  "%s frame_id(%d, %d) or dev_id(%d, %d) is not match\n",
+				  __func__,
+				  cur_fbcgain->frame_id, cur_spbuf->vb.sequence,
+				  cur_fbcgain->index, cur_spbuf->dev_id);
+		}
+	}
+}
+
+static void rkisp_bridge_save_fbcgain(struct rkisp_device *dev, struct rkisp_ispp_buf *fbcgain)
+{
+	struct rkisp_hw_dev *hw = dev->hw_dev;
+	struct rkisp_bridge_device *br_dev = &dev->br_dev;
+	unsigned long lock_flags = 0;
+
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	if (dev->cur_fbcgain) {
+		v4l2_dbg(3, rkisp_debug, &br_dev->sd,
+			 "%s old mfbcgain buf is exit, frame_id %d\n",
+			 __func__, dev->cur_fbcgain->frame_id);
+		list_add_tail(&dev->cur_fbcgain->list, &hw->list);
+		dev->cur_fbcgain = NULL;
+	}
+	dev->cur_fbcgain = fbcgain;
+	rkisp_bridge_try_sendtohal(dev);
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
+}
+
 static int frame_end(struct rkisp_bridge_device *dev, bool en)
 {
 	struct rkisp_hw_dev *hw = dev->ispdev->hw_dev;
 	struct v4l2_subdev *sd = v4l2_get_subdev_hostdata(&dev->sd);
 	unsigned long lock_flags = 0;
 	u64 ns = ktime_get_ns();
+	struct rkisp_bridge_buf *buf;
 
 	rkisp_dmarx_get_frame(dev->ispdev, &dev->dbg.id, NULL, NULL, true);
 	dev->dbg.interval = ns - dev->dbg.timestamp;
@@ -473,9 +554,31 @@ static int frame_end(struct rkisp_bridge_device *dev, bool en)
 				reg_buf->exposure = dev->ispdev->params_vdev.exposure;
 				dump_dbg_reg(dev, reg_buf);
 			}
-			v4l2_subdev_call(sd, video, s_rx_buffer, hw->cur_buf, NULL);
+
+			if (dev->ispdev->send_fbcgain) {
+				u32 *vaddr, size;
+
+				buf = to_bridge_buf(hw->cur_buf);
+				vaddr = buf->dummy[GROUP_BUF_PIC].vaddr;
+				size = buf->dummy[GROUP_BUF_PIC].size;
+				*(u64 *)(vaddr + size / 4 - 2) = ktime_get_ns();
+
+				vaddr = buf->dummy[GROUP_BUF_GAIN].vaddr;
+				size = buf->dummy[GROUP_BUF_GAIN].size;
+				*(u64 *)(vaddr + size / 4 - 2) = ktime_get_ns();
+				hw->cur_buf->mfbc_dmaidx = hw->cur_buf->didx[GROUP_BUF_PIC];
+				hw->cur_buf->gain_dmaidx = hw->cur_buf->didx[GROUP_BUF_GAIN];
+				hw->cur_buf->is_move_judge = true;
+				rkisp_bridge_save_fbcgain(dev->ispdev, hw->cur_buf);
+			} else {
+				hw->cur_buf->is_move_judge = false;
+				v4l2_subdev_call(sd, video, s_rx_buffer, hw->cur_buf, NULL);
+			}
 		}
 		hw->cur_buf = NULL;
+	} else if (dev->ispdev->send_fbcgain) {
+		v4l2_dbg(1, rkisp_debug, &dev->sd,
+			 "use dummy buffer, lost fbcgain data, frm_id %d\n", dev->dbg.id);
 	}
 
 	if (hw->nxt_buf) {
@@ -672,11 +775,25 @@ static void free_bridge_buf(struct rkisp_bridge_device *dev)
 		hw->nxt_buf = NULL;
 	}
 
+	if (dev->ispdev->cur_fbcgain) {
+		list_add_tail(&dev->ispdev->cur_fbcgain->list, &hw->list);
+		dev->ispdev->cur_fbcgain = NULL;
+	}
+
+	while (!list_empty(&hw->rpt_list)) {
+		dbufs = list_first_entry(&hw->rpt_list,
+				struct rkisp_ispp_buf, list);
+		list_del(&dbufs->list);
+		list_add_tail(&dbufs->list, &hw->list);
+	}
+
 	while (!list_empty(&hw->list)) {
 		dbufs = list_first_entry(&hw->list,
 				struct rkisp_ispp_buf, list);
 		list_del(&dbufs->list);
 	}
+
+	hw->is_buf_init = false;
 	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
 	for (i = 0; i < BRIDGE_BUF_MAX; i++) {
 		buf = &hw->bufs[i];
@@ -694,6 +811,7 @@ static int init_buf(struct rkisp_bridge_device *dev, u32 pic_size, u32 gain_size
 	struct rkisp_bridge_buf *buf;
 	struct rkisp_dummy_buffer *dummy;
 	int i, j, val, ret = 0;
+	unsigned long lock_flags = 0;
 
 	if (atomic_inc_return(&hw->refcnt) > 1)
 		return 0;
@@ -707,12 +825,16 @@ static int init_buf(struct rkisp_bridge_device *dev, u32 pic_size, u32 gain_size
 		buf = &hw->bufs[i];
 		for (j = 0; j < GROUP_BUF_MAX; j++) {
 			dummy = &buf->dummy[j];
+			dummy->is_need_vaddr = true;
 			dummy->is_need_dbuf = true;
-			dummy->size = !j ? pic_size : gain_size;
+			dummy->size = PAGE_ALIGN(!j ? pic_size : gain_size);
 			ret = rkisp_alloc_buffer(dev->ispdev, dummy);
 			if (ret)
 				goto err;
 			buf->dbufs.dbuf[j] = dummy->dbuf;
+			buf->dbufs.didx[j] = i * GROUP_BUF_MAX + j;
+			buf->dbufs.gain_size = PAGE_ALIGN(gain_size);
+			buf->dbufs.mfbc_size = PAGE_ALIGN(pic_size);
 		}
 		list_add_tail(&buf->dbufs.list, &hw->list);
 		ret = v4l2_subdev_call(sd, video, s_rx_buffer, &buf->dbufs, NULL);
@@ -767,6 +889,10 @@ static int init_buf(struct rkisp_bridge_device *dev, u32 pic_size, u32 gain_size
 		       CIF_MI_CTRL_INIT_OFFSET_EN, true);
 	rkisp_set_bits(dev->ispdev, MI_IMSC, 0,
 		       dev->cfg->frame_end_id, true);
+
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	hw->is_buf_init = true;
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
 	return 0;
 err:
 	free_bridge_buf(dev);
@@ -819,6 +945,9 @@ static int config_mode(struct rkisp_bridge_device *dev)
 	else
 		pic_size += w * h * 3 >> 1;
 	dev->cfg->offset = offs;
+
+	pic_size += RKISP_MOTION_DECT_TS_SIZE;
+	gain_size += RKISP_MOTION_DECT_TS_SIZE;
 	return init_buf(dev, pic_size, gain_size);
 }
 
@@ -862,13 +991,18 @@ static void crop_off(struct rkisp_bridge_device *dev)
 
 static int bridge_start(struct rkisp_bridge_device *dev)
 {
+	struct rkisp_stream *sp_stream;
+
+	sp_stream = &dev->ispdev->cap_dev.stream[RKISP_STREAM_SP];
 	crop_on(dev);
 	config_gain(dev);
 	dev->ops->config(dev);
+	rkisp_start_spstream(sp_stream);
 
 	if (!dev->ispdev->hw_dev->is_mi_update) {
 		rkisp_config_dmatx_valid_buf(dev->ispdev);
 		force_cfg_update(dev->ispdev);
+		rkisp_update_spstream_buf(sp_stream);
 
 		if (!(dev->work_mode & ISP_ISPP_QUICK))
 			update_mi(dev);
@@ -882,11 +1016,14 @@ static int bridge_start(struct rkisp_bridge_device *dev)
 
 static int bridge_stop(struct rkisp_bridge_device *dev)
 {
+	struct rkisp_stream *sp_stream;
 	int ret;
 	u32 irq;
 
+	sp_stream = &dev->ispdev->cap_dev.stream[RKISP_STREAM_SP];
 	dev->stopping = true;
 	dev->ops->disable(dev);
+	rkisp_stop_spstream(sp_stream);
 	hdr_stop_dmatx(dev->ispdev);
 	ret = wait_event_timeout(dev->done, !dev->en,
 				 msecs_to_jiffies(1000));
@@ -1156,12 +1293,156 @@ static struct v4l2_subdev_ops bridge_v4l2_ops = {
 	.pad = &bridge_pad_ops,
 };
 
+int rkisp_bridge_get_fbcbuf_fd(struct rkisp_device *dev, struct isp2x_buf_idxfd *idxfd)
+{
+	struct rkisp_hw_dev *hw = dev->hw_dev;
+	struct rkisp_bridge_device *br_dev = &dev->br_dev;
+	struct rkisp_bridge_buf *buf;
+	struct rkisp_dummy_buffer *dummy;
+	unsigned long lock_flags = 0;
+	int i, j, buf_idx, ret = 0;
+
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	if (!hw->is_buf_init) {
+		spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
+		ret = -EAGAIN;
+		return ret;
+	}
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
+
+	buf_idx = 0;
+	for (i = 0; i < br_dev->buf_num; i++) {
+		buf = &hw->bufs[i];
+		for (j = 0; j < GROUP_BUF_MAX; j++) {
+			dummy = &buf->dummy[j];
+			buf->dbufs.dfd[j] = dma_buf_fd(dummy->dbuf, O_CLOEXEC);
+			get_dma_buf(buf->dbufs.dbuf[j]);
+			idxfd->index[buf_idx] = buf->dbufs.didx[j];
+			idxfd->dmafd[buf_idx] = buf->dbufs.dfd[j];
+			buf_idx++;
+		}
+	}
+
+	idxfd->buf_num = buf_idx;
+
+	return ret;
+}
+
+void rkisp_bridge_sendtopp_buffer(struct rkisp_device *dev, u32 dev_id, u32 buf_idx)
+{
+	struct rkisp_hw_dev *hw = dev->hw_dev;
+	struct rkisp_bridge_device *br_dev = &dev->br_dev;
+	struct v4l2_subdev *sd = v4l2_get_subdev_hostdata(&br_dev->sd);
+	struct rkisp_ispp_buf *cur_buf, *cur_buf_tmp, *find_buf;
+	struct rkisp_bridge_buf *buf;
+	unsigned long lock_flags = 0;
+	bool find_flg = false;
+	u32 *vaddr, size;
+	u64 pic_ts, gain_ts;
+
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	list_for_each_entry(cur_buf, &hw->rpt_list, list) {
+		if (cur_buf->index == dev_id && cur_buf->buf_idx == buf_idx) {
+			find_flg = true;
+			break;
+		}
+	}
+
+	if (find_flg) {
+		list_del(&cur_buf->list);
+		find_buf = cur_buf;
+		list_for_each_entry_safe(cur_buf, cur_buf_tmp, &hw->rpt_list, list) {
+			if ((cur_buf->frame_id < find_buf->frame_id) &&
+				(cur_buf->index == find_buf->index)) {
+				list_del_init(&cur_buf->list);
+				v4l2_dbg(3, rkisp_debug, &br_dev->sd,
+					 "%s send buffer to pp, frame_id %d\n",
+					 __func__, cur_buf->frame_id);
+
+				buf = to_bridge_buf(cur_buf);
+				rkisp_prepare_buffer(dev, &buf->dummy[GROUP_BUF_GAIN]);
+				vaddr = buf->dummy[GROUP_BUF_PIC].vaddr;
+				size = buf->dummy[GROUP_BUF_PIC].size;
+				pic_ts = *(u64 *)(vaddr + size / 4 - 2);
+
+				vaddr = buf->dummy[GROUP_BUF_GAIN].vaddr;
+				size = buf->dummy[GROUP_BUF_GAIN].size;
+				gain_ts = *(u64 *)(vaddr + size / 4 - 2);
+				if (abs(pic_ts - gain_ts) > 5000000LL) {
+					v4l2_info(&br_dev->sd,
+						"%s: frame %d, timestamp is not match (pic_ts %lld, gain_ts %lld)",
+						__func__, cur_buf->frame_id, pic_ts, gain_ts);
+				}
+				cur_buf->is_move_judge = true;
+				v4l2_subdev_call(sd, video, s_rx_buffer, cur_buf, NULL);
+			}
+		}
+
+		v4l2_dbg(3, rkisp_debug, &br_dev->sd,
+			 "%s send buffer to pp, frame_id %d\n",
+			 __func__, find_buf->frame_id);
+
+		buf = to_bridge_buf(find_buf);
+		rkisp_prepare_buffer(dev, &buf->dummy[GROUP_BUF_GAIN]);
+		vaddr = buf->dummy[GROUP_BUF_PIC].vaddr;
+		size = buf->dummy[GROUP_BUF_PIC].size;
+		pic_ts = *(u64 *)(vaddr + size / 4 - 2);
+
+		vaddr = buf->dummy[GROUP_BUF_GAIN].vaddr;
+		size = buf->dummy[GROUP_BUF_GAIN].size;
+		gain_ts = *(u64 *)(vaddr + size / 4 - 2);
+		if (abs(pic_ts - gain_ts) > 5000000LL) {
+			v4l2_info(&br_dev->sd,
+				"%s: frame %d, timestamp is not match (pic_ts %lld, gain_ts %lld)",
+				__func__, find_buf->frame_id, pic_ts, gain_ts);
+		}
+		find_buf->is_move_judge = true;
+		v4l2_subdev_call(sd, video, s_rx_buffer, find_buf, NULL);
+	}
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
+}
+
+void rkisp_bridge_save_spbuf(struct rkisp_device *dev, struct rkisp_buffer *sp_buf)
+{
+	struct rkisp_hw_dev *hw = dev->hw_dev;
+	struct rkisp_bridge_device *br_dev = &dev->br_dev;
+	unsigned long lock_flags = 0;
+
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	if (dev->cur_spbuf) {
+		v4l2_dbg(3, rkisp_debug, &br_dev->sd,
+			 "%s old sp buf is exit, frame_id %d\n",
+			 __func__, dev->cur_spbuf->vb.sequence);
+		rkisp_spbuf_queue(&dev->cap_dev.stream[RKISP_STREAM_SP], dev->cur_spbuf);
+		dev->cur_spbuf = NULL;
+	}
+	dev->cur_spbuf = sp_buf;
+	rkisp_bridge_try_sendtohal(dev);
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
+}
+
+void rkisp_bridge_stop_spstream(struct rkisp_device *dev)
+{
+	struct rkisp_hw_dev *hw = dev->hw_dev;
+	unsigned long lock_flags = 0;
+
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	if (dev->cur_spbuf) {
+		rkisp_spbuf_queue(&dev->cap_dev.stream[RKISP_STREAM_SP], dev->cur_spbuf);
+		dev->cur_spbuf = NULL;
+	}
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
+}
+
 void rkisp_bridge_isr(u32 *mis_val, struct rkisp_device *dev)
 {
 	struct rkisp_bridge_device *bridge = &dev->br_dev;
 	void __iomem *base = dev->base_addr;
 	u32 irq;
 
+	if (!bridge->en)
+		return;
+
 	if (!bridge->cfg ||
 	    (bridge->cfg &&
 	     !(*mis_val & bridge->cfg->frame_end_id)))
diff --git a/drivers/media/platform/rockchip/isp/bridge.h b/drivers/media/platform/rockchip/isp/bridge.h
index 391ca2326f22..0e5dfa074dc4 100644
--- a/drivers/media/platform/rockchip/isp/bridge.h
+++ b/drivers/media/platform/rockchip/isp/bridge.h
@@ -5,6 +5,7 @@
 #define _RKISP_BRIDGE_H
 
 #include "linux/platform_device.h"
+#include <linux/rkisp1-config.h>
 #include "isp_ispp.h"
 
 #define BRIDGE_DEV_NAME DRIVER_NAME "-bridge-ispp"
@@ -60,7 +61,11 @@ struct rkisp_bridge_device {
 int rkisp_register_bridge_subdev(struct rkisp_device *dev,
 				 struct v4l2_device *v4l2_dev);
 void rkisp_unregister_bridge_subdev(struct rkisp_device *dev);
+int rkisp_bridge_get_fbcbuf_fd(struct rkisp_device *dev, struct isp2x_buf_idxfd *idxfd);
 void rkisp_bridge_isr(u32 *mis_val, struct rkisp_device *dev);
+void rkisp_bridge_sendtopp_buffer(struct rkisp_device *dev, u32 dev_id, u32 buf_idx);
+void rkisp_bridge_save_spbuf(struct rkisp_device *dev, struct rkisp_buffer *sp_buf);
+void rkisp_bridge_stop_spstream(struct rkisp_device *dev);
 void rkisp_get_bridge_sd(struct platform_device *dev,
 			 struct v4l2_subdev **sd);
 #endif
diff --git a/drivers/media/platform/rockchip/isp/capture.c b/drivers/media/platform/rockchip/isp/capture.c
index deb5543dbf75..5fbd34bb7ad4 100644
--- a/drivers/media/platform/rockchip/isp/capture.c
+++ b/drivers/media/platform/rockchip/isp/capture.c
@@ -53,6 +53,7 @@ int rkisp_fcc_xysubs(u32 fcc, u32 *xsubs, u32 *ysubs)
 	case V4L2_PIX_FMT_NV12M:
 	case V4L2_PIX_FMT_YUV420:
 	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_FBCG:
 		*xsubs = 2;
 		*ysubs = 2;
 		break;
@@ -384,6 +385,17 @@ static const struct capture_fmt sp_fmts[] = {
 		.mplanes = 1,
 		.write_format = MI_CTRL_SP_WRITE_PLA,
 		.output_format = MI_CTRL_SP_OUTPUT_RGB565,
+	},
+	/* fbcg */
+	{
+		.fourcc = V4L2_PIX_FMT_FBCG,
+		.fmt_type = FMT_FBCGAIN,
+		.bpp = { 8, 16 },
+		.cplanes = 2,
+		.mplanes = 2,
+		.uv_swap = 0,
+		.write_format = MI_CTRL_SP_WRITE_SPLA,
+		.output_format = MI_CTRL_SP_OUTPUT_YUV420,
 	}
 };
 
@@ -629,10 +641,10 @@ static int rkisp_set_fmt(struct rkisp_stream *stream,
 	 * it's important since we want to unify none-MPLANE
 	 * and MPLANE.
 	 */
-	if (fmt->mplanes == 1)
+	if (fmt->mplanes == 1 || fmt->fmt_type == FMT_FBCGAIN)
 		pixm->plane_fmt[0].sizeimage = imagsize;
 
-	if (!try) {
+	if (!try && !stream->start_stream && !stream->streaming) {
 		stream->out_isp_fmt = *fmt;
 		stream->out_fmt = *pixm;
 
diff --git a/drivers/media/platform/rockchip/isp/capture.h b/drivers/media/platform/rockchip/isp/capture.h
index 1b0d17fd86ee..8e95fe0e6b46 100644
--- a/drivers/media/platform/rockchip/isp/capture.h
+++ b/drivers/media/platform/rockchip/isp/capture.h
@@ -218,6 +218,7 @@ struct rkisp_stream {
 	bool stopping;
 	bool frame_end;
 	bool linked;
+	bool start_stream;
 	wait_queue_head_t done;
 	unsigned int burst;
 	atomic_t sequence;
diff --git a/drivers/media/platform/rockchip/isp/capture_v20.c b/drivers/media/platform/rockchip/isp/capture_v20.c
index 1b6f075556b7..b100e1aa3102 100644
--- a/drivers/media/platform/rockchip/isp/capture_v20.c
+++ b/drivers/media/platform/rockchip/isp/capture_v20.c
@@ -554,12 +554,20 @@ static int rkisp_stream_config_dcrop(struct rkisp_stream *stream, bool async)
 	struct rkisp_device *dev = stream->ispdev;
 	struct v4l2_rect *dcrop = &stream->dcrop;
 	struct v4l2_rect *input_win;
+	u32 src_w, src_h;
 
 	/* dual-crop unit get data from isp */
 	input_win = rkisp_get_isp_sd_win(&dev->isp_sdev);
+	src_w = input_win->width;
+	src_h = input_win->height;
 
-	if (dcrop->width == input_win->width &&
-	    dcrop->height == input_win->height &&
+	if (dev->isp_ver == ISP_V20 &&
+	    dev->csi_dev.rd_mode == HDR_RDBK_FRAME1 &&
+	    dev->isp_sdev.in_fmt.fmt_type == FMT_BAYER)
+		src_h += RKMODULE_EXTEND_LINE;
+
+	if (dcrop->width == src_w &&
+	    dcrop->height == src_h &&
 	    dcrop->left == 0 && dcrop->top == 0) {
 		rkisp_disable_dcrop(stream, async);
 		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
@@ -571,8 +579,7 @@ static int rkisp_stream_config_dcrop(struct rkisp_stream *stream, bool async)
 
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "stream %d crop: %dx%d -> %dx%d\n", stream->id,
-		 input_win->width, input_win->height,
-		 dcrop->width, dcrop->height);
+		 src_w, src_h, dcrop->width, dcrop->height);
 
 	return 0;
 }
@@ -590,7 +597,7 @@ static int rkisp_stream_config_rsz(struct rkisp_stream *stream, bool async)
 	u32 xsubs_out = 1, ysubs_out = 1;
 
 	if (input_isp_fmt->fmt_type == FMT_BAYER ||
-	    dev->br_dev.en)
+	    (dev->br_dev.en && stream->id != RKISP_STREAM_SP))
 		goto disable;
 
 	/* set input and output sizes for scale calculation */
@@ -607,8 +614,15 @@ static int rkisp_stream_config_rsz(struct rkisp_stream *stream, bool async)
 	in_c.width = in_y.width / xsubs_in;
 	in_c.height = in_y.height / ysubs_in;
 
-	if (output_isp_fmt->fmt_type == FMT_YUV) {
+	if (output_isp_fmt->fmt_type == FMT_YUV || output_isp_fmt->fmt_type == FMT_FBCGAIN) {
 		rkisp_fcc_xysubs(output_isp_fmt->fourcc, &xsubs_out, &ysubs_out);
+		if (stream->id == RKISP_STREAM_SP &&
+		    stream->out_isp_fmt.fmt_type == FMT_FBCGAIN &&
+		    !(dev->br_dev.work_mode & ISP_ISPP_422)) {
+			xsubs_out = 2;
+			ysubs_out = 1;
+		}
+
 		out_c.width = out_y.width / xsubs_out;
 		out_c.height = out_y.height / ysubs_out;
 	} else {
@@ -773,7 +787,7 @@ static int sp_config_mi(struct rkisp_stream *stream)
 	struct capture_fmt *output_isp_fmt = &stream->out_isp_fmt;
 	struct ispsd_out_fmt *input_isp_fmt =
 			rkisp_get_ispsd_out_fmt(&dev->isp_sdev);
-	u32 sp_in_fmt;
+	u32 sp_in_fmt, output_format;
 
 	if (mbus_code_sp_in_fmt(input_isp_fmt->mbus_code,
 				output_isp_fmt->fourcc, &sp_in_fmt)) {
@@ -806,8 +820,18 @@ static int sp_config_mi(struct rkisp_stream *stream)
 		sp_set_uv_swap(base);
 
 	config_mi_ctrl(stream, calc_burst_len(stream));
+	output_format = output_isp_fmt->output_format;
+	if (stream->id == RKISP_STREAM_SP &&
+	    stream->out_isp_fmt.fmt_type == FMT_FBCGAIN &&
+	    !(dev->br_dev.work_mode & ISP_ISPP_422)) {
+		sp_in_fmt = MI_CTRL_SP_INPUT_YUV422;
+		output_format = MI_CTRL_SP_OUTPUT_YUV422;
+		sp_set_y_width(base, 0);
+		sp_set_y_line_length(base, ALIGN(stream->out_fmt.width, 16));
+	}
+
 	sp_mi_ctrl_set_format(base, stream->out_isp_fmt.write_format |
-			      sp_in_fmt | output_isp_fmt->output_format);
+			      sp_in_fmt | output_format);
 
 	sp_mi_ctrl_autoupdate_en(base);
 
@@ -1330,6 +1354,7 @@ static int mi_frame_end(struct rkisp_stream *stream)
 	struct capture_fmt *isp_fmt = &stream->out_isp_fmt;
 	bool interlaced = stream->interlaced;
 	unsigned long lock_flags = 0;
+	u64 ns = 0;
 	int i = 0;
 
 	if (!stream->next_buf && stream->streaming &&
@@ -1345,7 +1370,6 @@ static int mi_frame_end(struct rkisp_stream *stream)
 	     (stream->u.sp.field_rec == RKISP_FIELD_ODD &&
 	      stream->u.sp.field == RKISP_FIELD_EVEN))) {
 		struct vb2_buffer *vb2_buf = &stream->curr_buf->vb.vb2_buf;
-		u64 ns = 0;
 
 		/* Dequeue a filled buffer */
 		for (i = 0; i < isp_fmt->mplanes; i++) {
@@ -1357,7 +1381,7 @@ static int mi_frame_end(struct rkisp_stream *stream)
 		    stream->id == RKISP_STREAM_SP)
 			rkisp_dmarx_get_frame(dev,
 					      &stream->curr_buf->vb.sequence,
-					      NULL, &ns, false);
+					      NULL, &ns, true);
 		else
 			stream->curr_buf->vb.sequence =
 				atomic_read(&stream->sequence) - 1;
@@ -1393,10 +1417,25 @@ static int mi_frame_end(struct rkisp_stream *stream)
 				vb2_buffer_done(vb2_buf, VB2_BUF_STATE_DONE);
 			}
 		} else {
-			vb2_buffer_done(vb2_buf, VB2_BUF_STATE_DONE);
+			if (stream->id == RKISP_STREAM_SP && isp_fmt->fmt_type == FMT_FBCGAIN) {
+				u32 sizeimage = vb2_plane_size(&stream->curr_buf->vb.vb2_buf, 0);
+				u32 *buf = (u32 *)vb2_plane_vaddr(&stream->curr_buf->vb.vb2_buf, 0);
+
+				*(u64 *)(buf + sizeimage / 4 - 2) = ktime_get_ns();
+				stream->curr_buf->dev_id = dev->dev_id;
+				rkisp_bridge_save_spbuf(dev, stream->curr_buf);
+			} else {
+				vb2_buffer_done(vb2_buf, VB2_BUF_STATE_DONE);
+			}
 		}
 
 		stream->curr_buf = NULL;
+	} else if (stream->id == RKISP_STREAM_SP && isp_fmt->fmt_type == FMT_FBCGAIN) {
+		u32 frm_id;
+
+		rkisp_dmarx_get_frame(dev, &frm_id, NULL, &ns, true);
+		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+			"use dummy buffer, lost sp data, frm_id %d\n", frm_id);
 	}
 
 	if (!interlaced ||
@@ -1515,6 +1554,9 @@ static int rkisp_start(struct rkisp_stream *stream)
 			!dev->cap_dev.stream[RKISP_STREAM_MP].streaming;
 	}
 
+	if (stream->id == RKISP_STREAM_SP && stream->out_isp_fmt.fmt_type == FMT_FBCGAIN)
+		is_update = false;
+
 	/* only MP support HDR mode, SP want to with HDR need
 	 * to start after MP.
 	 */
@@ -1572,10 +1614,21 @@ static int rkisp_queue_setup(struct vb2_queue *queue,
 		/* height to align with 16 when allocating memory
 		 * so that Rockchip encoder can use DMA buffer directly
 		 */
-		sizes[i] = (isp_fmt->fmt_type == FMT_YUV) ?
-			plane_fmt->sizeimage / pixm->height *
-			ALIGN(pixm->height, 16) :
-			plane_fmt->sizeimage;
+		switch (isp_fmt->fmt_type) {
+		case FMT_YUV:
+			sizes[i] = plane_fmt->sizeimage / pixm->height * ALIGN(pixm->height, 16);
+			break;
+		case FMT_FBCGAIN:
+			if (i == isp_fmt->mplanes - 1)
+				sizes[i] = sizeof(struct isp2x_ispgain_buf);
+			else
+				sizes[i] = plane_fmt->sizeimage / pixm->height *
+						ALIGN(pixm->height, 16) + RKISP_MOTION_DECT_TS_SIZE;
+			break;
+		default:
+			sizes[i] = plane_fmt->sizeimage;
+		}
+
 	}
 
 	rkisp_chk_tb_over(dev);
@@ -1614,7 +1667,7 @@ static void rkisp_buf_queue(struct vb2_buffer *vb)
 	 * NOTE: plane_fmt[0].sizeimage is total size of all planes for single
 	 * memory plane formats, so calculate the size explicitly.
 	 */
-	if (isp_fmt->mplanes == 1) {
+	if (isp_fmt->mplanes == 1 || isp_fmt->fmt_type == FMT_FBCGAIN) {
 		for (i = 0; i < isp_fmt->cplanes - 1; i++) {
 			ispbuf->buff_addr[i + 1] = (i == 0) ?
 				ispbuf->buff_addr[i] +
@@ -1629,6 +1682,9 @@ static void rkisp_buf_queue(struct vb2_buffer *vb)
 		 "stream:%d queue buf:0x%x\n",
 		 stream->id, ispbuf->buff_addr[0]);
 
+	if (stream->ispdev->send_fbcgain && stream->id == RKISP_STREAM_SP)
+		rkisp_bridge_sendtopp_buffer(stream->ispdev, stream->ispdev->dev_id, vb->index);
+
 	spin_lock_irqsave(&stream->vbq_lock, lock_flags);
 
 	/* XXX: replace dummy to speed up  */
@@ -1727,12 +1783,14 @@ static void rkisp_stop_streaming(struct vb2_queue *queue)
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "%s %d\n", __func__, stream->id);
 
-	if (!stream->streaming)
-		return;
+	if (stream->id != RKISP_STREAM_SP || stream->out_isp_fmt.fmt_type != FMT_FBCGAIN) {
+		if (!stream->streaming)
+			return;
+		rkisp_stream_stop(stream);
+	}
 
-	rkisp_stream_stop(stream);
 	if (stream->id == RKISP_STREAM_MP ||
-	    stream->id == RKISP_STREAM_SP) {
+	    (stream->id == RKISP_STREAM_SP && stream->out_isp_fmt.fmt_type != FMT_FBCGAIN)) {
 		/* call to the other devices */
 		media_pipeline_stop(&node->vdev.entity);
 		ret = dev->pipe.set_stream(&dev->pipe, false);
@@ -1741,6 +1799,8 @@ static void rkisp_stop_streaming(struct vb2_queue *queue)
 				 "pipeline stream-off failed:%d\n", ret);
 	}
 
+	rkisp_stop_spstream(stream);
+
 	/* release buffers */
 	destroy_buf_queue(stream, VB2_BUF_STATE_ERROR);
 
@@ -1749,6 +1809,11 @@ static void rkisp_stop_streaming(struct vb2_queue *queue)
 		v4l2_err(v4l2_dev, "pipeline close failed error:%d\n", ret);
 	rkisp_destroy_dummy_buf(stream);
 	atomic_dec(&dev->cap_dev.refcnt);
+	stream->start_stream = false;
+	if (stream->id == RKISP_STREAM_SP && stream->out_isp_fmt.fmt_type == FMT_FBCGAIN) {
+		stream->out_isp_fmt.fmt_type = FMT_YUV;
+		stream->out_isp_fmt.fourcc = V4L2_PIX_FMT_NV12;
+	}
 }
 
 static int rkisp_stream_start(struct rkisp_stream *stream)
@@ -1801,8 +1866,10 @@ rkisp_start_streaming(struct vb2_queue *queue, unsigned int count)
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "%s %d\n", __func__, stream->id);
 
-	if (WARN_ON(stream->streaming))
-		return -EBUSY;
+	if (stream->id != RKISP_STREAM_SP || stream->out_isp_fmt.fmt_type != FMT_FBCGAIN) {
+		if (WARN_ON(stream->streaming))
+			return -EBUSY;
+	}
 
 	atomic_inc(&dev->cap_dev.refcnt);
 	if (!dev->isp_inp || !stream->linked) {
@@ -1843,15 +1910,18 @@ rkisp_start_streaming(struct vb2_queue *queue, unsigned int count)
 		goto destroy_dummy_buf;
 	}
 
-	/* configure stream hardware to start */
-	ret = rkisp_stream_start(stream);
-	if (ret < 0) {
-		v4l2_err(v4l2_dev, "start streaming failed\n");
-		goto close_pipe;
+	if (stream->id != RKISP_STREAM_SP ||
+	    (stream->id == RKISP_STREAM_SP && stream->out_isp_fmt.fmt_type != FMT_FBCGAIN)) {
+		/* configure stream hardware to start */
+		ret = rkisp_stream_start(stream);
+		if (ret < 0) {
+			v4l2_err(v4l2_dev, "start streaming failed\n");
+			goto close_pipe;
+		}
 	}
 
 	if (stream->id == RKISP_STREAM_MP ||
-	    stream->id == RKISP_STREAM_SP) {
+	    (stream->id == RKISP_STREAM_SP && stream->out_isp_fmt.fmt_type != FMT_FBCGAIN)) {
 		/* start sub-devices */
 		ret = dev->pipe.set_stream(&dev->pipe, true);
 		if (ret < 0)
@@ -1865,6 +1935,7 @@ rkisp_start_streaming(struct vb2_queue *queue, unsigned int count)
 		}
 	}
 
+	stream->start_stream = true;
 	return 0;
 
 pipe_stream_off:
@@ -1931,7 +2002,7 @@ static int rkisp_stream_init(struct rkisp_device *dev, u32 id)
 
 	stream->linked = MEDIA_LNK_FL_ENABLED;
 	/* isp2 disable MP/SP, enable BRIDGE default */
-	if (id == RKISP_STREAM_SP || id == RKISP_STREAM_MP)
+	if (id == RKISP_STREAM_MP)
 		stream->linked = false;
 
 	switch (id) {
@@ -2046,6 +2117,79 @@ void rkisp_unregister_stream_v20(struct rkisp_device *dev)
 	rkisp_unregister_stream_vdev(stream);
 }
 
+void rkisp_spbuf_queue(struct rkisp_stream *stream, struct rkisp_buffer *sp_buf)
+{
+	unsigned long lock_flags = 0;
+
+	spin_lock_irqsave(&stream->vbq_lock, lock_flags);
+	/* XXX: replace dummy to speed up  */
+	if (stream->streaming &&
+	    !stream->next_buf &&
+	    !stream->interlaced &&
+	    stream->id != RKISP_STREAM_DMATX0 &&
+	    stream->id != RKISP_STREAM_DMATX1 &&
+	    stream->id != RKISP_STREAM_DMATX2 &&
+	    stream->id != RKISP_STREAM_DMATX3 &&
+	    atomic_read(&stream->ispdev->isp_sdev.frm_sync_seq) == 0) {
+		stream->next_buf = sp_buf;
+		stream->ops->update_mi(stream);
+	} else {
+		list_add_tail(&sp_buf->queue, &stream->buf_queue);
+	}
+	spin_unlock_irqrestore(&stream->vbq_lock, lock_flags);
+}
+
+int rkisp_start_spstream(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
+	int ret = -1;
+
+	dev->send_fbcgain = false;
+	if (stream->id == RKISP_STREAM_SP && stream->out_isp_fmt.fmt_type == FMT_FBCGAIN) {
+		/* configure stream hardware to start */
+		ret = rkisp_stream_start(stream);
+		if (ret < 0) {
+			v4l2_err(v4l2_dev, "start streaming failed\n");
+			return ret;
+		}
+		dev->send_fbcgain = true;
+	}
+
+	return 0;
+}
+
+void rkisp_stop_spstream(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	unsigned long lock_flags = 0;
+
+	if (stream->id == RKISP_STREAM_SP && stream->out_isp_fmt.fmt_type == FMT_FBCGAIN) {
+		rkisp_stream_stop(stream);
+		rkisp_bridge_stop_spstream(dev);
+		dev->send_fbcgain = false;
+
+		spin_lock_irqsave(&stream->vbq_lock, lock_flags);
+		if (stream->curr_buf) {
+			list_add_tail(&stream->curr_buf->queue, &stream->buf_queue);
+			if (stream->curr_buf == stream->next_buf)
+				stream->next_buf = NULL;
+			stream->curr_buf = NULL;
+		}
+		if (stream->next_buf) {
+			list_add_tail(&stream->next_buf->queue, &stream->buf_queue);
+			stream->next_buf = NULL;
+		}
+		spin_unlock_irqrestore(&stream->vbq_lock, lock_flags);
+	}
+}
+
+void rkisp_update_spstream_buf(struct rkisp_stream *stream)
+{
+	if (stream->id == RKISP_STREAM_SP && stream->out_isp_fmt.fmt_type == FMT_FBCGAIN)
+		mi_frame_end(stream);
+}
+
 /****************  Interrupter Handler ****************/
 
 void rkisp_mi_v20_isr(u32 mis_val, struct rkisp_device *dev)
@@ -2056,8 +2200,6 @@ void rkisp_mi_v20_isr(u32 mis_val, struct rkisp_device *dev)
 	v4l2_dbg(3, rkisp_debug, &dev->v4l2_dev,
 		 "mi isr:0x%x\n", mis_val);
 
-	rkisp_bridge_isr(&mis_val, dev);
-
 	if (mis_val & CIF_MI_DMA_READY)
 		rkisp_dmarx_isr(mis_val, dev);
 
@@ -2108,6 +2250,8 @@ void rkisp_mi_v20_isr(u32 mis_val, struct rkisp_device *dev)
 			}
 		}
 	}
+
+	rkisp_bridge_isr(&mis_val, dev);
 }
 
 void rkisp_mipi_v20_isr(unsigned int phy, unsigned int packet,
diff --git a/drivers/media/platform/rockchip/isp/capture_v2x.h b/drivers/media/platform/rockchip/isp/capture_v2x.h
index ceba63018e24..8a2365809012 100644
--- a/drivers/media/platform/rockchip/isp/capture_v2x.h
+++ b/drivers/media/platform/rockchip/isp/capture_v2x.h
@@ -9,6 +9,8 @@ extern struct stream_config rkisp2_dmatx1_stream_config;
 extern struct stream_config rkisp2_dmatx2_stream_config;
 extern struct stream_config rkisp2_dmatx3_stream_config;
 
+struct rkisp_stream;
+
 struct rkisp_dummy_buffer *hdr_dqbuf(struct list_head *q);
 void hdr_qbuf(struct list_head *q, struct rkisp_dummy_buffer *buf);
 int hdr_config_dmatx(struct rkisp_device *dev);
@@ -26,4 +28,10 @@ int rkisp_register_stream_v21(struct rkisp_device *dev);
 void rkisp_unregister_stream_v21(struct rkisp_device *dev);
 void rkisp_mi_v21_isr(u32 mis_val, struct rkisp_device *dev);
 void rkisp_mipi_v21_isr(u32 phy, u32 packet, u32 overflow, u32 state, struct rkisp_device *dev);
+
+void rkisp_spbuf_queue(struct rkisp_stream *stream, struct rkisp_buffer *sp_buf);
+int rkisp_start_spstream(struct rkisp_stream *stream);
+void rkisp_stop_spstream(struct rkisp_stream *stream);
+void rkisp_update_spstream_buf(struct rkisp_stream *stream);
+
 #endif
diff --git a/drivers/media/platform/rockchip/isp/common.c b/drivers/media/platform/rockchip/isp/common.c
index d780b4716dc5..328e5a79afee 100644
--- a/drivers/media/platform/rockchip/isp/common.c
+++ b/drivers/media/platform/rockchip/isp/common.c
@@ -119,7 +119,7 @@ int rkisp_alloc_buffer(struct rkisp_device *dev,
 }
 
 void rkisp_free_buffer(struct rkisp_device *dev,
-		       struct rkisp_dummy_buffer *buf)
+			struct rkisp_dummy_buffer *buf)
 {
 	const struct vb2_mem_ops *g_ops = dev->hw_dev->mem_ops;
 
@@ -140,6 +140,24 @@ void rkisp_free_buffer(struct rkisp_device *dev,
 	}
 }
 
+void rkisp_prepare_buffer(struct rkisp_device *dev,
+			struct rkisp_dummy_buffer *buf)
+{
+	const struct vb2_mem_ops *g_ops = dev->hw_dev->mem_ops;
+
+	if (buf && buf->mem_priv)
+		g_ops->prepare(buf->mem_priv);
+}
+
+void rkisp_finish_buffer(struct rkisp_device *dev,
+			struct rkisp_dummy_buffer *buf)
+{
+	const struct vb2_mem_ops *g_ops = dev->hw_dev->mem_ops;
+
+	if (buf && buf->mem_priv)
+		g_ops->finish(buf->mem_priv);
+}
+
 int rkisp_attach_hw(struct rkisp_device *isp)
 {
 	struct device_node *np;
diff --git a/drivers/media/platform/rockchip/isp/common.h b/drivers/media/platform/rockchip/isp/common.h
index 898dc8afb9f3..99a47573c991 100644
--- a/drivers/media/platform/rockchip/isp/common.h
+++ b/drivers/media/platform/rockchip/isp/common.h
@@ -63,6 +63,8 @@
 #define RKISP_EMDDATA_FIFO_MAX		4
 #define RKISP_DMATX_CHECK              0xA5A5A5A5
 
+#define RKISP_MOTION_DECT_TS_SIZE	16
+
 struct rkisp_device;
 
 /* ISP_V10_1 for only support MP */
@@ -96,6 +98,7 @@ enum rkisp_fmt_pix_type {
 	FMT_RGB,
 	FMT_BAYER,
 	FMT_JPEG,
+	FMT_FBCGAIN,
 	FMT_MAX
 };
 
@@ -109,6 +112,7 @@ enum rkisp_fmt_raw_pat_type {
 struct rkisp_buffer {
 	struct vb2_v4l2_buffer vb;
 	struct list_head queue;
+	int dev_id;
 	union {
 		u32 buff_addr[VIDEO_MAX_PLANES];
 		void *vaddr[VIDEO_MAX_PLANES];
@@ -164,6 +168,9 @@ void rkisp_update_regs(struct rkisp_device *dev, u32 start, u32 end);
 
 int rkisp_alloc_buffer(struct rkisp_device *dev, struct rkisp_dummy_buffer *buf);
 void rkisp_free_buffer(struct rkisp_device *dev, struct rkisp_dummy_buffer *buf);
+void rkisp_prepare_buffer(struct rkisp_device *dev, struct rkisp_dummy_buffer *buf);
+void rkisp_finish_buffer(struct rkisp_device *dev, struct rkisp_dummy_buffer *buf);
+
 int rkisp_attach_hw(struct rkisp_device *isp);
 int rkisp_alloc_common_dummy_buf(struct rkisp_device *dev);
 void rkisp_free_common_dummy_buf(struct rkisp_device *dev);
diff --git a/drivers/media/platform/rockchip/isp/csi.c b/drivers/media/platform/rockchip/isp/csi.c
index 4e171f82de3a..3e65068c894b 100644
--- a/drivers/media/platform/rockchip/isp/csi.c
+++ b/drivers/media/platform/rockchip/isp/csi.c
@@ -2,6 +2,7 @@
 /* Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd. */
 
 #include <linux/delay.h>
+#include <linux/iopoll.h>
 #include <linux/pm_runtime.h>
 #include <linux/rk-camera-module.h>
 #include <media/v4l2-common.h>
diff --git a/drivers/media/platform/rockchip/isp/dev.h b/drivers/media/platform/rockchip/isp/dev.h
index 0ff1199c7aa7..d42de2d25f06 100644
--- a/drivers/media/platform/rockchip/isp/dev.h
+++ b/drivers/media/platform/rockchip/isp/dev.h
@@ -215,5 +215,8 @@ struct rkisp_device {
 	unsigned int skip_frame;
 	unsigned int irq_ends;
 	unsigned int irq_ends_mask;
+	bool send_fbcgain;
+	struct rkisp_ispp_buf *cur_fbcgain;
+	struct rkisp_buffer *cur_spbuf;
 };
 #endif
diff --git a/drivers/media/platform/rockchip/isp/hw.c b/drivers/media/platform/rockchip/isp/hw.c
index 9c391d0e3f6d..b2378f663522 100644
--- a/drivers/media/platform/rockchip/isp/hw.c
+++ b/drivers/media/platform/rockchip/isp/hw.c
@@ -711,10 +711,12 @@ static int rkisp_hw_probe(struct platform_device *pdev)
 	atomic_set(&hw_dev->refcnt, 0);
 	spin_lock_init(&hw_dev->buf_lock);
 	INIT_LIST_HEAD(&hw_dev->list);
+	INIT_LIST_HEAD(&hw_dev->rpt_list);
 	hw_dev->is_idle = true;
 	hw_dev->is_single = true;
 	hw_dev->is_mi_update = false;
 	hw_dev->is_dma_contig = true;
+	hw_dev->is_buf_init = false;
 	hw_dev->is_mmu = is_iommu_enable(dev);
 	if (!hw_dev->is_mmu)
 		hw_dev->mem_ops = &vb2_dma_contig_memops;
diff --git a/drivers/media/platform/rockchip/isp/hw.h b/drivers/media/platform/rockchip/isp/hw.h
index 233da2ef002b..df1356af4d3d 100644
--- a/drivers/media/platform/rockchip/isp/hw.h
+++ b/drivers/media/platform/rockchip/isp/hw.h
@@ -52,6 +52,7 @@ struct rkisp_hw_dev {
 	struct rkisp_ispp_buf *cur_buf;
 	struct rkisp_ispp_buf *nxt_buf;
 	struct list_head list;
+	struct list_head rpt_list;
 	struct rkisp_dummy_buffer dummy_buf;
 	const struct vb2_mem_ops *mem_ops;
 	bool is_dma_contig;
@@ -63,6 +64,7 @@ struct rkisp_hw_dev {
 
 	bool is_feature_on;
 	u64 iq_feature;
+	bool is_buf_init;
 };
 
 int rkisp_register_irq(struct rkisp_hw_dev *dev);
diff --git a/drivers/media/platform/rockchip/isp/isp_ispp.h b/drivers/media/platform/rockchip/isp/isp_ispp.h
index 10297362e420..c6b152a9acf0 100644
--- a/drivers/media/platform/rockchip/isp/isp_ispp.h
+++ b/drivers/media/platform/rockchip/isp/isp_ispp.h
@@ -96,11 +96,19 @@ struct rkisp_ispp_reg {
 struct rkisp_ispp_buf {
 	struct list_head list;
 	struct dma_buf *dbuf[GROUP_BUF_MAX];
+	int dfd[GROUP_BUF_MAX];
+	u32 didx[GROUP_BUF_MAX];
 	/* timestamp in ns */
 	u64 frame_timestamp;
 	u32 frame_id;
 	u32 index;
 	bool is_isp;
+	bool is_move_judge;
+	u32 buf_idx;
+	u32 gain_dmaidx;
+	u32 mfbc_dmaidx;
+	u32 gain_size;
+	u32 mfbc_size;
 };
 
 #if IS_BUILTIN(CONFIG_VIDEO_ROCKCHIP_ISP) && IS_BUILTIN(CONFIG_VIDEO_ROCKCHIP_ISPP)
diff --git a/drivers/media/platform/rockchip/isp/rkisp.c b/drivers/media/platform/rockchip/isp/rkisp.c
index 1d1bd0349efd..fcb310a451a1 100644
--- a/drivers/media/platform/rockchip/isp/rkisp.c
+++ b/drivers/media/platform/rockchip/isp/rkisp.c
@@ -1750,9 +1750,6 @@ static int rkisp_subdev_link_setup(struct media_entity *entity,
 		}
 	} else if (!strcmp(remote->entity->name, SP_VDEV_NAME)) {
 		stream = &dev->cap_dev.stream[RKISP_STREAM_SP];
-		if (flags & MEDIA_LNK_FL_ENABLED &&
-		    dev->br_dev.linked)
-			goto err;
 	} else if (!strcmp(remote->entity->name, MP_VDEV_NAME)) {
 		stream = &dev->cap_dev.stream[RKISP_STREAM_MP];
 		if (flags & MEDIA_LNK_FL_ENABLED &&
@@ -1760,8 +1757,7 @@ static int rkisp_subdev_link_setup(struct media_entity *entity,
 			goto err;
 	} else if (!strcmp(remote->entity->name, BRIDGE_DEV_NAME)) {
 		if (flags & MEDIA_LNK_FL_ENABLED &&
-		    (dev->cap_dev.stream[RKISP_STREAM_SP].linked ||
-		     dev->cap_dev.stream[RKISP_STREAM_MP].linked))
+		    dev->cap_dev.stream[RKISP_STREAM_MP].linked)
 			goto err;
 		dev->br_dev.linked = flags & MEDIA_LNK_FL_ENABLED;
 	} else if (!strcmp(remote->entity->name, "rockchip-mipi-dphy-rx")) {
@@ -1863,6 +1859,7 @@ static long rkisp_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkisp_ldchbuf_info *ldchbuf;
 	struct rkisp_ldchbuf_size *ldchsize;
 	struct rkisp_thunderboot_shmem *shmem;
+	struct isp2x_buf_idxfd *idxfd;
 	void *resmem_va;
 	long ret = 0;
 
@@ -1925,6 +1922,10 @@ static long rkisp_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		shmem = (struct rkisp_thunderboot_shmem *)arg;
 		ret = rkisp_tb_shm_ioctl(shmem);
 		break;
+	case RKISP_CMD_GET_FBCBUF_FD:
+		idxfd = (struct isp2x_buf_idxfd *)arg;
+		ret = rkisp_bridge_get_fbcbuf_fd(isp_dev, idxfd);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 	}
@@ -1942,6 +1943,7 @@ static long rkisp_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkisp_ldchbuf_info ldchbuf;
 	struct rkisp_ldchbuf_size ldchsize;
 	struct rkisp_thunderboot_shmem shmem;
+	struct isp2x_buf_idxfd idxfd;
 	long ret = 0;
 	int mode;
 
@@ -1985,6 +1987,11 @@ static long rkisp_compat_ioctl32(struct v4l2_subdev *sd,
 				ret = copy_to_user(up, &shmem, sizeof(shmem));
 		}
 		break;
+	case RKISP_CMD_GET_FBCBUF_FD:
+		ret = rkisp_ioctl(sd, cmd, &idxfd);
+		if (!ret)
+			ret = copy_to_user(up, &idxfd, sizeof(idxfd));
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 	}
diff --git a/drivers/media/platform/rockchip/ispp/common.c b/drivers/media/platform/rockchip/ispp/common.c
index 1e54f0c8ec10..5bba87195b12 100644
--- a/drivers/media/platform/rockchip/ispp/common.c
+++ b/drivers/media/platform/rockchip/ispp/common.c
@@ -138,6 +138,24 @@ void rkispp_free_buffer(struct rkispp_device *dev,
 	}
 }
 
+void rkispp_prepare_buffer(struct rkispp_device *dev,
+			struct rkispp_dummy_buffer *buf)
+{
+	const struct vb2_mem_ops *g_ops = dev->hw_dev->mem_ops;
+
+	if (buf && buf->mem_priv)
+		g_ops->prepare(buf->mem_priv);
+}
+
+void rkispp_finish_buffer(struct rkispp_device *dev,
+			struct rkispp_dummy_buffer *buf)
+{
+	const struct vb2_mem_ops *g_ops = dev->hw_dev->mem_ops;
+
+	if (buf && buf->mem_priv)
+		g_ops->finish(buf->mem_priv);
+}
+
 int rkispp_attach_hw(struct rkispp_device *ispp)
 {
 	struct device_node *np;
@@ -261,6 +279,7 @@ static void rkispp_free_pool(struct rkispp_hw_dev *hw)
 	}
 
 	rkispp_free_regbuf(hw);
+	hw->is_idle = true;
 }
 
 static int rkispp_init_pool(struct rkispp_hw_dev *hw, struct rkisp_ispp_buf *dbufs)
@@ -303,8 +322,11 @@ static int rkispp_init_pool(struct rkispp_hw_dev *hw, struct rkisp_ispp_buf *dbu
 		if (rkispp_debug)
 			dev_info(hw->dev, "%s dma[%d]:0x%x\n",
 				 __func__, i, (u32)pool->dma[i]);
+
+		pool->vaddr[i] = g_ops->vaddr(mem);
 	}
 	rkispp_init_regbuf(hw);
+	hw->is_idle = true;
 	return ret;
 err:
 	rkispp_free_pool(hw);
diff --git a/drivers/media/platform/rockchip/ispp/common.h b/drivers/media/platform/rockchip/ispp/common.h
index 6cbf20722397..7b638394c6d5 100644
--- a/drivers/media/platform/rockchip/ispp/common.h
+++ b/drivers/media/platform/rockchip/ispp/common.h
@@ -40,6 +40,7 @@ struct rkispp_isp_buf_pool {
 	struct rkisp_ispp_buf *dbufs;
 	void *mem_priv[GROUP_BUF_MAX];
 	dma_addr_t dma[GROUP_BUF_MAX];
+	void *vaddr[GROUP_BUF_MAX];
 };
 
 /* One structure per video node */
@@ -69,6 +70,7 @@ struct rkispp_dummy_buffer {
 	u64 timestamp;
 	u32 size;
 	u32 id;
+	u32 index;
 	int dma_fd;
 	bool is_need_vaddr;
 	bool is_need_dbuf;
@@ -113,6 +115,10 @@ int rkispp_allow_buffer(struct rkispp_device *dev,
 			struct rkispp_dummy_buffer *buf);
 void rkispp_free_buffer(struct rkispp_device *dev,
 			struct rkispp_dummy_buffer *buf);
+void rkispp_prepare_buffer(struct rkispp_device *dev,
+			struct rkispp_dummy_buffer *buf);
+void rkispp_finish_buffer(struct rkispp_device *dev,
+			struct rkispp_dummy_buffer *buf);
 
 int rkispp_attach_hw(struct rkispp_device *ispp);
 int rkispp_event_handle(struct rkispp_device *ispp, u32 cmd, void *arg);
diff --git a/drivers/media/platform/rockchip/ispp/ispp.c b/drivers/media/platform/rockchip/ispp/ispp.c
index 7cbb523277cc..9ee64a433b4a 100644
--- a/drivers/media/platform/rockchip/ispp/ispp.c
+++ b/drivers/media/platform/rockchip/ispp/ispp.c
@@ -8,6 +8,7 @@
 #include <linux/videodev2.h>
 #include <media/media-entity.h>
 #include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-event.h>
 
 #include "dev.h"
 #include "regs.h"
@@ -398,6 +399,12 @@ static long rkispp_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		rkispp_reg_withstream = arg;
 		*rkispp_reg_withstream = rkispp_get_reg_withstream();
 		break;
+	case RKISPP_CMD_TRIGGER_YNRRUN:
+		rkispp_sendbuf_to_nr(ispp_dev, (struct rkispp_tnr_inf *)arg);
+		break;
+	case RKISPP_CMD_GET_TNRBUF_FD:
+		ret = rkispp_get_tnrbuf_fd(ispp_dev, (struct rkispp_buf_idxfd *)arg);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 	}
@@ -412,6 +419,8 @@ static long rkispp_compat_ioctl32(struct v4l2_subdev *sd,
 	void __user *up = compat_ptr(arg);
 	struct rkispp_fecbuf_info fecbuf;
 	struct rkispp_fecbuf_size fecsize;
+	struct rkispp_tnr_inf tnr_inf;
+	struct rkispp_buf_idxfd idxfd;
 	long ret = 0;
 
 	if (!up)
@@ -428,6 +437,16 @@ static long rkispp_compat_ioctl32(struct v4l2_subdev *sd,
 		if (!ret)
 			ret = rkispp_ioctl(sd, cmd, &fecsize);
 		break;
+	case RKISPP_CMD_TRIGGER_YNRRUN:
+		ret = copy_from_user(&tnr_inf, up, sizeof(tnr_inf));
+		if (!ret)
+			ret = rkispp_ioctl(sd, cmd, &tnr_inf);
+		break;
+	case RKISPP_CMD_GET_TNRBUF_FD:
+		ret = rkispp_ioctl(sd, cmd, &idxfd);
+		if (!ret)
+			ret = copy_to_user(up, &idxfd, sizeof(idxfd));
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 	}
@@ -436,6 +455,18 @@ static long rkispp_compat_ioctl32(struct v4l2_subdev *sd,
 }
 #endif
 
+static int rkispp_subscribe_event(struct v4l2_subdev *sd,
+				  struct v4l2_fh *fh,
+				  struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case RKISPP_V4L2_EVENT_TNR_COMPLETE:
+		return v4l2_event_subscribe(fh, sub, RKISPP_BUF_MAX, NULL);
+	default:
+		return -EINVAL;
+	}
+}
+
 static const struct media_entity_operations rkispp_sd_media_ops = {
 	.link_setup = rkispp_subdev_link_setup,
 	.link_validate = v4l2_subdev_link_validate,
@@ -459,6 +490,8 @@ static const struct v4l2_subdev_core_ops rkispp_sd_core_ops = {
 #ifdef CONFIG_COMPAT
 	.compat_ioctl32 = rkispp_compat_ioctl32,
 #endif
+	.subscribe_event = rkispp_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
 };
 
 static struct v4l2_subdev_ops rkispp_sd_ops = {
@@ -479,7 +512,7 @@ int rkispp_register_subdev(struct rkispp_device *dev,
 	sd = &ispp_sdev->sd;
 	ispp_sdev->state = ISPP_STOP;
 	v4l2_subdev_init(sd, &rkispp_sd_ops);
-	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
 	sd->entity.ops = &rkispp_sd_media_ops;
 	snprintf(sd->name, sizeof(sd->name), "rkispp-subdev");
 	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_COMPOSER;
diff --git a/drivers/media/platform/rockchip/ispp/stream.c b/drivers/media/platform/rockchip/ispp/stream.c
index 5308b472764e..fbb53d65224c 100644
--- a/drivers/media/platform/rockchip/ispp/stream.c
+++ b/drivers/media/platform/rockchip/ispp/stream.c
@@ -577,10 +577,17 @@ static void tnr_free_buf(struct rkispp_device *dev)
 		dbufs = get_list_buf(list, true);
 		kfree(dbufs);
 	}
+	list = &vdev->tnr.list_rpt;
+	while (!list_empty(list)) {
+		dbufs = get_list_buf(list, true);
+		kfree(dbufs);
+	}
 
 	for (i = 0; i < sizeof(vdev->tnr.buf) /
 	     sizeof(struct rkispp_dummy_buffer); i++)
 		rkispp_free_buffer(dev, &vdev->tnr.buf.iir + i);
+
+	vdev->tnr.is_but_init = false;
 }
 
 static int tnr_init_buf(struct rkispp_device *dev,
@@ -590,6 +597,7 @@ static int tnr_init_buf(struct rkispp_device *dev,
 	struct rkisp_ispp_buf *dbufs;
 	struct rkispp_dummy_buffer *buf;
 	int i, j, ret, cnt = RKISPP_BUF_MAX;
+	u32 buf_idx = 0;
 
 	if (dev->inp == INP_ISP && dev->isp_mode & ISP_ISPP_QUICK)
 		cnt = 1;
@@ -603,13 +611,17 @@ static int tnr_init_buf(struct rkispp_device *dev,
 		for (j = 0; j < GROUP_BUF_MAX; j++) {
 			buf = &vdev->tnr.buf.wr[i][j];
 			buf->is_need_dbuf = true;
-			buf->size = !j ? pic_size : gain_size;
+			buf->is_need_dmafd = false;
+			buf->is_need_vaddr = true;
+			buf->size = !j ? pic_size : PAGE_ALIGN(gain_size);
+			buf->index = buf_idx++;
 			ret = rkispp_allow_buffer(dev, buf);
 			if (ret) {
 				kfree(dbufs);
 				goto err;
 			}
 			dbufs->dbuf[j] = buf->dbuf;
+			dbufs->didx[j] = buf->index;
 		}
 		list_add_tail(&dbufs->list, &vdev->tnr.list_wr);
 	}
@@ -623,10 +635,16 @@ static int tnr_init_buf(struct rkispp_device *dev,
 	}
 
 	buf = &vdev->tnr.buf.gain_kg;
-	buf->size = gain_size * 4;
+	buf->is_need_vaddr = true;
+	buf->is_need_dbuf = true;
+	buf->is_need_dmafd = false;
+	buf->size = PAGE_ALIGN(gain_size * 4);
+	buf->index = buf_idx++;
 	ret = rkispp_allow_buffer(dev, buf);
 	if (ret < 0)
 		goto err;
+
+	vdev->tnr.is_but_init = true;
 	return 0;
 err:
 	tnr_free_buf(dev);
@@ -1064,6 +1082,20 @@ static void rkispp_stop_3a_run(struct rkispp_device *dev)
 			 "Waiting for 3A off use %d ms\n", 1000 - ret);
 }
 
+static void rkispp_tnr_complete(struct rkispp_device *dev, struct rkispp_tnr_inf *inf)
+{
+	struct rkispp_subdev *ispp_sdev = &dev->ispp_sdev;
+	struct v4l2_event ev = {
+		.type = RKISPP_V4L2_EVENT_TNR_COMPLETE,
+	};
+	struct rkispp_tnr_inf *tnr_inf;
+
+	tnr_inf = (struct rkispp_tnr_inf *)ev.u.data;
+	memcpy(tnr_inf, inf, sizeof(*tnr_inf));
+
+	v4l2_subdev_notify_event(&ispp_sdev->sd, &ev);
+}
+
 static int config_modules(struct rkispp_device *dev)
 {
 	int ret;
@@ -2639,6 +2671,8 @@ static void tnr_work_event(struct rkispp_device *dev,
 	bool is_3to1 = vdev->tnr.is_3to1, is_start = false, is_skip = false;
 	bool is_en = rkispp_read(dev, RKISPP_TNR_CORE_CTRL) & SW_TNR_EN;
 	struct rkisp_ispp_reg *reg_buf;
+	u32 *vaddr, buf_size;
+	u64 pic_ts, gain_ts;
 
 	if (!(vdev->module_ens & ISPP_MODULE_TNR) ||
 	    (dev->inp == INP_ISP && dev->isp_mode & ISP_ISPP_QUICK))
@@ -2663,9 +2697,26 @@ static void tnr_work_event(struct rkispp_device *dev,
 		}
 
 		if (vdev->tnr.cur_wr) {
-			/* tnr write buf to nr */
-			rkispp_module_work_event(dev, vdev->tnr.cur_wr, NULL,
-						 ISPP_MODULE_NR, is_isr);
+			struct rkispp_tnr_inf tnr_inf;
+
+			if (!vdev->tnr.cur_wr->is_move_judge) {
+				/* tnr write buf to nr */
+				rkispp_module_work_event(dev, vdev->tnr.cur_wr, NULL,
+							 ISPP_MODULE_NR, is_isr);
+			} else {
+				tnr_inf.dev_id = dev->dev_id;
+				tnr_inf.frame_id = vdev->tnr.cur_wr->frame_id;
+				tnr_inf.gainkg_idx = vdev->tnr.buf.gain_kg.index;
+				tnr_inf.gainwr_idx = vdev->tnr.cur_wr->didx[GROUP_BUF_GAIN];
+				tnr_inf.gainkg_size = vdev->tnr.buf.gain_kg.size;
+				dbuf = vdev->tnr.cur_wr->dbuf[GROUP_BUF_GAIN];
+				dummy = dbuf_to_dummy(dbuf, &vdev->tnr.buf.iir, size);
+				tnr_inf.gainwr_size = dummy->size;
+				rkispp_finish_buffer(dev, dummy);
+				rkispp_finish_buffer(dev, &vdev->tnr.buf.gain_kg);
+				rkispp_tnr_complete(dev, &tnr_inf);
+				list_add_tail(&vdev->tnr.cur_wr->list, &vdev->tnr.list_rpt);
+			}
 			vdev->tnr.cur_wr = NULL;
 		}
 	}
@@ -2747,21 +2798,43 @@ static void tnr_work_event(struct rkispp_device *dev,
 		} else {
 			buf = get_pool_buf(dev, vdev->tnr.cur_rd);
 			val = buf->dma[GROUP_BUF_PIC];
+			vaddr = (u32 *)buf->vaddr[GROUP_BUF_PIC];
+			buf_size = buf->dbufs->dbuf[GROUP_BUF_PIC]->size;
+			pic_ts = *(u64 *)(vaddr + buf_size / 4 - 2);
 			rkispp_write(dev, RKISPP_TNR_CUR_Y_BASE, val);
 			val += vdev->tnr.uv_offset;
 			rkispp_write(dev, RKISPP_TNR_CUR_UV_BASE, val);
 
 			val = buf->dma[GROUP_BUF_GAIN];
+			vaddr = (u32 *)buf->vaddr[GROUP_BUF_GAIN];
+			buf_size = buf->dbufs->dbuf[GROUP_BUF_GAIN]->size;
+			gain_ts = *(u64 *)(vaddr + buf_size / 4 - 2);
+			if (abs(pic_ts - gain_ts) > 5000000LL) {
+				v4l2_info(&dev->v4l2_dev,
+					"%s: frame %d, timestamp is not match (pic_ts %lld, gain_ts %lld)",
+					__func__, vdev->tnr.nxt_rd->frame_id, pic_ts, gain_ts);
+			}
 			rkispp_write(dev, RKISPP_TNR_GAIN_CUR_Y_BASE, val);
 			if (is_3to1) {
 				buf = get_pool_buf(dev, vdev->tnr.nxt_rd);
 				val = buf->dma[GROUP_BUF_PIC];
+				vaddr = (u32 *)buf->vaddr[GROUP_BUF_PIC];
+				buf_size = buf->dbufs->dbuf[GROUP_BUF_PIC]->size;
+				pic_ts = *(u64 *)(vaddr + buf_size / 4 - 2);
 				rkispp_write(dev, RKISPP_TNR_NXT_Y_BASE, val);
 				val += vdev->tnr.uv_offset;
 				rkispp_write(dev, RKISPP_TNR_NXT_UV_BASE, val);
 
 				val = buf->dma[GROUP_BUF_GAIN];
 				rkispp_write(dev, RKISPP_TNR_GAIN_NXT_Y_BASE, val);
+				vaddr = (u32 *)buf->vaddr[GROUP_BUF_GAIN];
+				buf_size = buf->dbufs->dbuf[GROUP_BUF_GAIN]->size;
+				gain_ts = *(u64 *)(vaddr + buf_size / 4 - 2);
+				if (abs(pic_ts - gain_ts) > 5000000LL) {
+					v4l2_info(&dev->v4l2_dev,
+						"%s: frame %d, timestamp is not match (pic_ts %lld, gain_ts %lld)",
+						__func__, vdev->tnr.nxt_rd->frame_id, pic_ts, gain_ts);
+				}
 
 				if (rkispp_read(dev, RKISPP_TNR_CTRL) & SW_TNR_1ST_FRM)
 					vdev->tnr.cur_rd = NULL;
@@ -2798,6 +2871,8 @@ static void tnr_work_event(struct rkispp_device *dev,
 				vdev->tnr.cur_wr->frame_id = seq;
 				vdev->tnr.cur_wr->frame_timestamp =
 					vdev->tnr.nxt_rd->frame_timestamp;
+				vdev->tnr.cur_wr->is_move_judge =
+					vdev->tnr.nxt_rd->is_move_judge;
 			}
 		}
 
@@ -2818,6 +2893,8 @@ static void tnr_work_event(struct rkispp_device *dev,
 		rkispp_write(dev, RKISPP_TNR_IIR_UV_BASE,
 			     rkispp_read(dev, RKISPP_TNR_WR_UV_BASE));
 
+		rkispp_prepare_buffer(dev, &vdev->tnr.buf.gain_kg);
+
 		vdev->tnr.dbg.id = seq;
 		vdev->tnr.dbg.timestamp = ktime_get_ns();
 		if (monitor->is_en) {
@@ -2856,6 +2933,100 @@ static void tnr_work_event(struct rkispp_device *dev,
 	spin_unlock_irqrestore(&vdev->tnr.buf_lock, lock_flags);
 }
 
+int rkispp_get_tnrbuf_fd(struct rkispp_device *dev, struct rkispp_buf_idxfd *idxfd)
+{
+	struct rkispp_stream_vdev *vdev = &dev->stream_vdev;
+	struct rkisp_ispp_buf *dbufs;
+	struct rkispp_dummy_buffer *buf;
+	unsigned long lock_flags = 0;
+	int j, buf_idx, ret = 0;
+
+	spin_lock_irqsave(&vdev->tnr.buf_lock, lock_flags);
+	if (!vdev->tnr.is_but_init) {
+		spin_unlock_irqrestore(&vdev->tnr.buf_lock, lock_flags);
+		ret = -EAGAIN;
+		return ret;
+	}
+	spin_unlock_irqrestore(&vdev->tnr.buf_lock, lock_flags);
+
+	buf_idx = 0;
+	list_for_each_entry(dbufs, &vdev->tnr.list_wr, list) {
+		for (j = 0; j < GROUP_BUF_MAX; j++) {
+			dbufs->dfd[j] = dma_buf_fd(dbufs->dbuf[j], O_CLOEXEC);
+			get_dma_buf(dbufs->dbuf[j]);
+			idxfd->index[buf_idx] = dbufs->didx[j];
+			idxfd->dmafd[buf_idx] = dbufs->dfd[j];
+			buf_idx++;
+		}
+	}
+
+	list_for_each_entry(dbufs, &vdev->tnr.list_rpt, list) {
+		for (j = 0; j < GROUP_BUF_MAX; j++) {
+			dbufs->dfd[j] = dma_buf_fd(dbufs->dbuf[j], O_CLOEXEC);
+			get_dma_buf(dbufs->dbuf[j]);
+			idxfd->index[buf_idx] = dbufs->didx[j];
+			idxfd->dmafd[buf_idx] = dbufs->dfd[j];
+			buf_idx++;
+		}
+	}
+
+	if (vdev->tnr.cur_wr) {
+		for (j = 0; j < GROUP_BUF_MAX; j++) {
+			vdev->tnr.cur_wr->dfd[j] = dma_buf_fd(vdev->tnr.cur_wr->dbuf[j], O_CLOEXEC);
+			get_dma_buf(vdev->tnr.cur_wr->dbuf[j]);
+			idxfd->index[buf_idx] = vdev->tnr.cur_wr->didx[j];
+			idxfd->dmafd[buf_idx] = vdev->tnr.cur_wr->dfd[j];
+			buf_idx++;
+		}
+	}
+
+	buf = &vdev->tnr.buf.gain_kg;
+	buf->dma_fd = dma_buf_fd(buf->dbuf, O_CLOEXEC);
+	get_dma_buf(buf->dbuf);
+	idxfd->index[buf_idx] = buf->index;
+	idxfd->dmafd[buf_idx] = buf->dma_fd;
+	buf_idx++;
+
+	idxfd->buf_num = buf_idx;
+
+	return ret;
+}
+
+void rkispp_sendbuf_to_nr(struct rkispp_device *dev,
+			  struct rkispp_tnr_inf *tnr_inf)
+{
+	struct rkispp_stream_vdev *vdev = &dev->stream_vdev;
+	struct rkispp_dummy_buffer *dummy;
+	struct rkisp_ispp_buf *cur_buf;
+	unsigned long lock_flags = 0;
+	bool find_flg = false;
+	struct dma_buf *dbuf;
+	u32 size;
+
+	size = sizeof(vdev->tnr.buf) / sizeof(*dummy);
+	spin_lock_irqsave(&vdev->tnr.buf_lock, lock_flags);
+	list_for_each_entry(cur_buf, &vdev->tnr.list_rpt, list) {
+		if (cur_buf->index == tnr_inf->dev_id &&
+		    cur_buf->didx[GROUP_BUF_GAIN] == tnr_inf->gainwr_idx) {
+			find_flg = true;
+			break;
+		}
+	}
+
+	if (find_flg) {
+		list_del(&cur_buf->list);
+
+		dbuf = cur_buf->dbuf[GROUP_BUF_GAIN];
+		dummy = dbuf_to_dummy(dbuf, &vdev->tnr.buf.iir, size);
+		rkispp_prepare_buffer(dev, dummy);
+
+		/* tnr write buf to nr */
+		rkispp_module_work_event(dev, cur_buf, NULL,
+					 ISPP_MODULE_NR, false);
+	}
+	spin_unlock_irqrestore(&vdev->tnr.buf_lock, lock_flags);
+}
+
 void rkispp_module_work_event(struct rkispp_device *dev,
 			      void *buf_rd, void *buf_wr,
 			      u32 module, bool is_isr)
@@ -2981,12 +3152,14 @@ int rkispp_register_stream_vdevs(struct rkispp_device *dev)
 	atomic_set(&stream_vdev->refcnt, 0);
 	INIT_LIST_HEAD(&stream_vdev->tnr.list_rd);
 	INIT_LIST_HEAD(&stream_vdev->tnr.list_wr);
+	INIT_LIST_HEAD(&stream_vdev->tnr.list_rpt);
 	INIT_LIST_HEAD(&stream_vdev->nr.list_rd);
 	INIT_LIST_HEAD(&stream_vdev->nr.list_wr);
 	INIT_LIST_HEAD(&stream_vdev->fec.list_rd);
 	spin_lock_init(&stream_vdev->tnr.buf_lock);
 	spin_lock_init(&stream_vdev->nr.buf_lock);
 	spin_lock_init(&stream_vdev->fec.buf_lock);
+	stream_vdev->tnr.is_but_init = false;
 
 	for (i = 0; i < STREAM_MAX; i++) {
 		stream = &stream_vdev->stream[i];
diff --git a/drivers/media/platform/rockchip/ispp/stream.h b/drivers/media/platform/rockchip/ispp/stream.h
index f4927084ba3a..1c92d1006c75 100644
--- a/drivers/media/platform/rockchip/ispp/stream.h
+++ b/drivers/media/platform/rockchip/ispp/stream.h
@@ -92,6 +92,7 @@ struct tnr_module {
 	struct in_tnr_buf buf;
 	struct list_head list_rd;
 	struct list_head list_wr;
+	struct list_head list_rpt;
 	spinlock_t buf_lock;
 	struct rkisp_ispp_buf *cur_rd;
 	struct rkisp_ispp_buf *nxt_rd;
@@ -101,6 +102,7 @@ struct tnr_module {
 	u32 uv_offset;
 	bool is_end;
 	bool is_3to1;
+	bool is_but_init;
 };
 
 struct nr_module {
@@ -226,6 +228,9 @@ struct rkispp_stream_vdev {
 	u32 irq_ends;
 };
 
+int rkispp_get_tnrbuf_fd(struct rkispp_device *dev, struct rkispp_buf_idxfd *idxfd);
+void rkispp_sendbuf_to_nr(struct rkispp_device *dev,
+			  struct rkispp_tnr_inf *tnr_inf);
 void rkispp_module_work_event(struct rkispp_device *dev,
 			      void *buf_rd, void *buf_wr,
 			      u32 module, bool is_isr);
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index 31260b87095d..d2d37382043c 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1360,6 +1360,7 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 		case V4L2_PIX_FMT_MT21C:	descr = "Mediatek Compressed Format"; break;
 		case V4L2_PIX_FMT_FBC2:		descr = "Rockchip yuv422sp fbc encoder"; break;
 		case V4L2_PIX_FMT_FBC0:		descr = "Rockchip yuv420sp fbc encoder"; break;
+		case V4L2_PIX_FMT_FBCG:		descr = "Rockchip fbc gain"; break;
 		default:
 			WARN(1, "Unknown pixelformat 0x%08x\n", fmt->pixelformat);
 			if (fmt->description[0])
diff --git a/include/uapi/linux/rkisp2-config.h b/include/uapi/linux/rkisp2-config.h
index a3809b0ef360..1de204b7916f 100644
--- a/include/uapi/linux/rkisp2-config.h
+++ b/include/uapi/linux/rkisp2-config.h
@@ -33,6 +33,9 @@
 #define RKISP_CMD_GET_SHM_BUFFD \
 	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct rkisp_thunderboot_shmem)
 
+#define RKISP_CMD_GET_FBCBUF_FD \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 7, struct isp2x_buf_idxfd)
+
 #define ISP2X_ID_DPCC			(0)
 #define ISP2X_ID_BLS			(1)
 #define ISP2X_ID_SDG			(2)
@@ -198,6 +201,8 @@
 
 #define ISP2X_THUNDERBOOT_VIDEO_BUF_NUM	30
 
+#define ISP2X_FBCBUF_FD_NUM		64
+
 /* trigger event mode
  * T_TRY: trigger maybe with retry
  * T_TRY_YES: trigger to retry
@@ -233,6 +238,20 @@ enum isp2x_csi_memory {
 	CSI_MEM_MAX,
 };
 
+struct isp2x_ispgain_buf {
+	u32 gain_dmaidx;
+	u32 mfbc_dmaidx;
+	u32 gain_size;
+	u32 mfbc_size;
+	u32 frame_id;
+} __attribute__ ((packed));
+
+struct isp2x_buf_idxfd {
+	u32 buf_num;
+	u32 index[ISP2X_FBCBUF_FD_NUM];
+	s32 dmafd[ISP2X_FBCBUF_FD_NUM];
+} __attribute__ ((packed));
+
 struct isp2x_window {
 	u16 h_offs;
 	u16 v_offs;
diff --git a/include/uapi/linux/rkispp-config.h b/include/uapi/linux/rkispp-config.h
index 1b1522b7e7a9..28ad57eda61d 100644
--- a/include/uapi/linux/rkispp-config.h
+++ b/include/uapi/linux/rkispp-config.h
@@ -81,6 +81,8 @@
 #define FEC_MESH_XY_NUM			131072
 #define FEC_MESH_BUF_NUM		2
 
+#define TNR_BUF_IDXFD_NUM		64
+
 #define RKISPP_CMD_GET_FECBUF_INFO	\
 	_IOR('V', BASE_VIDIOC_PRIVATE + 0, struct rkispp_fecbuf_info)
 
@@ -90,6 +92,15 @@
 #define RKISPP_CMD_FEC_IN_OUT \
 	_IOW('V', BASE_VIDIOC_PRIVATE + 10, struct rkispp_fec_in_out)
 
+#define RKISPP_CMD_TRIGGER_YNRRUN       \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 11, struct rkispp_tnr_inf)
+
+#define RKISPP_CMD_GET_TNRBUF_FD \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 12, struct rkispp_buf_idxfd)
+
+#define RKISPP_V4L2_EVENT_TNR_COMPLETE  \
+	(V4L2_EVENT_PRIVATE_START + 3)
+
 struct rkispp_fec_in_out {
 	int width;
 	int height;
@@ -103,6 +114,21 @@ struct rkispp_fec_in_out {
 	int mesh_yfra_fd;
 };
 
+struct rkispp_tnr_inf {
+	u32 dev_id;
+	u32 frame_id;
+	u32 gainkg_idx;
+	u32 gainwr_idx;
+	u32 gainkg_size;
+	u32 gainwr_size;
+} __attribute__ ((packed));
+
+struct rkispp_buf_idxfd {
+	u32 buf_num;
+	u32 index[TNR_BUF_IDXFD_NUM];
+	s32 dmafd[TNR_BUF_IDXFD_NUM];
+} __attribute__ ((packed));
+
 struct rkispp_tnr_config {
 	u8 opty_en;
 	u8 optc_en;
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
index f5c73be7e84d..dbc18149e37a 100644
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -699,6 +699,7 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_INZI     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
 #define V4L2_PIX_FMT_FBC2     v4l2_fourcc('F', 'B', 'C', '2') /* Rockchip yuv422sp frame buffer compression encoder */
 #define V4L2_PIX_FMT_FBC0     v4l2_fourcc('F', 'B', 'C', '0') /* Rockchip yuv420sp frame buffer compression encoder */
+#define V4L2_PIX_FMT_FBCG     v4l2_fourcc('F', 'B', 'C', 'G')
 
 /* 10bit raw bayer packed, 32 bytes for every 25 pixels, last LSB 6 bits unused */
 #define V4L2_PIX_FMT_IPU3_SBGGR10	v4l2_fourcc('i', 'p', '3', 'b') /* IPU3 packed 10-bit BGGR bayer */
-- 
2.35.3

