From 8f5dace1e0e1ee755e06559fafa1451959ccd901 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Thu, 25 Jan 2018 10:36:23 +0800
Subject: [PATCH] spi: remove unused rk drivers

Change-Id: Ib0eb7eb391637253cbe5f09f684ef2dc9a266b2e
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/spi/rk29_spim.c         | 2183 -------------------------------
 drivers/spi/rk29_spim.h         |  265 ----
 drivers/spi/spi-rk.c            |  349 -----
 drivers/spi/spi-rockchip-core.c | 1134 ----------------
 drivers/spi/spi-rockchip-core.h |  312 -----
 drivers/spi/spi-rockchip-dma.c  |  387 ------
 drivers/spi/spi_test.c          |  248 ----
 7 files changed, 4878 deletions(-)
 delete mode 100755 drivers/spi/rk29_spim.c
 delete mode 100755 drivers/spi/rk29_spim.h
 delete mode 100644 drivers/spi/spi-rk.c
 delete mode 100755 drivers/spi/spi-rockchip-core.c
 delete mode 100755 drivers/spi/spi-rockchip-core.h
 delete mode 100755 drivers/spi/spi-rockchip-dma.c
 delete mode 100755 drivers/spi/spi_test.c

diff --git a/drivers/spi/rk29_spim.c b/drivers/spi/rk29_spim.c
deleted file mode 100755
index e8a02cbe28a7..000000000000
--- a/drivers/spi/rk29_spim.c
+++ /dev/null
@@ -1,2183 +0,0 @@
-/*drivers/serial/rk29xx_spim.c - driver for rk29xx spim device 
- *
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/highmem.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/cpufreq.h>
-#include <mach/gpio.h>
-#include <mach/irqs.h>
-#include <linux/dma-mapping.h>
-#include <asm/dma.h>
-#include <linux/preempt.h>
-#include "rk29_spim.h"
-#include <linux/spi/spi.h>
-#include <mach/board.h>
-
-#ifdef CONFIG_DEBUG_FS
-#include <linux/debugfs.h>
-#endif
-
-/*原有的spi驱动效率比较低，
-无法满足大数据量的传输；
-QUICK_TRANSFER用于快速传输，同时可指定半双工或全双工，
-默认使用半双工
-*/
-
-//#define QUICK_TRANSFER         
-#if 0
-#define DBG   printk
-//#define PRINT_TRANS_DATA
-#else
-#define DBG(x...)
-#endif
-
-#define DMA_BUFFER_SIZE PAGE_SIZE
-#define DMA_MIN_BYTES 32 //>32x16bits FIFO
-
-
-#define START_STATE	((void *)0)
-#define RUNNING_STATE	((void *)1)
-#define DONE_STATE	((void *)2)
-#define ERROR_STATE	((void *)-1)
-
-#define QUEUE_RUNNING	0
-#define QUEUE_STOPPED	1
-
-#define MRST_SPI_DEASSERT	0
-#define MRST_SPI_ASSERT		1  ///CS0
-#define MRST_SPI_ASSERT1	2  ///CS1
-
-/* Slave spi_dev related */
-struct chip_data {
-	u16 cr0;
-	u8 cs;			/* chip select pin */
-	u8 n_bytes;		/* current is a 1/2/4 byte op */
-	u8 tmode;		/* TR/TO/RO/EEPROM */
-	u8 mode;		/* ??? */
-	u8 type;		/* SPI/SSP/MicroWire */
-
-	u8 poll_mode;		/* 1 means use poll mode */
-	u8 slave_enable;
-	u32 dma_width;
-	u32 rx_threshold;
-	u32 tx_threshold;
-	u8 enable_dma:1;
-	u8 bits_per_word;
-	u16 clk_div;		/* baud rate divider */
-	u32 speed_hz;		/* baud rate */
-	int (*write)(struct rk29xx_spi *dws);
-	int (*read)(struct rk29xx_spi *dws);
-	void (*cs_control)(struct rk29xx_spi *dws, u32 cs, u8 flag);
-};
-
-#define SUSPND    (1<<0)
-#define SPIBUSY   (1<<1)
-#define RXBUSY    (1<<2)
-#define TXBUSY    (1<<3)
-
-//
-#ifdef CONFIG_LCD_USE_SPIM_CONTROL
-void rk29_lcd_spim_spin_lock(void)
-{
-#ifdef CONFIG_LCD_USE_SPI0
-	disable_irq(IRQ_SPI0);
-#endif
-
-#ifdef CONFIG_LCD_USE_SPI1
-	disable_irq(IRQ_SPI1);
-#endif
-
-	preempt_disable();
-}
-
-void rk29_lcd_spim_spin_unlock(void)
-{
-	preempt_enable();
-	
-#ifdef CONFIG_LCD_USE_SPI0
-	enable_irq(IRQ_SPI0);
-#endif
-
-#ifdef CONFIG_LCD_USE_SPI1
-	enable_irq(IRQ_SPI1);
-#endif
-}
-#else
-void rk29_lcd_spim_spin_lock(void)
-{
-     return;
-}
-
-void rk29_lcd_spim_spin_unlock(void)
-{
-     return;
-}
-#endif
-
-#if defined(PRINT_TRANS_DATA)
-static void printk_transfer_data(unsigned char *buf, int len)
-{
-	int i = 0;
-	for(i=0; i<len; i++)
-		printk("0x%x,",*buf++);
-
-	printk("\n");
-
-}
-#endif
-
-#if 0
-static void spi_dump_regs(struct rk29xx_spi *dws) {
-	DBG("MRST SPI0 registers:\n");
-	DBG("=================================\n");
-	DBG("CTRL0: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_CTRLR0));
-	DBG("CTRL1: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_CTRLR1));
-	DBG("SSIENR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_ENR));
-	DBG("SER: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_SER));
-	DBG("BAUDR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_BAUDR));
-	DBG("TXFTLR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_TXFTLR));
-	DBG("RXFTLR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_RXFTLR));
-	DBG("TXFLR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_TXFLR));
-	DBG("RXFLR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_RXFLR));
-	DBG("SR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_SR));
-	DBG("IMR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_IMR));
-	DBG("ISR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_ISR));
-	DBG("DMACR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_DMACR));
-	DBG("DMATDLR: \t0x%08x\n", rk29xx_readl(dws, SPIM_DMATDLR));
-	DBG("DMARDLR: \t0x%08x\n", rk29xx_readl(dws, SPIM_DMARDLR));
-	DBG("=================================\n");
-
-}
-#endif
-
-#ifdef CONFIG_DEBUG_FS
-static int spi_show_regs_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-#define SPI_REGS_BUFSIZE	1024
-static ssize_t  spi_show_regs(struct file *file, char __user *user_buf,
-				size_t count, loff_t *ppos)
-{
-	struct rk29xx_spi *dws;
-	char *buf;
-	u32 len = 0;
-	ssize_t ret;
-
-	dws = file->private_data;
-
-	buf = kzalloc(SPI_REGS_BUFSIZE, GFP_KERNEL);
-	if (!buf)
-		return 0;
-
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"MRST SPI0 registers:\n");
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"=================================\n");
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"CTRL0: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_CTRLR0));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"CTRL1: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_CTRLR1));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"SSIENR: \t0x%08x\n", rk29xx_readl(dws, SPIM_ENR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"SER: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_SER));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"BAUDR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_BAUDR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"TXFTLR: \t0x%08x\n", rk29xx_readl(dws, SPIM_TXFTLR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"RXFTLR: \t0x%08x\n", rk29xx_readl(dws, SPIM_RXFTLR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"TXFLR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_TXFLR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"RXFLR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_RXFLR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"SR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_SR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"IMR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_IMR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"ISR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_ISR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"DMACR: \t\t0x%08x\n", rk29xx_readl(dws, SPIM_DMACR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"DMATDLR: \t0x%08x\n", rk29xx_readl(dws, SPIM_DMATDLR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"DMARDLR: \t0x%08x\n", rk29xx_readl(dws, SPIM_DMARDLR));
-	len += printk(buf + len, SPI_REGS_BUFSIZE - len,
-			"=================================\n");
-
-	ret =  simple_read_from_buffer(user_buf, count, ppos, buf, len);
-	kfree(buf);
-	return ret;
-}
-
-static const struct file_operations mrst_spi_regs_ops = {
-	.owner		= THIS_MODULE,
-	.open		= spi_show_regs_open,
-	.read		= spi_show_regs,
-};
-
-static int mrst_spi_debugfs_init(struct rk29xx_spi *dws)
-{
-	dws->debugfs = debugfs_create_dir("mrst_spi", NULL);
-	if (!dws->debugfs)
-		return -ENOMEM;
-
-	debugfs_create_file("registers", S_IFREG | S_IRUGO,
-		dws->debugfs, (void *)dws, &mrst_spi_regs_ops);
-	return 0;
-}
-
-static void mrst_spi_debugfs_remove(struct rk29xx_spi *dws)
-{
-	if (dws->debugfs)
-		debugfs_remove_recursive(dws->debugfs);
-}
-
-#else
-static inline int mrst_spi_debugfs_init(struct rk29xx_spi *dws)
-{
-	return 0;
-}
-
-static inline void mrst_spi_debugfs_remove(struct rk29xx_spi *dws)
-{
-}
-#endif /* CONFIG_DEBUG_FS */
-
-static void dma_transfer(struct rk29xx_spi *dws) ;
-static void transfer_complete(struct rk29xx_spi *dws);
-
-static void wait_till_not_busy(struct rk29xx_spi *dws)
-{
-	unsigned long end = jiffies + 1 + usecs_to_jiffies(1000);
-	//if spi was slave, it is SR_BUSY always.  
-	if(dws->cur_chip) {
-		if(dws->cur_chip->slave_enable == 1)
-			return;
-	}
-	
-	while (time_before(jiffies, end)) {
-		if (!(rk29xx_readw(dws, SPIM_SR) & SR_BUSY))
-			return;
-	}
-	dev_err(&dws->master->dev,
-		"DW SPI: Status keeps busy for 1000us after a read/write!\n");
-}
-
-#if defined(QUICK_TRANSFER)
-static void wait_till_tf_empty(struct rk29xx_spi *dws)
-{
-	unsigned long end = jiffies + 1 + usecs_to_jiffies(1000);
-
-	while (time_before(jiffies, end)) {
-		if (rk29xx_readw(dws, SPIM_SR) & SR_TF_EMPT)
-			return;
-	}
-	dev_err(&dws->master->dev,
-		"DW SPI: Status keeps busy for 1000us after a read/write!\n");
-}
-#endif
-
-static void flush(struct rk29xx_spi *dws)
-{
-	while (!(rk29xx_readw(dws, SPIM_SR) & SR_RF_EMPT))
-		rk29xx_readw(dws, SPIM_RXDR);
-
-	wait_till_not_busy(dws);
-}
-
-static void spi_cs_control(struct rk29xx_spi *dws, u32 cs, u8 flag)
-{
-	#if 1
-	if (flag)
-		rk29xx_writel(dws, SPIM_SER, 1 << cs);
-	else 		
-		rk29xx_writel(dws, SPIM_SER, 0);
-	return;
-	#else
-	
-	#error "Warning: not support"
-	struct rk29xx_spi_platform_data *pdata = dws->master->dev.platform_data;
-	struct spi_cs_gpio *cs_gpios = pdata->chipselect_gpios;
-
-	if (flag == 0) {
-		gpio_direction_output(cs_gpios[cs].cs_gpio, GPIO_HIGH);
-	}
-	else {
-		gpio_direction_output(cs_gpios[cs].cs_gpio, GPIO_LOW);
-	}
-	#endif
-}
-
-static int null_writer(struct rk29xx_spi *dws)
-{
-	u8 n_bytes = dws->n_bytes;
-
-	if ((rk29xx_readw(dws, SPIM_SR) & SR_TF_FULL)
-		|| (dws->tx == dws->tx_end))
-		return 0;
-	rk29xx_writew(dws, SPIM_TXDR, 0);
-	dws->tx += n_bytes;
-	//wait_till_not_busy(dws);
-
-	return 1;
-}
-
-static int null_reader(struct rk29xx_spi *dws)
-{
-	u8 n_bytes = dws->n_bytes;
-	DBG("func: %s, line: %d\n", __FUNCTION__, __LINE__);
-	while ((!(rk29xx_readw(dws, SPIM_SR) & SR_RF_EMPT))
-		&& (dws->rx < dws->rx_end)) {
-		rk29xx_readw(dws, SPIM_RXDR);
-		dws->rx += n_bytes;
-	}
-	wait_till_not_busy(dws);
-	return dws->rx == dws->rx_end;
-}
-
-static int u8_writer(struct rk29xx_spi *dws)
-{	
-	//spi_dump_regs(dws)
-#if defined(PRINT_TRANS_DATA)
-	DBG("tx: 0x%02x\n", *(u8 *)(dws->tx));
-#endif
-	if ((rk29xx_readw(dws, SPIM_SR) & SR_TF_FULL)
-		|| (dws->tx == dws->tx_end))
-		return 0;
-	rk29xx_writew(dws, SPIM_TXDR, *(u8 *)(dws->tx));
-	++dws->tx;
-	//wait_till_not_busy(dws);
-
-	return 1;
-}
-
-static int u8_reader(struct rk29xx_spi *dws)
-{
-    //spi_dump_regs(dws);
-	while (!(rk29xx_readw(dws, SPIM_SR) & SR_RF_EMPT)
-		&& (dws->rx < dws->rx_end)) {
-		*(u8 *)(dws->rx) = rk29xx_readw(dws, SPIM_RXDR) & 0xFFU;
-#if defined(PRINT_TRANS_DATA)
-		DBG("rx: 0x%02x\n", *(u8 *)(dws->rx));
-#endif
-		++dws->rx;
-	}
-
-	wait_till_not_busy(dws);
-	return dws->rx == dws->rx_end;
-}
-
-static int u16_writer(struct rk29xx_spi *dws)
-{	
-#if defined(PRINT_TRANS_DATA)
-	DBG("tx: 0x%04x\n", *(u16 *)(dws->tx));
-#endif
-	if ((rk29xx_readw(dws, SPIM_SR) & SR_TF_FULL)
-		|| (dws->tx == dws->tx_end))
-		return 0;
-
-	rk29xx_writew(dws, SPIM_TXDR, *(u16 *)(dws->tx));
-	dws->tx += 2;
-	//wait_till_not_busy(dws);
-
-	return 1;
-}
-
-static int u16_reader(struct rk29xx_spi *dws)
-{
-	u16 temp;
-
-	while (!(rk29xx_readw(dws, SPIM_SR) & SR_RF_EMPT)
-		&& (dws->rx < dws->rx_end)) {
-		temp = rk29xx_readw(dws, SPIM_RXDR);
-		*(u16 *)(dws->rx) = temp;
-#if defined(PRINT_TRANS_DATA)
-		DBG("rx: 0x%04x\n", *(u16 *)(dws->rx));
-#endif
-		dws->rx += 2;
-	}
-
-	wait_till_not_busy(dws);
-	return dws->rx == dws->rx_end;
-}
-
-static void *next_transfer(struct rk29xx_spi *dws)
-{
-	struct spi_message *msg = dws->cur_msg;
-	struct spi_transfer *trans = dws->cur_transfer;
-
-	/* Move to next transfer */
-	if (trans->transfer_list.next != &msg->transfers) {
-		dws->cur_transfer =
-			list_entry(trans->transfer_list.next,
-					struct spi_transfer,
-					transfer_list);
-		return RUNNING_STATE;
-	} else
-		return DONE_STATE;
-}
-
-static void rk29_spi_dma_rxcb(void *buf_id,
-				 int size, enum rk29_dma_buffresult res)
-{
-	struct rk29xx_spi *dws = buf_id;
-	unsigned long flags;
-
-	DBG("func: %s, line: %d\n", __FUNCTION__, __LINE__);
-	
-	spin_lock_irqsave(&dws->lock, flags);
-
-	if (res == RK29_RES_OK)
-		dws->state &= ~RXBUSY;
-	else
-		dev_err(&dws->master->dev, "error:DmaAbrtRx-%d, size: %d,res=%d\n", res, size,res);
-
-	//copy data from dma to transfer buf
-	if(dws->cur_transfer && (dws->cur_transfer->rx_buf != NULL))
-	{
-		memcpy(dws->cur_transfer->rx_buf, dws->buffer_rx_dma, dws->cur_transfer->len);
-		
-		#if defined(PRINT_TRANS_DATA)
-		printk("dma rx:");
-		printk_transfer_data(dws->cur_transfer->rx_buf, dws->cur_transfer->len);
-		#endif
-	}
-	
-	spin_unlock_irqrestore(&dws->lock, flags);
-	
-	/* If the other done */
-	if (!(dws->state & TXBUSY))
-	{
-		//complete(&dws->xfer_completion);	
-		DBG("func: %s, line: %d,dma transfer complete\n", __FUNCTION__, __LINE__);
-		//DMA could not lose intterupt
-		transfer_complete(dws);
-	}
-
-}
-
-static void rk29_spi_dma_txcb(void *buf_id,
-				 int size, enum rk29_dma_buffresult res)
-{
-	struct rk29xx_spi *dws = buf_id;
-	unsigned long flags;
-
-	DBG("func: %s, line: %d\n", __FUNCTION__, __LINE__);
-	
-	spin_lock_irqsave(&dws->lock, flags);
-
-	if (res == RK29_RES_OK)
-		dws->state &= ~TXBUSY;
-	else
-		dev_err(&dws->master->dev, "error:DmaAbrtTx-%d, size: %d,res=%d \n", res, size,res);
-
-	spin_unlock_irqrestore(&dws->lock, flags);
-	
-	/* If the other done */
-	if (!(dws->state & RXBUSY)) 
-	{
-		//complete(&dws->xfer_completion);
-		
-		DBG("func: %s, line: %d,dma transfer complete\n", __FUNCTION__, __LINE__);
-		//DMA could not lose intterupt
-		transfer_complete(dws);
-	}
-
-}
-
-
-static struct rk29_dma_client rk29_spi_dma_client = {
-	.name = "rk29xx-spi-dma",
-};
-
-static int acquire_dma(struct rk29xx_spi *dws)
-{	
-	if (dws->dma_inited) {
-		return 0;
-	}
-
-	dws->buffer_tx_dma = dma_alloc_coherent(&dws->pdev->dev, DMA_BUFFER_SIZE, &dws->tx_dma, GFP_KERNEL | GFP_DMA);
-	if (!dws->buffer_tx_dma)
-	{
-		dev_err(&dws->pdev->dev, "fail to dma tx buffer alloc\n");
-		return -1;
-	}
-
-	dws->buffer_rx_dma = dma_alloc_coherent(&dws->pdev->dev, DMA_BUFFER_SIZE, &dws->rx_dma, GFP_KERNEL | GFP_DMA);
-	if (!dws->buffer_rx_dma)
-	{
-		dev_err(&dws->pdev->dev, "fail to dma rx buffer alloc\n");
-		return -1;
-	}
-
-	if(rk29_dma_request(dws->rx_dmach, 
-		&rk29_spi_dma_client, NULL) < 0) {
-		dev_err(&dws->master->dev, "dws->rx_dmach : %d, cannot get RxDMA\n", dws->rx_dmach);
-		return -1;
-	}
-
-	if (rk29_dma_request(dws->tx_dmach,
-					&rk29_spi_dma_client, NULL) < 0) {
-		dev_err(&dws->master->dev, "dws->tx_dmach : %d, cannot get TxDMA\n", dws->tx_dmach);
-		rk29_dma_free(dws->rx_dmach, &rk29_spi_dma_client);
-		return -1;
-	}
-
-	if (dws->tx_dma) {
-		if (rk29_dma_set_buffdone_fn(dws->tx_dmach, rk29_spi_dma_txcb)) {
-			dev_err(&dws->master->dev, "rk29_dma_set_buffdone_fn fail\n");
-			return -1;
-		}
-		if (rk29_dma_devconfig(dws->tx_dmach, RK29_DMASRC_MEM,
-					dws->sfr_start + SPIM_TXDR)) {
-			dev_err(&dws->master->dev, "rk29_dma_devconfig fail\n");
-			return -1;
-		}
-	}
-
-	if (dws->rx_dma) {
-		if (rk29_dma_set_buffdone_fn(dws->rx_dmach, rk29_spi_dma_rxcb)) {
-			dev_err(&dws->master->dev, "rk29_dma_set_buffdone_fn fail\n");
-			return -1;
-		}
-		if (rk29_dma_devconfig(dws->rx_dmach, RK29_DMASRC_HW,
-					dws->sfr_start + SPIM_RXDR)) {
-			dev_err(&dws->master->dev, "rk29_dma_devconfig fail\n");
-			return -1;
-		}
-	}
-	
-    	dws->dma_inited = 1;
-	return 0;
-}
-
-static void release_dma(struct rk29xx_spi *dws)
-{
-	if(!dws && dws->dma_inited) {
-		rk29_dma_free(dws->rx_dmach, &rk29_spi_dma_client);
-		rk29_dma_free(dws->tx_dmach, &rk29_spi_dma_client);
-	}
-}
-
-/*
- * Note: first step is the protocol driver prepares
- * a dma-capable memory, and this func just need translate
- * the virt addr to physical
- */
-static int map_dma_buffers(struct rk29xx_spi *dws)
-{
-	if (!dws->dma_inited || !dws->cur_chip->enable_dma)
-	{
-		printk("%s:error\n",__func__);
-		return -1;
-	}
-
-	if(dws->cur_transfer->tx_buf)
-	{
-		memcpy(dws->buffer_tx_dma,dws->cur_transfer->tx_buf,dws->cur_transfer->len);
-	}
-	
-	dws->cur_transfer->tx_dma = dws->tx_dma;
-	dws->cur_transfer->rx_dma = dws->rx_dma;
-	
-	return 0;
-}
-
-/* Caller already set message->status; dma and pio irqs are blocked */
-static void giveback(struct rk29xx_spi *dws)
-{
-	struct spi_transfer *last_transfer;
-	unsigned long flags;
-	struct spi_message *msg;
-
-	spin_lock_irqsave(&dws->lock, flags);
-	msg = dws->cur_msg;
-	dws->cur_msg = NULL;
-	dws->cur_transfer = NULL;
-	dws->prev_chip = dws->cur_chip;
-	dws->cur_chip = NULL;
-	dws->dma_mapped = 0;
-
-	
-	/*it is important to close intterrupt*/
-	spi_mask_intr(dws, 0xff);
-	rk29xx_writew(dws, SPIM_DMACR, 0);
-	
-	queue_work(dws->workqueue, &dws->pump_messages);
-	spin_unlock_irqrestore(&dws->lock, flags);
-
-	last_transfer = list_entry(msg->transfers.prev,
-					struct spi_transfer,
-					transfer_list);
-
-	if (!last_transfer->cs_change && dws->cs_control)
-		dws->cs_control(dws,msg->spi->chip_select, MRST_SPI_DEASSERT);
-
-	msg->state = NULL;
-	if (msg->complete)
-		msg->complete(msg->context);
-
-	DBG("%s ok\n",__func__);
-
-}
-
-static void int_error_stop(struct rk29xx_spi *dws, const char *msg)
-{
-	/* Stop and reset hw */
-	flush(dws);
-	spi_enable_chip(dws, 0);
-
-	dev_err(&dws->master->dev, "%s\n", msg);
-	dws->cur_msg->state = ERROR_STATE;
-	tasklet_schedule(&dws->pump_transfers);
-}
-
-static void transfer_complete(struct rk29xx_spi *dws)
-{
-	/* Update total byte transfered return count actual bytes read */
-	dws->cur_msg->actual_length += dws->len;
-
-	/* Move to next transfer */
-	dws->cur_msg->state = next_transfer(dws);
-
-	/* Handle end of message */
-	if (dws->cur_msg->state == DONE_STATE) {
-		dws->cur_msg->status = 0;
-		giveback(dws);
-	} else
-		tasklet_schedule(&dws->pump_transfers);
-}
-
-static irqreturn_t interrupt_transfer(struct rk29xx_spi *dws)
-{
-	u16 irq_status, irq_mask = 0x1f;
-	u32 int_level = dws->fifo_len / 2;
-	u32 left;
-
-	irq_status = rk29xx_readw(dws, SPIM_ISR) & irq_mask;
-	/* Error handling */
-	if (irq_status & (SPI_INT_TXOI | SPI_INT_RXOI | SPI_INT_RXUI)) {
-		rk29xx_writew(dws, SPIM_ICR, SPI_CLEAR_INT_TXOI | SPI_CLEAR_INT_RXOI | SPI_CLEAR_INT_RXUI);
-		int_error_stop(dws, "interrupt_transfer: fifo overrun");
-		mutex_unlock(&dws->dma_lock);	
-		return IRQ_HANDLED;
-	}
-
-	if (irq_status & SPI_INT_TXEI) {
-		spi_mask_intr(dws, SPI_INT_TXEI);
-
-		left = (dws->tx_end - dws->tx) / dws->n_bytes;
-		left = (left > int_level) ? int_level : left;
-
-		while (left--) {
-			dws->write(dws);
-			wait_till_not_busy(dws);
-		}
-		if (dws->rx) {
-		    dws->read(dws);
-		}
-
-		/* Re-enable the IRQ if there is still data left to tx */
-		if (dws->tx_end > dws->tx)
-			spi_umask_intr(dws, SPI_INT_TXEI);
-		else
-			transfer_complete(dws);
-	}
-
-	if (irq_status & SPI_INT_RXFI) {
-		spi_mask_intr(dws, SPI_INT_RXFI);
-		
-		dws->read(dws);
-
-		/* Re-enable the IRQ if there is still data left to rx */
-		if (dws->rx_end > dws->rx) {
-			left = ((dws->rx_end - dws->rx) / dws->n_bytes) - 1;
-		    left = (left > int_level) ? int_level : left;
-
-			rk29xx_writew(dws, SPIM_RXFTLR, left);
-			spi_umask_intr(dws, SPI_INT_RXFI);
-		}
-		else {
-			transfer_complete(dws);
-		}
-		
-	}	
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t rk29xx_spi_irq(int irq, void *dev_id)
-{
-	struct rk29xx_spi *dws = dev_id;
-
-	if (!dws->cur_msg) {
-		spi_mask_intr(dws, SPI_INT_TXEI);
-		/* Never fail */
-		return IRQ_HANDLED;
-	}
-
-	return dws->transfer_handler(dws);
-}
-
-/* Must be called inside pump_transfers() */
-static void poll_transfer(struct rk29xx_spi *dws)
-{
-#if defined(PRINT_TRANS_DATA)
-	DBG("%s\n",__func__);
-#endif
-	while (dws->write(dws)) {
-		wait_till_not_busy(dws);
-		dws->read(dws);
-	}
-	transfer_complete(dws);
-}
-static void spi_chip_sel(struct rk29xx_spi *dws, u16 cs)
-{
-    if(cs >= dws->master->num_chipselect)
-		return;
-
-	if (dws->cs_control){
-	    dws->cs_control(dws, cs, MRST_SPI_ASSERT);
-	}
-	rk29xx_writel(dws, SPIM_SER, 1 << cs);
-}
-
-static void pump_transfers(unsigned long data)
-{
-	struct rk29xx_spi *dws = (struct rk29xx_spi *)data;
-	struct spi_message *message = NULL;
-	struct spi_transfer *transfer = NULL;
-	struct spi_transfer *previous = NULL;
-	struct spi_device *spi = NULL;
-	struct chip_data *chip = NULL;
-	u8 bits = 0;
-	u8 spi_dfs = 0;
-	u8 imask = 0;
-	u8 cs_change = 0;
-	u16 txint_level = 0;
-	u16 rxint_level = 0;
-	u16 clk_div = 0;
-	u32 speed = 0;
-	u32 cr0 = 0;
-
-	if((dws->cur_chip->enable_dma) && (dws->cur_transfer->len > DMA_MIN_BYTES) && (dws->cur_transfer->len < DMA_BUFFER_SIZE)){	
-		dma_transfer(dws);
-		return;
-	}	
-	
-	DBG(KERN_INFO "pump_transfers,len=%d\n",dws->cur_transfer->len);
-
-	/* Get current state information */
-	message = dws->cur_msg;
-	transfer = dws->cur_transfer;
-	chip = dws->cur_chip;
-	spi = message->spi;	
-	if (unlikely(!chip->clk_div))
-		chip->clk_div = clk_get_rate(dws->clock_spim) / chip->speed_hz;	
-	if (message->state == ERROR_STATE) {
-		message->status = -EIO;
-		goto early_exit;
-	}
-
-	/* Handle end of message */
-	if (message->state == DONE_STATE) {
-		message->status = 0;
-		goto early_exit;
-	}
-
-	/* Delay if requested at end of transfer*/
-	if (message->state == RUNNING_STATE) {
-		previous = list_entry(transfer->transfer_list.prev,
-					struct spi_transfer,
-					transfer_list);
-		if (previous->delay_usecs)
-			udelay(previous->delay_usecs);
-	}
-
-	dws->n_bytes = chip->n_bytes;
-	dws->dma_width = chip->dma_width;
-	dws->cs_control = chip->cs_control;
-
-	//dws->rx_dma = transfer->rx_dma;
-	//dws->tx_dma = transfer->tx_dma;
-	dws->tx = (void *)transfer->tx_buf;
-	dws->tx_end = dws->tx + transfer->len;
-	dws->rx = (void *)transfer->rx_buf;
-	dws->rx_end = dws->rx + transfer->len;
-	dws->write = dws->tx ? chip->write : null_writer;
-	dws->read = dws->rx ? chip->read : null_reader;
-	dws->cs_change = transfer->cs_change;
-	dws->len = dws->cur_transfer->len;
-	if (chip != dws->prev_chip)
-		cs_change = 1;
-
-	cr0 = chip->cr0;
-
-	/* Handle per transfer options for bpw and speed */
-	if (transfer->speed_hz) {
-		speed = chip->speed_hz;
-
-		if (transfer->speed_hz != speed) {
-			speed = transfer->speed_hz;
-			if (speed > clk_get_rate(dws->clock_spim)) {
-				dev_err(&dws->master->dev, "MRST SPI0: unsupported "
-					"freq: %dHz\n", speed);
-				message->status = -EIO;
-				goto early_exit;
-			}
-
-			/* clk_div doesn't support odd number */
-			clk_div = clk_get_rate(dws->clock_spim) / speed;
-			clk_div = (clk_div + 1) & 0xfffe;
-
-			chip->speed_hz = speed;
-			chip->clk_div = clk_div;
-		}
-	}
-	
-	if (transfer->bits_per_word) {
-		bits = transfer->bits_per_word;
-
-		switch (bits) {
-		case 8:
-			dws->n_bytes = 1;
-			dws->dma_width = 1;
-			dws->read = (dws->read != null_reader) ?
-					u8_reader : null_reader;
-			dws->write = (dws->write != null_writer) ?
-					u8_writer : null_writer;
-			spi_dfs = SPI_DFS_8BIT;
-			break;
-		case 16:
-			dws->n_bytes = 2;
-			dws->dma_width = 2;
-			dws->read = (dws->read != null_reader) ?
-					u16_reader : null_reader;
-			dws->write = (dws->write != null_writer) ?
-					u16_writer : null_writer;
-			spi_dfs = SPI_DFS_16BIT;
-			break;
-		default:
-			dev_err(&dws->master->dev, "MRST SPI0: unsupported bits:"
-				"%db\n", bits);
-			message->status = -EIO;
-			goto early_exit;
-		}
-
-		cr0 = (spi_dfs << SPI_DFS_OFFSET)
-			| (SPI_HALF_WORLD_OFF << SPI_HALF_WORLD_TX_OFFSET)
-			| (SPI_SSN_DELAY_ONE << SPI_SSN_DELAY_OFFSET)
-			| (chip->type << SPI_FRF_OFFSET)
-			| (spi->mode << SPI_MODE_OFFSET)
-			| (chip->tmode << SPI_TMOD_OFFSET);
-	}
-	message->state = RUNNING_STATE;
- 
-	/*
-	 * Adjust transfer mode if necessary. Requires platform dependent
-	 * chipselect mechanism.
-	 */
-	if (dws->cs_control) {
-		if (dws->rx && dws->tx)
-			chip->tmode = SPI_TMOD_TR;
-		else if (dws->rx)
-			chip->tmode = SPI_TMOD_RO;
-		else
-			chip->tmode = SPI_TMOD_TO;
-
-		cr0 &= ~(0x3 << SPI_MODE_OFFSET);		
-		cr0 &= ~(0x3 << SPI_TMOD_OFFSET);
-		cr0 &= ~(0x1 << SPI_OPMOD_OFFSET);	
-		cr0 |= (spi->mode << SPI_MODE_OFFSET);
-		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
-		cr0 |= ((chip->slave_enable & 1) << SPI_OPMOD_OFFSET);
-	} 
-
-	/*
-	 * Interrupt mode
-	 * we only need set the TXEI IRQ, as TX/RX always happen syncronizely
-	 */
-	if (!dws->dma_mapped && !chip->poll_mode) {	
-		int templen ;
-		
-		if (chip->tmode == SPI_TMOD_RO) {
-			templen = dws->len / dws->n_bytes - 1;
-			rxint_level = dws->fifo_len / 2;
-			rxint_level = (templen > rxint_level) ? rxint_level : templen;
-			imask |= SPI_INT_RXFI;
-		}
-		else {	
-			templen = dws->len / dws->n_bytes;
-			txint_level = dws->fifo_len / 2;
-			txint_level = (templen > txint_level) ? txint_level : templen;
-			imask |= SPI_INT_TXEI;
-		}
-		dws->transfer_handler = interrupt_transfer;
-	}
-
-	/*
-	 * Reprogram registers only if
-	 *	1. chip select changes
-	 *	2. clk_div is changed
-	 *	3. control value changes
-	 */
-	if ((rk29xx_readl(dws, SPIM_CTRLR0) != cr0) || cs_change || clk_div || imask) {
-		spi_enable_chip(dws, 0);
-		if (rk29xx_readl(dws, SPIM_CTRLR0) != cr0)
-			rk29xx_writel(dws, SPIM_CTRLR0, cr0);
-
-		spi_set_clk(dws, clk_div ? clk_div : chip->clk_div);		
-		spi_chip_sel(dws, spi->chip_select);
-
-        rk29xx_writew(dws, SPIM_CTRLR1, dws->len-1);
-		
-		if (txint_level)
-			rk29xx_writew(dws, SPIM_TXFTLR, txint_level);
-		spi_enable_chip(dws, 1);	
-			
-		if (rxint_level)
-			rk29xx_writew(dws, SPIM_RXFTLR, rxint_level);
-		/* Set the interrupt mask, for poll mode just diable all int */
-		spi_mask_intr(dws, 0xff);
-		if (imask)
-			spi_umask_intr(dws, imask);
-		
-		if (cs_change)
-			dws->prev_chip = chip;
-	} 
-
-	if (chip->poll_mode)
-		poll_transfer(dws);
-
-	return;
-
-early_exit:
-	giveback(dws);
-	return;
-}
-
-static void dma_transfer(struct rk29xx_spi *dws) 
-{
-	struct spi_message *message = NULL;
-	struct spi_transfer *transfer = NULL;
-	struct spi_transfer *previous = NULL;
-	struct spi_device *spi = NULL;
-	struct chip_data *chip = NULL;
-	//unsigned long val;	
-	//unsigned long flags;
-	//int ms;
-	int iRet;
-	//int burst;
-	u8 bits = 0;
-	u8 spi_dfs = 0;
-	u8 cs_change = 0;
-	u16 clk_div = 0;
-	u32 speed = 0;
-	u32 cr0 = 0;
-	u32 dmacr = 0;
-	
-	DBG(KERN_INFO "dma_transfer,len=%d\n",dws->cur_transfer->len);	
-	
-	if (acquire_dma(dws)) {
-		dev_err(&dws->master->dev, "acquire dma failed\n");
-		goto err_out;
-	}
-
-	if (map_dma_buffers(dws)) {
-		dev_err(&dws->master->dev, "acquire dma failed\n");
-		goto err_out;
-	}
-
-	/* Get current state information */
-	message = dws->cur_msg;
-	transfer = dws->cur_transfer;
-	chip = dws->cur_chip;
-	spi = message->spi;	
-	if (unlikely(!chip->clk_div))
-		chip->clk_div = clk_get_rate(dws->clock_spim) / chip->speed_hz;	
-	if (message->state == ERROR_STATE) {
-		message->status = -EIO;
-		goto err_out;
-	}
-
-	/* Handle end of message */
-	if (message->state == DONE_STATE) {
-		message->status = 0;
-		goto err_out;
-	}
-
-	/* Delay if requested at end of transfer*/
-	if (message->state == RUNNING_STATE) {
-		previous = list_entry(transfer->transfer_list.prev,
-					struct spi_transfer,
-					transfer_list);
-		if (previous->delay_usecs)
-			udelay(previous->delay_usecs);
-	}
-
-	dws->n_bytes = chip->n_bytes;
-	dws->dma_width = chip->dma_width;
-	dws->cs_control = chip->cs_control;
-
-	//dws->rx_dma = transfer->rx_dma;
-	//dws->tx_dma = transfer->tx_dma;
-	dws->tx = (void *)transfer->tx_buf;
-	dws->tx_end = dws->tx + transfer->len;
-	dws->rx = (void *)transfer->rx_buf;
-	dws->rx_end = dws->rx + transfer->len;
-	dws->write = dws->tx ? chip->write : null_writer;
-	dws->read = dws->rx ? chip->read : null_reader;
-	dws->cs_change = transfer->cs_change;
-	dws->len = dws->cur_transfer->len;
-	if (chip != dws->prev_chip)
-		cs_change = 1;
-
-	cr0 = chip->cr0;
-	
-	/* Handle per transfer options for bpw and speed */
-	if (transfer->speed_hz) {
-		speed = chip->speed_hz;
-		if (transfer->speed_hz != speed) {
-			speed = transfer->speed_hz;
-			if (speed > clk_get_rate(dws->clock_spim)) {
-				dev_err(&dws->master->dev, "MRST SPI0: unsupported "
-					"freq: %dHz\n", speed);
-				message->status = -EIO;
-				goto err_out;
-			}
-
-			/* clk_div doesn't support odd number */
-			clk_div = clk_get_rate(dws->clock_spim) / speed;
-			clk_div = (clk_div + 1) & 0xfffe;
-
-			chip->speed_hz = speed;
-			chip->clk_div = clk_div;
-		}
-	}
-
-	
-	if (transfer->bits_per_word) {
-		bits = transfer->bits_per_word;
-
-		switch (bits) {
-		case 8:
-			dws->n_bytes = 1;
-			dws->dma_width = 1;
-			spi_dfs = SPI_DFS_8BIT;
-			break;
-		case 16:
-			dws->n_bytes = 2;
-			dws->dma_width = 2;
-			spi_dfs = SPI_DFS_16BIT;
-			break;
-		default:
-			dev_err(&dws->master->dev, "MRST SPI0: unsupported bits:"
-				"%db\n", bits);
-			message->status = -EIO;
-			goto err_out;
-		}
-
-		cr0 = (spi_dfs << SPI_DFS_OFFSET)
-			| (SPI_HALF_WORLD_OFF << SPI_HALF_WORLD_TX_OFFSET)
-			| (SPI_SSN_DELAY_ONE << SPI_SSN_DELAY_OFFSET)
-			| (chip->type << SPI_FRF_OFFSET)
-			| (spi->mode << SPI_MODE_OFFSET)
-			| (chip->tmode << SPI_TMOD_OFFSET);
-	}
-	message->state = RUNNING_STATE;
- 
-	/*
-	 * Adjust transfer mode if necessary. Requires platform dependent
-	 * chipselect mechanism.
-	 */
-	if (dws->cs_control) {
-		if (dws->rx && dws->tx)
-			chip->tmode = SPI_TMOD_TR;
-		else if (dws->rx)
-			chip->tmode = SPI_TMOD_RO;
-		else
-			chip->tmode = SPI_TMOD_TO;
-
-		cr0 &= ~(0x3 << SPI_MODE_OFFSET);
-		cr0 &= ~(0x3 << SPI_TMOD_OFFSET);
-		cr0 &= ~(0x1 << SPI_OPMOD_OFFSET);		
-		cr0 |= (spi->mode << SPI_MODE_OFFSET);
-		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
-		cr0 |= ((chip->slave_enable & 1) << SPI_OPMOD_OFFSET);
-	}
-
-	/*
-	 * Reprogram registers only if
-	 *	1. chip select changes
-	 *	2. clk_div is changed
-	 *	3. control value changes
-	 */
-	if ((rk29xx_readl(dws, SPIM_CTRLR0) != cr0) || cs_change || clk_div) {
-		spi_enable_chip(dws, 0);
-		if (rk29xx_readl(dws, SPIM_CTRLR0) != cr0) {
-			rk29xx_writel(dws, SPIM_CTRLR0, cr0);
-		}
-		spi_set_clk(dws, clk_div ? clk_div : chip->clk_div);		
-		spi_chip_sel(dws, spi->chip_select);
-		/* Set the interrupt mask, for poll mode just diable all int */
-		spi_mask_intr(dws, 0xff);
-		
-		if (transfer->tx_buf != NULL) {
-			dmacr |= SPI_DMACR_TX_ENABLE;
-			rk29xx_writew(dws, SPIM_DMATDLR, 0);
-		}
-		if (transfer->rx_buf != NULL) {
-			dmacr |= SPI_DMACR_RX_ENABLE;
-			rk29xx_writew(dws, SPIM_DMARDLR, 0);
-			rk29xx_writew(dws, SPIM_CTRLR1, transfer->len-1);	
-		}
-		rk29xx_writew(dws, SPIM_DMACR, dmacr);
-		spi_enable_chip(dws, 1);
-		if (cs_change)
-			dws->prev_chip = chip;
-	} 
-
-	//INIT_COMPLETION(dws->xfer_completion);
-
-	//spi_dump_regs(dws);
-	
-	DBG("dws->tx_dmach: %d, dws->rx_dmach: %d, dws->tx_dma: 0x%x,dws->rx_dma: 0x%x\n", dws->tx_dmach, dws->rx_dmach, (unsigned int)dws->tx_dma,(unsigned int)dws->rx_dma);	
-	DBG("dws->buffer_tx_dma: 0x%p, dws->buffer_rx_dma: 0x%p,dws->dma_width=%d\n", dws->buffer_tx_dma, dws->buffer_rx_dma,dws->dma_width);	
-
-	if (transfer->tx_buf != NULL)		
-		dws->state |= TXBUSY;	
-	if (transfer->rx_buf != NULL) 
-		dws->state |= RXBUSY;
-
-	if (transfer->tx_buf != NULL) {	
-		DBG("%s:start dma tx,dws->state=0x%x\n",__func__,dws->state);
-		#if defined(PRINT_TRANS_DATA)
-		printk("dma tx:");
-		printk_transfer_data(dws->buffer_tx_dma, dws->cur_transfer->len);
-		#endif
-		/*if (transfer->len & 0x3) {
-			burst = 1;
-		}
-		else {
-			burst = 4;
-		}
-		if (rk29_dma_config(dws->tx_dmach, burst)) {*/
-		if (rk29_dma_config(dws->tx_dmach, dws->dma_width, 1)) {//there is not dma burst but bitwide, set it 1 alwayss
-			dev_err(&dws->master->dev, "function: %s, line: %d\n", __FUNCTION__, __LINE__);
-			goto err_out;
-		}
-		
-		rk29_dma_ctrl(dws->tx_dmach, RK29_DMAOP_FLUSH);	
-		
-		iRet = rk29_dma_enqueue(dws->tx_dmach, (void *)dws,
-					dws->tx_dma, transfer->len);
-		if (iRet) {
-			dev_err(&dws->master->dev, "function: %s, line: %d, iRet: %d(dws->tx_dmach: %d, transfer->tx_dma: 0x%x)\n", __FUNCTION__, __LINE__, iRet, 
-				dws->tx_dmach, (unsigned int)transfer->tx_dma);
-			goto err_out;
-		}
-		
-		if (rk29_dma_ctrl(dws->tx_dmach, RK29_DMAOP_START)) {
-			dev_err(&dws->master->dev, "function: %s, line: %d\n", __FUNCTION__, __LINE__);
-			goto err_out;
-		}
-	}
-
-	//wait_till_not_busy(dws);
-	
-	if (transfer->rx_buf != NULL) {			
-		DBG("%s:start dma rx,dws->state=0x%x\n",__func__,dws->state);
-		if (rk29_dma_config(dws->rx_dmach, dws->dma_width, 1)) {
-			dev_err(&dws->master->dev, "function: %s, line: %d\n", __FUNCTION__, __LINE__);
-			goto err_out;
-		}
-
-		rk29_dma_ctrl(dws->rx_dmach, RK29_DMAOP_FLUSH);	
-		
-		iRet = rk29_dma_enqueue(dws->rx_dmach, (void *)dws,
-					dws->rx_dma, transfer->len);
-		if (iRet) {
-			dev_err(&dws->master->dev, "function: %s, line: %d\n", __FUNCTION__, __LINE__);
-			goto err_out;
-		}
-		
-		if (rk29_dma_ctrl(dws->rx_dmach, RK29_DMAOP_START)) {
-			dev_err(&dws->master->dev, "function: %s, line: %d\n", __FUNCTION__, __LINE__);
-			goto err_out;
-		}
-	}
-	
-	//wait_till_not_busy(dws);
-	
-	return;
-
-err_out:
-	giveback(dws);
-	return;
-
-}
-
-static void pump_messages(struct work_struct *work)
-{
-	struct rk29xx_spi *dws =
-		container_of(work, struct rk29xx_spi, pump_messages);
-	unsigned long flags;
-
-	DBG(KERN_INFO "pump_messages,line=%d\n",__LINE__);
-	
-	/* Lock queue and check for queue work */
-	spin_lock_irqsave(&dws->lock, flags);
-	if (list_empty(&dws->queue) || dws->run == QUEUE_STOPPED) {
-		dws->busy = 0;
-		spin_unlock_irqrestore(&dws->lock, flags);
-		DBG("%s:line=%d,list_empty\n",__func__,__LINE__);
-		return;
-	}
-
-	/* Make sure we are not already running a message */
-	if (dws->cur_msg) {
-		spin_unlock_irqrestore(&dws->lock, flags);		
-		DBG("%s:line=%d,dws->cur_msg\n",__func__,__LINE__);
-		return;
-	}
-
-	/* Extract head of queue */
-	dws->cur_msg = list_entry(dws->queue.next, struct spi_message, queue);
-	list_del_init(&dws->cur_msg->queue);
-
-	/* Initial message state*/
-	dws->cur_msg->state = START_STATE;
-	dws->cur_transfer = list_entry(dws->cur_msg->transfers.next,
-						struct spi_transfer,
-						transfer_list);
-	dws->cur_chip = spi_get_ctldata(dws->cur_msg->spi);
-    	dws->prev_chip = NULL; //每个pump message时强制更新cs dxj
-
-	
-	/* Mark as busy and launch transfers */
-	tasklet_schedule(&dws->pump_transfers);
-	dws->busy = 1;
-	spin_unlock_irqrestore(&dws->lock, flags);
-	
-}
-
-#if defined(QUICK_TRANSFER)
-static void do_read(struct rk29xx_spi *dws)
-{
-	int count = 0;
-
-	spi_enable_chip(dws, 0);
-	rk29xx_writew(dws, SPIM_CTRLR1, dws->rx_end-dws->rx-1);
-	spi_enable_chip(dws, 1);		
-	rk29xx_writew(dws, SPIM_TXDR, 0);
-	while (1) {
-		if (dws->read(dws))
-			break;
-		if (count++ == 0x20) {
-			dev_err(&dws->master->dev, "+++++++++++spi receive data time out+++++++++++++\n");
-			break;
-		}
-		
-	}
-}
-
-static void do_write(struct rk29xx_spi *dws)
-{
-	while (dws->tx<dws->tx_end) {
-		dws->write(dws);
-	}
-}
-
-/* Caller already set message->status; dma and pio irqs are blocked */
-static void msg_giveback(struct rk29xx_spi *dws)
-{
-	struct spi_transfer *last_transfer;
-	struct spi_message *msg;
-
-	DBG("+++++++++++++++enter %s++++++++++++++++++\n", __func__);
-
-	msg = dws->cur_msg;
-	dws->cur_msg = NULL;
-	dws->cur_transfer = NULL;
-	dws->prev_chip = dws->cur_chip;
-	dws->cur_chip = NULL;
-	dws->dma_mapped = 0;
-	dws->busy = 0;
-
-	last_transfer = list_entry(msg->transfers.prev,
-					struct spi_transfer,
-					transfer_list);
-
-	if (!last_transfer->cs_change && dws->cs_control)
-		dws->cs_control(dws,msg->spi->chip_select,MRST_SPI_DEASSERT);
-
-	msg->state = NULL;	
-}
-
-/* Must be called inside pump_transfers() */
-static int do_full_transfer(struct rk29xx_spi *dws)
-{
-	if ((dws->read(dws))) {
-		goto comple;
-	}
-	
-	while (dws->tx<dws->tx_end){
-		dws->write(dws);		
-		dws->read(dws);
-	}
-	
-	if (dws->rx < dws->rx_end) {
-		dws->read(dws);
-	}
-
-comple:
-	
-	dws->cur_msg->actual_length += dws->len;
-	
-	/* Move to next transfer */
-	dws->cur_msg->state = next_transfer(dws);
-					
-	if (dws->cur_msg->state == DONE_STATE) {
-		dws->cur_msg->status = 0;
-		//msg_giveback(dws);
-		return 0;
-	}
-	else {
-		return -1;
-	}
-	
-}
-
-
-/* Must be called inside pump_transfers() */
-static int do_half_transfer(struct rk29xx_spi *dws)
-{
-	if (dws->rx) {
-		if (dws->tx) {
-			do_write(dws);
-		}
-		wait_till_tf_empty(dws);
-		wait_till_not_busy(dws);
-		do_read(dws);
-	}
-	else {
-		do_write(dws);
-		wait_till_tf_empty(dws);
-		wait_till_not_busy(dws);
-	}
-	
-	dws->cur_msg->actual_length += dws->len;
-	
-	/* Move to next transfer */
-	dws->cur_msg->state = next_transfer(dws);
-					
-	if (dws->cur_msg->state == DONE_STATE) {
-		dws->cur_msg->status = 0;
-		//msg_giveback(dws);
-		return 0;
-	}
-	else {
-		return -1;
-	}
-}
-
-
-static int rk29xx_pump_transfers(struct rk29xx_spi *dws, int mode)
-{
-	struct spi_message *message = NULL;
-	struct spi_transfer *transfer = NULL;
-	struct spi_transfer *previous = NULL;
-	struct spi_device *spi = NULL;
-	struct chip_data *chip = NULL;
-	u8 bits = 0;
-	u8 spi_dfs = 0;
-	u8 cs_change = 0;
-	u16 clk_div = 0;
-	u32 speed = 0;
-	u32 cr0 = 0;
-	u32 dmacr = 0;
-	
-	DBG(KERN_INFO "+++++++++++++++enter %s++++++++++++++++++\n", __func__);
-
-	/* Get current state information */
-	message = dws->cur_msg;
-	transfer = dws->cur_transfer;
-	chip = dws->cur_chip;
-	spi = message->spi;	
-
-	if (unlikely(!chip->clk_div))
-		chip->clk_div = clk_get_rate(dws->clock_spim) / chip->speed_hz;
-	if (message->state == ERROR_STATE) {
-		message->status = -EIO;
-		goto early_exit;
-	}
-
-	/* Handle end of message */
-	if (message->state == DONE_STATE) {
-		message->status = 0;
-		goto early_exit;
-	}
-
-	/* Delay if requested at end of transfer*/
-	if (message->state == RUNNING_STATE) {
-		previous = list_entry(transfer->transfer_list.prev,
-					struct spi_transfer,
-					transfer_list);
-		if (previous->delay_usecs)
-			udelay(previous->delay_usecs);
-	}
-
-	dws->n_bytes = chip->n_bytes;
-	dws->dma_width = chip->dma_width;
-	dws->cs_control = chip->cs_control;
-
-	dws->rx_dma = transfer->rx_dma;
-	dws->tx_dma = transfer->tx_dma;
-	dws->tx = (void *)transfer->tx_buf;
-	dws->tx_end = dws->tx + transfer->len;
-	dws->rx = transfer->rx_buf;
-	dws->rx_end = dws->rx + transfer->len;
-	dws->write = dws->tx ? chip->write : null_writer;
-	dws->read = dws->rx ? chip->read : null_reader;
-	if (dws->rx && dws->tx) {
-		int temp_len = transfer->len;
-		int len;
-		unsigned char *tx_buf;
-		for (len=0; *tx_buf++ != 0; len++);
-		dws->tx_end = dws->tx + len;
-		dws->rx_end = dws->rx + temp_len - len;
-	}
-	dws->cs_change = transfer->cs_change;
-	dws->len = dws->cur_transfer->len;
-	if (chip != dws->prev_chip)
-		cs_change = 1;
-
-	cr0 = chip->cr0;
-
-	/* Handle per transfer options for bpw and speed */
-	if (transfer->speed_hz) {
-		speed = chip->speed_hz;
-
-		if (transfer->speed_hz != speed) {
-			speed = transfer->speed_hz;
-			if (speed > clk_get_rate(dws->clock_spim)) {
-				dev_err(&dws->master->dev, "MRST SPI0: unsupported"
-					"freq: %dHz\n", speed);
-				message->status = -EIO;
-				goto early_exit;
-			}
-
-			/* clk_div doesn't support odd number */
-			clk_div = clk_get_rate(dws->clock_spim) / speed;
-			clk_div = (clk_div + 1) & 0xfffe;
-
-			chip->speed_hz = speed;
-			chip->clk_div = clk_div;
-		}
-	}
-	if (transfer->bits_per_word) {
-		bits = transfer->bits_per_word;
-
-		switch (bits) {
-		case 8:
-			dws->n_bytes = 1;
-			dws->dma_width = 1;
-			dws->read = (dws->read != null_reader) ?
-					u8_reader : null_reader;
-			dws->write = (dws->write != null_writer) ?
-					u8_writer : null_writer;
-			spi_dfs = SPI_DFS_8BIT;
-			break;
-		case 16:
-			dws->n_bytes = 2;
-			dws->dma_width = 2;
-			dws->read = (dws->read != null_reader) ?
-					u16_reader : null_reader;
-			dws->write = (dws->write != null_writer) ?
-					u16_writer : null_writer;
-			spi_dfs = SPI_DFS_16BIT;
-			break;
-		default:
-			dev_err(&dws->master->dev, "MRST SPI0: unsupported bits:"
-				"%db\n", bits);
-			message->status = -EIO;
-			goto early_exit;
-		}
-
-		cr0 = (spi_dfs << SPI_DFS_OFFSET)
-			| (chip->type << SPI_FRF_OFFSET)
-			| (spi->mode << SPI_MODE_OFFSET)
-			| (chip->tmode << SPI_TMOD_OFFSET);
-	}
-	message->state = RUNNING_STATE;
- 
-	/*
-	 * Adjust transfer mode if necessary. Requires platform dependent
-	 * chipselect mechanism.
-	 */
-	if (dws->cs_control) {
-		if (dws->rx && dws->tx)
-			chip->tmode = SPI_TMOD_TR;
-		else if (dws->rx)
-			chip->tmode = SPI_TMOD_RO;
-		else
-			chip->tmode = SPI_TMOD_TO;
-
-		cr0 &= ~(0x3 << SPI_MODE_OFFSET);
-		cr0 &= ~(0x3 << SPI_TMOD_OFFSET);
-		cr0 |= (spi->mode << SPI_MODE_OFFSET);
-		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
-	}
-	
-	/* Check if current transfer is a DMA transaction */
-	dws->dma_mapped = map_dma_buffers(dws);
-
-	/*
-	 * Reprogram registers only if
-	 *	1. chip select changes
-	 *	2. clk_div is changed
-	 *	3. control value changes
-	 */
-	spi_enable_chip(dws, 0);
-	if (rk29xx_readl(dws, SPIM_CTRLR0) != cr0)
-		rk29xx_writel(dws, SPIM_CTRLR0, cr0);
-
-    DBG(KERN_INFO "clk_div: 0x%x, chip->clk_div: 0x%x\n", clk_div, chip->clk_div);
-	spi_set_clk(dws, clk_div ? clk_div : chip->clk_div);		
-	spi_chip_sel(dws, spi->chip_select);		
-	rk29xx_writew(dws, SPIM_CTRLR1, 0);//add by lyx
-	if(dws->dma_mapped ) {
-		dmacr = rk29xx_readw(dws, SPIM_DMACR);
-		dmacr = dmacr | SPI_DMACR_TX_ENABLE;
-		if (mode) 
-			dmacr = dmacr | SPI_DMACR_RX_ENABLE;
-		rk29xx_writew(dws, SPIM_DMACR, dmacr);
-	}
-	spi_enable_chip(dws, 1);
-	if (cs_change)
-		dws->prev_chip = chip;
-	
-	if (mode)
-		return do_full_transfer(dws);
-	else
-		return do_half_transfer(dws);	
-	
-early_exit:
-	
-	//msg_giveback(dws);
-	
-	return 0;
-}
-
-static void rk29xx_pump_messages(struct rk29xx_spi *dws, int mode)
-{
-	DBG(KERN_INFO "+++++++++++++++enter %s++++++++++++++++++\n", __func__);
-	
-	while (!acquire_dma(dws))
-			msleep(10);
-
-	if (list_empty(&dws->queue) || dws->run == QUEUE_STOPPED) {
-		dws->busy = 0;
-		return;
-	}
-
-	/* Make sure we are not already running a message */
-	if (dws->cur_msg) {
-		return;
-	}
-
-	/* Extract head of queue */
-	dws->cur_msg = list_entry(dws->queue.next, struct spi_message, queue);
-	list_del_init(&dws->cur_msg->queue);
-
-	/* Initial message state*/
-	dws->cur_msg->state = START_STATE;
-	dws->cur_transfer = list_entry(dws->cur_msg->transfers.next,
-						struct spi_transfer,
-						transfer_list);
-	dws->cur_chip = spi_get_ctldata(dws->cur_msg->spi);
-    dws->prev_chip = NULL; //每个pump message时强制更新cs dxj
-    
-	/* Mark as busy and launch transfers */
-	dws->busy = 1;
-
-	while (rk29xx_pump_transfers(dws, mode)) ;
-}
-
-/* spi_device use this to queue in their spi_msg */
-static int rk29xx_spi_quick_transfer(struct spi_device *spi, struct spi_message *msg)
-{
-	struct rk29xx_spi *dws = spi_master_get_devdata(spi->master);
-	unsigned long flags;
-	struct rk29xx_spi_chip *chip_info = spi->controller_data;
-	struct spi_message *mmsg;
-	
-	DBG(KERN_INFO "+++++++++++++++enter %s++++++++++++++++++\n", __func__);
-	
-	spin_lock_irqsave(&dws->lock, flags);
-
-	if (dws->run == QUEUE_STOPPED) {
-		spin_unlock_irqrestore(&dws->lock, flags);
-		return -ESHUTDOWN;
-	}
-
-	msg->actual_length = 0;
-	msg->status = -EINPROGRESS;
-	msg->state = START_STATE;
-
-	list_add_tail(&msg->queue, &dws->queue);
-
-	if (chip_info && (chip_info->transfer_mode == rk29xx_SPI_FULL_DUPLEX)) {
-		rk29xx_pump_messages(dws,1);
-	}
-	else {		
-		rk29xx_pump_messages(dws,0);
-	}
-
-	mmsg = dws->cur_msg;
-	msg_giveback(dws);
-	
-	spin_unlock_irqrestore(&dws->lock, flags);
-
-	if (mmsg->complete)
-		mmsg->complete(mmsg->context);
-	
-	return 0;
-}
-
-#else
-
-/* spi_device use this to queue in their spi_msg */
-static int rk29xx_spi_transfer(struct spi_device *spi, struct spi_message *msg)
-{
-	struct rk29xx_spi *dws = spi_master_get_devdata(spi->master);
-	unsigned long flags;
-
-	spin_lock_irqsave(&dws->lock, flags);
-
-	if (dws->run == QUEUE_STOPPED) {
-		spin_unlock_irqrestore(&dws->lock, flags);
-		return -ESHUTDOWN;
-	}
-
-	msg->actual_length = 0;
-	msg->status = -EINPROGRESS;
-	msg->state = START_STATE;
-
-	list_add_tail(&msg->queue, &dws->queue);
-
-	if (dws->run == QUEUE_RUNNING && !dws->busy) {
-
-		if (dws->cur_transfer || dws->cur_msg)
-			queue_work(dws->workqueue,
-					&dws->pump_messages);
-		else {
-			/* If no other data transaction in air, just go */
-			spin_unlock_irqrestore(&dws->lock, flags);
-			pump_messages(&dws->pump_messages);			
-			return 0;
-		}
-	}
-
-	spin_unlock_irqrestore(&dws->lock, flags);
-	
-	return 0;
-}
-
-#endif
-
-/* This may be called twice for each spi dev */
-static int rk29xx_spi_setup(struct spi_device *spi)
-{
-	struct rk29xx_spi_chip *chip_info = NULL;
-	struct chip_data *chip;
-	u8 spi_dfs = 0;
-
-	if (spi->bits_per_word != 8 && spi->bits_per_word != 16)
-		return -EINVAL;
-
-	/* Only alloc on first setup */
-	chip = spi_get_ctldata(spi);
-	if (!chip) {
-		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
-		if (!chip)
-			return -ENOMEM;
-
-		chip->cs_control = spi_cs_control;
-		chip->enable_dma = 0;  //0;
-	}
-
-	/*
-	 * Protocol drivers may change the chip settings, so...
-	 * if chip_info exists, use it
-	 */
-	chip_info = spi->controller_data;
-
-	/* chip_info doesn't always exist */
-	if (chip_info) {
-		if (chip_info->cs_control)
-			chip->cs_control = chip_info->cs_control;
-
-		chip->poll_mode = chip_info->poll_mode;
-		chip->type = chip_info->type;
-		chip->slave_enable = chip_info->slave_enable;
-		chip->rx_threshold = 0;
-		chip->tx_threshold = 0;
-
-		chip->enable_dma = chip_info->enable_dma;
-	}
-
-	if (spi->bits_per_word == 8) {
-		chip->n_bytes = 1;
-		chip->dma_width = 1;
-		chip->read = u8_reader;
-		chip->write = u8_writer;
-		spi_dfs = SPI_DFS_8BIT;
-	} else if (spi->bits_per_word == 16) {
-		chip->n_bytes = 2;
-		chip->dma_width = 2;
-		chip->read = u16_reader;
-		chip->write = u16_writer;
-		spi_dfs = SPI_DFS_16BIT;
-	} else {
-		/* Never take >16b case for MRST SPIC */
-		dev_err(&spi->dev, "invalid wordsize\n");
-		return -EINVAL;
-	}
-	chip->bits_per_word = spi->bits_per_word;
-
-	if (!spi->max_speed_hz) {
-		dev_err(&spi->dev, "No max speed HZ parameter\n");
-		return -EINVAL;
-	}
-	chip->speed_hz = spi->max_speed_hz;
-
-	chip->tmode = 0; /* Tx & Rx */
-	/* Default SPI mode is SCPOL = 0, SCPH = 0 */
-	chip->cr0 = (spi_dfs << SPI_DFS_OFFSET)
-	        | (SPI_HALF_WORLD_OFF << SPI_HALF_WORLD_TX_OFFSET)
-			| (SPI_SSN_DELAY_ONE << SPI_SSN_DELAY_OFFSET)
-			| (chip->type << SPI_FRF_OFFSET)
-			| (spi->mode  << SPI_MODE_OFFSET)
-			| (chip->tmode << SPI_TMOD_OFFSET);
-
-	spi_set_ctldata(spi, chip);
-	return 0;
-}
-
-static void rk29xx_spi_cleanup(struct spi_device *spi)
-{
-	struct chip_data *chip = spi_get_ctldata(spi);
-	kfree(chip);
-}
-
-static int __devinit init_queue(struct rk29xx_spi *dws)
-{
-	INIT_LIST_HEAD(&dws->queue);
-	spin_lock_init(&dws->lock);
-
-	dws->run = QUEUE_STOPPED;
-	dws->busy = 0;
-
-	init_completion(&dws->xfer_completion);
-
-	tasklet_init(&dws->pump_transfers,
-			pump_transfers,	(unsigned long)dws);
-
-	INIT_WORK(&dws->pump_messages, pump_messages);
-	dws->workqueue = create_singlethread_workqueue(
-					dev_name(dws->master->dev.parent));
-	if (dws->workqueue == NULL)
-		return -EBUSY;
-
-
-	return 0;
-}
-
-static int start_queue(struct rk29xx_spi *dws)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&dws->lock, flags);
-
-	if (dws->run == QUEUE_RUNNING || dws->busy) {
-		spin_unlock_irqrestore(&dws->lock, flags);
-		return -EBUSY;
-	}
-
-	dws->run = QUEUE_RUNNING;
-	dws->cur_msg = NULL;
-	dws->cur_transfer = NULL;
-	dws->cur_chip = NULL;
-	dws->prev_chip = NULL;
-	spin_unlock_irqrestore(&dws->lock, flags);
-
-	queue_work(dws->workqueue, &dws->pump_messages);
-
-	return 0;
-}
-
-static int stop_queue(struct rk29xx_spi *dws)
-{
-	unsigned long flags;
-	unsigned limit = 50;
-	int status = 0;
-
-	spin_lock_irqsave(&dws->lock, flags);
-	dws->run = QUEUE_STOPPED;
-	while (!list_empty(&dws->queue) && dws->busy && limit--) {
-		spin_unlock_irqrestore(&dws->lock, flags);
-		msleep(10);
-		spin_lock_irqsave(&dws->lock, flags);
-	}
-
-	if (!list_empty(&dws->queue) || dws->busy)
-		status = -EBUSY;
-	spin_unlock_irqrestore(&dws->lock, flags);
-
-	return status;
-}
-
-static int destroy_queue(struct rk29xx_spi *dws)
-{
-	int status;
-
-	status = stop_queue(dws);
-	if (status != 0)
-		return status;
-	destroy_workqueue(dws->workqueue);
-	return 0;
-}
-
-/* Restart the controller, disable all interrupts, clean rx fifo */
-static void spi_hw_init(struct rk29xx_spi *dws)
-{
-	spi_enable_chip(dws, 0);
-	spi_mask_intr(dws, 0xff);
-	
-	/*
-	 * Try to detect the FIFO depth if not set by interface driver,
-	 * the depth could be from 2 to 32 from HW spec
-	 */
-	if (!dws->fifo_len) {
-		u32 fifo;
-		for (fifo = 2; fifo <= 31; fifo++) {
-			rk29xx_writew(dws, SPIM_TXFTLR, fifo);
-			if (fifo != rk29xx_readw(dws, SPIM_TXFTLR))
-				break;
-		}
-
-		dws->fifo_len = (fifo == 31) ? 0 : fifo;
-		rk29xx_writew(dws, SPIM_TXFTLR, 0);
-	}
-	
-	spi_enable_chip(dws, 1);
-	//flush(dws);
-}
-
-/* cpufreq driver support */
-#ifdef CONFIG_CPU_FREQ
-
-static int rk29xx_spim_cpufreq_transition(struct notifier_block *nb, unsigned long val, void *data)
-{
-        struct rk29xx_spi *info;
-        unsigned long newclk;
-
-        info = container_of(nb, struct rk29xx_spi, freq_transition);
-        newclk = clk_get_rate(info->clock_spim);
-
-        return 0;
-}
-
-static inline int rk29xx_spim_cpufreq_register(struct rk29xx_spi *info)
-{
-        info->freq_transition.notifier_call = rk29xx_spim_cpufreq_transition;
-
-        return cpufreq_register_notifier(&info->freq_transition, CPUFREQ_TRANSITION_NOTIFIER);
-}
-
-static inline void rk29xx_spim_cpufreq_deregister(struct rk29xx_spi *info)
-{
-        cpufreq_unregister_notifier(&info->freq_transition, CPUFREQ_TRANSITION_NOTIFIER);
-}
-
-#else
-static inline int rk29xx_spim_cpufreq_register(struct rk29xx_spi *info)
-{
-        return 0;
-}
-
-static inline void rk29xx_spim_cpufreq_deregister(struct rk29xx_spi *info)
-{
-}
-#endif
-static int __init rk29xx_spim_probe(struct platform_device *pdev)
-{
-	struct resource		*regs, *dmatx_res, *dmarx_res;
-	struct rk29xx_spi   *dws;
-	struct spi_master   *master;
-	int			irq; 
-	int ret;
-	struct rk29xx_spi_platform_data *pdata = pdev->dev.platform_data;
-
-	if (pdata && pdata->io_init) {
-		ret = pdata->io_init(pdata->chipselect_gpios, pdata->num_chipselect);
-		if (ret) {			
-			return -ENXIO;	
-		}
-	}
-	
-	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!regs)
-		return -ENXIO;
-	dmatx_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-	if (dmatx_res == NULL) {
-		dev_err(&pdev->dev, "Unable to get SPI-Tx dma resource\n");
-		return -ENXIO;
-	}
-
-	dmarx_res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
-	if (dmarx_res == NULL) {
-		dev_err(&pdev->dev, "Unable to get SPI-Rx dma resource\n");
-		return -ENXIO;
-	}
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
-		return irq;			
-	/* setup spi core then atmel-specific driver state */
-	ret = -ENOMEM;	
-	master = spi_alloc_master(&pdev->dev, sizeof *dws);
-	if (!master) {
-		ret = -ENOMEM;
-		goto exit;
-	}
-
-	platform_set_drvdata(pdev, master);
-	dws = spi_master_get_devdata(master);
-	dws->clock_spim = clk_get(&pdev->dev, "spi");
-	clk_enable(dws->clock_spim);
-	if (IS_ERR(dws->clock_spim)) {
-		dev_err(&pdev->dev, "clk_get for spi fail(%p)\n", dws->clock_spim);
-		return PTR_ERR(dws->clock_spim);
-	}
-
-	dws->pclk = clk_get(&pdev->dev, "pclk_spi");
-	clk_enable(dws->pclk);
-	
-	mutex_init(&dws->dma_lock);
-	
-	dws->regs = ioremap(regs->start, (regs->end - regs->start) + 1);
-	if (!dws->regs){
-    	release_mem_region(regs->start, (regs->end - regs->start) + 1);
-		return -EBUSY;
-	}
-	DBG(KERN_INFO "dws->regs: %p\n", dws->regs);
-    	dws->irq = irq;
-	dws->irq_polarity = IRQF_TRIGGER_NONE;
-	dws->master = master;
-	dws->type = SSI_MOTO_SPI;
-	dws->prev_chip = NULL;
-	dws->sfr_start = regs->start;
-	dws->tx_dmach = dmatx_res->start;
-	dws->rx_dmach = dmarx_res->start;
-	dws->dma_inited = 0;  ///0;
-	///dws->dma_addr = (dma_addr_t)(dws->paddr + 0x60);
-	ret = request_irq(dws->irq, rk29xx_spi_irq, dws->irq_polarity,
-			"rk29xx_spim", dws);
-	if (ret < 0) {
-		dev_err(&master->dev, "can not get IRQ\n");
-		goto err_free_master;
-	}
-
-	master->mode_bits = SPI_CPOL | SPI_CPHA;
-	master->bus_num = pdev->id;
-	master->num_chipselect = pdata->num_chipselect;
-	master->dev.platform_data = pdata;
-	master->cleanup = rk29xx_spi_cleanup;
-	master->setup = rk29xx_spi_setup;
-	#if defined(QUICK_TRANSFER)
-	master->transfer = rk29xx_spi_quick_transfer;
-	#else
-	master->transfer = rk29xx_spi_transfer;
-	#endif
-	
-	dws->pdev = pdev;
-	/* Basic HW init */
-	spi_hw_init(dws);
-	flush(dws);
-	/* Initial and start queue */
-	ret = init_queue(dws);
-	if (ret) {
-		dev_err(&master->dev, "problem initializing queue\n");
-		goto err_diable_hw;
-	}
-
-	ret = start_queue(dws);
-	if (ret) {
-		dev_err(&master->dev, "problem starting queue\n");
-		goto err_diable_hw;
-	}
-
-	spi_master_set_devdata(master, dws);
-	ret = spi_register_master(master);
-	if (ret) {
-		dev_err(&master->dev, "problem registering spi master\n");
-		goto err_queue_alloc;
-	}
-
-    ret =rk29xx_spim_cpufreq_register(dws);
-    if (ret < 0) {
-        dev_err(&master->dev, "rk29xx spim failed to init cpufreq support\n");
-        goto err_queue_alloc;
-    }
-	printk(KERN_INFO "rk29xx_spim: driver initialized, fifo_len=%d,bus_num=%d\n", dws->fifo_len,master->bus_num);
-	mrst_spi_debugfs_init(dws);
-	return 0;
-
-err_queue_alloc:
-	destroy_queue(dws);
-err_diable_hw:
-	spi_enable_chip(dws, 0);
-	free_irq(dws->irq, dws);
-err_free_master:
-	spi_master_put(master);
-	iounmap(dws->regs);
-exit:
-	return ret;
-}
-
-static void __exit rk29xx_spim_remove(struct platform_device *pdev)
-{
-	struct spi_master *master = platform_get_drvdata(pdev);
-	struct rk29xx_spi *dws = spi_master_get_devdata(master);
-	int status = 0;
-
-	if (!dws)
-		return;
-	rk29xx_spim_cpufreq_deregister(dws);
-	mrst_spi_debugfs_remove(dws);
-
-	if(dws->buffer_tx_dma)
-	dma_free_coherent(&pdev->dev, DMA_BUFFER_SIZE, dws->buffer_tx_dma, dws->tx_dma);
-	if(dws->buffer_rx_dma)
-	dma_free_coherent(&pdev->dev, DMA_BUFFER_SIZE, dws->buffer_rx_dma, dws->rx_dma);
-	release_dma(dws);
-
-	/* Remove the queue */
-	status = destroy_queue(dws);
-	if (status != 0)
-		dev_err(&dws->master->dev, "rk29xx_spi_remove: workqueue will not "
-			"complete, message memory not freed\n");
-	
-	clk_disable(dws->clock_spim);
-	clk_put(dws->clock_spim);
-	clk_disable(dws->pclk);
-	clk_put(dws->pclk);
-	spi_enable_chip(dws, 0);
-	/* Disable clk */
-	spi_set_clk(dws, 0);
-	free_irq(dws->irq, dws);
-
-	/* Disconnect from the SPI framework */
-	spi_unregister_master(dws->master);
-	iounmap(dws->regs);
-}
-
-
-#ifdef	CONFIG_PM
-
-static int rk29xx_spim_suspend(struct platform_device *pdev, pm_message_t mesg)
-{
-	struct spi_master *master = platform_get_drvdata(pdev);
-	struct rk29xx_spi *dws = spi_master_get_devdata(master);
-	struct rk29xx_spi_platform_data *pdata = pdev->dev.platform_data;
-	int status;
-	
-	flush(dws);
-	status = stop_queue(dws);
-	if (status != 0)
-		return status;
-	clk_disable(dws->clock_spim);
-	if (pdata && pdata->io_fix_leakage_bug)
- 	{
-		pdata->io_fix_leakage_bug( );
-	}
-	clk_disable(dws->pclk);
-	return 0;
-}
-
-static int rk29xx_spim_resume(struct platform_device *pdev)
-{
-	struct spi_master *master = platform_get_drvdata(pdev);
-	struct rk29xx_spi *dws = spi_master_get_devdata(master);
-	struct rk29xx_spi_platform_data *pdata = pdev->dev.platform_data;
-	int ret;
-
-	clk_enable(dws->pclk);
-	clk_enable(dws->clock_spim);	
-	spi_hw_init(dws);
-	ret = start_queue(dws);
-	if (ret)
-		dev_err(&dws->master->dev, "fail to start queue (%d)\n", ret);
-	if (pdata && pdata->io_resume_leakage_bug)
- 	{
-		pdata->io_resume_leakage_bug( ); 
-	}
-	return ret;
-}
-
-#else
-#define	rk29xx_spim_suspend	NULL
-#define	rk29xx_spim_resume	NULL
-#endif
-
-static struct platform_driver rk29xx_platform_spim_driver = {
-	.remove		= __exit_p(rk29xx_spim_remove),
-	.driver		= {
-		.name	= "rk29xx_spim",
-		.owner	= THIS_MODULE,
-	},
-	.suspend	= rk29xx_spim_suspend,
-	.resume		= rk29xx_spim_resume,
-};
-
-static int __init rk29xx_spim_init(void)
-{
-	int ret;
-	ret = platform_driver_probe(&rk29xx_platform_spim_driver, rk29xx_spim_probe);	
-	return ret;
-}
-
-static void __exit rk29xx_spim_exit(void)
-{
-	platform_driver_unregister(&rk29xx_platform_spim_driver);
-}
-
-arch_initcall_sync(rk29xx_spim_init);
-module_exit(rk29xx_spim_exit);
-
-MODULE_AUTHOR("www.rock-chips.com");
-MODULE_DESCRIPTION("Rockchip RK29xx spim port driver");
-MODULE_LICENSE("GPL");;
-
diff --git a/drivers/spi/rk29_spim.h b/drivers/spi/rk29_spim.h
deleted file mode 100755
index 073c434a7929..000000000000
--- a/drivers/spi/rk29_spim.h
+++ /dev/null
@@ -1,265 +0,0 @@
-/* drivers/spi/rk29xx_spim.h
- *
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#ifndef __DRIVERS_SPIM_RK29XX_HEADER_H
-#define __DRIVERS_SPIM_RK29XX_HEADER_H
-#include <linux/io.h>
-#ifdef CONFIG_ARCH_RK30
-#include <plat/dma-pl330.h>
-#else
-#include <mach/dma-pl330.h>
-#endif
-
-/* SPI register offsets */
-#define SPIM_CTRLR0				0x0000
-#define SPIM_CTRLR1				0x0004
-#define SPIM_ENR				0x0008
-#define SPIM_SER				0x000c
-#define SPIM_BAUDR				0x0010
-#define SPIM_TXFTLR				0x0014
-#define SPIM_RXFTLR				0x0018
-#define SPIM_TXFLR				0x001c
-#define SPIM_RXFLR				0x0020
-#define SPIM_SR					0x0024
-#define SPIM_IPR                0x0028
-#define SPIM_IMR				0x002c
-#define SPIM_ISR				0x0030
-#define SPIM_RISR				0x0034
-#define SPIM_ICR				0x0038
-#define SPIM_DMACR				0x003c
-#define SPIM_DMATDLR			0x0040
-#define SPIM_DMARDLR			0x0044
-#define SPIM_TXDR				0x0400
-#define SPIM_RXDR               0x0800
-
-/* --------Bit fields in CTRLR0--------begin */
-
-#define SPI_DFS_OFFSET			0                  /* Data Frame Size */
-#define SPI_DFS_4BIT            0x00
-#define SPI_DFS_8BIT            0x01
-#define SPI_DFS_16BIT           0x02
-#define SPI_DFS_RESV            0x03
-
-#define SPI_FRF_OFFSET			16                 /* Frame Format */
-#define SPI_FRF_SPI			    0x00               /* motorola spi */
-#define SPI_FRF_SSP			    0x01               /* Texas Instruments SSP*/
-#define SPI_FRF_MICROWIRE		0x02               /*  National Semiconductors Microwire */
-#define SPI_FRF_RESV			0x03
-
-#define SPI_MODE_OFFSET		    6                 /* SCPH & SCOL */
-
-#define SPI_SCPH_OFFSET			6                  /* Serial Clock Phase */
-#define SPI_SCPH_TOGMID         0                  /* Serial clock toggles in middle of first data bit */
-#define SPI_SCPH_TOGSTA         1                  /* Serial clock toggles at start of first data bit */
-
-#define SPI_SCOL_OFFSET			7                  /* Serial Clock Polarity */
-
-#define SPI_OPMOD_OFFSET	    20
-#define SPI_OPMOD_MASTER        0
-#define SPI_OPMOD_SLAVE         1
-
-#define SPI_TMOD_OFFSET			18                 /* Transfer Mode */
-#define	SPI_TMOD_TR			    0x00		       /* xmit & recv */
-#define SPI_TMOD_TO			    0x01		       /* xmit only */
-#define SPI_TMOD_RO			    0x02		       /* recv only */
-#define SPI_TMOD_RESV		    0x03
-
-#define SPI_CFS_OFFSET			2                  /* Control Frame Size */
-
-#define SPI_CSM_OFFSET          8                  /* Chip Select Mode */
-#define SPI_CSM_KEEP            0x00               /* ss_n keep low after every frame data is transferred */
-#define SPI_CSM_HALF            0x01               /* ss_n be high for half sclk_out cycles after every frame data is transferred */
-#define SPI_CSM_ONE             0x02               /* ss_n be high for one sclk_out cycle after every frame data is transferred */
-
-#define SPI_SSN_DELAY_OFFSET    10
-#define SPI_SSN_DELAY_HALF      0x00
-#define SPI_SSN_DELAY_ONE       0x01
-
-#define SPI_HALF_WORLD_TX_OFFSET       13
-#define SPI_HALF_WORLD_ON       0x00
-#define SPI_HALF_WORLD_OFF      0x01
-
-
-/* --------Bit fields in CTRLR0--------end */
-
-
-/* Bit fields in SR, 7 bits */
-#define SR_MASK				0x7f		/* cover 7 bits */
-#define SR_BUSY				(1 << 0)
-#define SR_TF_FULL		    (1 << 1)
-#define SR_TF_EMPT			(1 << 2)
-#define SR_RF_EMPT		    (1 << 3)
-#define SR_RF_FULL			(1 << 4)
-
-/* Bit fields in ISR, IMR, RISR, 7 bits */
-#define SPI_INT_TXEI			(1 << 0)
-#define SPI_INT_TXOI			(1 << 1)
-#define SPI_INT_RXUI			(1 << 2)
-#define SPI_INT_RXOI			(1 << 3)
-#define SPI_INT_RXFI			(1 << 4)
-
-/* Bit fields in DMACR */
-#define SPI_DMACR_TX_ENABLE     (1 << 1)
-#define SPI_DMACR_RX_ENABLE     (1 << 0)
-
-/* Bit fields in ICR */
-#define SPI_CLEAR_INT_ALL       (1<< 0)
-#define SPI_CLEAR_INT_RXUI      (1 << 1)
-#define SPI_CLEAR_INT_RXOI      (1 << 2)
-#define SPI_CLEAR_INT_TXOI      (1 << 3)
-
-enum rk29xx_ssi_type {
-	SSI_MOTO_SPI = 0,
-	SSI_TI_SSP,
-	SSI_NS_MICROWIRE,
-};
-
-struct rk29xx_spi {
-	struct spi_master	*master;
-	struct spi_device	*cur_dev;
-	enum rk29xx_ssi_type	type;
-
-	void __iomem		*regs;
-	unsigned long		paddr;
-	u32			iolen;
-	int			irq;
-	u32         irq_polarity;
-	u32			fifo_len;	/* depth of the FIFO buffer */
-	struct clk		*clock_spim;	/* clk apb */
-	struct clk		*pclk;
-	struct platform_device	*pdev;
-	
-	/* Driver message queue */
-	struct workqueue_struct	*workqueue;
-	struct work_struct	pump_messages;
-	spinlock_t		lock;	
-	struct mutex 		dma_lock;
-	struct list_head	queue;
-	int			busy;
-	int			run;
-
-	/* Message Transfer pump */
-	struct tasklet_struct	pump_transfers;	
-	struct tasklet_struct	dma_transfers;	
-
-	/* Current message transfer state info */
-	struct spi_message	*cur_msg;
-	struct spi_transfer	*cur_transfer;
-	struct chip_data	*cur_chip;
-	struct chip_data	*prev_chip;
-	size_t			len;
-	void			*tx;
-	void			*tx_end;
-	void			*rx;
-	void			*rx_end;
-	int			dma_mapped;
-	dma_addr_t		rx_dma;
-	dma_addr_t		tx_dma;
-	void			*buffer_tx_dma;
-	void			*buffer_rx_dma;
-	size_t			rx_map_len;
-	size_t			tx_map_len;
-	u8			n_bytes;	/* current is a 1/2 bytes op */
-	u8			max_bits_per_word;	/* maxim is 16b */
-	u32			dma_width;
-	int			cs_change;
-	int			(*write)(struct rk29xx_spi *dws);
-	int			(*read)(struct rk29xx_spi *dws);
-	irqreturn_t		(*transfer_handler)(struct rk29xx_spi *dws);
-	void (*cs_control)(struct rk29xx_spi *dws, u32 cs, u8 flag);
-
-	/* Dma info */
-	struct completion               xfer_completion;
-	
-	struct completion               tx_completion;
-	struct completion               rx_completion;
-	unsigned    state;
-	unsigned                        cur_speed;
-	unsigned long                   sfr_start;
-	int			dma_inited;
-	enum dma_ch rx_dmach;
-	enum dma_ch tx_dmach;
-	int			txdma_done;
-	int			rxdma_done;
-	u64			tx_param;
-	u64			rx_param;
-	struct device		*dma_dev;
-	dma_addr_t		dma_addr;
-
-	/* Bus interface info */
-	void			*priv;
-#ifdef CONFIG_DEBUG_FS
-	struct dentry *debugfs;
-#endif
-#ifdef CONFIG_CPU_FREQ
-        struct notifier_block   freq_transition;
-#endif
-};
-
-#define rk29xx_readl(dw, off) \
-	__raw_readl(dw->regs + off)
-#define rk29xx_writel(dw,off,val) \
-	__raw_writel(val, dw->regs + off)
-#define rk29xx_readw(dw, off) \
-	__raw_readw(dw->regs + off)
-#define rk29xx_writew(dw,off,val) \
-	__raw_writel(val, dw->regs + off)
-
-static inline void spi_enable_chip(struct rk29xx_spi *dws, int enable)
-{
-	rk29xx_writel(dws, SPIM_ENR, (enable ? 1 : 0));
-}
-
-static inline void spi_set_clk(struct rk29xx_spi *dws, u16 div)
-{
-	rk29xx_writel(dws, SPIM_BAUDR, div);
-}
-
-/* Disable IRQ bits */
-static inline void spi_mask_intr(struct rk29xx_spi *dws, u32 mask)
-{
-	u32 new_mask;
-
-	new_mask = rk29xx_readl(dws, SPIM_IMR) & ~mask;
-	rk29xx_writel(dws, SPIM_IMR, new_mask);
-}
-
-/* Enable IRQ bits */
-static inline void spi_umask_intr(struct rk29xx_spi *dws, u32 mask)
-{
-	u32 new_mask;
-
-	new_mask = rk29xx_readl(dws, SPIM_IMR) | mask;
-	rk29xx_writel(dws, SPIM_IMR, new_mask);
-}
-
-//spi transfer mode                   add by lyx
-#define rk29xx_SPI_HALF_DUPLEX 0
-#define rk29xx_SPI_FULL_DUPLEX 1
-
-/*
- * Each SPI slave device to work with rk29xx spi controller should
- * has such a structure claiming its working mode (PIO/DMA etc),
- * which can be save in the "controller_data" member of the
- * struct spi_device
- */
-struct rk29xx_spi_chip {
-	u8 transfer_mode;/*full or half duplex*/
-	u8 poll_mode;	/* 0 for contoller polling mode */
-	u8 type;	/* SPI/SSP/Micrwire */
-	u8 enable_dma;
-	u8 slave_enable;
-	void (*cs_control)(struct rk29xx_spi *dws, u32 cs, u8 flag);
-};
-
-#endif /* __DRIVERS_SPIM_RK29XX_HEADER_H */
diff --git a/drivers/spi/spi-rk.c b/drivers/spi/spi-rk.c
deleted file mode 100644
index 257319be2dbe..000000000000
--- a/drivers/spi/spi-rk.c
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * rockchip spi interface driver for DW SPI Core
- *
- * Copyright (c) 2014, ROCKCHIP Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/dma-mapping.h>
-#include <linux/dmaengine.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/spi/spi.h>
-#include <linux/gpio.h>
-#include <linux/of.h>
-#include <linux/of_gpio.h>
-#include <linux/platform_data/spi-rockchip.h>
-
-#include "spi-rockchip-core.h"
-
-
-#define DRIVER_NAME "rockchip_spi_driver_data"
-#define SPI_MAX_FREQUENCY	24000000
-
-struct rockchip_spi_driver_data {
-	struct platform_device *pdev;
-	struct dw_spi	dws;
-	struct rockchip_spi_info *info;
-	struct clk                      *clk_spi;
-	struct clk                      *pclk_spi;
-};
-
-#ifdef CONFIG_OF
-static struct rockchip_spi_info *rockchip_spi_parse_dt(struct device *dev)
-{
-	struct rockchip_spi_info *info;
-	u32 temp;
-
-	info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
-	if (!info) {
-		dev_err(dev, "memory allocation for spi_info failed\n");
-		return ERR_PTR(-ENOMEM);
-	}
-
-	if (of_property_read_u32(dev->of_node, "rockchip,spi-src-clk", &temp)) {
-		dev_warn(dev, "spi bus clock parent not specified, using clock at index 0 as parent\n");
-		info->src_clk_nr = 0;
-	} else {
-		info->src_clk_nr = temp;
-	}
-#if 0
-	if (of_property_read_u32(dev->of_node, "bus-num", &temp)) {
-		dev_warn(dev, "number of bus not specified, assuming bus 0\n");
-		info->bus_num= 0;
-	} else {
-		info->bus_num = temp;
-	}
-#endif
-	if (of_property_read_u32(dev->of_node, "num-cs", &temp)) {
-		dev_warn(dev, "number of chip select lines not specified, assuming 1 chip select line\n");
-		info->num_cs = 1;
-	} else {
-		info->num_cs = temp;
-	}
-
-	if (of_property_read_u32(dev->of_node, "max-freq", &temp)) {
-		dev_warn(dev, "fail to get max-freq,default set %dHZ\n",SPI_MAX_FREQUENCY);
-		info->spi_freq = SPI_MAX_FREQUENCY;
-	} else {
-		info->spi_freq = temp;
-	}
-	
-	//printk("%s:line=%d,src_clk_nr=%d,bus_num=%d,num_cs=%d\n",__func__, __LINE__,info->src_clk_nr,info->bus_num,info->num_cs);
-	
-	return info;
-}
-#else
-static struct rockchip_spi_info *rockchip_spi_parse_dt(struct device *dev)
-{
-	return dev->platform_data;
-}
-#endif
-
-
-static int rockchip_spi_probe(struct platform_device *pdev)
-{
-	struct resource	*mem_res;
-	struct rockchip_spi_driver_data *sdd;
-	struct rockchip_spi_info *info = pdev->dev.platform_data;
-	struct dw_spi *dws;
-	int ret, irq;
-	char clk_name[16];
-
-	if (!info && pdev->dev.of_node) {
-		info = rockchip_spi_parse_dt(&pdev->dev);
-		if (IS_ERR(info))
-			return PTR_ERR(info);
-	}
-
-	if (!info) {
-		dev_err(&pdev->dev, "platform_data missing!\n");
-		return -ENODEV;
-	}	
-
-	sdd = kzalloc(sizeof(struct rockchip_spi_driver_data), GFP_KERNEL);
-	if (!sdd) {
-		ret = -ENOMEM;
-		goto err_kfree;
-	}
-
-	
-	sdd->pdev = pdev;
-	sdd->info = info;
-	dws = &sdd->dws;
-
-	atomic_set(&dws->debug_flag, 0);//debug flag
-
-	/* Get basic io resource and map it */
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_warn(&pdev->dev, "Failed to get IRQ: %d\n", irq);
-		return irq;
-	}
-	
-	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (mem_res == NULL) {
-		dev_err(&pdev->dev, "Unable to get SPI MEM resource\n");
-		ret =  -ENXIO;
-		goto err_unmap;
-	}
-	
-	dws->regs = ioremap(mem_res->start, (mem_res->end - mem_res->start) + 1);
-	if (!dws->regs){
-		ret = -EBUSY;
-		goto err_unmap;
-	}
-
-	dws->paddr = mem_res->start;
-	dws->iolen = (mem_res->end - mem_res->start) + 1;
-	
-	printk(KERN_INFO "dws->regs: %p\n", dws->regs);
-
-	//get bus num
-	if (pdev->dev.of_node) {
-		ret = of_alias_get_id(pdev->dev.of_node, "spi");
-		if (ret < 0) {
-			dev_err(&pdev->dev, "failed to get alias id, errno %d\n",
-				ret);
-			goto err_release_mem;
-		}
-		info->bus_num = ret;
-	} else {
-		info->bus_num = pdev->id;
-	}
-
-	/* Setup clocks */
-	sdd->clk_spi = devm_clk_get(&pdev->dev, "spi");
-	if (IS_ERR(sdd->clk_spi)) {
-		dev_err(&pdev->dev, "Unable to acquire clock 'spi'\n");
-		ret = PTR_ERR(sdd->clk_spi);
-		goto err_clk;
-	}
-
-	if (clk_prepare_enable(sdd->clk_spi)) {
-		dev_err(&pdev->dev, "Couldn't enable clock 'spi'\n");
-		ret = -EBUSY;
-		goto err_clk;
-	}
-	
-	sprintf(clk_name, "pclk_spi%d", info->src_clk_nr);
-	sdd->pclk_spi = devm_clk_get(&pdev->dev, clk_name);
-	if (IS_ERR(sdd->pclk_spi)) {
-		dev_err(&pdev->dev,
-			"Unable to acquire clock '%s'\n", clk_name);
-		ret = PTR_ERR(sdd->pclk_spi);
-		goto err_pclk;
-	}
-
-	if (clk_prepare_enable(sdd->pclk_spi)) {
-		dev_err(&pdev->dev, "Couldn't enable clock '%s'\n", clk_name);
-		ret = -EBUSY;
-		goto err_pclk;
-	}
-
-	clk_set_rate(sdd->clk_spi, info->spi_freq);
-	
-	dws->max_freq = clk_get_rate(sdd->clk_spi);
-	dws->parent_dev = &pdev->dev;
-	dws->bus_num = info->bus_num;
-	dws->num_cs = info->num_cs;
-	dws->irq = irq;
-	dws->clk_spi = sdd->clk_spi;	
-	dws->pclk_spi = sdd->pclk_spi;
-
-	/*
-	 * handling for rockchip paltforms, like dma setup,
-	 * clock rate, FIFO depth.
-	 */
-	
-#ifdef CONFIG_SPI_ROCKCHIP_DMA
-	ret = dw_spi_dma_init(dws);
-	if (ret)
-	printk("%s:fail to init dma\n",__func__);
-#endif
-
-	ret = dw_spi_add_host(dws);
-	if (ret)
-		goto err_release_mem;
-
-	platform_set_drvdata(pdev, sdd);
-
-	printk("%s:num_cs=%d,bus_num=%d,irq=%d,freq=%d ok\n",__func__, info->num_cs, info->bus_num, irq, dws->max_freq);
-	
-	return 0;
-err_release_mem:
-    release_mem_region(mem_res->start, (mem_res->end - mem_res->start) + 1);
-err_pclk:
-	clk_disable_unprepare(sdd->pclk_spi);
-err_clk:
-	clk_disable_unprepare(sdd->clk_spi);
-err_unmap:
-	iounmap(dws->regs);
-err_kfree:
-	kfree(sdd);
-	return ret;
-}
-
-static int rockchip_spi_remove(struct platform_device *pdev)
-{
-	struct rockchip_spi_driver_data *sdd = platform_get_drvdata(pdev);
-	
-	platform_set_drvdata(pdev, NULL);
-	dw_spi_remove_host(&sdd->dws);
-	iounmap(sdd->dws.regs);
-	kfree(sdd);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int rockchip_spi_suspend(struct device *dev)
-{
-	struct rockchip_spi_driver_data *sdd = dev_get_drvdata(dev);
-	int ret = 0;
-	
-	ret = dw_spi_suspend_host(&sdd->dws);
-	
-	return ret;
-}
-
-static int rockchip_spi_resume(struct device *dev)
-{
-	struct rockchip_spi_driver_data *sdd = dev_get_drvdata(dev);
-	int ret = 0;
-	
-	ret = dw_spi_resume_host(&sdd->dws);	
-
-	return ret;
-}
-#endif /* CONFIG_PM_SLEEP */
-
-#ifdef CONFIG_PM_RUNTIME
-static int rockchip_spi_runtime_suspend(struct device *dev)
-{
-	struct rockchip_spi_driver_data *sdd = dev_get_drvdata(dev);
-	struct dw_spi *dws = &sdd->dws;
-	
-	clk_disable_unprepare(sdd->clk_spi);
-	clk_disable_unprepare(sdd->pclk_spi);
-
-	
-	DBG_SPI("%s\n",__func__);
-	
-	return 0;
-}
-
-static int rockchip_spi_runtime_resume(struct device *dev)
-{
-	struct rockchip_spi_driver_data *sdd = dev_get_drvdata(dev);
-	struct dw_spi *dws = &sdd->dws;
-
-	clk_prepare_enable(sdd->pclk_spi);
-	clk_prepare_enable(sdd->clk_spi);
-	
-	DBG_SPI("%s\n",__func__);
-	return 0;
-}
-#endif /* CONFIG_PM_RUNTIME */
-
-static const struct dev_pm_ops rockchip_spi_pm = {
-	SET_SYSTEM_SLEEP_PM_OPS(rockchip_spi_suspend, rockchip_spi_resume)
-	SET_RUNTIME_PM_OPS(rockchip_spi_runtime_suspend,
-			   rockchip_spi_runtime_resume, NULL)
-};
-
-#ifdef CONFIG_OF
-static const struct of_device_id rockchip_spi_dt_match[] = {
-	{ .compatible = "rockchip,rockchip-spi",
-	},
-	{ },
-};
-MODULE_DEVICE_TABLE(of, rockchip_spi_dt_match);
-#endif /* CONFIG_OF */
-
-static struct platform_driver rockchip_spi_driver = {
-	.driver = {
-		.name	= "rockchip-spi",
-		.owner = THIS_MODULE,
-		.pm = &rockchip_spi_pm,
-		.of_match_table = of_match_ptr(rockchip_spi_dt_match),
-	},
-	.remove = rockchip_spi_remove,
-};
-MODULE_ALIAS("platform:rockchip-spi");
-
-static int __init rockchip_spi_init(void)
-{
-	return platform_driver_probe(&rockchip_spi_driver, rockchip_spi_probe);
-}
-module_init(rockchip_spi_init);
-
-static void __exit rockchip_spi_exit(void)
-{
-	platform_driver_unregister(&rockchip_spi_driver);
-}
-module_exit(rockchip_spi_exit);
-
-MODULE_AUTHOR("Luo Wei <lw@rock-chips.com>");
-MODULE_DESCRIPTION("ROCKCHIP SPI Controller Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi-rockchip-core.c b/drivers/spi/spi-rockchip-core.c
deleted file mode 100755
index dbe542cc11d5..000000000000
--- a/drivers/spi/spi-rockchip-core.c
+++ /dev/null
@@ -1,1134 +0,0 @@
-/*
- * Designware SPI core controller driver (refer spi_dw.c)
- *
- * Copyright (c) 2009, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/highmem.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/spi/spi.h>
-#include <linux/clk.h>
-
-
-#include "spi-rockchip-core.h"
-
-#ifdef CONFIG_DEBUG_FS
-#include <linux/debugfs.h>
-#endif
-
-#define START_STATE	((void *)0)
-#define RUNNING_STATE	((void *)1)
-#define DONE_STATE	((void *)2)
-#define ERROR_STATE	((void *)-1)
-
-#define QUEUE_RUNNING	0
-#define QUEUE_STOPPED	1
-
-#define MRST_SPI_DEASSERT	0
-#define MRST_SPI_ASSERT		1
-
-
-/* Slave spi_dev related */
-struct chip_data {
-	u16 cr0;
-	u8 cs;			/* chip select pin */
-	u8 n_bytes;		/* current is a 1/2/4 byte op */
-	u8 tmode;		/* TR/TO/RO/EEPROM */
-	u8 type;		/* SPI/SSP/MicroWire */
-
-	u8 poll_mode;		/* 1 means use poll mode */
-	
-	u8 slave_enable;
-	u32 dma_width;
-	u32 rx_threshold;
-	u32 tx_threshold;
-	u8 enable_dma;
-	u8 bits_per_word;
-	u16 clk_div;		/* baud rate divider */
-	u32 speed_hz;		/* baud rate */
-	void (*cs_control)(struct dw_spi *dws, u32 cs, u8 flag);
-};
-
-#ifdef CONFIG_DEBUG_FS
-#define SPI_REGS_BUFSIZE	1024
-
-static ssize_t spi_write_proc_data(struct file *file, const char __user *buffer,
-			   size_t count, loff_t *data)
-{	
-	struct dw_spi *dws;
-	char *buf;
-	ssize_t ret;
-	int reg = 0,value = 0;
-	
-	dws = file->private_data;
-
-	buf = kzalloc(32, GFP_KERNEL);
-	if (!buf)
-	return 0;
-	
-	ret = copy_from_user(buf, buffer, count);
-	if (ret)
-	{
-		return ret; 
-	}
-
-	if((strstr(buf, "debug") != NULL) || (strstr(buf, "DEBUG") != NULL))
-	{		
-		atomic_set(&dws->debug_flag, 1);		
-		kfree(buf);
-		printk("%s:open debug\n",__func__);
-		return count;
-	}
-	else if((strstr(buf, "stop") != NULL) || (strstr(buf, "STOP") != NULL))
-	{		
-		atomic_set(&dws->debug_flag, 0);
-		printk("%s:close debug\n",__func__);
-	}
-	else if((strstr(buf, "=") != NULL))
-	{
-		printk("%s:invalid command\n",__func__);	
-		return count;
-	}
-
-	sscanf(buf, "0x%x=0x%x", &reg, &value);
-
-	if((reg >= SPIM_CTRLR0) && (reg <= SPIM_DMARDLR))	
-	{
-		dw_writew(dws, reg, value);
-		printk("%s:write data[0x%x] to reg[0x%x] succesfully\n",__func__, value, reg);
-	}
-	else
-	{
-		printk("%s:data[0x%x] or reg[0x%x] is out of range\n",__func__, value, reg);
-	}
-	
-	kfree(buf);
-		
-	return count; 
-}
-
-static ssize_t  spi_show_regs(struct file *file, char __user *user_buf,
-				size_t count, loff_t *ppos)
-{
-	struct dw_spi *dws;
-	char *buf;
-	u32 len = 0;
-	ssize_t ret;
-
-	dws = file->private_data;
-
-	buf = kzalloc(SPI_REGS_BUFSIZE, GFP_KERNEL);
-	if (!buf)
-		return 0;
-
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"MRST SPI0 registers:\n");
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"=================================\n");
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"CTRL0: \t\t0x%08x\n", dw_readl(dws, SPIM_CTRLR0));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"CTRL1: \t\t0x%08x\n", dw_readl(dws, SPIM_CTRLR1));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"SSIENR: \t0x%08x\n", dw_readl(dws, SPIM_SSIENR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"SER: \t\t0x%08x\n", dw_readl(dws, SPIM_SER));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"BAUDR: \t\t0x%08x\n", dw_readl(dws, SPIM_BAUDR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"TXFTLR: \t0x%08x\n", dw_readl(dws, SPIM_TXFTLR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"RXFTLR: \t0x%08x\n", dw_readl(dws, SPIM_RXFTLR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"TXFLR: \t\t0x%08x\n", dw_readl(dws, SPIM_TXFLR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"RXFLR: \t\t0x%08x\n", dw_readl(dws, SPIM_RXFLR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"SR: \t\t0x%08x\n", dw_readl(dws, SPIM_SR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"IMR: \t\t0x%08x\n", dw_readl(dws, SPIM_IMR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"ISR: \t\t0x%08x\n", dw_readl(dws, SPIM_ISR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"DMACR: \t\t0x%08x\n", dw_readl(dws, SPIM_DMACR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"DMATDLR: \t0x%08x\n", dw_readl(dws, SPIM_DMATDLR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"DMARDLR: \t0x%08x\n", dw_readl(dws, SPIM_DMARDLR));
-	len += snprintf(buf + len, SPI_REGS_BUFSIZE - len,
-			"=================================\n");
-
-	ret =  simple_read_from_buffer(user_buf, count, ppos, buf, len);
-	kfree(buf);
-	return ret;
-}
-
-static const struct file_operations spi_regs_ops = {
-	.owner		= THIS_MODULE,
-	.open		= simple_open,
-	.read		= spi_show_regs,
-	.write		= spi_write_proc_data,
-	.llseek		= default_llseek,
-};
-
-static int spi_debugfs_init(struct dw_spi *dws)
-{
-	dws->debugfs = debugfs_create_dir("spi", NULL);
-	if (!dws->debugfs)
-		return -ENOMEM;
-
-	debugfs_create_file("registers", S_IFREG | S_IRUGO,
-		dws->debugfs, (void *)dws, &spi_regs_ops);
-	return 0;
-}
-
-static void spi_debugfs_remove(struct dw_spi *dws)
-{
-	if (dws->debugfs)
-		debugfs_remove_recursive(dws->debugfs);
-}
-
-#else
-static inline int spi_debugfs_init(struct dw_spi *dws)
-{
-	return 0;
-}
-
-static inline void spi_debugfs_remove(struct dw_spi *dws)
-{
-}
-#endif /* CONFIG_DEBUG_FS */
-
-
-static void wait_till_not_busy(struct dw_spi *dws)
-{
-	unsigned long end = jiffies + 1 + usecs_to_jiffies(1000);
-	//if spi was slave, it is SR_BUSY always.  
-	if(dws->cur_chip) {
-		if(dws->cur_chip->slave_enable == 1)
-			return;
-	}
-	
-	while (time_before(jiffies, end)) {
-		if (!(dw_readw(dws, SPIM_SR) & SR_BUSY))
-			return;
-	}
-	dev_err(&dws->master->dev,
-		"DW SPI: Status keeps busy for 1000us after a read/write!\n");
-}
-
-
-static void flush(struct dw_spi *dws)
-{
-	while (!(dw_readw(dws, SPIM_SR) & SR_RF_EMPT))
-		dw_readw(dws, SPIM_RXDR);
-
-	wait_till_not_busy(dws);
-}
-
-
-/* Return the max entries we can fill into tx fifo */
-static inline u32 tx_max(struct dw_spi *dws)
-{
-	u32 tx_left, tx_room;
-
-	tx_left = (dws->tx_end - dws->tx) / dws->n_bytes;
-	tx_room = dws->fifo_len - dw_readw(dws, SPIM_TXFLR);
-
-	/*
-	 * Another concern is about the tx/rx mismatch, we
-	 * though to use (dws->fifo_len - rxflr - txflr) as
-	 * one maximum value for tx, but it doesn't cover the
-	 * data which is out of tx/rx fifo and inside the
-	 * shift registers. So a control from sw point of
-	 * view is taken.
-	 */
-	//rxtx_gap =  ((dws->rx_end - dws->rx) - (dws->tx_end - dws->tx))
-	//		/ dws->n_bytes;
-
-	return min(tx_left, tx_room);
-}
-
-/* Return the max entries we should read out of rx fifo */
-static inline u32 rx_max(struct dw_spi *dws)
-{
-	u32 rx_left = (dws->rx_end - dws->rx) / dws->n_bytes;
-
-	return min(rx_left, (u32)dw_readw(dws, SPIM_RXFLR));
-}
-
-static void dw_writer(struct dw_spi *dws)
-{
-	u32 max = tx_max(dws);
-	u16 txw = 0;	
-	
-	DBG_SPI("%dbyte tx:",dws->n_bytes);
-	while (max--) {
-		/* Set the tx word if the transfer's original "tx" is not null */
-		if (dws->tx_end - dws->len) {
-			if (dws->n_bytes == 1)
-			{
-				txw = *(u8 *)(dws->tx);	
-				DBG_SPI("0x%02x,", *(u8 *)(dws->tx));
-			}
-			else
-			{
-				txw = *(u16 *)(dws->tx);
-				DBG_SPI("0x%02x,", *(u16 *)(dws->tx));
-			}
-		}
-		dw_writew(dws, SPIM_TXDR, txw);
-		dws->tx += dws->n_bytes;
-	}
-	
-	//it is neccessary
-	wait_till_not_busy(dws);
-	
-	DBG_SPI("\n");
-}
-
-static void dw_reader(struct dw_spi *dws)
-{
-	u32 max = rx_max(dws);
-	u16 rxw;
-	
-	DBG_SPI("%dbyte rx:",dws->n_bytes);
-
-	while (max--) {
-		rxw = dw_readw(dws, SPIM_RXDR);
-		/* Care rx only if the transfer's original "rx" is not null */
-		if (dws->rx_end - dws->len) {
-			if (dws->n_bytes == 1)
-			{
-				*(u8 *)(dws->rx) = rxw;
-				DBG_SPI("0x%02x,", *(u8 *)(dws->rx));
-			}
-			else
-			{
-				*(u16 *)(dws->rx) = rxw;
-				DBG_SPI("0x%02x,", *(u16 *)(dws->rx));
-			}
-		}
-		
-		dws->rx += dws->n_bytes;
-	}
-	
-	DBG_SPI("\n");
-}
-
-static int reader_all(struct dw_spi *dws)
-{
-	while (!(dw_readw(dws, SPIM_SR) & SR_RF_EMPT)
-		&& (dws->rx < dws->rx_end)) {
-			dw_reader(dws);		
-			wait_till_not_busy(dws);
-		}
-
-	return dws->rx == dws->rx_end;
-}
-
-
-static void *next_transfer(struct dw_spi *dws)
-{
-	struct spi_message *msg = dws->cur_msg;
-	struct spi_transfer *trans = dws->cur_transfer;
-
-	/* Move to next transfer */
-	if (trans->transfer_list.next != &msg->transfers) {
-		dws->cur_transfer =
-			list_entry(trans->transfer_list.next,
-					struct spi_transfer,
-					transfer_list);
-		return RUNNING_STATE;
-	} else
-		return DONE_STATE;
-}
-
-/*
- * Note: first step is the protocol driver prepares
- * a dma-capable memory, and this func just need translate
- * the virt addr to physical
- */
-static int map_dma_buffers(struct dw_spi *dws)
-{
-	if (!dws->dma_inited
-		|| !dws->cur_chip->enable_dma
-		|| !dws->dma_ops)
-		return 0;
-
-	if (dws->cur_transfer->tx_dma)
-		dws->tx_dma = dws->cur_transfer->tx_dma;
-
-	if (dws->cur_transfer->rx_dma)
-		dws->rx_dma = dws->cur_transfer->rx_dma;
-	
-	DBG_SPI("%s:line=%d\n",__func__,__LINE__);
-	return 1;
-}
-
-/* Caller already set message->status; dma and pio irqs are blocked */
-static void giveback(struct dw_spi *dws)
-{
-	struct spi_transfer *last_transfer;
-	unsigned long flags;
-	struct spi_message *msg;	
-	struct spi_message *next_msg;
-	
-	spin_lock_irqsave(&dws->lock, flags);
-	msg = dws->cur_msg;
-	dws->cur_msg = NULL;
-	dws->cur_transfer = NULL;
-	dws->prev_chip = dws->cur_chip;
-	dws->cur_chip = NULL;
-	dws->dma_mapped = 0;
-	dws->state = 0;
-	//queue_work(dws->workqueue, &dws->pump_messages);
-
-	/*it is important to close intterrupt*/
-	spi_mask_intr(dws, 0xff);
-	//rk29xx_writew(dws, SPIM_DMACR, 0);
-	
-	spin_unlock_irqrestore(&dws->lock, flags);
-
-	last_transfer = list_entry(msg->transfers.prev,
-					struct spi_transfer,
-					transfer_list);
-
-	if (!last_transfer->cs_change && dws->cs_control)
-		dws->cs_control(dws, msg->spi->chip_select, MRST_SPI_DEASSERT);
-
-	msg->state = NULL;
-
-	/* get a pointer to the next message, if any */
-	next_msg = spi_get_next_queued_message(dws->master);
-
-	/* see if the next and current messages point
-	* to the same chip
-	*/
-	if (next_msg && next_msg->spi != msg->spi)
-	next_msg = NULL;
-	
-	dws->cur_chip = NULL;
-	spi_finalize_current_message(dws->master);
-	
-	DBG_SPI("%s:line=%d,tx_left=%ld\n",__func__,__LINE__, (long)(dws->tx_end - dws->tx) / dws->n_bytes);
-}
-
-
-static void int_error_stop(struct dw_spi *dws, const char *msg)
-{
-	/* Stop the hw */
-	flush(dws);
-	spi_enable_chip(dws, 0);
-
-	dev_err(&dws->master->dev, "%s\n", msg);
-	dws->cur_msg->state = ERROR_STATE;
-	tasklet_schedule(&dws->pump_transfers);	
-	DBG_SPI("%s:line=%d\n",__func__,__LINE__);
-}
-
-void dw_spi_xfer_done(struct dw_spi *dws)
-{
-	/* Update total byte transferred return count actual bytes read */
-	dws->cur_msg->actual_length += dws->len;
-
-	/* Move to next transfer */
-	dws->cur_msg->state = next_transfer(dws);
-
-	/* Handle end of message */
-	if (dws->cur_msg->state == DONE_STATE) {
-		dws->cur_msg->status = 0;
-		giveback(dws);
-	} else
-		tasklet_schedule(&dws->pump_transfers);
-	
-	DBG_SPI("%s:line=%d\n",__func__,__LINE__);
-}
-EXPORT_SYMBOL_GPL(dw_spi_xfer_done);
-
-static irqreturn_t interrupt_transfer(struct dw_spi *dws)
-{
-	u16 irq_status;
-	u32 int_level = dws->fifo_len / 2;
-	u32 left;
-
-
-	irq_status = dw_readw(dws, SPIM_ISR) & 0x1f;
-	
-	DBG_SPI("%s:line=%d,irq_status=0x%x\n",__func__,__LINE__,irq_status);
-	
-	/* Error handling */
-	if (irq_status & (SPI_INT_TXOI | SPI_INT_RXOI | SPI_INT_RXUI)) {
-		dw_writew(dws, SPIM_ICR, SPI_CLEAR_INT_TXOI | SPI_CLEAR_INT_RXOI | SPI_CLEAR_INT_RXUI);
-		printk("%s:irq_status=0x%x\n",__func__,irq_status);
-		int_error_stop(dws, "interrupt_transfer: fifo overrun/underrun");
-		return IRQ_HANDLED;
-	}
-
-	if (irq_status & SPI_INT_TXEI) 
-	{
-		spi_mask_intr(dws, SPI_INT_TXEI);
-		dw_writer(dws);
-
-		if (dws->rx) {
-		    reader_all(dws);
-		}
-
-		/* Re-enable the IRQ if there is still data left to tx */
-		if (dws->tx_end > dws->tx)
-			spi_umask_intr(dws, SPI_INT_TXEI);
-		else
-			dw_spi_xfer_done(dws);
-	}
-
-	if (irq_status & SPI_INT_RXFI) {
-		spi_mask_intr(dws, SPI_INT_RXFI);
-		
-		reader_all(dws);
-
-		/* Re-enable the IRQ if there is still data left to rx */
-		if (dws->rx_end > dws->rx) {
-			left = ((dws->rx_end - dws->rx) / dws->n_bytes) - 1;
-		    left = (left > int_level) ? int_level : left;
-
-			dw_writew(dws, SPIM_RXFTLR, left);
-			spi_umask_intr(dws, SPI_INT_RXFI);
-		}
-		else {
-			dw_spi_xfer_done(dws);
-		}
-		
-	}
-
-	return IRQ_HANDLED;
-}
-
-
-static irqreturn_t dw_spi_irq(int irq, void *dev_id)
-{
-	struct dw_spi *dws = dev_id;
-	u16 irq_status = dw_readw(dws, SPIM_ISR)&0x3f;
-
-	if (!irq_status)
-		return IRQ_NONE;
-
-	if (!dws->cur_msg) {
-		spi_mask_intr(dws, SPI_INT_TXEI);
-		return IRQ_HANDLED;
-	}
-
-	return dws->transfer_handler(dws);
-}
-
-/* Must be called inside pump_transfers() */
-static void poll_transfer(struct dw_spi *dws)
-{	
-	DBG_SPI("%s:len=%ld\n",__func__, (long)dws->len);
-	
-	do {
-		dw_writer(dws);
-		dw_reader(dws);
-		cpu_relax();
-	} while (dws->rx_end > dws->rx);
-
-	dw_spi_xfer_done(dws);
-	
-}
-
-static void pump_transfers(unsigned long data)
-{
-	struct dw_spi *dws = (struct dw_spi *)data;
-	struct spi_message *message = NULL;
-	struct spi_transfer *transfer = NULL;
-	struct spi_transfer *previous = NULL;
-	struct spi_device *spi = NULL;
-	struct chip_data *chip = NULL;
-	u8 bits = 0;
-	u8 imask = 0;
-	u8 cs_change = 0;
-	u16 txint_level = 0;	
-	u16 rxint_level = 0;
-	u16 clk_div = 0;
-	u32 speed = 0;
-	u32 cr0 = 0;	
-	u16 dma_ctrl = 0;
-	int i = 0;
-
-	/* Get current state information */
-	message = dws->cur_msg;
-	transfer = dws->cur_transfer;
-	chip = dws->cur_chip;
-	spi = message->spi;
-
-	if (unlikely(!chip->clk_div))
-	{
-		chip->clk_div = dws->max_freq / chip->speed_hz;
-		chip->clk_div = (chip->clk_div + 1) & 0xfffe;
-		chip->speed_hz = dws->max_freq / chip->clk_div;
-	}
-
-
-	if (message->state == ERROR_STATE) {
-		message->status = -EIO;
-		goto early_exit;
-	}
-
-	/* Handle end of message */
-	if (message->state == DONE_STATE) {
-		message->status = 0;
-		goto early_exit;
-	}
-
-	/* Delay if requested at end of transfer*/
-	if (message->state == RUNNING_STATE) {
-		previous = list_entry(transfer->transfer_list.prev,
-					struct spi_transfer,
-					transfer_list);
-		if (previous->delay_usecs)
-			udelay(previous->delay_usecs);
-	}
-
-	dws->n_bytes = chip->n_bytes;
-	dws->dma_width = chip->dma_width;
-	dws->cs_control = chip->cs_control;
-
-	dws->rx_dma = transfer->rx_dma;
-	dws->tx_dma = transfer->tx_dma;
-	dws->tx = (void *)transfer->tx_buf;
-	dws->tx_end = dws->tx + transfer->len;
-	dws->rx = transfer->rx_buf;
-	dws->rx_end = dws->rx + transfer->len;
-	dws->cs_change = transfer->cs_change;
-	dws->len = dws->cur_transfer->len;
-	if (chip != dws->prev_chip)
-		cs_change = 1;
-
-	cr0 = chip->cr0;
-
-	
-
-	/* Handle per transfer options for bpw and speed */
-	if (transfer->speed_hz) {
-		speed = chip->speed_hz;
-
-		if (transfer->speed_hz != speed) {
-			speed = transfer->speed_hz;
-			if (speed > dws->max_freq) {
-				printk(KERN_ERR "MRST SPI0: unsupported"
-					"freq: %dHz\n", speed);
-				message->status = -EIO;
-				goto early_exit;
-			}
-
-			/* clk_div doesn't support odd number */
-			clk_div = dws->max_freq / speed;
-			clk_div = (clk_div + 1) & 0xfffe;
-
-			chip->speed_hz = dws->max_freq / clk_div;
-			chip->clk_div = clk_div;
-		}
-	}
-	DBG_SPI("%s:len=%ld,clk_div=%d,speed_hz=%d\n",__func__, (long)dws->len,chip->clk_div,chip->speed_hz);
-	if (transfer->bits_per_word) {
-		bits = transfer->bits_per_word;
-
-		switch (bits) {
-		case 8:
-		case 16:
-			dws->n_bytes = dws->dma_width = bits >> 3;
-			break;
-		default:
-			printk(KERN_ERR "MRST SPI0: unsupported bits:"
-				"%db\n", bits);
-			message->status = -EIO;
-			goto early_exit;
-		}
-
-		cr0 =((dws->n_bytes) << SPI_DFS_OFFSET)
-			| (SPI_HALF_WORLD_OFF << SPI_HALF_WORLD_TX_OFFSET)
-			| (SPI_SSN_DELAY_ONE << SPI_SSN_DELAY_OFFSET)
-			| (chip->type << SPI_FRF_OFFSET)
-			| (spi->mode << SPI_MODE_OFFSET)
-			| (chip->tmode << SPI_TMOD_OFFSET);
-	}
-	message->state = RUNNING_STATE;
-
-	/*
-	 * Adjust transfer mode if necessary. Requires platform dependent
-	 * chipselect mechanism.
-	 */
-	if (dws->cs_control) {
-		if (dws->rx && dws->tx)
-			chip->tmode = SPI_TMOD_TR;
-		else if (dws->rx)
-			chip->tmode = SPI_TMOD_RO;
-		else
-			chip->tmode = SPI_TMOD_TO;
-
-
-		cr0 &= ~(0x3 << SPI_MODE_OFFSET);		
-		cr0 &= ~(0x3 << SPI_TMOD_OFFSET);
-		cr0 &= ~(0x1 << SPI_OPMOD_OFFSET);	
-		cr0 |= (spi->mode << SPI_MODE_OFFSET);
-		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
-		cr0 |= ((chip->slave_enable & 1) << SPI_OPMOD_OFFSET);
-	}
-
-	/* Check if current transfer is a DMA transaction */
-	dws->dma_mapped = map_dma_buffers(dws);
-
-	/*
-	 * Interrupt mode
-	 * we only need set the TXEI IRQ, as TX/RX always happen syncronizely
-	 */
-	if (!dws->dma_mapped && !chip->poll_mode) {	
-		int templen ;
-		
-		if (chip->tmode == SPI_TMOD_RO) {
-			templen = dws->len / dws->n_bytes - 1;
-			rxint_level = dws->fifo_len / 2;
-			rxint_level = (templen > rxint_level) ? rxint_level : templen;
-			imask |= SPI_INT_RXFI;
-		}
-		else {	
-			templen = dws->len / dws->n_bytes;
-			txint_level = dws->fifo_len / 2;
-			txint_level = (templen > txint_level) ? txint_level : templen;
-			imask |= SPI_INT_TXEI | SPI_INT_TXOI;
-		}
-		dws->transfer_handler = interrupt_transfer;
-	}
-
-	/*
-	 * Reprogram registers only if
-	 *	1. chip select changes
-	 *	2. clk_div is changed
-	 *	3. control value changes
-	 */
-	//if (dw_readw(dws, SPIM_CTRLR0) != cr0 || cs_change || clk_div || imask) 		
-	if(dws->tx || dws->rx)
-	{
-		spi_enable_chip(dws, 0);
-		if (dw_readl(dws, SPIM_CTRLR0) != cr0)
-			dw_writel(dws, SPIM_CTRLR0, cr0);
-
-
-		spi_set_clk(dws, clk_div ? clk_div : chip->clk_div);		
-		spi_chip_sel(dws, spi->chip_select);
-
-		dw_writew(dws, SPIM_CTRLR1, dws->len-1);
-
-		if (txint_level != dw_readl(dws, SPIM_TXFTLR))
-			dw_writew(dws, SPIM_TXFTLR, txint_level);
-			
-		if (rxint_level != dw_readl(dws, SPIM_RXFTLR))
-		{
-			dw_writew(dws, SPIM_RXFTLR, rxint_level);
-			DBG_SPI("%s:rxint_level=%d\n",__func__,rxint_level);
-		}
-
-		/* setup DMA related registers */
-		if(dws->dma_mapped)
-		{
-			dws->dmatdlr = dws->n_bytes;
-			dws->dmardlr = dws->n_bytes - 1;
-			for(i=dws->n_bytes; i<=dws->fifo_len / 4; i++)
-			{
-				if((dws->len / dws->n_bytes) % i == 0)
-				dws->dmatdlr = i;
-			}
-
-			/* Set the interrupt mask, for poll mode just diable all int */
-			spi_mask_intr(dws, 0xff);		
-			if(dws->tx)
-			{
-				dma_ctrl |= SPI_DMACR_TX_ENABLE;		
-				dw_writew(dws, SPIM_DMATDLR, dws->dmatdlr);
-				dw_writew(dws, SPIM_CTRLR1, dws->len-1);	
-			}
-
-			dws->dmardlr = (dws->dmatdlr != dws->n_bytes)?(dws->dmatdlr-1):(dws->n_bytes-1);
-			
-			if (dws->rx)
-			{
-				dma_ctrl |= SPI_DMACR_RX_ENABLE;	
-				dw_writew(dws, SPIM_DMARDLR, dws->dmardlr);
-				dw_writew(dws, SPIM_CTRLR1, dws->len-1);
-			}
-			dw_writew(dws, SPIM_DMACR, dma_ctrl);
-
-			DBG_SPI("%s:dma_ctrl=0x%x,dmatdlr=%d,dmardlr=%d\n",__func__,dw_readw(dws, SPIM_DMACR),dws->dmatdlr, dws->dmardlr);
-			
-		}
-
-		if((!dws->dma_mapped) || (dws->dma_mapped && dws->tx))
-		spi_enable_chip(dws, 1);
-
-		DBG_SPI("%s:ctrl0=0x%x\n",__func__,dw_readw(dws, SPIM_CTRLR0));
-
-		/* Set the interrupt mask, for poll mode just diable all int */
-		spi_mask_intr(dws, 0xff);
-		if (imask)
-			spi_umask_intr(dws, imask);
-		
-		if (cs_change)
-			dws->prev_chip = chip;
-
-	}
-	else
-	{
-		printk("%s:warning tx and rx is null\n",__func__);
-	}
-
-	/*dma should be ready before spi_enable_chip*/
-	if (dws->dma_mapped)
-	dws->dma_ops->dma_transfer(dws, cs_change); 
-
-	if (chip->poll_mode)
-		poll_transfer(dws);
-
-	return;
-
-early_exit:
-	giveback(dws);
-	return;
-}
-
-static int dw_spi_transfer_one_message(struct spi_master *master,
-					   struct spi_message *msg)
-{
-	struct dw_spi *dws = spi_master_get_devdata(master);
-	int ret = 0;
-	
-	dws->cur_msg = msg;
-	/* Initial message state*/
-	dws->cur_msg->state = START_STATE;
-	dws->cur_transfer = list_entry(dws->cur_msg->transfers.next,
-						struct spi_transfer,
-						transfer_list);
-
-	/* prepare to setup the SSP, in pump_transfers, using the per
-	 * chip configuration */
-	dws->cur_chip = spi_get_ctldata(dws->cur_msg->spi);
-	
-	dws->dma_mapped = map_dma_buffers(dws);	
-	INIT_COMPLETION(dws->xfer_completion);
-	
-	/* Mark as busy and launch transfers */
-	tasklet_schedule(&dws->pump_transfers);
-	
-	DBG_SPI("%s:line=%d\n",__func__,__LINE__);
-	if (dws->dma_mapped)
-	{
-		ret = wait_for_completion_timeout(&dws->xfer_completion,
-							msecs_to_jiffies(2000));
-		if(ret == 0)
-		{
-			dev_err(&dws->master->dev, "dma transfer timeout\n");			
-			giveback(dws);
-			return 0;
-		}
-		
-		DBG_SPI("%s:wait %d\n",__func__, ret);
-	}
-		
-	return 0;
-}
-
-static int dw_spi_prepare_transfer(struct spi_master *master)
-{
-	struct dw_spi *dws = spi_master_get_devdata(master);
-
-	//pm_runtime_get_sync(&dws->pdev->dev);
-	
-	DBG_SPI("%s:line=%d\n",__func__,__LINE__);
-	return 0;
-}
-
-static int dw_spi_unprepare_transfer(struct spi_master *master)
-{
-	struct dw_spi *dws = spi_master_get_devdata(master);
-
-	/* Disable the SSP now */
-	//write_SSCR0(read_SSCR0(dws->ioaddr) & ~SSCR0_SSE,
-	//	    dws->ioaddr);
-
-	//pm_runtime_mark_last_busy(&dws->pdev->dev);
-	//pm_runtime_put_autosuspend(&dws->pdev->dev);
-	
-	DBG_SPI("%s:line=%d\n",__func__,__LINE__);
-	return 0;
-}
-
-/* This may be called twice for each spi dev */
-static int dw_spi_setup(struct spi_device *spi)
-{
-	struct dw_spi_chip *chip_info = NULL;
-	struct chip_data *chip;
-
-	if (spi->bits_per_word != 8 && spi->bits_per_word != 16)
-		return -EINVAL;
-
-	/* Only alloc on first setup */
-	chip = spi_get_ctldata(spi);
-	if (!chip) {
-		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
-		if (!chip)
-			return -ENOMEM;
-
-		chip->cs_control = spi_cs_control;
-		chip->enable_dma = 0; 
-	}
-
-	/*
-	 * Protocol drivers may change the chip settings, so...
-	 * if chip_info exists, use it
-	 */
-	chip_info = spi->controller_data;
-
-	/* chip_info doesn't always exist */
-	if (chip_info) {
-		if (chip_info->cs_control)
-			chip->cs_control = chip_info->cs_control;
-
-		chip->poll_mode = chip_info->poll_mode;
-		chip->type = chip_info->type;
-
-		chip->rx_threshold = 0;
-		chip->tx_threshold = 0;
-
-		chip->enable_dma = chip_info->enable_dma;
-	}
-
-	if (spi->bits_per_word <= 8) {
-		chip->n_bytes = 1;
-		chip->dma_width = 1;
-	} else if (spi->bits_per_word <= 16) {
-		chip->n_bytes = 2;
-		chip->dma_width = 2;
-	} else {
-		/* Never take >16b case for MRST SPIC */
-		dev_err(&spi->dev, "invalid wordsize\n");
-		return -EINVAL;
-	}
-	chip->bits_per_word = spi->bits_per_word;
-
-	if (!spi->max_speed_hz) {
-		dev_err(&spi->dev, "No max speed HZ parameter\n");
-		return -EINVAL;
-	}
-	chip->speed_hz = spi->max_speed_hz;
-
-	chip->tmode = 0; /* Tx & Rx */
-	/* Default SPI mode is SCPOL = 0, SCPH = 0 */
-	chip->cr0 = ((chip->n_bytes) << SPI_DFS_OFFSET)
-		    | (SPI_HALF_WORLD_OFF << SPI_HALF_WORLD_TX_OFFSET)
-			| (SPI_SSN_DELAY_ONE << SPI_SSN_DELAY_OFFSET)
-			| (chip->type << SPI_FRF_OFFSET)
-			| (spi->mode  << SPI_MODE_OFFSET)
-			| (chip->tmode << SPI_TMOD_OFFSET);
-
-	spi_set_ctldata(spi, chip);
-	
-	//printk("%s:line=%d\n",__func__,__LINE__);
-	return 0;
-}
-
-static void dw_spi_cleanup(struct spi_device *spi)
-{
-	struct chip_data *chip = spi_get_ctldata(spi);
-	kfree(chip);
-}
-
-
-/* Restart the controller, disable all interrupts, clean rx fifo */
-static void spi_hw_init(struct dw_spi *dws)
-{
-	spi_enable_chip(dws, 0);
-	spi_mask_intr(dws, 0xff);
-
-	/*
-	 * Try to detect the FIFO depth if not set by interface driver,
-	 * the depth could be from 2 to 32 from HW spec
-	 */
-	if (!dws->fifo_len) {
-		u32 fifo;
-		for (fifo = 2; fifo <= 31; fifo++) {
-			dw_writew(dws, SPIM_TXFTLR, fifo);
-			if (fifo != dw_readw(dws, SPIM_TXFTLR))
-				break;
-		}
-
-		dws->fifo_len = (fifo == 31) ? 0 : fifo;
-		dw_writew(dws, SPIM_TXFTLR, 0);
-	}
-	
-	//spi_enable_chip(dws, 1);
-	flush(dws);
-	DBG_SPI("%s:fifo_len=%d\n",__func__, dws->fifo_len);
-}
-
-int dw_spi_add_host(struct dw_spi *dws)
-{
-	struct spi_master *master;
-	int ret;
-
-	BUG_ON(dws == NULL);
-
-	master = spi_alloc_master(dws->parent_dev, 0);
-	if (!master) {
-		ret = -ENOMEM;
-		goto exit;
-	}
-
-	dws->master = master;
-	dws->type = SSI_MOTO_SPI;
-	dws->prev_chip = NULL;
-	dws->dma_inited = 0;
-	dws->tx_dma_addr = (dma_addr_t)(dws->paddr + SPIM_TXDR);	
-	dws->rx_dma_addr = (dma_addr_t)(dws->paddr + SPIM_RXDR);
-	snprintf(dws->name, sizeof(dws->name), "dw_spi%d",
-			dws->bus_num);
-
-	ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED,
-			dws->name, dws);
-	if (ret < 0) {
-		dev_err(&master->dev, "can not get IRQ\n");
-		goto err_free_master;
-	}
-	
-	master->dev.parent = dws->parent_dev;
-	master->dev.of_node = dws->parent_dev->of_node;	
-	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
-	master->bus_num = dws->bus_num;
-	master->num_chipselect = dws->num_cs;
-	master->cleanup = dw_spi_cleanup;
-	master->setup = dw_spi_setup;
-	master->transfer_one_message = dw_spi_transfer_one_message;
-	master->prepare_transfer_hardware = dw_spi_prepare_transfer;
-	master->unprepare_transfer_hardware = dw_spi_unprepare_transfer;
-	
-	spin_lock_init(&dws->lock);
-	tasklet_init(&dws->pump_transfers,
-			pump_transfers,	(unsigned long)dws);
-
-
-	/* Basic HW init */
-	spi_hw_init(dws);
-
-	if (dws->dma_ops && dws->dma_ops->dma_init) {
-		ret = dws->dma_ops->dma_init(dws);
-		if (ret) {
-			dev_warn(&master->dev, "DMA init failed,ret=%d\n",ret);
-			dws->dma_inited = 0;
-		}
-	}
-	
-	spi_master_set_devdata(master, dws);
-	ret = spi_register_master(master);
-	if (ret) {
-		dev_err(&master->dev, "problem registering spi master\n");
-		goto err_queue_alloc;
-	}
-
-	spi_debugfs_init(dws);
-
-	
-	DBG_SPI("%s:bus_num=%d\n",__func__, dws->bus_num);
-	return 0;
-
-err_queue_alloc:
-	if (dws->dma_ops && dws->dma_ops->dma_exit)
-		dws->dma_ops->dma_exit(dws);
-/* err_diable_hw: */
-	spi_enable_chip(dws, 0);
-	free_irq(dws->irq, dws);
-err_free_master:
-	spi_master_put(master);
-exit:
-	return ret;
-}
-EXPORT_SYMBOL_GPL(dw_spi_add_host);
-
-void dw_spi_remove_host(struct dw_spi *dws)
-{
-	if (!dws)
-		return;
-	
-	spi_debugfs_remove(dws);
-
-	if (dws->dma_ops && dws->dma_ops->dma_exit)
-		dws->dma_ops->dma_exit(dws);
-	
-	spi_enable_chip(dws, 0);
-	/* Disable clk */
-	spi_set_clk(dws, 0);
-	free_irq(dws->irq, dws);
-
-	/* Disconnect from the SPI framework */
-	spi_unregister_master(dws->master);
-
-	
-	DBG_SPI("%s:bus_num=%d\n",__func__, dws->bus_num);
-}
-EXPORT_SYMBOL_GPL(dw_spi_remove_host);
-
-int dw_spi_suspend_host(struct dw_spi *dws)
-{
-	int ret = 0;
-	
-	ret = spi_master_suspend(dws->master);
-	if (ret != 0)
-	return ret;
-	
-	spi_enable_chip(dws, 0);
-	spi_set_clk(dws, 0);
-	
-	clk_disable_unprepare(dws->clk_spi);
-	
-	DBG_SPI("%s:bus_num=%d\n",__func__, dws->bus_num);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(dw_spi_suspend_host);
-
-int dw_spi_resume_host(struct dw_spi *dws)
-{
-	int ret;
-
-	/* Enable the SPI clock */
-	clk_prepare_enable(dws->clk_spi);
-	
-	spi_hw_init(dws);
-
-	/* Start the queue running */
-	ret = spi_master_resume(dws->master);
-	if (ret != 0) {
-		printk("%s:problem starting queue (%d)\n", __func__, ret);
-		return ret;
-	}
-	
-	DBG_SPI("%s:bus_num=%d\n",__func__, dws->bus_num);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(dw_spi_resume_host);
-
-MODULE_AUTHOR("Luo Wei <lw@rock-chips.com>");
-MODULE_DESCRIPTION("Driver for DesignWare SPI controller core");
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/spi-rockchip-core.h b/drivers/spi/spi-rockchip-core.h
deleted file mode 100755
index bb07d58ba3e0..000000000000
--- a/drivers/spi/spi-rockchip-core.h
+++ /dev/null
@@ -1,312 +0,0 @@
-#ifndef DW_SPI_HEADER_H
-#define DW_SPI_HEADER_H
-
-#include <linux/io.h>
-#include <linux/scatterlist.h>
-#include <linux/dmaengine.h>
-
-
-#if 1
-#define DBG_SPI(x...)  if(atomic_read(&dws->debug_flag) == 1) printk(KERN_DEBUG x)
-#else
-#define DBG_SPI(x...)
-#endif
-
-/* SPI register offsets */
-#define SPIM_CTRLR0				0x0000
-#define SPIM_CTRLR1				0x0004
-#define SPIM_SSIENR				0x0008
-#define SPIM_SER				0x000c
-#define SPIM_BAUDR				0x0010
-#define SPIM_TXFTLR				0x0014
-#define SPIM_RXFTLR				0x0018
-#define SPIM_TXFLR				0x001c
-#define SPIM_RXFLR				0x0020
-#define SPIM_SR					0x0024
-#define SPIM_IPR                0x0028
-#define SPIM_IMR				0x002c
-#define SPIM_ISR				0x0030
-#define SPIM_RISR				0x0034
-#define SPIM_ICR				0x0038
-#define SPIM_DMACR				0x003c
-#define SPIM_DMATDLR			0x0040
-#define SPIM_DMARDLR			0x0044
-#define SPIM_TXDR				0x0400
-#define SPIM_RXDR               0x0800
-
-/* --------Bit fields in CTRLR0--------begin */
-
-#define SPI_DFS_OFFSET			0                  /* Data Frame Size */
-#define SPI_DFS_4BIT            0x00
-#define SPI_DFS_8BIT            0x01
-#define SPI_DFS_16BIT           0x02
-#define SPI_DFS_RESV            0x03
-
-#define SPI_FRF_OFFSET			16                 /* Frame Format */
-#define SPI_FRF_SPI			    0x00               /* motorola spi */
-#define SPI_FRF_SSP			    0x01               /* Texas Instruments SSP*/
-#define SPI_FRF_MICROWIRE		0x02               /*  National Semiconductors Microwire */
-#define SPI_FRF_RESV			0x03
-
-#define SPI_MODE_OFFSET		    6                 /* SCPH & SCOL */
-
-#define SPI_SCPH_OFFSET			6                  /* Serial Clock Phase */
-#define SPI_SCPH_TOGMID         0                  /* Serial clock toggles in middle of first data bit */
-#define SPI_SCPH_TOGSTA         1                  /* Serial clock toggles at start of first data bit */
-
-#define SPI_SCOL_OFFSET			7                  /* Serial Clock Polarity */
-
-#define SPI_OPMOD_OFFSET	    20
-#define SPI_OPMOD_MASTER        0
-#define SPI_OPMOD_SLAVE         1
-
-#define SPI_TMOD_OFFSET			18                 /* Transfer Mode */
-//#define SPI_TMOD_MASK			(0x3 << SPI_TMOD_OFFSET)
-#define	SPI_TMOD_TR			    0x00		       /* xmit & recv */
-#define SPI_TMOD_TO			    0x01		       /* xmit only */
-#define SPI_TMOD_RO			    0x02		       /* recv only */
-#define SPI_TMOD_RESV		    0x03
-
-#define SPI_CFS_OFFSET			2                  /* Control Frame Size */
-
-#define SPI_CSM_OFFSET          8                  /* Chip Select Mode */
-#define SPI_CSM_KEEP            0x00               /* ss_n keep low after every frame data is transferred */
-#define SPI_CSM_HALF            0x01               /* ss_n be high for half sclk_out cycles after every frame data is transferred */
-#define SPI_CSM_ONE             0x02               /* ss_n be high for one sclk_out cycle after every frame data is transferred */
-
-#define SPI_SSN_DELAY_OFFSET    10
-#define SPI_SSN_DELAY_HALF      0x00
-#define SPI_SSN_DELAY_ONE       0x01
-
-#define SPI_HALF_WORLD_TX_OFFSET       13
-#define SPI_HALF_WORLD_ON       0x00
-#define SPI_HALF_WORLD_OFF      0x01
-
-
-/* --------Bit fields in CTRLR0--------end */
-
-
-/* Bit fields in SR, 7 bits */
-#define SR_MASK				0x7f		/* cover 7 bits */
-#define SR_BUSY				(1 << 0)
-#define SR_TF_FULL		    (1 << 1)
-#define SR_TF_EMPT			(1 << 2)
-#define SR_RF_EMPT		    (1 << 3)
-#define SR_RF_FULL			(1 << 4)
-
-/* Bit fields in ISR, IMR, RISR, 7 bits */
-#define SPI_INT_TXEI			(1 << 0)
-#define SPI_INT_TXOI			(1 << 1)
-#define SPI_INT_RXUI			(1 << 2)
-#define SPI_INT_RXOI			(1 << 3)
-#define SPI_INT_RXFI			(1 << 4)
-
-/* Bit fields in DMACR */
-#define SPI_DMACR_TX_ENABLE     (1 << 1)
-#define SPI_DMACR_RX_ENABLE     (1 << 0)
-
-/* Bit fields in ICR */
-#define SPI_CLEAR_INT_ALL       (1<< 0)
-#define SPI_CLEAR_INT_RXUI      (1 << 1)
-#define SPI_CLEAR_INT_RXOI      (1 << 2)
-#define SPI_CLEAR_INT_TXOI      (1 << 3)
-
-#define SUSPND    (1<<0)
-#define SPIBUSY   (1<<1)
-#define RXBUSY    (1<<2)
-#define TXBUSY    (1<<3)
-
-
-enum dw_ssi_type {
-	SSI_MOTO_SPI = 0,
-	SSI_TI_SSP,
-	SSI_NS_MICROWIRE,
-};
-
-struct dw_spi;
-struct dw_spi_dma_ops {
-	int (*dma_init)(struct dw_spi *dws);
-	void (*dma_exit)(struct dw_spi *dws);
-	int (*dma_transfer)(struct dw_spi *dws, int cs_change);
-};
-
-struct dw_spi {
-	struct spi_master	*master;
-	struct spi_device	*cur_dev;
-	struct device		*parent_dev;
-	enum dw_ssi_type	type;
-	char			name[16];
-
-	struct clk          *clk_spi;
-	struct clk          *pclk_spi;
-
-	void __iomem		*regs;
-	unsigned long		paddr;
-	u32			iolen;
-	int			irq;
-	u32			fifo_len;	/* depth of the FIFO buffer */
-	u32			max_freq;	/* max bus freq supported */
-
-	u16			bus_num;
-	u16			num_cs;		/* supported slave numbers */
-
-	/* Driver message queue */
-	struct workqueue_struct	*workqueue;
-	struct work_struct	pump_messages;
-	spinlock_t		lock;
-	struct list_head	queue;
-	int			busy;
-	int			run;
-
-	/* Message Transfer pump */
-	struct tasklet_struct	pump_transfers;
-
-	/* Current message transfer state info */
-	struct spi_message	*cur_msg;
-	struct spi_transfer	*cur_transfer;
-	struct chip_data	*cur_chip;
-	struct chip_data	*prev_chip;
-	size_t			len;
-	void			*tx;
-	void			*tx_end;
-	void			*rx;
-	void			*rx_end;
-	int				dma_mapped;
-	dma_addr_t		rx_dma;
-	dma_addr_t		tx_dma;
-	size_t			rx_map_len;
-	size_t			tx_map_len;
-	u8			n_bytes;	/* current is a 1/2 bytes op */
-	u8			max_bits_per_word;	/* maxim is 16b */
-	u32			dma_width;
-	int			dmatdlr;
-	int			dmardlr;
-	int			cs_change;
-	void			*tx_buffer;
-	void			*rx_buffer;
-	dma_addr_t		rx_dma_init;
-	dma_addr_t		tx_dma_init;
-	dma_cookie_t		rx_cookie;
-	dma_cookie_t		tx_cookie;
-	int 			state;
-	struct completion	xfer_completion;
-	irqreturn_t		(*transfer_handler)(struct dw_spi *dws);
-	void			(*cs_control)(struct dw_spi *dws, u32 cs, u8 flag);
-
-	/* Dma info */
-	int			dma_inited;
-	struct dma_chan		*txchan;
-	struct scatterlist	tx_sgl;
-	struct dma_chan		*rxchan;
-	struct scatterlist	rx_sgl;
-	int			dma_chan_done;
-	struct device		*dma_dev;
-	dma_addr_t		tx_dma_addr; /* phy address of the Data register */	
-	dma_addr_t		rx_dma_addr; /* phy address of the Data register */
-	struct dw_spi_dma_ops	*dma_ops;
-	void			*dma_priv; /* platform relate info */
-	
-	//struct pci_dev		*dmac;
-	atomic_t		debug_flag;
-
-	/* Bus interface info */
-	void			*priv;
-#ifdef CONFIG_DEBUG_FS
-	struct dentry *debugfs;
-#endif
-};
-
-static inline u32 dw_readl(struct dw_spi *dws, u32 offset)
-{
-	return __raw_readl(dws->regs + offset);
-}
-
-static inline void dw_writel(struct dw_spi *dws, u32 offset, u32 val)
-{
-	__raw_writel(val, dws->regs + offset);
-}
-
-static inline u16 dw_readw(struct dw_spi *dws, u32 offset)
-{
-	return __raw_readw(dws->regs + offset);
-}
-
-static inline void dw_writew(struct dw_spi *dws, u32 offset, u16 val)
-{
-	__raw_writew(val, dws->regs + offset);
-}
-
-static inline void spi_enable_chip(struct dw_spi *dws, int enable)
-{
-	dw_writel(dws, SPIM_SSIENR, (enable ? 1 : 0));
-}
-
-static inline void spi_set_clk(struct dw_spi *dws, u16 div)
-{
-	dw_writel(dws, SPIM_BAUDR, div);
-}
-
-static inline void spi_chip_sel(struct dw_spi *dws, u16 cs)
-{
-	if (cs > dws->num_cs)
-		return;
-
-	if (dws->cs_control)
-		dws->cs_control(dws, cs, 1);
-
-	dw_writel(dws, SPIM_SER, 1 << cs);
-
-	DBG_SPI("%s:cs=%d\n",__func__,cs);
-}
-
-static  inline void spi_cs_control(struct dw_spi *dws, u32 cs, u8 flag)
-{
-	if (flag)
-		dw_writel(dws, SPIM_SER, 1 << cs);
-	else 		
-		dw_writel(dws, SPIM_SER, 0);
-	
-	return;
-}
-
-
-/* Disable IRQ bits */
-static inline void spi_mask_intr(struct dw_spi *dws, u32 mask)
-{
-	u32 new_mask;
-
-	new_mask = dw_readl(dws, SPIM_IMR) & ~mask;
-	dw_writel(dws, SPIM_IMR, new_mask);
-}
-
-/* Enable IRQ bits */
-static inline void spi_umask_intr(struct dw_spi *dws, u32 mask)
-{
-	u32 new_mask;
-
-	new_mask = dw_readl(dws, SPIM_IMR) | mask;
-	dw_writel(dws, SPIM_IMR, new_mask);
-}
-
-/*
- * Each SPI slave device to work with dw_api controller should
- * has such a structure claiming its working mode (PIO/DMA etc),
- * which can be save in the "controller_data" member of the
- * struct spi_device
- */
-struct dw_spi_chip {
-	u8 poll_mode;	/* 0 for contoller polling mode */
-	u8 type;	/* SPI/SSP/Micrwire */
-	u8 enable_dma;
-	void (*cs_control)(struct dw_spi *dws, u32 cs, u8 flag);
-};
-
-extern int dw_spi_add_host(struct dw_spi *dws);
-extern void dw_spi_remove_host(struct dw_spi *dws);
-extern int dw_spi_suspend_host(struct dw_spi *dws);
-extern int dw_spi_resume_host(struct dw_spi *dws);
-extern void dw_spi_xfer_done(struct dw_spi *dws);
-
-/* platform related setup */
-extern int dw_spi_dma_init(struct dw_spi *dws); /* Intel MID platforms */
-#endif /* SPIM_HEADER_H */
diff --git a/drivers/spi/spi-rockchip-dma.c b/drivers/spi/spi-rockchip-dma.c
deleted file mode 100755
index 6952201406cd..000000000000
--- a/drivers/spi/spi-rockchip-dma.c
+++ /dev/null
@@ -1,387 +0,0 @@
-/*
- * Special handling for DW core on Intel MID platform
- *
- * Copyright (c) 2009, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/dma-mapping.h>
-#include <linux/dmaengine.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/spi/spi.h>
-#include <linux/gpio.h>
-#include <linux/of.h>
-#include <linux/of_gpio.h>
-#include <linux/platform_data/spi-rockchip.h>
-
-
-#include "spi-rockchip-core.h"
-
-#ifdef CONFIG_SPI_ROCKCHIP_DMA
-#define DMA_BUFFER_SIZE (PAGE_SIZE<<4)
-
-
-struct spi_dma_slave {
-	struct dma_chan *ch;
-	enum dma_transfer_direction direction;
-	unsigned int dmach;
-};
-
-
-struct spi_dma {
-	struct spi_dma_slave	dmas_tx;
-	struct spi_dma_slave	dmas_rx;
-};
-
-static void printk_transfer_data(struct dw_spi *dws, char *buf, int len)
-{
-	int i = 0;
-	for(i=0; i<len; i++)
-		DBG_SPI("0x%02x,",*buf++);
-
-	DBG_SPI("\n");
-
-}
-
-static int mid_spi_dma_init(struct dw_spi *dws)
-{
-	struct spi_dma *dw_dma = dws->dma_priv;
-	struct spi_dma_slave *rxs, *txs;
-	
-	DBG_SPI("%s:start\n",__func__);
-
-	/* 1. Init rx channel */
-	dws->rxchan = dma_request_slave_channel(dws->parent_dev, "rx");
-	if (!dws->rxchan)
-	{
-		dev_err(dws->parent_dev, "Failed to get RX DMA channel\n");
-		goto err_exit;
-	}
-	
-	DBG_SPI("%s:rx_chan_id=%d\n",__func__,dws->rxchan->chan_id);
-	
-	rxs = &dw_dma->dmas_rx;
-	dws->rxchan->private = rxs;
-
-	/* 2. Init tx channel */
-	dws->txchan = dma_request_slave_channel(dws->parent_dev, "tx");
-	if (!dws->txchan)
-	{
-		dev_err(dws->parent_dev, "Failed to get TX DMA channel\n");
-		goto free_rxchan;
-	}
-	txs = &dw_dma->dmas_tx;
-	dws->txchan->private = txs;
-	
-	DBG_SPI("%s:tx_chan_id=%d\n",__func__,dws->txchan->chan_id);
-
-	dws->dma_inited = 1;
-
-	DBG_SPI("%s:line=%d\n",__func__,__LINE__);
-	return 0;
-
-free_rxchan:
-	dma_release_channel(dws->rxchan);
-err_exit:
-	return -1;
-
-}
-
-static void mid_spi_dma_exit(struct dw_spi *dws)
-{
-	DBG_SPI("%s:start\n",__func__);
-	dma_release_channel(dws->txchan);
-	dma_release_channel(dws->rxchan);
-}
-
-
-static void dw_spi_dma_rxcb(void *arg)
-{
-	struct dw_spi *dws = arg;
-	unsigned long flags;
-	struct dma_tx_state		state;
-	int				dma_status;
-
-	dma_sync_single_for_device(dws->rxchan->device->dev, dws->rx_dma,
-				   dws->len, DMA_FROM_DEVICE);
-	
-	dma_status = dmaengine_tx_status(dws->rxchan, dws->rx_cookie, &state);
-	
-	DBG_SPI("%s:dma_status=0x%x\n", __FUNCTION__, dma_status);
-	
-	spin_lock_irqsave(&dws->lock, flags);		
-	if (dma_status == DMA_SUCCESS)
-		dws->state &= ~RXBUSY;
-	else
-		dev_err(&dws->master->dev, "error:rx dma_status=%x\n", dma_status);
-
-	//copy data from dma to transfer buf
-	if(dws->cur_transfer && (dws->cur_transfer->rx_buf != NULL))
-	{
-		memcpy(dws->cur_transfer->rx_buf, dws->rx_buffer, dws->cur_transfer->len);
-		
-		DBG_SPI("dma rx:");
-		printk_transfer_data(dws, dws->cur_transfer->rx_buf, dws->cur_transfer->len);
-	}
-	
-	spin_unlock_irqrestore(&dws->lock, flags);
-	
-	/* If the other done */
-	if (!(dws->state & TXBUSY))
-	{
-		//DMA could not lose intterupt
-		dw_spi_xfer_done(dws);
-		complete(&dws->xfer_completion);
-		DBG_SPI("%s:complete\n", __FUNCTION__);
-	}
-
-}
-
-static void dw_spi_dma_txcb(void *arg)
-{
-	struct dw_spi *dws = arg;
-	unsigned long flags;
-	struct dma_tx_state		state;
-	int				dma_status;
-
-	dma_sync_single_for_device(dws->txchan->device->dev, dws->tx_dma,
-				   dws->len, DMA_TO_DEVICE);
-	
-	dma_status = dmaengine_tx_status(dws->txchan, dws->tx_cookie, &state);
-	
-	DBG_SPI("%s:dma_status=0x%x\n", __FUNCTION__, dma_status);
-	DBG_SPI("dma tx:");
-	printk_transfer_data(dws, (char *)dws->cur_transfer->tx_buf, dws->cur_transfer->len);
-	
-	spin_lock_irqsave(&dws->lock, flags);
-	
-	if (dma_status == DMA_SUCCESS)
-		dws->state &= ~TXBUSY;
-	else	
-		dev_err(&dws->master->dev, "error:tx dma_status=%x\n", dma_status);	
-
-	spin_unlock_irqrestore(&dws->lock, flags);
-	
-	/* If the other done */
-	if (!(dws->state & RXBUSY))
-	{
-		//DMA could not lose intterupt
-		dw_spi_xfer_done(dws);
-		complete(&dws->xfer_completion);
-		DBG_SPI("%s:complete\n", __FUNCTION__);
-	}
-
-}
-
-
-static int mid_spi_dma_transfer(struct dw_spi *dws, int cs_change)
-{
-	struct dma_async_tx_descriptor *txdesc = NULL, *rxdesc = NULL;
-	struct dma_chan *txchan, *rxchan;
-	struct dma_slave_config txconf, rxconf;
-	int ret = 0;
-	
-	enum dma_slave_buswidth width;
-
-	DBG_SPI("%s:cs_change=%d\n",__func__,cs_change);
-	
-	//alloc dma buffer default while cur_transfer->tx_dma or cur_transfer->rx_dma is null
-	if((dws->cur_transfer->tx_buf) && dws->dma_mapped && (!dws->cur_transfer->tx_dma))
-	{
-		//printk("%s:warning tx_dma is %p\n",__func__, (int *)dws->tx_dma);
-		memcpy(dws->tx_buffer, dws->cur_transfer->tx_buf, dws->cur_transfer->len);		
-		dws->tx_dma = dws->tx_dma_init;
-	}
-
-	if((dws->cur_transfer->rx_buf) && dws->dma_mapped && (!dws->cur_transfer->rx_dma))
-	{		
-		//printk("%s:warning rx_dma is %p\n",__func__, (int *)dws->rx_dma);
-		dws->rx_dma = dws->rx_dma_init;
-	}
-
-	
-	if (dws->tx)
-		dws->state |= TXBUSY;	
-	if (dws->rx)
-		dws->state |= RXBUSY;
-
-	
-	switch (dws->n_bytes) {
-	case 1:
-		width = DMA_SLAVE_BUSWIDTH_1_BYTE;
-		break;
-	case 2:
-		width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-		break;
-	default:
-		width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-		break;
-	}
-		
-	dws->dma_chan_done = 0;
-	
-	if (dws->tx)
-	txchan = dws->txchan;
-	
-	if (dws->rx)
-	rxchan = dws->rxchan;
-	
-	if (dws->tx)
-	{
-		/* 2. Prepare the TX dma transfer */
-		txconf.direction = DMA_MEM_TO_DEV;
-		txconf.dst_addr = dws->tx_dma_addr;
-		txconf.dst_maxburst = dws->dmatdlr;//dws->dma_width;
-		//txconf.src_addr_width = width;
-		txconf.dst_addr_width = width;
-		//txconf.device_fc = false;
-
-		ret = dmaengine_slave_config(txchan, &txconf);
-		if (ret) {
-			dev_warn(dws->parent_dev, "TX DMA slave config failed\n");
-			return -1;
-		}
-		
-		memset(&dws->tx_sgl, 0, sizeof(dws->tx_sgl));
-		dws->tx_sgl.dma_address = dws->tx_dma;
-#ifdef CONFIG_NEED_SG_DMA_LENGTH
-		dws->tx_sgl.dma_length = dws->len;
-#else
-		dws->tx_sgl.length = dws->len;
-#endif
-		txdesc = dmaengine_prep_slave_sg(txchan,
-					&dws->tx_sgl,
-					1,
-					DMA_MEM_TO_DEV,
-					DMA_PREP_INTERRUPT);
-		
-		txdesc->callback = dw_spi_dma_txcb;
-		txdesc->callback_param = dws;
-
-		DBG_SPI("%s:dst_addr=0x%p,tx_dma=0x%p,len=%ld,burst=%d,width=%d\n"
-			,__func__,(int *)dws->tx_dma_addr, (int *)dws->tx_dma, (long)dws->len,txconf.dst_maxburst, width);
-	}
-
-	if (dws->rx)
-	{
-		/* 3. Prepare the RX dma transfer */
-		rxconf.direction = DMA_DEV_TO_MEM;
-		rxconf.src_addr = dws->rx_dma_addr;
-		rxconf.src_maxburst = dws->dmardlr + 1;//dws->dma_width;
-		//rxconf.dst_addr_width = width;
-		rxconf.src_addr_width = width;
-		//rxconf.device_fc = false;
-
-		ret = dmaengine_slave_config(rxchan, &rxconf);
-		if (ret) {
-			dev_warn(dws->parent_dev, "RX DMA slave config failed\n");
-			return -1;
-		}
-
-		memset(&dws->rx_sgl, 0, sizeof(dws->rx_sgl));
-		dws->rx_sgl.dma_address = dws->rx_dma;
-#ifdef CONFIG_NEED_SG_DMA_LENGTH
-		dws->rx_sgl.dma_length = dws->len;				
-#else
-		dws->rx_sgl.length = dws->len;
-#endif
-
-		rxdesc = dmaengine_prep_slave_sg(rxchan,
-					&dws->rx_sgl,
-					1,
-					DMA_DEV_TO_MEM,
-					DMA_PREP_INTERRUPT);
-		rxdesc->callback = dw_spi_dma_rxcb;
-		rxdesc->callback_param = dws;
-		
-		DBG_SPI("%s:src_addr=0x%p,rx_dma=0x%p,len=%ld,burst=%d,width=%d\n"
-			,__func__, (int *)dws->rx_dma_addr, (int *)dws->rx_dma, (long)dws->len, rxconf.src_maxburst, width);
-	}
-
-	if(!dws->tx)
-	spi_enable_chip(dws, 1);
-	
-	/* rx must be started before tx due to spi instinct */	
-	if (dws->rx)
-	{		
-		dws->rx_cookie = dmaengine_submit(rxdesc);
-		dma_sync_single_for_device(rxchan->device->dev, dws->rx_dma,
-				   dws->len, DMA_FROM_DEVICE);
-		dma_async_issue_pending(rxchan);
-		
-		DBG_SPI("%s:rx end\n",__func__);
-	}
-	
-	if (dws->tx)
-	{		
-		dws->tx_cookie = dmaengine_submit(txdesc);
-		dma_sync_single_for_device(txchan->device->dev, dws->tx_dma,
-				   dws->len, DMA_TO_DEVICE);
-		dma_async_issue_pending(txchan);
-		
-		DBG_SPI("%s:tx end\n",__func__);
-	}
-	
-	return 0;
-}
-
-static struct dw_spi_dma_ops spi_dma_ops = {
-	.dma_init	= mid_spi_dma_init,
-	.dma_exit	= mid_spi_dma_exit,
-	.dma_transfer	= mid_spi_dma_transfer,
-};
-
-int dw_spi_dma_init(struct dw_spi *dws)
-{
-	DBG_SPI("%s:start\n",__func__);
-	dws->dma_priv = kzalloc(sizeof(struct spi_dma), GFP_KERNEL);
-	if (!dws->dma_priv)
-		return -ENOMEM;
-	dws->dma_ops = &spi_dma_ops;
-
-	dws->tx_buffer = dma_alloc_coherent(dws->parent_dev, DMA_BUFFER_SIZE, &dws->tx_dma_init, GFP_KERNEL | GFP_DMA);
-	if (!dws->tx_buffer)
-	{
-		dev_err(dws->parent_dev, "fail to dma tx buffer alloc\n");
-		return -1;
-	}
-
-	dws->rx_buffer = dma_alloc_coherent(dws->parent_dev, DMA_BUFFER_SIZE, &dws->rx_dma_init, GFP_KERNEL | GFP_DMA);
-	if (!dws->rx_buffer)
-	{
-		dev_err(dws->parent_dev, "fail to dma rx buffer alloc\n");
-		return -1;
-	}
-
-	memset(dws->tx_buffer, 0, DMA_BUFFER_SIZE);
-	memset(dws->rx_buffer, 0, DMA_BUFFER_SIZE);
-
-	dws->state = 0;
-	
-	init_completion(&dws->xfer_completion);
-	
-	return 0;
-}
-#endif
-
diff --git a/drivers/spi/spi_test.c b/drivers/spi/spi_test.c
deleted file mode 100755
index 3b1fec729540..000000000000
--- a/drivers/spi/spi_test.c
+++ /dev/null
@@ -1,248 +0,0 @@
-/*drivers/serial/spi_test.c -spi test driver
- *
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/highmem.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/cpufreq.h>
-#include <mach/gpio.h>
-#include <mach/irqs.h>
-#include <linux/miscdevice.h>
-#include <asm/dma.h>
-#include <linux/preempt.h>
-#include "rk29_spim.h"
-#include <linux/spi/spi.h>
-#include <mach/board.h>
-
-#define MAX_SPI_BUS_NUM 2
-
-struct spi_test_data {
-	struct device	*dev;
-	struct spi_device	*spi;	
-	char *rx_buf;
-	int rx_len; 
-	char *tx_buf;
-	int tx_len; 
-};
-static struct spi_test_data *g_spi_test_data[MAX_SPI_BUS_NUM];
-
-
-static struct rk29xx_spi_chip spi_test_chip[] = {
-{
-	//.poll_mode = 1,
-	.enable_dma = 1,
-},
-{
-	//.poll_mode = 1,
-	.enable_dma = 1,
-},
-
-};
-	
-static struct spi_board_info board_spi_test_devices[] = {	
-#if defined(CONFIG_SPIM0_RK29)
-	{
-		.modalias  = "spi_test_bus0",
-		.bus_num = 0,	//0 or 1
-		.max_speed_hz  = 12*1000*1000,
-		.chip_select   = 0,		
-		.mode	= SPI_MODE_0,
-		.controller_data = &spi_test_chip[0],
-	},
-#endif
-#if defined(CONFIG_SPIM1_RK29)
-	{
-		.modalias  = "spi_test_bus1",
-		.bus_num = 1,	//0 or 1
-		.max_speed_hz  = 12*1000*1000,
-		.chip_select   = 0,		
-		.mode	= SPI_MODE_0,
-		.controller_data = &spi_test_chip[1],
-	}
-#endif
-};
-
-static ssize_t spi_test_write(struct file *file, 
-			const char __user *buf, size_t count, loff_t *offset)
-{
-	char nr_buf[8];
-	int nr = 0, ret;
-	int i = 0;
-	struct spi_device *spi = NULL;
-	char txbuf[256],rxbuf[256];
-
-	printk("%s:0:bus=0,cs=0; 1:bus=0,cs=1; 2:bus=1,cs=0; 3:bus=1,cs=1\n",__func__);
-
-	if(count > 3)
-	    return -EFAULT;
-	ret = copy_from_user(nr_buf, buf, count);
-	if(ret < 0)
-	    return -EFAULT;
-
-	sscanf(nr_buf, "%d", &nr);
-	if(nr >= 4 || nr < 0)
-	{
-		printk("%s:cmd is error\n",__func__);
-	    return -EFAULT;
-	}
-	
-	for(i=0; i<256; i++)
-	txbuf[i] = i;
-
-
-#if !defined(CONFIG_SPIM0_RK29)
-	if((nr == 0) || (nr == 1))
-	{
-		printk("%s:error SPIM0 need selected\n",__func__);	
-		return -EFAULT;
-	}
-#endif
-
-#if !defined(CONFIG_SPIM1_RK29)
-	if((nr == 2) || (nr == 3))
-	{
-		printk("%s:error SPIM1 need selected\n",__func__);	
-		return -EFAULT;
-	}
-#endif
-
-	switch(nr)
-	{
-		case 0:	
-			if(!g_spi_test_data[0]->spi)		
-			return -EFAULT;
-			spi = g_spi_test_data[0]->spi;
-			spi->chip_select = 0;
-			break;
-		case 1:	
-			if(!g_spi_test_data[0]->spi)		
-			return -EFAULT;
-			spi = g_spi_test_data[0]->spi;
-			spi->chip_select = 1;
-			break;
-		case 2:	
-			if(!g_spi_test_data[1]->spi)		
-			return -EFAULT;
-			spi = g_spi_test_data[1]->spi;
-			spi->chip_select = 0;
-			break;
-		case 3:	
-			if(!g_spi_test_data[1]->spi)		
-			return -EFAULT;
-			spi = g_spi_test_data[1]->spi;
-			spi->chip_select = 1;
-			break;
-		
-		default:
-			break;
-	}
-
-	for(i=0; i<10; i++)
-	{
-		ret = spi_write(spi, txbuf, 256);
-		ret = spi_read(spi, rxbuf, 256);
-		ret = spi_write_then_read(spi,txbuf,256,rxbuf,256);
-		printk("%s:test %d times\n\n",__func__,i+1);
-	}
-	
-	if(!ret)
-	printk("%s:bus_num=%d,chip_select=%d,ok\n",__func__,spi->master->bus_num, spi->chip_select);
-	else
-	printk("%s:bus_num=%d,chip_select=%d,error\n",__func__,spi->master->bus_num, spi->chip_select);
-	
-	return count;
-}
-
-
-static const struct file_operations spi_test_fops = {
-	.write = spi_test_write,
-};
-
-static struct miscdevice spi_test_misc = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "spi_misc_test",
-	.fops = &spi_test_fops,
-};
-
-static int __devinit spi_test_probe(struct spi_device *spi)
-{	
-	struct spi_test_data *spi_test_data;
-	int ret;
-
-	if(!spi)	
-	return -ENOMEM;
-
-	if((spi->master->bus_num >= MAX_SPI_BUS_NUM) || (spi->master->bus_num < 0))
-	{
-		printk("%s:error:bus_num=%d\n",__func__, spi->master->bus_num);	
-		return -ENOMEM;
-	}
-	
-	spi_test_data = (struct spi_test_data *)kzalloc(sizeof(struct spi_test_data), GFP_KERNEL);
-	if(!spi_test_data){
-		dev_err(&spi->dev, "ERR: no memory for spi_test_data\n");
-		return -ENOMEM;
-	}
-
-	spi->bits_per_word = 8;
-	
-	spi_test_data->spi = spi;
-	spi_test_data->dev = &spi->dev;
-	ret = spi_setup(spi);
-	if (ret < 0){
-		dev_err(spi_test_data->dev, "ERR: fail to setup spi\n");
-		return -1;
-	}	
-
-	g_spi_test_data[spi->master->bus_num] = spi_test_data;
-
-	printk("%s:bus_num=%d,ok\n",__func__,spi->master->bus_num);
-
-	return ret;
-
-}
-
-static const struct spi_device_id spi_test_id[] = {		
-	{"spi_test_bus0", 0},
-	{"spi_test_bus1", 1},
-	{},
-};
-
-
-static struct spi_driver spi_test_driver = {
-	.driver = {
-		.name		= "spi_test",
-		.bus		= &spi_bus_type,
-		.owner		= THIS_MODULE,
-	},
-	.id_table = spi_test_id,
-
-	.probe		= spi_test_probe,
-};
-
-static int __init spi_test_init(void)
-{	
-	printk("%s\n",__func__);
-	spi_register_board_info(board_spi_test_devices, ARRAY_SIZE(board_spi_test_devices));
-	misc_register(&spi_test_misc);
-	return spi_register_driver(&spi_test_driver);
-}
-
-static void __exit spi_test_exit(void)
-{
-        misc_deregister(&spi_test_misc);
-	return spi_unregister_driver(&spi_test_driver);
-}
-module_init(spi_test_init);
-module_exit(spi_test_exit);
-
-- 
2.35.3

