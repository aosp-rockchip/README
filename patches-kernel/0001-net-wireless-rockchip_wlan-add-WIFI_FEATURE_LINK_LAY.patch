From 6b8e6ee6958824bf8007621d6aefaec26c6d38e0 Mon Sep 17 00:00:00 2001
From: Alex Zhao <zzc@rock-chips.com>
Date: Mon, 22 Jan 2018 15:38:11 +0800
Subject: [PATCH] net: wireless: rockchip_wlan: add
 WIFI_FEATURE_LINK_LAYER_STATS support

Change-Id: I97334e69270e280f39236eebee7663e08b78d6be
Signed-off-by: Alex Zhao <zzc@rock-chips.com>
---
 .../wireless/rockchip_wlan/rtl8723cs/Makefile |   2 +-
 .../rockchip_wlan/rtl8723cs/core/rtw_mlme.c   |  61 +++
 .../rtl8723cs/core/rtw_pwrctrl.c              |  24 +-
 .../rockchip_wlan/rtl8723cs/core/rtw_recv.c   |  11 +-
 .../rockchip_wlan/rtl8723cs/core/rtw_xmit.c   |   6 +-
 .../rtl8723cs/include/rtw_mlme.h              |   8 +
 .../rtl8723cs/include/rtw_pwrctrl.h           |   3 +
 .../rtl8723cs/include/rtw_recv.h              |   2 +-
 .../rtl8723cs/include/rtw_version.h           |   2 +-
 .../rtl8723cs/include/rtw_xmit.h              |   2 +-
 .../rtl8723cs/os_dep/linux/os_intfs.c         |   8 +-
 .../rtl8723cs/os_dep/linux/rtw_cfgvendor.c    | 211 ++++++---
 .../rtl8723cs/os_dep/linux/rtw_cfgvendor.h    | 421 +++++++++++++++---
 13 files changed, 624 insertions(+), 137 deletions(-)

diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/Makefile b/drivers/net/wireless/rockchip_wlan/rtl8723cs/Makefile
index ac66ab359d2c..cbfbe5ada474 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/Makefile
@@ -24,7 +24,7 @@ EXTRA_CFLAGS += -I$(src)/include
 EXTRA_CFLAGS += -I$(src)/hal/phydm
 
 EXTRA_LDFLAGS += --strip-debug
-
+EXTRA_CFLAGS += -DLINK_LAYER_STATS_SUPPORT
 CONFIG_AUTOCFG_CP = n
 
 ########################## WIFI IC ############################
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_mlme.c b/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_mlme.c
index ae324bd9caea..1847a6c87048 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_mlme.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_mlme.c
@@ -120,6 +120,14 @@ sint	_rtw_init_mlme_priv(_adapter *padapter)
 		| RTW_FT_STA_OVER_DS_SUPPORTED
 		;
 #endif
+#ifdef LINK_LAYER_STATS_SUPPORT
+	pmlmepriv->radio_on_start_time = 0;
+	pmlmepriv->trx_total_time= 0;
+	pmlmepriv->on_time = 0;
+	pmlmepriv->tx_time = 0;
+	pmlmepriv->rx_time = 0;
+#endif /* LINK_LAYER_STATS_SUPPORT */
+
 	rtw_init_mlme_timer(padapter);
 
 exit:
@@ -3013,9 +3021,62 @@ static void collect_traffic_statistics(_adapter *padapter)
 	RTW_INFO("cur_rx_tp:%d\n", pdvobjpriv->traffic_stat.cur_rx_tp);
 	#endif
 }
+#ifdef LINK_LAYER_STATS_SUPPORT
+void LinkLayerStats(_adapter *padapter)
+{
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	struct xmit_priv		*pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv		*precvpriv = &(padapter->recvpriv);
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	u64 trx_total_bytes = 0;
+	u64 tmp = 0;
+	RTW_INFO("%s adapter type : %u\n", __func__, padapter->adapter_type);
+if ( padapter->bup == _TRUE ) {
+
+	pmlmepriv->on_time += rtw_get_passing_time_ms(pmlmepriv->radio_on_start_time);
+	pmlmepriv->radio_on_start_time = rtw_get_current_time();
+	if ( pwrpriv->bpower_saving == _TRUE ) {
+		pmlmepriv->pwr_saving_time += rtw_get_passing_time_ms(pwrpriv->pwr_saving_start_time);
+		pwrpriv->pwr_saving_start_time = rtw_get_current_time();
+	}
+
+	trx_total_bytes = pxmitpriv->tx_total_bytes + precvpriv->rx_total_bytes;
+	//Deviation caused by caculation start time
+	if ( pmlmepriv->pwr_saving_time > pmlmepriv->on_time )
+		pmlmepriv->pwr_saving_time = pmlmepriv->on_time;
+	pmlmepriv->trx_total_time = pmlmepriv->on_time - pmlmepriv->pwr_saving_time;
+	if ( trx_total_bytes == 0) {
+		pmlmepriv->tx_time = 0;
+		pmlmepriv->rx_time = 0;
+	} else {
+		tmp = (pxmitpriv->tx_total_bytes * pmlmepriv->trx_total_time);
+		tmp = rtw_division64(tmp, trx_total_bytes);
+		pmlmepriv->tx_time = tmp;
+
+		tmp = (precvpriv->rx_total_bytes * pmlmepriv->trx_total_time);
+		tmp = rtw_division64(tmp, trx_total_bytes);
+		pmlmepriv->rx_time = tmp;
+		//pmlmepriv->tx_time = (pmlmepriv->trx_total_time * pxmitpriv->tx_total_bytes) / trx_total_bytes;
+		//pmlmepriv->rx_time = (pmlmepriv->trx_total_time * precvpriv->rx_total_bytes) / trx_total_bytes;
 
+	}
+#if 1
+	RTW_INFO("- tx_bytes : %llu rx_bytes : %llu total bytes : %llu\n", pxmitpriv->tx_total_bytes, precvpriv->rx_total_bytes
+		, trx_total_bytes);
+	RTW_INFO("- pwr_saving_time : %u ms\n", pmlmepriv->pwr_saving_time);
+	RTW_INFO("- trx_total_time : %u ms\n", pmlmepriv->trx_total_time);	
+	RTW_INFO("- on_time : %u ms\n", pmlmepriv->on_time);
+	RTW_INFO("- tx_time : %u ms\n", pmlmepriv->tx_time);
+	RTW_INFO("- rx_time : %u ms\n", pmlmepriv->rx_time);
+#endif
+}
+}
+#endif
 void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 {
+#ifdef LINK_LAYER_STATS_SUPPORT
+LinkLayerStats(adapter);
+#endif /* LINK_LAYER_STATS_SUPPORT */
 	if (!adapter)
 		return;
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_pwrctrl.c b/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_pwrctrl.c
index e637c3cfa57d..f2839f0256d1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_pwrctrl.c
@@ -89,7 +89,9 @@ void _ips_enter(_adapter *padapter)
 
 		if (pwrpriv->ips_mode == IPS_LEVEL_2)
 			pwrpriv->bkeepfwalive = _TRUE;
-
+#ifdef LINK_LAYER_STATS_SUPPORT		
+		pwrpriv->pwr_saving_start_time = rtw_get_current_time();
+#endif /* LINK_LAYER_STATS_SUPPORT */
 		rtw_ips_pwr_down(padapter);
 		pwrpriv->rf_pwrstate = rf_off;
 	}
@@ -115,7 +117,9 @@ int _ips_leave(_adapter *padapter)
 {
 	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
 	int result = _SUCCESS;
-
+#ifdef LINK_LAYER_STATS_SUPPORT
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+#endif /* LINK_LAYER_STATS_SUPPORT */
 	if ((pwrpriv->rf_pwrstate == rf_off) && (!pwrpriv->bips_processing)) {
 		pwrpriv->bips_processing = _TRUE;
 		pwrpriv->change_rfpwrstate = rf_on;
@@ -125,6 +129,9 @@ int _ips_leave(_adapter *padapter)
 		result = rtw_ips_pwr_up(padapter);
 		if (result == _SUCCESS)
 			pwrpriv->rf_pwrstate = rf_on;
+#ifdef LINKSTAT_SUPPORT	
+		pmlmepriv->pwr_saving_time+= rtw_get_passing_time_ms(pwrpriv->pwr_saving_start_time);
+#endif
 		RTW_PRINT("nolinked power save leave\n");
 
 		RTW_INFO("==> ips_leave.....LED(0x%08x)...\n", rtw_read32(padapter, 0x4c));
@@ -1076,6 +1083,9 @@ void LPS_Enter(PADAPTER padapter, const char *msg)
 			if (pwrpriv->pwr_mode == PS_MODE_ACTIVE) {
 				sprintf(buf, "WIFI-%s", msg);
 				pwrpriv->bpower_saving = _TRUE;
+#ifdef LINK_LAYER_STATS_SUPPORT
+				pwrpriv->pwr_saving_start_time = rtw_get_current_time();
+#endif /* LINK_LAYER_STATS_SUPPORT */
 				rtw_set_ps_mode(padapter, pwrpriv->power_mgnt, padapter->registrypriv.smart_ps, 0, buf);
 			}
 		} else
@@ -1100,6 +1110,9 @@ void LPS_Leave(PADAPTER padapter, const char *msg)
 	u8 bAwake = _FALSE;
 	char buf[32] = {0};
 	struct debug_priv *pdbgpriv = &dvobj->drv_dbg;
+#ifdef LINK_LAYER_STATS_SUPPORT
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+#endif /* LINK_LAYER_STATS_SUPPORT */	
 
 
 	/*	RTW_INFO("+LeisurePSLeave\n"); */
@@ -1113,6 +1126,9 @@ void LPS_Leave(PADAPTER padapter, const char *msg)
 		if (pwrpriv->pwr_mode != PS_MODE_ACTIVE) {
 			sprintf(buf, "WIFI-%s", msg);
 			rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, buf);
+#ifdef LINK_LAYER_STATS_SUPPORT	
+			pmlmepriv->pwr_saving_time += rtw_get_passing_time_ms(pwrpriv->pwr_saving_start_time);
+#endif /* LINK_LAYER_STATS_SUPPORT */
 
 			if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
 				LPS_RF_ON_check(padapter, LPS_LEAVE_TIMEOUT_MS);
@@ -2053,7 +2069,9 @@ void rtw_init_pwrctrl_priv(PADAPTER padapter)
 #ifdef CONFIG_LPS_POFF
 	rtw_hal_set_hwreg(padapter, HW_VAR_LPS_POFF_INIT, 0);
 #endif
-
+#ifdef LINK_LAYER_STATS_SUPPORT
+	pwrctrlpriv->pwr_saving_start_time = 0;
+#endif /* LINK_LAYER_STATS_SUPPORT */
 
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_recv.c b/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_recv.c
index 4c09d8f29fae..e0d237e59b2f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_recv.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_recv.c
@@ -151,6 +151,8 @@ sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
 
 	rtw_set_signal_stat_timer(precvpriv);
 #endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
+	precvpriv->rx_total_bytes = 0;
+	precvpriv->rx_bytes = 0;
 
 exit:
 
@@ -4223,7 +4225,9 @@ int recv_func(_adapter *padapter, union recv_frame *rframe)
 	struct recv_priv *recvpriv = &padapter->recvpriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv *mlmepriv = &padapter->mlmepriv;
-
+#ifdef LINK_LAYER_STATS_SUPPORT
+	uint sz = 0;
+#endif /* LINK_LAYER_STATS_SUPPORT */
 	if (check_fwstate(mlmepriv, WIFI_MONITOR_STATE)) {
 		/* monitor mode */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24))
@@ -4248,7 +4252,10 @@ int recv_func(_adapter *padapter, union recv_frame *rframe)
 				RTW_INFO(FUNC_ADPT_FMT" dequeue %d from uc_swdec_pending_queue\n",
 					 FUNC_ADPT_ARG(padapter), cnt);
 		}
-
+#ifdef LINK_LAYER_STATS_SUPPORT
+	sz = get_recvframe_len(rframe);
+	recvpriv->rx_total_bytes += sz;
+#endif /* LINK_LAYER_STATS_SUPPORT */
 	DBG_COUNTER(padapter->rx_logs.core_rx);
 	ret = recv_func_prehandle(padapter, rframe);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_xmit.c b/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_xmit.c
index 09e1a20f8aa2..7ccc4b014b94 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_xmit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/core/rtw_xmit.c
@@ -336,6 +336,8 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 	pxmitpriv->amsdu_debug_coalesce_one = 0;
 	pxmitpriv->amsdu_debug_coalesce_two = 0;
 #endif
+	pxmitpriv->tx_total_bytes = 0;
+	pxmitpriv->tx_bytes = 0;
 	rtw_hal_init_xmit_priv(padapter);
 
 exit:
@@ -2886,7 +2888,9 @@ void rtw_count_tx_stats(PADAPTER padapter, struct xmit_frame *pxmitframe, int sz
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	u8	pkt_num = 1;
-
+#ifdef LINK_LAYER_STATS_SUPPORT
+	pxmitpriv->tx_total_bytes += sz;
+#endif /* LINK_LAYER_STATS_SUPPORT */
 	if ((pxmitframe->frame_tag & 0x0f) == DATA_FRAMETAG) {
 #if defined(CONFIG_USB_TX_AGGREGATION) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 		pkt_num = pxmitframe->agg_num;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_mlme.h b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_mlme.h
index 9290c14e576e..c5a3a3d21f6d 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_mlme.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_mlme.h
@@ -849,6 +849,14 @@ struct mlme_priv {
 	u8 vendor_ie[WLAN_MAX_VENDOR_IE_NUM][WLAN_MAX_VENDOR_IE_LEN];
 	u32 vendor_ielen[WLAN_MAX_VENDOR_IE_NUM];
 #endif
+#ifdef LINK_LAYER_STATS_SUPPORT
+	u32 pwr_saving_time;
+	u32 radio_on_start_time;
+	u32 trx_total_time;
+	u32 on_time;
+	u32 tx_time;
+	u32 rx_time;
+#endif /* LINK_LAYER_STATS_SUPPORT */
 };
 
 #define mlme_set_scan_to_timer(mlme, ms) \
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_pwrctrl.h b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_pwrctrl.h
index 1f170a9facad..8c8e225674c4 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_pwrctrl.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_pwrctrl.h
@@ -448,6 +448,9 @@ struct pwrctrl_priv {
 	u8 blpspg_info_up;
 #endif
 	u8 current_lps_hw_port_id;
+#ifdef LINK_LAYER_STATS_SUPPORT
+	u32 pwr_saving_start_time;
+#endif /* LINK_LAYER_STATS_SUPPORT */
 };
 
 #define rtw_get_ips_mode_req(pwrctl) \
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_recv.h
index 349ca3f25fc4..f29ee210bfa1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_recv.h
@@ -402,7 +402,7 @@ struct recv_priv {
 
 
 	u32 is_any_non_be_pkts;
-
+	u64 rx_total_bytes;
 	u64	rx_bytes;
 	u64	rx_pkts;
 	u64	rx_drop;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_version.h b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_version.h
index e8782f715854..80f296cff7f1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_version.h
@@ -1,2 +1,2 @@
-#define DRIVERVERSION	"v5.2.1.7_25082.20171108_COEX20170626-1a00"
+#define DRIVERVERSION	"v5.2.1.7_25082.20171108_COEX20170626-1a00_wifi_hal"
 #define BTCOEXVERSION	"COEX20170626-1a00"
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_xmit.h
index 9669a20e3e71..f2eb45a6e683 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/include/rtw_xmit.h
@@ -734,7 +734,7 @@ struct	xmit_priv	{
 	u8	vcs;
 	u8	vcs_type;
 	/* u16  rts_thresh; */
-
+	u64	tx_total_bytes;
 	u64	tx_bytes;
 	u64	tx_pkts;
 	u64	tx_drop;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/os_intfs.c b/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/os_intfs.c
index 517137e6fa58..69144c0a1499 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/os_intfs.c
@@ -2798,7 +2798,9 @@ int _netdev_open(struct net_device *pnetdev)
 #ifdef CONFIG_BT_COEXIST_SOCKET_TRX
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
 #endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
-
+#ifdef LINK_LAYER_STATS_SUPPORT
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+#endif
 
 	RTW_INFO(FUNC_NDEV_FMT" , bup=%d\n", FUNC_NDEV_ARG(pnetdev), padapter->bup);
 
@@ -2833,7 +2835,9 @@ int _netdev_open(struct net_device *pnetdev)
 #if 0/*#ifdef CONFIG_MI_WITH_MBSSID_CAM*/
 		rtw_hal_set_hwreg(padapter, HW_VAR_MAC_ADDR, adapter_mac_addr(padapter)); /* set mac addr to mac register */
 #endif
-
+#ifdef LINK_LAYER_STATS_SUPPORT
+		pmlmepriv->radio_on_start_time = rtw_get_current_time();
+#endif
 		RTW_INFO("MAC Address = "MAC_FMT"\n", MAC_ARG(pnetdev->dev_addr));
 
 		status = rtw_start_drv_threads(padapter);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/rtw_cfgvendor.c b/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/rtw_cfgvendor.c
index b8497d9ed7ef..ab633e46d49f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/rtw_cfgvendor.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/rtw_cfgvendor.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -11,12 +11,7 @@
  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
+ *****************************************************************************/
 
 #include <drv_types.h>
 
@@ -214,22 +209,34 @@ static int rtw_cfgvendor_send_cmd_reply(struct wiphy *wiphy,
 	return rtw_cfg80211_vendor_cmd_reply(skb);
 }
 
-#define WIFI_FEATURE_INFRA              0x0001      /* Basic infrastructure mode       */
-#define WIFI_FEATURE_INFRA_5G           0x0002      /* Support for 5 GHz Band          */
-#define WIFI_FEATURE_HOTSPOT            0x0004      /* Support for GAS/ANQP            */
-#define WIFI_FEATURE_P2P                0x0008      /* Wifi-Direct                     */
-#define WIFI_FEATURE_SOFT_AP            0x0010      /* Soft AP                         */
-#define WIFI_FEATURE_GSCAN              0x0020      /* Google-Scan APIs                */
-#define WIFI_FEATURE_NAN                0x0040      /* Neighbor Awareness Networking   */
-#define WIFI_FEATURE_D2D_RTT            0x0080      /* Device-to-device RTT            */
-#define WIFI_FEATURE_D2AP_RTT           0x0100      /* Device-to-AP RTT                */
-#define WIFI_FEATURE_BATCH_SCAN         0x0200      /* Batched Scan (legacy)           */
-#define WIFI_FEATURE_PNO                0x0400      /* Preferred network offload       */
-#define WIFI_FEATURE_ADDITIONAL_STA     0x0800      /* Support for two STAs            */
-#define WIFI_FEATURE_TDLS               0x1000      /* Tunnel directed link setup      */
-#define WIFI_FEATURE_TDLS_OFFCHANNEL    0x2000      /* Support for TDLS off channel    */
-#define WIFI_FEATURE_EPR                0x4000      /* Enhanced power reporting        */
-#define WIFI_FEATURE_AP_STA             0x8000      /* Support for AP STA Concurrency  */
+/* Feature enums */
+#define WIFI_FEATURE_INFRA              0x0001      // Basic infrastructure mode
+#define WIFI_FEATURE_INFRA_5G           0x0002      // Support for 5 GHz Band
+#define WIFI_FEATURE_HOTSPOT            0x0004      // Support for GAS/ANQP
+#define WIFI_FEATURE_P2P                0x0008      // Wifi-Direct
+#define WIFI_FEATURE_SOFT_AP            0x0010      // Soft AP
+#define WIFI_FEATURE_GSCAN              0x0020      // Google-Scan APIs
+#define WIFI_FEATURE_NAN                0x0040      // Neighbor Awareness Networking
+#define WIFI_FEATURE_D2D_RTT            0x0080      // Device-to-device RTT
+#define WIFI_FEATURE_D2AP_RTT           0x0100      // Device-to-AP RTT
+#define WIFI_FEATURE_BATCH_SCAN         0x0200      // Batched Scan (legacy)
+#define WIFI_FEATURE_PNO                0x0400      // Preferred network offload
+#define WIFI_FEATURE_ADDITIONAL_STA     0x0800      // Support for two STAs
+#define WIFI_FEATURE_TDLS               0x1000      // Tunnel directed link setup
+#define WIFI_FEATURE_TDLS_OFFCHANNEL    0x2000      // Support for TDLS off channel
+#define WIFI_FEATURE_EPR                0x4000      // Enhanced power reporting
+#define WIFI_FEATURE_AP_STA             0x8000      // Support for AP STA Concurrency
+#define WIFI_FEATURE_LINK_LAYER_STATS   0x10000     // Link layer stats collection
+#define WIFI_FEATURE_LOGGER             0x20000     // WiFi Logger
+#define WIFI_FEATURE_HAL_EPNO           0x40000     // WiFi PNO enhanced
+#define WIFI_FEATURE_RSSI_MONITOR       0x80000     // RSSI Monitor
+#define WIFI_FEATURE_MKEEP_ALIVE        0x100000    // WiFi mkeep_alive
+#define WIFI_FEATURE_CONFIG_NDO         0x200000    // ND offload configure
+#define WIFI_FEATURE_TX_TRANSMIT_POWER  0x400000    // Capture Tx transmit power levels
+#define WIFI_FEATURE_CONTROL_ROAMING    0x800000    // Enable/Disable firmware roaming
+#define WIFI_FEATURE_IE_WHITELIST       0x1000000   // Support Probe IE white listing
+#define WIFI_FEATURE_SCAN_RAND          0x2000000   // Support MAC & Probe Sequence Number randomization
+// Add more features here
 
 #define MAX_FEATURE_SET_CONCURRRENT_GROUPS  3
 
@@ -252,6 +259,9 @@ int rtw_dev_get_feature_set(struct net_device *dev)
 	feature_set |= WIFI_FEATURE_SOFT_AP;
 
 	feature_set |= WIFI_FEATURE_ADDITIONAL_STA;
+#ifdef LINK_LAYER_STATS_SUPPORT
+	feature_set |= WIFI_FEATURE_LINK_LAYER_STATS;
+#endif /* LINK_LAYER_STATS_SUPPORT */
 
 	return feature_set;
 }
@@ -1112,57 +1122,86 @@ static int wl_cfgvendor_rtt_get_capability(struct wiphy *wiphy, struct wireless_
 }
 
 #endif /* RTT_SUPPORT */
-static int wl_cfgvendor_priv_string_handler(struct wiphy *wiphy,
-		struct wireless_dev *wdev, const void  *data, int len)
+
+#ifdef LINK_LAYER_STATS_SUPPORT
+enum {
+    LSTATS_SUBCMD_GET_INFO = ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START,
+	LSTATS_SUBCMD_SET_INFO,
+	LSTATS_SUBCMD_CLEAR_INFO,
+};
+#define DUMMY_TIME_STATICS 99
+static int wl_cfgvendor_lstats_get_info(struct wiphy *wiphy,	
+	struct wireless_dev *wdev, const void  *data, int len)
 {
 	int err = 0;
-	u8 resp[1] = {'\0'};
+	_adapter *padapter = GET_PRIMARY_ADAPTER(wiphy_to_adapter(wiphy));
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	wifi_radio_stat *radio;
+	wifi_iface_stat *iface;
+	char *output;
+
+	output = rtw_malloc(sizeof(wifi_radio_stat) + sizeof(wifi_iface_stat)+1);
+	if (output == NULL) {
+		RTW_DBG("Allocate lstats info buffer fail!\n");
+	}
 
-	RTW_PRINT(FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char *)data);
-	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), resp, 1);
+	radio = (wifi_radio_stat *)output;
+
+	radio->num_channels = 0;
+	radio->radio = 1;
+	radio->on_time = pmlmepriv->on_time;
+	radio->tx_time = pmlmepriv->tx_time;
+	radio->rx_time = pmlmepriv->rx_time;
+	radio->num_tx_levels = 1;
+	radio->tx_time_per_levels = NULL;
+	radio->tx_time_per_levels = (u32*)(output+sizeof(wifi_radio_stat) + sizeof(wifi_iface_stat));
+	*(radio->tx_time_per_levels) = DUMMY_TIME_STATICS;
+
+	radio->on_time_scan = 0;
+	radio->on_time_nbd = 0;
+	radio->on_time_gscan = 0;
+	radio->on_time_pno_scan = 0;
+	radio->on_time_hs20 = 0;
+	#if 1
+	RTW_INFO("==== %s ====\n", __func__);
+	RTW_INFO("radio->radio : %d\n", (radio->radio));
+	RTW_INFO("pmlmepriv->on_time : %u ms\n", (pmlmepriv->on_time));
+	RTW_INFO("pmlmepriv->tx_time :  %u ms\n", (pmlmepriv->tx_time));
+	RTW_INFO("pmlmepriv->rx_time :  %u ms\n", (pmlmepriv->rx_time));
+	RTW_INFO("radio->on_time :  %u ms\n", (radio->on_time));
+	RTW_INFO("radio->tx_time :  %u ms\n", (radio->tx_time));
+	RTW_INFO("radio->rx_time :  %u ms\n", (radio->rx_time));
+	RTW_INFO("radio->tx_time_per_levels value :  %u ms\n", *(radio->tx_time_per_levels));
+	#endif
+	
+	RTW_INFO(FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char*)data);
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), 
+		output, sizeof(wifi_iface_stat) + sizeof(wifi_radio_stat)+1);
 	if (unlikely(err))
-		RTW_ERR(FUNC_NDEV_FMT"Vendor Command reply failed ret:%d\n"
+		RTW_ERR(FUNC_NDEV_FMT"Vendor Command reply failed ret:%d \n"
 			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
-
+	rtw_mfree(output, sizeof(wifi_iface_stat) + sizeof(wifi_radio_stat)+1);
 	return err;
-#if 0
-	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+}
+static int wl_cfgvendor_lstats_set_info(struct wiphy *wiphy,	
+	struct wireless_dev *wdev, const void  *data, int len)
+{
 	int err = 0;
-	int data_len = 0;
-
-	bzero(cfg->ioctl_buf, WLC_IOCTL_MAXLEN);
-
-	if (strncmp((char *)data, BRCM_VENDOR_SCMD_CAPA, strlen(BRCM_VENDOR_SCMD_CAPA)) == 0) {
-		err = wldev_iovar_getbuf(bcmcfg_to_prmry_ndev(cfg), "cap", NULL, 0,
-			cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
-		if (unlikely(err)) {
-			WL_ERR(("error (%d)\n", err));
-			return err;
-		}
-		data_len = strlen(cfg->ioctl_buf);
-		cfg->ioctl_buf[data_len] = '\0';
-	}
-
-	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
-					    cfg->ioctl_buf, data_len + 1);
-	if (unlikely(err))
-		WL_ERR(("Vendor Command reply failed ret:%d\n", err));
-	else
-		WL_INFORM(("Vendor Command reply sent successfully!\n"));
-
+	RTW_INFO("%s\n", __func__);
+	return err;
+}
+static int wl_cfgvendor_lstats_clear_info(struct wiphy *wiphy,	
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	RTW_INFO("%s\n", __func__);
 	return err;
-#endif
 }
 
+#endif /* LINK_LAYER_STATS_SUPPORT */
+
+
 static const struct wiphy_vendor_command rtw_vendor_cmds[] = {
-	{
-		{
-			.vendor_id = OUI_BRCM,
-			.subcmd = BRCM_VENDOR_SCMD_PRIV_STR
-		},
-		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
-		.doit = wl_cfgvendor_priv_string_handler
-	},
 #if defined(GSCAN_SUPPORT) && 0
 	{
 		{
@@ -1263,10 +1302,36 @@ static const struct wiphy_vendor_command rtw_vendor_cmds[] = {
 		.doit = wl_cfgvendor_rtt_get_capability
 	},
 #endif /* RTT_SUPPORT */
+#ifdef LINK_LAYER_STATS_SUPPORT
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = LSTATS_SUBCMD_GET_INFO
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_lstats_get_info
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = LSTATS_SUBCMD_SET_INFO
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_lstats_set_info
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = LSTATS_SUBCMD_CLEAR_INFO
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_lstats_clear_info
+	},
+#endif /* LINK_LAYER_STATS_SUPPORT */
 	{
 		{
 			.vendor_id = OUI_GOOGLE,
-			.subcmd = ANDR_WIFI_SUBCMD_GET_FEATURE_SET
+			.subcmd = WIFI_SUBCMD_GET_FEATURE_SET
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = rtw_cfgvendor_get_feature_set
@@ -1274,7 +1339,7 @@ static const struct wiphy_vendor_command rtw_vendor_cmds[] = {
 	{
 		{
 			.vendor_id = OUI_GOOGLE,
-			.subcmd = ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX
+			.subcmd = WIFI_SUBCMD_GET_FEATURE_SET_MATRIX
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = rtw_cfgvendor_get_feature_set_matrix
@@ -1282,20 +1347,18 @@ static const struct wiphy_vendor_command rtw_vendor_cmds[] = {
 };
 
 static const struct  nl80211_vendor_cmd_info rtw_vendor_events[] = {
-	{ OUI_BRCM, BRCM_VENDOR_EVENT_UNSPEC },
-	{ OUI_BRCM, BRCM_VENDOR_EVENT_PRIV_STR },
 #if defined(GSCAN_SUPPORT) && 0
-	{ OUI_GOOGLE, GOOGLE_GSCAN_SIGNIFICANT_EVENT },
-	{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT },
-	{ OUI_GOOGLE, GOOGLE_GSCAN_BATCH_SCAN_EVENT },
-	{ OUI_GOOGLE, GOOGLE_SCAN_FULL_RESULTS_EVENT },
+	{ OUI_GOOGLE, GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS },
+	{ OUI_GOOGLE, GSCAN_EVENT_HOTLIST_RESULTS_FOUND },
+	{ OUI_GOOGLE, GSCAN_EVENT_SCAN_RESULTS_AVAILABLE },
+	{ OUI_GOOGLE, GSCAN_EVENT_FULL_SCAN_RESULTS },
 #endif /* GSCAN_SUPPORT */
 #if defined(RTT_SUPPORT) && 0
-	{ OUI_GOOGLE, GOOGLE_RTT_COMPLETE_EVENT },
+	{ OUI_GOOGLE, RTT_EVENT_COMPLETE },
 #endif /* RTT_SUPPORT */
 #if defined(GSCAN_SUPPORT) && 0
-	{ OUI_GOOGLE, GOOGLE_SCAN_COMPLETE_EVENT },
-	{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_LOST_EVENT }
+	{ OUI_GOOGLE, GSCAN_EVENT_COMPLETE_SCAN },
+	{ OUI_GOOGLE, GSCAN_EVENT_HOTLIST_RESULTS_LOST }
 #endif /* GSCAN_SUPPORT */
 };
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/rtw_cfgvendor.h b/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/rtw_cfgvendor.h
index 2ed3a9e623f9..1ba3536c461f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/rtw_cfgvendor.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723cs/os_dep/linux/rtw_cfgvendor.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -11,12 +11,7 @@
  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
+ *****************************************************************************/
 
 #ifndef _RTW_CFGVENDOR_H_
 #define _RTW_CFGVENDOR_H_
@@ -44,54 +39,91 @@
 				     VENDOR_SUBCMD_OVERHEAD + \
 				     VENDOR_DATA_OVERHEAD)
 typedef enum {
-	/* don't use 0 as a valid subcommand */
-	VENDOR_NL80211_SUBCMD_UNSPECIFIED,
+    /* don't use 0 as a valid subcommand */
+    VENDOR_NL80211_SUBCMD_UNSPECIFIED,
+
+    /* define all vendor startup commands between 0x0 and 0x0FFF */
+    VENDOR_NL80211_SUBCMD_RANGE_START = 0x0001,
+    VENDOR_NL80211_SUBCMD_RANGE_END   = 0x0FFF,
+
+    /* define all GScan related commands between 0x1000 and 0x10FF */
+    ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START = 0x1000,
+    ANDROID_NL80211_SUBCMD_GSCAN_RANGE_END   = 0x10FF,
 
-	/* define all vendor startup commands between 0x0 and 0x0FFF */
-	VENDOR_NL80211_SUBCMD_RANGE_START = 0x0001,
-	VENDOR_NL80211_SUBCMD_RANGE_END   = 0x0FFF,
+    /* define all NearbyDiscovery related commands between 0x1100 and 0x11FF */
+    ANDROID_NL80211_SUBCMD_NBD_RANGE_START = 0x1100,
+    ANDROID_NL80211_SUBCMD_NBD_RANGE_END   = 0x11FF,
 
-	/* define all GScan related commands between 0x1000 and 0x10FF */
-	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START = 0x1000,
-	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_END   = 0x10FF,
+    /* define all RTT related commands between 0x1100 and 0x11FF */
+    ANDROID_NL80211_SUBCMD_RTT_RANGE_START = 0x1100,
+    ANDROID_NL80211_SUBCMD_RTT_RANGE_END   = 0x11FF,
 
-	/* define all NearbyDiscovery related commands between 0x1100 and 0x11FF */
-	ANDROID_NL80211_SUBCMD_NBD_RANGE_START = 0x1100,
-	ANDROID_NL80211_SUBCMD_NBD_RANGE_END   = 0x11FF,
+    ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START = 0x1200,
+    ANDROID_NL80211_SUBCMD_LSTATS_RANGE_END   = 0x12FF,
 
-	/* define all RTT related commands between 0x1100 and 0x11FF */
-	ANDROID_NL80211_SUBCMD_RTT_RANGE_START = 0x1100,
-	ANDROID_NL80211_SUBCMD_RTT_RANGE_END   = 0x11FF,
+    /* define all Logger related commands between 0x1400 and 0x14FF */
+    ANDROID_NL80211_SUBCMD_DEBUG_RANGE_START = 0x1400,
+    ANDROID_NL80211_SUBCMD_DEBUG_RANGE_END   = 0x14FF,
 
-	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START = 0x1200,
-	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_END   = 0x12FF,
+    /* define all wifi offload related commands between 0x1600 and 0x16FF */
+    ANDROID_NL80211_SUBCMD_WIFI_OFFLOAD_RANGE_START = 0x1600,
+    ANDROID_NL80211_SUBCMD_WIFI_OFFLOAD_RANGE_END   = 0x16FF,
 
-	ANDROID_NL80211_SUBCMD_TDLS_RANGE_START = 0x1300,
-	ANDROID_NL80211_SUBCMD_TDLS_RANGE_END	= 0x13FF,
-	/* This is reserved for future usage */
+    /* define all NAN related commands between 0x1700 and 0x17FF */
+    ANDROID_NL80211_SUBCMD_NAN_RANGE_START = 0x1700,
+    ANDROID_NL80211_SUBCMD_NAN_RANGE_END   = 0x17FF,
+
+    /* define all Android Packet Filter related commands between 0x1800 and 0x18FF */
+    ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_START = 0x1800,
+    ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_END   = 0x18FF,
+
+    /* This is reserved for future usage */
 
 } ANDROID_VENDOR_SUB_COMMAND;
 
 enum wl_vendor_subcmd {
-	BRCM_VENDOR_SCMD_UNSPEC,
-	BRCM_VENDOR_SCMD_PRIV_STR,
-	GSCAN_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START,
-	GSCAN_SUBCMD_SET_CONFIG,
-	GSCAN_SUBCMD_SET_SCAN_CONFIG,
-	GSCAN_SUBCMD_ENABLE_GSCAN,
-	GSCAN_SUBCMD_GET_SCAN_RESULTS,
-	GSCAN_SUBCMD_SCAN_RESULTS,
-	GSCAN_SUBCMD_SET_HOTLIST,
-	GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,
-	GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,
-	GSCAN_SUBCMD_GET_CHANNEL_LIST,
-	ANDR_WIFI_SUBCMD_GET_FEATURE_SET,
-	ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,
+    GSCAN_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START,
+
+    GSCAN_SUBCMD_SET_CONFIG,                            /* 0x1001 */
+
+    GSCAN_SUBCMD_SET_SCAN_CONFIG,                       /* 0x1002 */
+    GSCAN_SUBCMD_ENABLE_GSCAN,                          /* 0x1003 */
+    GSCAN_SUBCMD_GET_SCAN_RESULTS,                      /* 0x1004 */
+    GSCAN_SUBCMD_SCAN_RESULTS,                          /* 0x1005 */
+
+    GSCAN_SUBCMD_SET_HOTLIST,                           /* 0x1006 */
+
+    GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,         /* 0x1007 */
+    GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,              /* 0x1008 */
+    GSCAN_SUBCMD_GET_CHANNEL_LIST,                       /* 0x1009 */
+
+    WIFI_SUBCMD_GET_FEATURE_SET,                         /* 0x100A */
+    WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,                  /* 0x100B */
+    WIFI_SUBCMD_SET_PNO_RANDOM_MAC_OUI,                  /* 0x100C */
+    WIFI_SUBCMD_NODFS_SET,                               /* 0x100D */
+    WIFI_SUBCMD_SET_COUNTRY_CODE,                             /* 0x100E */
+    /* Add more sub commands here */
+    GSCAN_SUBCMD_SET_EPNO_SSID,                          /* 0x100F */
+
+    WIFI_SUBCMD_SET_SSID_WHITE_LIST,                    /* 0x1010 */
+    WIFI_SUBCMD_SET_ROAM_PARAMS,                        /* 0x1011 */
+    WIFI_SUBCMD_ENABLE_LAZY_ROAM,                       /* 0x1012 */
+    WIFI_SUBCMD_SET_BSSID_PREF,                         /* 0x1013 */
+    WIFI_SUBCMD_SET_BSSID_BLACKLIST,                     /* 0x1014 */
+
+    GSCAN_SUBCMD_ANQPO_CONFIG,                          /* 0x1015 */
+    WIFI_SUBCMD_SET_RSSI_MONITOR,                       /* 0x1016 */
+    WIFI_SUBCMD_CONFIG_ND_OFFLOAD,                      /* 0x1017 */
+    /* Add more sub commands here */
+
+    GSCAN_SUBCMD_MAX,
+
 	RTT_SUBCMD_SET_CONFIG = ANDROID_NL80211_SUBCMD_RTT_RANGE_START,
 	RTT_SUBCMD_CANCEL_CONFIG,
 	RTT_SUBCMD_GETCAPABILITY,
-	/* Add more sub commands here */
-	VENDOR_SUBCMD_MAX
+
+    APF_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_START,
+    APF_SUBCMD_SET_FILTER,
 };
 
 enum gscan_attributes {
@@ -184,15 +216,20 @@ enum rtt_attributes {
 };
 
 typedef enum wl_vendor_event {
-	BRCM_VENDOR_EVENT_UNSPEC,
-	BRCM_VENDOR_EVENT_PRIV_STR,
-	GOOGLE_GSCAN_SIGNIFICANT_EVENT,
-	GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT,
-	GOOGLE_GSCAN_BATCH_SCAN_EVENT,
-	GOOGLE_SCAN_FULL_RESULTS_EVENT,
-	GOOGLE_RTT_COMPLETE_EVENT,
-	GOOGLE_SCAN_COMPLETE_EVENT,
-	GOOGLE_GSCAN_GEOFENCE_LOST_EVENT
+    RTK_RESERVED1,
+    RTK_RESERVED2,
+    GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS ,
+    GSCAN_EVENT_HOTLIST_RESULTS_FOUND,
+    GSCAN_EVENT_SCAN_RESULTS_AVAILABLE,
+    GSCAN_EVENT_FULL_SCAN_RESULTS,
+    RTT_EVENT_COMPLETE,
+    GSCAN_EVENT_COMPLETE_SCAN,
+    GSCAN_EVENT_HOTLIST_RESULTS_LOST,
+    GSCAN_EVENT_EPNO_EVENT,
+    GOOGLE_DEBUG_RING_EVENT,
+    GOOGLE_DEBUG_MEM_DUMP_EVENT,
+    GSCAN_EVENT_ANQPO_HOTSPOT_MATCH,
+    GOOGLE_RSSI_MONITOR_EVENT
 } wl_vendor_event_t;
 
 enum andr_wifi_feature_set_attr {
@@ -227,6 +264,288 @@ typedef enum gscan_complete_event {
 	WIFI_SCAN_BUFFER_FULL,
 	WIFI_SCAN_COMPLETE
 } gscan_complete_event_t;
+/* wifi_hal.h */
+/* WiFi Common definitions */
+typedef unsigned char byte;
+typedef int wifi_request_id;
+typedef int wifi_channel;                       // indicates channel frequency in MHz
+typedef int wifi_rssi;
+typedef byte mac_addr[6];
+typedef byte oui[3];
+typedef int64_t wifi_timestamp;                 // In microseconds (us)
+typedef int64_t wifi_timespan;                  // In picoseconds  (ps)
+
+struct wifi_info;
+struct wifi_interface_info;
+typedef struct wifi_info *wifi_handle;
+typedef struct wifi_interface_info *wifi_interface_handle;
+
+/* channel operating width */
+typedef enum {
+    WIFI_CHAN_WIDTH_20    = 0,
+    WIFI_CHAN_WIDTH_40    = 1,
+    WIFI_CHAN_WIDTH_80    = 2,
+    WIFI_CHAN_WIDTH_160   = 3,
+    WIFI_CHAN_WIDTH_80P80 = 4,
+    WIFI_CHAN_WIDTH_5     = 5,
+    WIFI_CHAN_WIDTH_10    = 6,
+    WIFI_CHAN_WIDTH_INVALID = -1
+} wifi_channel_width;
+
+typedef int wifi_radio;
+typedef int wifi_channel;
+
+typedef struct {
+    wifi_channel_width width;
+    int center_frequency0;
+    int center_frequency1;
+    int primary_frequency;
+} wifi_channel_spec;
+
+typedef enum {
+    WIFI_SUCCESS = 0,
+    WIFI_ERROR_NONE = 0,
+    WIFI_ERROR_UNKNOWN = -1,
+    WIFI_ERROR_UNINITIALIZED = -2,
+    WIFI_ERROR_NOT_SUPPORTED = -3,
+    WIFI_ERROR_NOT_AVAILABLE = -4,              // Not available right now, but try later
+    WIFI_ERROR_INVALID_ARGS = -5,
+    WIFI_ERROR_INVALID_REQUEST_ID = -6,
+    WIFI_ERROR_TIMED_OUT = -7,
+    WIFI_ERROR_TOO_MANY_REQUESTS = -8,          // Too many instances of this request
+    WIFI_ERROR_OUT_OF_MEMORY = -9,
+    WIFI_ERROR_BUSY = -10,
+} wifi_error;
+
+#ifdef LINK_LAYER_STATS_SUPPORT
+#define STATS_MAJOR_VERSION      1
+#define STATS_MINOR_VERSION      0
+#define STATS_MICRO_VERSION      0
+
+typedef enum {
+    WIFI_DISCONNECTED = 0,
+    WIFI_AUTHENTICATING = 1,
+    WIFI_ASSOCIATING = 2,
+    WIFI_ASSOCIATED = 3,
+    WIFI_EAPOL_STARTED = 4,   // if done by firmware/driver
+    WIFI_EAPOL_COMPLETED = 5, // if done by firmware/driver
+} wifi_connection_state;
+
+typedef enum {
+    WIFI_ROAMING_IDLE = 0,
+    WIFI_ROAMING_ACTIVE = 1,
+} wifi_roam_state;
+
+typedef enum {
+    WIFI_INTERFACE_STA = 0,
+    WIFI_INTERFACE_SOFTAP = 1,
+    WIFI_INTERFACE_IBSS = 2,
+    WIFI_INTERFACE_P2P_CLIENT = 3,
+    WIFI_INTERFACE_P2P_GO = 4,
+    WIFI_INTERFACE_NAN = 5,
+    WIFI_INTERFACE_MESH = 6,
+    WIFI_INTERFACE_UNKNOWN = -1
+ } wifi_interface_mode;
+
+#define WIFI_CAPABILITY_QOS          0x00000001     // set for QOS association
+#define WIFI_CAPABILITY_PROTECTED    0x00000002     // set for protected association (802.11 beacon frame control protected bit set)
+#define WIFI_CAPABILITY_INTERWORKING 0x00000004     // set if 802.11 Extended Capabilities element interworking bit is set
+#define WIFI_CAPABILITY_HS20         0x00000008     // set for HS20 association
+#define WIFI_CAPABILITY_SSID_UTF8    0x00000010     // set is 802.11 Extended Capabilities element UTF-8 SSID bit is set
+#define WIFI_CAPABILITY_COUNTRY      0x00000020     // set is 802.11 Country Element is present
+
+typedef struct {
+   wifi_interface_mode mode;     // interface mode
+   u8 mac_addr[6];               // interface mac address (self)
+   wifi_connection_state state;  // connection state (valid for STA, CLI only)
+   wifi_roam_state roaming;      // roaming state
+   u32 capabilities;             // WIFI_CAPABILITY_XXX (self)
+   u8 ssid[33];                  // null terminated SSID
+   u8 bssid[6];                  // bssid
+   u8 ap_country_str[3];         // country string advertised by AP
+   u8 country_str[3];            // country string for this association
+} wifi_interface_link_layer_info;
+
+/* channel information */
+typedef struct {
+   wifi_channel_width width;   // channel width (20, 40, 80, 80+80, 160)
+   wifi_channel center_freq;   // primary 20 MHz channel
+   wifi_channel center_freq0;  // center frequency (MHz) first segment
+   wifi_channel center_freq1;  // center frequency (MHz) second segment
+} wifi_channel_info;
+
+/* wifi rate */
+typedef struct {
+   u32 preamble   :3;   // 0: OFDM, 1:CCK, 2:HT 3:VHT 4..7 reserved
+   u32 nss        :2;   // 0:1x1, 1:2x2, 3:3x3, 4:4x4
+   u32 bw         :3;   // 0:20MHz, 1:40Mhz, 2:80Mhz, 3:160Mhz
+   u32 rateMcsIdx :8;   // OFDM/CCK rate code would be as per ieee std in the units of 0.5mbps
+                        // HT/VHT it would be mcs index
+   u32 reserved  :16;   // reserved
+   u32 bitrate;         // units of 100 Kbps
+} wifi_rate;
+
+/* channel statistics */
+typedef struct {
+   wifi_channel_info channel;  // channel
+   u32 on_time;                // msecs the radio is awake (32 bits number accruing over time)
+   u32 cca_busy_time;          // msecs the CCA register is busy (32 bits number accruing over time)
+} wifi_channel_stat;
+
+// Max number of tx power levels. The actual number vary per device and is specified by |num_tx_levels|
+#define RADIO_STAT_MAX_TX_LEVELS 256
+
+/* radio statistics */
+typedef struct {
+   wifi_radio radio;                      // wifi radio (if multiple radio supported)
+   u32 on_time;                           // msecs the radio is awake (32 bits number accruing over time)
+   u32 tx_time;                           // msecs the radio is transmitting (32 bits number accruing over time)
+   u32 num_tx_levels;                     // number of radio transmit power levels
+   u32* tx_time_per_levels;               // pointer to an array of radio transmit per power levels in
+                                          // msecs accured over time
+   u32 rx_time;                           // msecs the radio is in active receive (32 bits number accruing over time)
+   u32 on_time_scan;                      // msecs the radio is awake due to all scan (32 bits number accruing over time)
+   u32 on_time_nbd;                       // msecs the radio is awake due to NAN (32 bits number accruing over time)
+   u32 on_time_gscan;                     // msecs the radio is awake due to G?scan (32 bits number accruing over time)
+   u32 on_time_roam_scan;                 // msecs the radio is awake due to roam?scan (32 bits number accruing over time)
+   u32 on_time_pno_scan;                  // msecs the radio is awake due to PNO scan (32 bits number accruing over time)
+   u32 on_time_hs20;                      // msecs the radio is awake due to HS2.0 scans and GAS exchange (32 bits number accruing over time)
+   u32 num_channels;                      // number of channels
+   wifi_channel_stat channels[];          // channel statistics
+} wifi_radio_stat;
+
+/**
+ * Packet statistics reporting by firmware is performed on MPDU basi (i.e. counters increase by 1 for each MPDU)
+ * As well, "data packet" in associated comments, shall be interpreted as 802.11 data packet,
+ * that is, 802.11 frame control subtype == 2 and excluding management and control frames.
+ *
+ * As an example, in the case of transmission of an MSDU fragmented in 16 MPDUs which are transmitted
+ * OTA in a 16 units long a-mpdu, for which a block ack is received with 5 bits set:
+ *          tx_mpdu : shall increase by 5
+ *          retries : shall increase by 16
+ *          tx_ampdu : shall increase by 1
+ * data packet counters shall not increase regardless of the number of BAR potentially sent by device for this a-mpdu
+ * data packet counters shall not increase regardless of the number of BA received by device for this a-mpdu
+ *
+ * For each subsequent retransmission of the 11 remaining non ACK'ed mpdus
+ * (regardless of the fact that they are transmitted in a-mpdu or not)
+ *          retries : shall increase by 1
+ *
+ * If no subsequent BA or ACK are received from AP, until packet lifetime expires for those 11 packet that were not ACK'ed
+ *          mpdu_lost : shall increase by 11
+ */
+
+/* per rate statistics */
+typedef struct {
+   wifi_rate rate;     // rate information
+   u32 tx_mpdu;        // number of successfully transmitted data pkts (ACK rcvd)
+   u32 rx_mpdu;        // number of received data pkts
+   u32 mpdu_lost;      // number of data packet losses (no ACK)
+   u32 retries;        // total number of data pkt retries
+   u32 retries_short;  // number of short data pkt retries
+   u32 retries_long;   // number of long data pkt retries
+} wifi_rate_stat;
+
+/* access categories */
+typedef enum {
+   WIFI_AC_VO  = 0,
+   WIFI_AC_VI  = 1,
+   WIFI_AC_BE  = 2,
+   WIFI_AC_BK  = 3,
+   WIFI_AC_MAX = 4,
+} wifi_traffic_ac;
+
+/* wifi peer type */
+typedef enum
+{
+   WIFI_PEER_STA,
+   WIFI_PEER_AP,
+   WIFI_PEER_P2P_GO,
+   WIFI_PEER_P2P_CLIENT,
+   WIFI_PEER_NAN,
+   WIFI_PEER_TDLS,
+   WIFI_PEER_INVALID,
+} wifi_peer_type;
+
+/* per peer statistics */
+typedef struct {
+   wifi_peer_type type;           // peer type (AP, TDLS, GO etc.)
+   u8 peer_mac_address[6];        // mac address
+   u32 capabilities;              // peer WIFI_CAPABILITY_XXX
+   u32 num_rate;                  // number of rates
+   wifi_rate_stat rate_stats[];   // per rate statistics, number of entries  = num_rate
+} wifi_peer_info;
+
+/* Per access category statistics */
+typedef struct {
+   wifi_traffic_ac ac;             // access category (VI, VO, BE, BK)
+   u32 tx_mpdu;                    // number of successfully transmitted unicast data pkts (ACK rcvd)
+   u32 rx_mpdu;                    // number of received unicast data packets
+   u32 tx_mcast;                   // number of succesfully transmitted multicast data packets
+                                   // STA case: implies ACK received from AP for the unicast packet in which mcast pkt was sent
+   u32 rx_mcast;                   // number of received multicast data packets
+   u32 rx_ampdu;                   // number of received unicast a-mpdus; support of this counter is optional
+   u32 tx_ampdu;                   // number of transmitted unicast a-mpdus; support of this counter is optional
+   u32 mpdu_lost;                  // number of data pkt losses (no ACK)
+   u32 retries;                    // total number of data pkt retries
+   u32 retries_short;              // number of short data pkt retries
+   u32 retries_long;               // number of long data pkt retries
+   u32 contention_time_min;        // data pkt min contention time (usecs)
+   u32 contention_time_max;        // data pkt max contention time (usecs)
+   u32 contention_time_avg;        // data pkt avg contention time (usecs)
+   u32 contention_num_samples;     // num of data pkts used for contention statistics
+} wifi_wmm_ac_stat;
+
+/* interface statistics */
+typedef struct {
+   wifi_interface_handle iface;          // wifi interface
+   wifi_interface_link_layer_info info;  // current state of the interface
+   u32 beacon_rx;                        // access point beacon received count from connected AP
+   u64 average_tsf_offset;               // average beacon offset encountered (beacon_TSF - TBTT)
+                                         // The average_tsf_offset field is used so as to calculate the
+                                         // typical beacon contention time on the channel as well may be
+                                         // used to debug beacon synchronization and related power consumption issue
+   u32 leaky_ap_detected;                // indicate that this AP typically leaks packets beyond the driver guard time.
+   u32 leaky_ap_avg_num_frames_leaked;  // average number of frame leaked by AP after frame with PM bit set was ACK'ed by AP
+   u32 leaky_ap_guard_time;              // guard time currently in force (when implementing IEEE power management based on
+                                         // frame control PM bit), How long driver waits before shutting down the radio and
+                                         // after receiving an ACK for a data frame with PM bit set)
+   u32 mgmt_rx;                          // access point mgmt frames received count from connected AP (including Beacon)
+   u32 mgmt_action_rx;                   // action frames received count
+   u32 mgmt_action_tx;                   // action frames transmit count
+   wifi_rssi rssi_mgmt;                  // access Point Beacon and Management frames RSSI (averaged)
+   wifi_rssi rssi_data;                  // access Point Data Frames RSSI (averaged) from connected AP
+   wifi_rssi rssi_ack;                   // access Point ACK RSSI (averaged) from connected AP
+   wifi_wmm_ac_stat ac[WIFI_AC_MAX];     // per ac data packet statistics
+   u32 num_peers;                        // number of peers
+   wifi_peer_info peer_info[];           // per peer statistics
+} wifi_iface_stat;
+
+/* configuration params */
+typedef struct {
+   u32 mpdu_size_threshold;             // threshold to classify the pkts as short or long
+                                        // packet size < mpdu_size_threshold => short
+   u32 aggressive_statistics_gathering; // set for field debug mode. Driver should collect all statistics regardless of performance impact.
+} wifi_link_layer_params;
+
+/* callback for reporting link layer stats */
+typedef struct {
+  void (*on_link_stats_results) (wifi_request_id id, wifi_iface_stat *iface_stat,
+         int num_radios, wifi_radio_stat *radio_stat);
+} wifi_stats_result_handler;
+
+
+/* wifi statistics bitmap  */
+#define WIFI_STATS_RADIO              0x00000001      // all radio statistics
+#define WIFI_STATS_RADIO_CCA          0x00000002      // cca_busy_time (within radio statistics)
+#define WIFI_STATS_RADIO_CHANNELS     0x00000004      // all channel statistics (within radio statistics)
+#define WIFI_STATS_RADIO_SCAN         0x00000008      // all scan statistics (within radio statistics)
+#define WIFI_STATS_IFACE              0x00000010      // all interface statistics
+#define WIFI_STATS_IFACE_TXRATE       0x00000020      // all tx rate statistics (within interface statistics)
+#define WIFI_STATS_IFACE_AC           0x00000040      // all ac statistics (within interface statistics)
+#define WIFI_STATS_IFACE_CONTENTION   0x00000080      // all contention (min, max, avg) statistics (within ac statisctics)
+
+#endif /* LINK_LAYER_STATS_SUPPORT */
 
 /* Capture the BRCM_VENDOR_SUBCMD_PRIV_STRINGS* here */
 #define BRCM_VENDOR_SCMD_CAPA	"cap"
-- 
2.35.3

