From 51c95fc6288a1f2f631746a5c2d1ac6eb5899539 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Mon, 5 Nov 2018 09:49:50 +0800
Subject: [PATCH] drivers/mfd: remove unused wm831x driver

Change-Id: I18fb4e6b2259cc3ebcb2e0a51355f67b14410045
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/input/keyboard/wm831x_gpio_keys.c | 468 -------------
 drivers/mfd/wm831x-spi-a22.c              | 810 ----------------------
 drivers/power/wm831x_charger_display.c    | 503 --------------
 3 files changed, 1781 deletions(-)
 delete mode 100755 drivers/input/keyboard/wm831x_gpio_keys.c
 delete mode 100755 drivers/mfd/wm831x-spi-a22.c
 delete mode 100755 drivers/power/wm831x_charger_display.c

diff --git a/drivers/input/keyboard/wm831x_gpio_keys.c b/drivers/input/keyboard/wm831x_gpio_keys.c
deleted file mode 100755
index db0f44811ce7..000000000000
--- a/drivers/input/keyboard/wm831x_gpio_keys.c
+++ /dev/null
@@ -1,468 +0,0 @@
-/*
- * Driver for keys on GPIO lines capable of generating interrupts.
- *
- * Copyright 2005 Phil Blundell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/module.h>
-
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/sched.h>
-#include <linux/pm.h>
-#include <linux/sysctl.h>
-#include <linux/proc_fs.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/workqueue.h>
-
-#include <asm/gpio.h>
-
-#include <linux/mfd/wm831x/core.h>
-#include <linux/mfd/wm831x/pdata.h>
-
-#define CONFIG_WM831X_GPIO_KEY_DEBUG	  0
-
-#if (CONFIG_WM831X_GPIO_KEY_DEBUG)
-#define WM831X_GPIO_KEY_DG(format, ...)      printk(format, ## __VA_ARGS__)
-#else
-#define WM831X_GPIO_KEY_DG(format, ...)
-#endif
-bool isHSKeyMIC = false;
-int pre_state = 0;
-struct wm831x_gpio_keys_button *media_button;
-
-extern bool wm8994_set_status(void);
-extern int headset_status(void);
-
-struct wm831x_gpio_button_data {
-	struct wm831x_gpio_keys_button *button;
-	struct input_dev *input;
-	struct timer_list timer;
-	struct work_struct work;
-};
-
-struct wm831x_gpio_keys_drvdata {
-	struct input_dev *input;
-	struct wm831x_gpio_button_data data[0];
-};
-
-bool isHSKey_MIC(void)
-{	    
-	return isHSKeyMIC;
-}
-EXPORT_SYMBOL_GPL(isHSKey_MIC);
-
-void detect_HSMic(void)
-{
-	int state;
-	struct wm831x_gpio_keys_button *button = media_button;
-	WM831X_GPIO_KEY_DG("detect_HSMic\n");
-	if(!headset_status())
-	{
-		isHSKeyMIC = false;
-		return ;
-	}
-	else
-	{
-		mdelay(500);
-	}
-	
-	state = (gpio_get_value(button->gpio) ? 1 : 0) ^ button->active_low;
-
-	WM831X_GPIO_KEY_DG("detect_HSMic: code=%d,gpio=%d\n",button->gpio,button->code);
-	if(state){
-		WM831X_GPIO_KEY_DG("detect_HSMic:---headset without MIC and HSKey---\n");
-		isHSKeyMIC = false;
-	}else{
-		WM831X_GPIO_KEY_DG("detect_HSMic:---headset with MIC---\n");
-		isHSKeyMIC = true;
-	}
-
-	return;
-}
-EXPORT_SYMBOL_GPL(detect_HSMic);
-
-static int HSKeyDetect(int state)
-{
-	WM831X_GPIO_KEY_DG("HSKeyDetect\n");
-
-	if(headset_status()){
-		WM831X_GPIO_KEY_DG("headset_status()  == true !\n");
-		if(pre_state != state && !wm8994_set_status()){
-			WM831X_GPIO_KEY_DG("wm8994_set_status()  == true !\n");
-			pre_state = state;
-			
-			if(!isHSKeyMIC){
-				state = -1;
-			}
-		}
-		else{
-			WM831X_GPIO_KEY_DG("wm8994_set_status()  == false !\n");
-			state = -1;
-		}
-	}
-	else{
-		WM831X_GPIO_KEY_DG("headset_status()  == false !\n");
-		isHSKeyMIC = false;
-		state = -1;
-	}
-
-	return state;
-}
-
-static void wm831x_gpio_keys_report_event(struct work_struct *work)
-{
-	struct wm831x_gpio_button_data *bdata =
-		container_of(work, struct wm831x_gpio_button_data, work);
-	struct wm831x_gpio_keys_button *button = bdata->button;
-	struct input_dev *input = bdata->input;
-	unsigned int type = button->type ?: EV_KEY;
-	
-	int state = (gpio_get_value(button->gpio) ? 1 : 0) ^ button->active_low;
-	if(button->code == KEY_MEDIA)
-	{
-		state = HSKeyDetect(state);
-		
-		if(state == -1)
-		{
-			WM831X_GPIO_KEY_DG("wm831x_gpio_keys_report_event:HSKeyDetect=-1\n");
-			goto out;
-		}
-	}
-	printk("wm831x_gpio_keys_report_event:state=%d,code=%d \n",state,button->code);
-	
-	input_event(input, type, button->code, state);
-	input_sync(input);
-out:	
-	enable_irq(gpio_to_irq(button->gpio));
-	return;
-}
-
-static void wm831x_gpio_keys_timer(unsigned long _data)
-{
-	struct wm831x_gpio_button_data *data = (struct wm831x_gpio_button_data *)_data;
-
-	WM831X_GPIO_KEY_DG("wm831x_gpio_keys_timer\n");
-	schedule_work(&data->work);
-}
-
-static irqreturn_t wm831x_gpio_keys_isr(int irq, void *dev_id)
-{
-	struct wm831x_gpio_button_data *bdata = dev_id;
-	struct wm831x_gpio_keys_button *button = bdata->button;
-	
-	//printk("wm831x_gpio_keys_isr:irq=%d,%d \n",irq,button->debounce_interval);
-	
-	BUG_ON(irq != gpio_to_irq(button->gpio));
-	disable_irq_nosync(gpio_to_irq(button->gpio));
-	if (button->debounce_interval)
-		mod_timer(&bdata->timer,
-			jiffies + msecs_to_jiffies(button->debounce_interval));
-	else
-		schedule_work(&bdata->work);
-		
-	return IRQ_HANDLED;
-}
-
-static int __devinit wm831x_gpio_keys_probe(struct platform_device *pdev)
-{
-
-	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
-	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
-	struct wm831x_gpio_keys_pdata *gpio_keys;
-	struct wm831x_gpio_keys_drvdata *ddata;
-	struct input_dev *input;
-	int i, error;
-	//int wakeup = 0;
-
-	printk("wm831x_gpio_keys_probe\n");
-	
-	if (pdata == NULL || pdata->gpio_keys == NULL)
-		return -ENODEV;
-
-	gpio_keys = pdata->gpio_keys;
-	
-	ddata = kzalloc(sizeof(struct wm831x_gpio_keys_drvdata) +
-			gpio_keys->nbuttons * sizeof(struct wm831x_gpio_button_data),
-			GFP_KERNEL);
-	input = input_allocate_device();
-	if (!ddata || !input) {
-		error = -ENOMEM;
-		goto fail1;
-	}
-	
-	platform_set_drvdata(pdev, ddata);
-
-	input->name = pdev->name;
-	input->phys = "wm831x_gpio-keys/input0";
-	input->dev.parent = &pdev->dev;
-
-	input->id.bustype = BUS_I2C;
-	input->id.vendor = 0x0001;
-	input->id.product = 0x0001;
-	input->id.version = 0x0100;
-
-	/* Enable auto repeat feature of Linux input subsystem */
-	if (gpio_keys->rep)
-		__set_bit(EV_REP, input->evbit);
-
-	ddata->input = input;
-	
-	for (i = 0; i < gpio_keys->nbuttons; i++) {
-		struct wm831x_gpio_keys_button *button = &gpio_keys->buttons[i];
-		struct wm831x_gpio_button_data *bdata = &ddata->data[i];
-		int irq = 0;
-		unsigned int type = button->type ?: EV_KEY;
-
-		bdata->input = input;
-		bdata->button = button;
-		
-		if(button->code == KEY_MEDIA)
-		{
-			media_button = button;
-		}
-		if (button->debounce_interval)
-			setup_timer(&bdata->timer,
-			   	 	wm831x_gpio_keys_timer, (unsigned long)bdata);
-		//else
-		INIT_WORK(&bdata->work, wm831x_gpio_keys_report_event);
-
-		error = gpio_request(button->gpio, button->desc ?: "wm831x_gpio_keys");
-		if (error < 0) {
-			pr_err("wm831x_gpio-keys: failed to request GPIO %d,"
-				" error %d\n", button->gpio, error);
-			goto fail2;
-		}
-
-		if(button->gpio >= WM831X_P01 && button->gpio <= WM831X_P12)
-		{
-			error = gpio_pull_updown(button->gpio,GPIOPullUp);
-			if (error < 0) {
-				pr_err("wm831x_gpio-keys: failed to pull up"
-					" for GPIO %d, error %d\n",
-					button->gpio, error);
-				gpio_free(button->gpio);
-				goto fail2;
-			}
-		}
-		
-		error = gpio_direction_input(button->gpio);
-		if (error < 0) {
-			pr_err("wm831x_gpio-keys: failed to configure input"
-				" direction for GPIO %d, error %d\n",
-				button->gpio, error);
-			gpio_free(button->gpio);
-			goto fail2;
-		}
-
-		irq = gpio_to_irq(button->gpio);
-		if (irq < 0) {
-			error = irq;
-			pr_err("wm831x_gpio-keys: Unable to get irq number"
-				" for GPIO %d, error %d\n",
-				button->gpio, error);
-			gpio_free(button->gpio);
-			goto fail2;
-		}
-		printk("wm831x_gpio_keys_probe:i=%d,gpio=%d,irq=%d \n",i,button->gpio,irq);
-		enable_irq_wake(irq);	
-		if(button->gpio >= WM831X_P01 && button->gpio <= WM831X_P12)
-		{
-			error = request_threaded_irq(irq, NULL,wm831x_gpio_keys_isr,
-					    IRQF_SHARED |
-					    IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
-					    button->desc ? button->desc : "wm831x_gpio_keys",
-					    bdata);
-		}
-		else if(button->gpio >= TCA6424_P00 && button->gpio <= TCA6424_P27)
-		{
-			error = request_irq(irq, wm831x_gpio_keys_isr,
-				    IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
-				    button->desc ? button->desc : "tca6424_gpio_keys",
-				    bdata);
-		}
-		
-		if (error) {
-			pr_err("wm831x_gpio-keys: Unable to claim irq %d; error %d\n",
-				irq, error);
-			gpio_free(button->gpio);
-			goto fail2;
-		}
-
-		//if (button->wakeup)
-		//	wakeup = 1;
-
-		input_set_capability(input, type, button->code);
-	}
-
-	error = input_register_device(input);
-	if (error) {
-		pr_err("wm831x_gpio-keys: Unable to register input device, "
-			"error: %d\n", error);
-		goto fail2;
-	}
-
-	//device_init_wakeup(&pdev->dev, wakeup);
-
-	return 0;
-
- fail2:
-	while (--i >= 0) {
-		free_irq(gpio_to_irq(gpio_keys->buttons[i].gpio), &ddata->data[i]);
-		if (gpio_keys->buttons[i].debounce_interval)
-			del_timer_sync(&ddata->data[i].timer);
-		//else
-			cancel_work_sync(&ddata->data[i].work);
-		gpio_free(gpio_keys->buttons[i].gpio);
-	}
-
-	platform_set_drvdata(pdev, NULL);
- fail1:
-	input_free_device(input);
-	kfree(ddata);
-
-	return error;
-}
-
-static int __devexit wm831x_gpio_keys_remove(struct platform_device *pdev)
-{
-	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
-	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
-	struct wm831x_gpio_keys_pdata *gpio_keys;
-	struct wm831x_gpio_keys_drvdata *ddata = platform_get_drvdata(pdev);
-	struct input_dev *input = ddata->input;
-	int i;
-	
-	if (pdata == NULL || pdata->gpio_keys == NULL)
-		return -ENODEV;
-	
-	gpio_keys = pdata->gpio_keys;
-	
-	//device_init_wakeup(&pdev->dev, 0);
-
-	for (i = 0; i < gpio_keys->nbuttons; i++) {
-		int irq = gpio_to_irq(gpio_keys->buttons[i].gpio);
-		free_irq(irq, &ddata->data[i]);
-		if (gpio_keys->buttons[i].debounce_interval)
-			del_timer_sync(&ddata->data[i].timer);
-		//else
-			cancel_work_sync(&ddata->data[i].work);
-		gpio_free(gpio_keys->buttons[i].gpio);
-	}
-
-	input_unregister_device(input);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int wm831x_gpio_keys_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
-	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
-	struct wm831x_gpio_keys_pdata *gpio_keys;
-	int i,irq;
-
-	if (pdata == NULL || pdata->gpio_keys == NULL)
-	{
-		printk("wm831x_gpio_keys_suspend fail\n");
-		return -ENODEV;
-	}	
-
-	//printk("wm831x_gpio_keys_suspend\n");
-	
-	gpio_keys = pdata->gpio_keys;
-	
-	//if (device_may_wakeup(&pdev->dev)) {
-		for (i = 0; i < gpio_keys->nbuttons; i++) {
-			struct wm831x_gpio_keys_button *button = &gpio_keys->buttons[i];
-			if (button->wakeup) {
-				irq = gpio_to_irq(button->gpio);
-				enable_irq_wake(irq);			
-			}
-			else
-			{
-				irq = gpio_to_irq(button->gpio);
-				disable_irq_wake(irq);
-			}
-		}
-	//}
-
-	return 0;
-}
-
-static int wm831x_gpio_keys_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
-	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
-	struct wm831x_gpio_keys_pdata *gpio_keys;
-	int i,irq;
-
-	if (pdata == NULL || pdata->gpio_keys == NULL)
-	{
-		printk("wm831x_gpio_keys_resume fail\n");
-		return -ENODEV;
-	}
-	
-	//printk("wm831x_gpio_keys_resume\n");
-	
-	gpio_keys = pdata->gpio_keys;
-	
-	//if (device_may_wakeup(&pdev->dev)) {
-		for (i = 0; i < gpio_keys->nbuttons; i++) {
-			struct wm831x_gpio_keys_button *button = &gpio_keys->buttons[i];
-			//if (button->wakeup) {		
-				irq = gpio_to_irq(button->gpio);
-				enable_irq_wake(irq);
-			//}
-		}
-	//}
-
-	return 0;
-}
-
-static const struct dev_pm_ops wm831x_gpio_keys_pm_ops = {
-	.suspend	= wm831x_gpio_keys_suspend,
-	.resume		= wm831x_gpio_keys_resume,
-};		
-#endif
-
-static struct platform_driver wm831x_gpio_keys_device_driver = {
-	.probe		= wm831x_gpio_keys_probe,
-	.remove		= __devexit_p(wm831x_gpio_keys_remove),
-	.driver		= {
-		.name	= "wm831x_gpio-keys",
-		.owner	= THIS_MODULE,
-#ifdef CONFIG_PM
-		.pm	= &wm831x_gpio_keys_pm_ops,
-#endif
-	}
-};
-
-static int __init wm831x_gpio_keys_init(void)
-{
-	return platform_driver_register(&wm831x_gpio_keys_device_driver);
-}
-
-static void __exit wm831x_gpio_keys_exit(void)
-{
-	platform_driver_unregister(&wm831x_gpio_keys_device_driver);
-}
-
-subsys_initcall(wm831x_gpio_keys_init);
-module_exit(wm831x_gpio_keys_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("SRT <srt@rock-chip.com>");
-MODULE_DESCRIPTION("Keyboard driver for WM831x GPIOs");
-MODULE_ALIAS("platform:wm831x_gpio-keys");
diff --git a/drivers/mfd/wm831x-spi-a22.c b/drivers/mfd/wm831x-spi-a22.c
deleted file mode 100755
index 392faf002fff..000000000000
--- a/drivers/mfd/wm831x-spi-a22.c
+++ /dev/null
@@ -1,810 +0,0 @@
-/*
- * wm831x-spi.c  --  SPI access for Wolfson WM831x PMICs
- *
- * Copyright 2009,2010 Wolfson Microelectronics PLC.
- *
- * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/spi/spi.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-
-#include <linux/mfd/wm831x/core.h>
-#include <linux/mfd/wm831x/pdata.h>
-#include <linux/mfd/wm831x/irq.h>
-#include <linux/mfd/wm831x/auxadc.h>
-#include <linux/mfd/wm831x/otp.h>
-#include <linux/mfd/wm831x/regulator.h>
-#include <linux/mfd/wm831x/pmu.h>
-
-
-
-/* DC-DC*/
-#define WM831X_BUCKV_MAX_SELECTOR 0x68
-#define WM831X_BUCKP_MAX_SELECTOR 0x66
-
-#define WM831X_DCDC_MODE_FAST    0
-#define WM831X_DCDC_MODE_NORMAL  1
-#define WM831X_DCDC_MODE_IDLE    2
-#define WM831X_DCDC_MODE_STANDBY 3
-
-//#define WM831X_DCDC_MAX_NAME 6
-
-/* Register offsets in control block */
-#define WM831X_DCDC_CONTROL_1     0
-#define WM831X_DCDC_CONTROL_2     1
-#define WM831X_DCDC_ON_CONFIG     2
-#define WM831X_DCDC_SLEEP_CONTROL 3
-#define WM831X_DCDC_DVS_CONTROL   4
-
-/* LDO*/
-#define WM831X_LDO_CONTROL       0
-#define WM831X_LDO_ON_CONTROL    1
-#define WM831X_LDO_SLEEP_CONTROL 2
-
-#define WM831X_ALIVE_LDO_ON_CONTROL    0
-#define WM831X_ALIVE_LDO_SLEEP_CONTROL 1
-
-static int wm831x_spi_read_device(struct wm831x *wm831x, unsigned short reg,
-				  int bytes, void *dest)
-{
-	u16 tx_val;
-	u16 *d = dest;
-	int r, ret;
-
-	/* Go register at a time */
-	for (r = reg; r < reg + (bytes / 2); r++) {
-		tx_val = cpu_to_be16(r | 0x8000);
-
-		ret = spi_write_then_read(wm831x->control_data,
-					  (u8 *)&tx_val, 2, (u8 *)d, 2);
-		if (ret != 0)
-			return ret;
-
-		//*d = be16_to_cpu(*d);
-
-		d++;
-	}
-
-	return 0;
-}
-
-static int wm831x_spi_write_device(struct wm831x *wm831x, unsigned short reg,
-				   int bytes, void *src)
-{
-	struct spi_device *spi = wm831x->control_data;
-	u16 *s = src;
-	u16 data[2];
-	int ret, r;
-
-	/* Go register at a time */
-	for (r = reg; r < reg + (bytes / 2); r++) {
-		data[0] = cpu_to_be16(r);
-		data[1] = *s++;
-		//printk("%s:reg=0x%x,data=0x%x\n",__FUNCTION__,be16_to_cpu(data[0]),be16_to_cpu(data[1]));
-		ret = spi_write(spi, (char *)&data, sizeof(data));
-		if (ret != 0)
-			return ret;
-	}
-
-	return 0;
-}
-
-
-int wm831x_isinkv_values[WM831X_ISINK_MAX_ISEL + 1] = {
-	2,
-	2,
-	3,
-	3,
-	4,
-	5,
-	6,
-	7,
-	8,
-	10,
-	11,
-	13,
-	16,
-	19,
-	23,
-	27,
-	32,
-	38,
-	45,
-	54,
-	64,
-	76,
-	91,
-	108,
-	128,
-	152,
-	181,
-	215,
-	256,
-	304,
-	362,
-	431,
-	512,
-	609,
-	724,
-	861,
-	1024,
-	1218,
-	1448,
-	1722,
-	2048,
-	2435,
-	2896,
-	3444,
-	4096,
-	4871,
-	5793,
-	6889,
-	8192,
-	9742,
-	11585,
-	13777,
-	16384,
-	19484,
-	23170,
-	27554,
-};
-EXPORT_SYMBOL_GPL(wm831x_isinkv_values);
-
-static int wm831x_reg_locked(struct wm831x *wm831x, unsigned short reg)
-{
-	if (!wm831x->locked)
-		return 0;
-
-	switch (reg) {
-	case WM831X_WATCHDOG:
-	case WM831X_DC4_CONTROL:
-	case WM831X_ON_PIN_CONTROL:
-	case WM831X_BACKUP_CHARGER_CONTROL:
-	case WM831X_CHARGER_CONTROL_1:
-	case WM831X_CHARGER_CONTROL_2:
-		return 1;
-
-	default:
-		return 0;
-	}
-}
-
-/**
- * wm831x_reg_unlock: Unlock user keyed registers
- *
- * The WM831x has a user key preventing writes to particularly
- * critical registers.  This function locks those registers,
- * allowing writes to them.
- */
-void wm831x_reg_lock(struct wm831x *wm831x)
-{
-	int ret;
-
-	ret = wm831x_reg_write(wm831x, WM831X_SECURITY_KEY, 0);
-	if (ret == 0) {
-		dev_vdbg(wm831x->dev, "Registers locked\n");
-
-		mutex_lock(&wm831x->io_lock);
-		WARN_ON(wm831x->locked);
-		wm831x->locked = 1;
-		mutex_unlock(&wm831x->io_lock);
-	} else {
-		dev_err(wm831x->dev, "Failed to lock registers: %d\n", ret);
-	}
-
-}
-EXPORT_SYMBOL_GPL(wm831x_reg_lock);
-
-/**
- * wm831x_reg_unlock: Unlock user keyed registers
- *
- * The WM831x has a user key preventing writes to particularly
- * critical registers.  This function locks those registers,
- * preventing spurious writes.
- */
-int wm831x_reg_unlock(struct wm831x *wm831x)
-{
-	int ret;
-
-	/* 0x9716 is the value required to unlock the registers */
-	ret = wm831x_reg_write(wm831x, WM831X_SECURITY_KEY, 0x9716);
-	if (ret == 0) {
-		dev_vdbg(wm831x->dev, "Registers unlocked\n");
-
-		mutex_lock(&wm831x->io_lock);
-		WARN_ON(!wm831x->locked);
-		wm831x->locked = 0;
-		mutex_unlock(&wm831x->io_lock);
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(wm831x_reg_unlock);
-
-static int wm831x_read(struct wm831x *wm831x, unsigned short reg,
-		       int bytes, void *dest)
-{
-	int ret, i;
-	u16 *buf = dest;
-
-	BUG_ON(bytes % 2);
-	BUG_ON(bytes <= 0);
-
-	ret = wm831x->read_dev(wm831x, reg, bytes, dest);
-	if (ret < 0)
-		return ret;
-
-	for (i = 0; i < bytes / 2; i++) {
-		buf[i] = be16_to_cpu(buf[i]);
-
-		dev_vdbg(wm831x->dev, "Read %04x from R%d(0x%x)\n",
-			 buf[i], reg + i, reg + i);
-	}
-
-	return 0;
-}
-
-/**
- * wm831x_reg_read: Read a single WM831x register.
- *
- * @wm831x: Device to read from.
- * @reg: Register to read.
- */
-int wm831x_reg_read(struct wm831x *wm831x, unsigned short reg)
-{
-	unsigned short val;
-	int ret;
-
-	mutex_lock(&wm831x->io_lock);
-
-	ret = wm831x_read(wm831x, reg, 2, &val);
-
-	mutex_unlock(&wm831x->io_lock);
-
-	if (ret < 0)
-		return ret;
-	else
-		return val;
-}
-EXPORT_SYMBOL_GPL(wm831x_reg_read);
-
-/**
- * wm831x_bulk_read: Read multiple WM831x registers
- *
- * @wm831x: Device to read from
- * @reg: First register
- * @count: Number of registers
- * @buf: Buffer to fill.
- */
-int wm831x_bulk_read(struct wm831x *wm831x, unsigned short reg,
-		     int count, u16 *buf)
-{
-	int ret;
-
-	mutex_lock(&wm831x->io_lock);
-
-	ret = wm831x_read(wm831x, reg, count * 2, buf);
-
-	mutex_unlock(&wm831x->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(wm831x_bulk_read);
-
-static int wm831x_write(struct wm831x *wm831x, unsigned short reg,
-			int bytes, void *src)
-{
-	u16 *buf = src;
-	int i;
-
-	BUG_ON(bytes % 2);
-	BUG_ON(bytes <= 0);
-
-	for (i = 0; i < bytes / 2; i++) {
-		if (wm831x_reg_locked(wm831x, reg))
-			return -EPERM;
-
-		dev_vdbg(wm831x->dev, "Write %04x to R%d(0x%x)\n",
-			 buf[i], reg + i, reg + i);
-
-		buf[i] = cpu_to_be16(buf[i]);
-	}
-
-	return wm831x->write_dev(wm831x, reg, bytes, src);
-}
-
-/**
- * wm831x_reg_write: Write a single WM831x register.
- *
- * @wm831x: Device to write to.
- * @reg: Register to write to.
- * @val: Value to write.
- */
-int wm831x_reg_write(struct wm831x *wm831x, unsigned short reg,
-		     unsigned short val)
-{
-	int ret;
-
-	mutex_lock(&wm831x->io_lock);
-
-	ret = wm831x_write(wm831x, reg, 2, &val);
-
-	mutex_unlock(&wm831x->io_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(wm831x_reg_write);
-
-
-static int wm831x_init(struct wm831x *wm831x)
-{
-
-/*wm831x_pre_init*/
-	wm831x_reg_write(wm831x, WM831X_POWER_STATE, 0x8804);	//900ma
-	
-/*wm831x_irq_init:irq=252,180 mask irq*/
-	wm831x_reg_write(wm831x, 0x4019, 0xffff);	
-	wm831x_reg_write(wm831x, 0x401a, 0xffff);	
-	wm831x_reg_write(wm831x, 0x401b, 0xffff);	
-	wm831x_reg_write(wm831x, 0x401c, 0xffff);	
-	wm831x_reg_write(wm831x, 0x401d, 0xffff);	
-	wm831x_reg_write(wm831x, 0x4018, 0xffff);//wm831x_reg_write(wm831x, 0x4018, 0x0);	
-	wm831x_reg_write(wm831x, 0x4019, 0xffff);	
-
-/*regulator: DCDC1: 600 <--> 1800 mV */
-	//wm831x_reg_write(wm831x, 0x401c, 0xfffe);
-	//wm831x_reg_write(wm831x, 0x401c, 0xfefe);
-
-/*regulator: DCDC2: 600 <--> 1800 mV*/ 
-	//wm831x_reg_write(wm831x, 0x401c, 0xfefc);
-	//wm831x_reg_write(wm831x, 0x401c, 0xfcfc);
-
-/* regulator: DCDC3: 850 <--> 3400 mV */
-	//wm831x_reg_write(wm831x, 0x401c, 0xfcf8);
-
-/*regulator: DCDC4: 0 <--> 30000 mV */
-	//wm831x_reg_write(wm831x, 0x401c, 0xfcf0);
-
-/*wm831x_isink_enable*/
-	wm831x_reg_write(wm831x, 0x404e, 0x8500);
-	wm831x_reg_write(wm831x, 0x404e, 0xc500);
-
-/*wm831x_isink_probe:line=203,irq=220*/
-	//wm831x_reg_write(wm831x, 0x401a, 0xffbf);
-	//wm831x_reg_write(wm831x, 0x401a, 0xff3f);
-
-
-/*regulator: LDO1: 900 <--> 3300 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xfffe);
-
-/*regulator: LDO2: 900 <--> 3300 mV*/ 
-	//wm831x_reg_write(wm831x, 0x401b, 0xfffc);
-
-/*regulator: LDO3: 900 <--> 3300 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xfff8);
-
-/*regulator: LDO4: 900 <--> 3300 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xfff0);
-
-/* regulator: LDO5: 900 <--> 3300 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xffe0);
-
-/*regulator: LDO6: 900 <--> 3300 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xffc0);
-
-/*regulator: LDO7: 1000 <--> 3500 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xff80);
-
-/*regulator: LDO8: 1000 <--> 3500 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xff00);
-
-/*regulator: LDO9: 1000 <--> 3500 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xfe00);
-
-/*regulator: LDO10: 1000 <--> 3500 mV */
-	//wm831x_reg_write(wm831x, 0x401b, 0xfc00);
-
-/*regulator: LDO11: 1200 <--> 1550 mV */
-	wm831x_reg_write(wm831x, 0x4008, 0x9716);
-	wm831x_reg_write(wm831x, 0x4006, 0x8463);
-
-/*wm831x_post_init set dcdc3=3000000mV end*/
-	wm831x_reg_write(wm831x, 0x4051, 0xfa49);
-	wm831x_reg_write(wm831x, 0x4062, 0x2156);
-	
-
-/*wm831x_post_init set ldo10=3000000mV end*/
-	wm831x_reg_write(wm831x, 0x4084, 0x201a);
-
-/*wm831x_post_init set dcdc2=1300000mV end8*/
-	wm831x_reg_write(wm831x, 0x405d, 0x4140);
-
-/* wm831x_post_init set dcdc1=1800000mV end*/
-	wm831x_reg_write(wm831x, 0x4058, 0x6168);
-
-/*wm831x_post_init set ldo1=1800000mV end*/
-	wm831x_reg_write(wm831x, 0x4069, 0x6010);
-
-/*wm831x_post_init set ldo4=2500000mV end*/
-	wm831x_reg_write(wm831x, 0x4072, 0x8017);
-
-/*wm831x_post_init set ldo7=3300000mV end*/
-	wm831x_reg_write(wm831x, 0x407b, 0xa01d);
-
-/*wm831x_post_init set dcdc4=-22mV end*/
-	wm831x_reg_write(wm831x, 0x4050, 0xf);
-
-/*wm831x_post_init set ldo2=3000000mV end*/
-	wm831x_reg_write(wm831x, 0x406c, 0x1c);
-	wm831x_reg_write(wm831x, 0x4051, 0x24b);
-
-/*wm831x_post_init set ldo3=1800000mV end*/
-	wm831x_reg_write(wm831x, 0x406f, 0x10);
-	wm831x_reg_write(wm831x, 0x4051, 0x24f);
-
-/*wm831x_post_init set ldo5=3000000mV end*/
-	wm831x_reg_write(wm831x, 0x4075, 0x1c);
-	wm831x_reg_write(wm831x, 0x4051, 0x25f);
-
-/*wm831x_post_init set ldo6=2800000mV end*/
-	wm831x_reg_write(wm831x, 0x4078, 0x1a);
-	wm831x_reg_write(wm831x, 0x4051, 0x27f);
-
-/*wm831x_post_init set ldo8=1200000mV end*/
-	wm831x_reg_write(wm831x, 0x407e, 0x4);
-	wm831x_reg_write(wm831x, 0x4051, 0x2ff);
-
-/*wm831x_post_init set ldo9=3000000mV end*/
-	wm831x_reg_write(wm831x, 0x4081, 0x1a);
-	wm831x_reg_write(wm831x, 0x4051, 0x3ff);
-
-	wm831x_reg_write(wm831x, 0x4008, 0x0);
-
-	wm831x_reg_write(wm831x, 0x4008, 0x9716);
-	wm831x_reg_write(wm831x, 0x4064, 0x104);
-	wm831x_reg_write(wm831x, 0x4008, 0x0);
-	wm831x_reg_write(wm831x, 0x4050, 0x7);
-
-/* backlight brightness=255*/
-	wm831x_reg_write(wm831x, 0x404e, 0xc500);
-	wm831x_reg_write(wm831x, 0x4050, 0xf);
-	wm831x_reg_write(wm831x, 0x404e, 0xc535);
-	wm831x_reg_write(wm831x, 0x404e, 0xc535);
-
-
-/*wm831x-rtc wm831x-rtc: rtc core: registered wm831x as rtc0*/
-	//wm831x_reg_write(wm831x, 0x4019, 0xeef7);
-	//wm831x_reg_write(wm831x, 0x4019, 0xeef3);
-	
-/*wm831x_power_probe:wm831x_power initialized*/
-	wm831x_reg_write(wm831x, 0x4008, 0x9716);
-	wm831x_reg_write(wm831x, 0x404b, 0x8812);
-
-	wm831x_reg_write(wm831x, 0x4008, 0x0);
-	wm831x_reg_write(wm831x, 0x4008, 0x9716);
-	wm831x_reg_write(wm831x, 0x4048, 0x9c21);
-
-	wm831x_reg_write(wm831x, 0x4048, 0x9c21);
-
-	wm831x_reg_write(wm831x, 0x4049, 0x44ff);
-	wm831x_reg_write(wm831x, 0x4001, 0x57);
-	wm831x_reg_write(wm831x, 0x4008, 0x0);	
-	//wm831x_reg_write(wm831x, 0x4019, 0x6ef3);
-	//wm831x_reg_write(wm831x, 0x4019, 0x2ef3);	
-	
-/*device-mapper: uevent: version 1.0.3*/
-	wm831x_reg_write(wm831x, 0x402e, 0x8000);
-	wm831x_reg_write(wm831x, 0x4014, 0x8);
-	wm831x_reg_write(wm831x, 0x402f, 0x400);
-	wm831x_reg_write(wm831x, 0x402e, 0xc000);
-
-/*gpu: power on... done!*/
-	wm831x_reg_write(wm831x, 0x402e, 0x0);
-	wm831x_reg_write(wm831x, 0x4011, 0x2100);
-	wm831x_reg_write(wm831x, 0x402e, 0x8000);
-	wm831x_reg_write(wm831x, 0x402f, 0x200);
-	wm831x_reg_write(wm831x, 0x402e, 0xc000);
-
-
-/*wm831x_isink_is_enabled:line=85*/
-/*wm831x-rtc wm831x-rtc: setting system clock to 1970-01-02 04:18:35 UTC (101915)*/
-	wm831x_reg_write(wm831x, 0x402e, 0x0);
-	wm831x_reg_write(wm831x, 0x4011, 0x100);
-
-	wm831x_reg_write(wm831x, 0x402e, 0x8000);
-	wm831x_reg_write(wm831x, 0x402f, 0x100);
-	wm831x_reg_write(wm831x, 0x402e, 0xc000);
-	wm831x_reg_write(wm831x, 0x4011, 0x100);
-	wm831x_reg_write(wm831x, 0x402e, 0x0);
-
-	printk("%s\n",__FUNCTION__);
-	
-}
-
-extern void rk29_send_power_key(int state);
-static int gNumInt = 0, gNumTimer = 0;
-static struct timer_list 	irq_timer;
-static struct wm831x *gwm831x;
-
-void wm831x_power_off(void)
-{
-	wm831x_reg_write(gwm831x, WM831X_POWER_STATE, 0);//power off
-}
-
-static void wm831x_irq_timer(unsigned long data)
-{
-	struct wm831x *wm831x = (struct wm831x *)data;
-	int pin = irq_to_gpio(wm831x->irq);
-
-	if(gNumInt >0)
-	{
-		if(gpio_get_value(pin) > 0)	
-		gNumTimer++;
-		else
-		gNumTimer = 0;
-
-		if(gNumTimer >20)
-		{
-			rk29_send_power_key(0);
-			gNumTimer = 0;
-			gNumInt = 0;
-		}
-	}
-		
-	irq_timer.expires  = jiffies + msecs_to_jiffies(20);
-	add_timer(&irq_timer);
-
-}
-
-static void wm831x_irq_worker(struct work_struct *work)
-{
-	struct wm831x *wm831x = container_of(work, struct wm831x, irq_work);	
-	wm831x_reg_write(wm831x, WM831X_INTERRUPT_STATUS_1, 0xffff);//clear all intterupt
-	gNumInt++;
-	rk29_send_power_key(1);
-	enable_irq(wm831x->irq);	
-	wake_unlock(&wm831x->irq_wake);
-	//printk("%s,irq=%d\n",__FUNCTION__,wm831x->irq);
-}
-
-static irqreturn_t wm831x_irq_thread(int irq, void *data)
-{
-	struct wm831x *wm831x = data;
-
-	disable_irq_nosync(irq);
-	wake_lock(&wm831x->irq_wake);
-	queue_work(wm831x->irq_wq, &wm831x->irq_work);
-
-	return IRQ_HANDLED;
-}
-
-static int __devinit wm831x_spi_probe(struct spi_device *spi)
-{
-	struct wm831x *wm831x;
-	enum wm831x_parent type;
-	int ret,gpio,irq;
-	
-	/* Currently SPI support for ID tables is unmerged, we're faking it */
-	if (strcmp(spi->modalias, "wm8310") == 0)
-		type = WM8310;
-	else if (strcmp(spi->modalias, "wm8311") == 0)
-		type = WM8311;
-	else if (strcmp(spi->modalias, "wm8312") == 0)
-		type = WM8312;
-	else if (strcmp(spi->modalias, "wm8320") == 0)
-		type = WM8320;
-	else if (strcmp(spi->modalias, "wm8321") == 0)
-		type = WM8321;
-	else if (strcmp(spi->modalias, "wm8325") == 0)
-		type = WM8325;
-	else {
-		dev_err(&spi->dev, "Unknown device type\n");
-		return -EINVAL;
-	}
-
-	wm831x = kzalloc(sizeof(struct wm831x), GFP_KERNEL);
-	if (wm831x == NULL)
-		return -ENOMEM;
-
-	spi->bits_per_word = 16;
-	spi->mode = SPI_MODE_0;
-
-	gpio = spi->irq;
-	ret = gpio_request(gpio, "wm831x");
-	if (ret) {
-		printk( "failed to request rk gpio irq for wm831x \n");
-		return ret;
-	}
-	gpio_pull_updown(gpio, GPIOPullUp);
-	if (ret) {
-	    printk("failed to pull up gpio irq for wm831x \n");
-		return ret;
-	}	
-	irq = gpio_to_irq(gpio);
-
-	dev_set_drvdata(&spi->dev, wm831x);
-	wm831x->dev = &spi->dev;
-	wm831x->control_data = spi;
-	wm831x->read_dev = wm831x_spi_read_device;
-	wm831x->write_dev = wm831x_spi_write_device;
-	gwm831x = wm831x;
-	mutex_init(&wm831x->io_lock);
-	
-	wm831x_init(wm831x);
-	
-	wm831x->irq_wq = create_singlethread_workqueue("wm831x-irq");
-	if (!wm831x->irq_wq) {
-		dev_err(wm831x->dev, "Failed to allocate IRQ worker\n");
-		return -ESRCH;
-	}
-	
-	INIT_WORK(&wm831x->irq_work, wm831x_irq_worker);
-	wake_lock_init(&wm831x->irq_wake, WAKE_LOCK_SUSPEND, "wm831x_irq_wake");
-
-	ret = request_threaded_irq(irq, wm831x_irq_thread, NULL, 
-				 IRQF_TRIGGER_LOW,
-				   "wm831x", wm831x);
-	if (ret != 0) {
-		dev_err(wm831x->dev, "Failed to request IRQ %d: %d\n",
-			wm831x->irq, ret);
-		return ret;
-	}
-	wm831x->irq = irq;
-	enable_irq_wake(irq); // so wm831x irq can wake up system
-	/* only support on intterupt */
-	wm831x_reg_write(wm831x, WM831X_SYSTEM_INTERRUPTS_MASK, 0xefff);
-	wm831x_reg_write(wm831x, WM831X_INTERRUPT_STATUS_1_MASK, 0xefff);
-
-	setup_timer(&irq_timer, wm831x_irq_timer, (unsigned long)wm831x);
-	irq_timer.expires  = jiffies+2000;
-	add_timer(&irq_timer);
-
-	return 0;
-	//return wm831x_device_init(wm831x, type, irq);
-}
-
-static int __devexit wm831x_spi_remove(struct spi_device *spi)
-{
-	struct wm831x *wm831x = dev_get_drvdata(&spi->dev);
-
-	//wm831x_device_exit(wm831x);
-
-	return 0;
-}
-
-static int wm831x_spi_suspend(struct spi_device *spi, pm_message_t m)
-{
-	struct wm831x *wm831x = dev_get_drvdata(&spi->dev);
-	return 0;
-	//return wm831x_device_suspend(wm831x);
-}
-
-static int wm831x_spi_resume(struct spi_device *spi)
-{
-	return 0;
-}
-
-static struct spi_driver wm8310_spi_driver = {
-	.driver = {
-		.name	= "wm8310",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= wm831x_spi_probe,
-	.remove		= __devexit_p(wm831x_spi_remove),
-	.suspend	= wm831x_spi_suspend,
-	.resume	= wm831x_spi_resume,
-};
-
-static struct spi_driver wm8311_spi_driver = {
-	.driver = {
-		.name	= "wm8311",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= wm831x_spi_probe,
-	.remove		= __devexit_p(wm831x_spi_remove),
-	.suspend	= wm831x_spi_suspend,
-};
-
-static struct spi_driver wm8312_spi_driver = {
-	.driver = {
-		.name	= "wm8312",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= wm831x_spi_probe,
-	.remove		= __devexit_p(wm831x_spi_remove),
-	.suspend	= wm831x_spi_suspend,
-};
-
-static struct spi_driver wm8320_spi_driver = {
-	.driver = {
-		.name	= "wm8320",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= wm831x_spi_probe,
-	.remove		= __devexit_p(wm831x_spi_remove),
-	.suspend	= wm831x_spi_suspend,
-};
-
-static struct spi_driver wm8321_spi_driver = {
-	.driver = {
-		.name	= "wm8321",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= wm831x_spi_probe,
-	.remove		= __devexit_p(wm831x_spi_remove),
-	.suspend	= wm831x_spi_suspend,
-};
-
-static struct spi_driver wm8325_spi_driver = {
-	.driver = {
-		.name	= "wm8325",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= wm831x_spi_probe,
-	.remove		= __devexit_p(wm831x_spi_remove),
-	.suspend	= wm831x_spi_suspend,
-};
-
-static int __init wm831x_spi_init(void)
-{
-	int ret;
-
-	ret = spi_register_driver(&wm8310_spi_driver);
-	if (ret != 0)
-		pr_err("Failed to register WM8310 SPI driver: %d\n", ret);
-
-	ret = spi_register_driver(&wm8311_spi_driver);
-	if (ret != 0)
-		pr_err("Failed to register WM8311 SPI driver: %d\n", ret);
-
-	ret = spi_register_driver(&wm8312_spi_driver);
-	if (ret != 0)
-		pr_err("Failed to register WM8312 SPI driver: %d\n", ret);
-
-	ret = spi_register_driver(&wm8320_spi_driver);
-	if (ret != 0)
-		pr_err("Failed to register WM8320 SPI driver: %d\n", ret);
-
-	ret = spi_register_driver(&wm8321_spi_driver);
-	if (ret != 0)
-		pr_err("Failed to register WM8321 SPI driver: %d\n", ret);
-
-	ret = spi_register_driver(&wm8325_spi_driver);
-	if (ret != 0)
-		pr_err("Failed to register WM8325 SPI driver: %d\n", ret);
-
-	return 0;
-}
-subsys_initcall(wm831x_spi_init);
-
-static void __exit wm831x_spi_exit(void)
-{
-	spi_unregister_driver(&wm8325_spi_driver);
-	spi_unregister_driver(&wm8321_spi_driver);
-	spi_unregister_driver(&wm8320_spi_driver);
-	spi_unregister_driver(&wm8312_spi_driver);
-	spi_unregister_driver(&wm8311_spi_driver);
-	spi_unregister_driver(&wm8310_spi_driver);
-}
-module_exit(wm831x_spi_exit);
-
-MODULE_DESCRIPTION("SPI support for WM831x/2x AudioPlus PMICs");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Mark Brown");
diff --git a/drivers/power/wm831x_charger_display.c b/drivers/power/wm831x_charger_display.c
deleted file mode 100755
index c08fa6bbcc18..000000000000
--- a/drivers/power/wm831x_charger_display.c
+++ /dev/null
@@ -1,503 +0,0 @@
-/* drivers/power/wm831x_charger_display.c
- *
- * battery detect driver for the rk2818 
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/input.h>
-#include <linux/interrupt.h>
-#include <linux/fb.h>
-#include <linux/delay.h>
-#include <linux/suspend.h>
-#include <linux/linux_logo.h>
-#include <linux/regulator/consumer.h>
-#include <linux/platform_device.h>
-#include <linux/workqueue.h>
-#include <linux/mfd/wm831x/core.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-#include <mach/rk29_iomap.h>
-
-#include <linux/mfd/wm831x/core.h>
-#include <linux/mfd/wm831x/auxadc.h>
-#include <linux/mfd/wm831x/pmu.h>
-#include <linux/mfd/wm831x/pdata.h>
-#include <linux/mfd/wm831x/irq.h>
-#include <linux/power_supply.h>
-
-#define READ_ON_PIN_CNT 20/*11*/
-#define BACKLIGHT_CNT	2
-#define OPEN_CNT		18
-#define MC_OPEN 7/*10*/ 
-#define BAT_CHARGING    1
-#define BAT_DISCHARGING 0
-#define BL_DELAY_TIME   (8*1000)
-
-
-#define SET_BACKLIGHT_ON 	1
-#define OPEN_SYSTEM			2
-#define SUSPEND_SYSTEM		3
-
-#if 0
-#define DBG(x...)   printk(x)
-#else
-#define DBG(x...)
-#endif 
-
-extern void request_suspend_state(suspend_state_t new_state);
-extern void kernel_restart(char *cmd);
-extern void kernel_power_off(void);
-
-extern unsigned g_vbus_status_register;
-extern unsigned long *g_pcd_for_charger;
-
-extern int rk29_backlight_ctrl(int open);
-
-extern void fb_show_charge_logo(struct linux_logo *logo);
-
-extern void kernel_restart_prepare(char *cmd);
-extern int dwc_vbus_status( void );
-extern int dwc_otg_pcd_check_vbus_detech( unsigned long pdata );
-
-#if defined(CONFIG_LOGO_CHARGER_CLUT224)
-extern struct linux_logo logo_charger01_clut224;
-extern struct linux_logo logo_charger02_clut224;
-extern struct linux_logo logo_charger03_clut224;
-extern struct linux_logo logo_charger04_clut224;
-extern struct linux_logo logo_charger05_clut224;
-extern struct linux_logo logo_charger06_clut224;
-extern struct linux_logo logo_charger07_clut224;
-extern struct linux_logo logo_charger08_clut224;
-#endif
-
-extern struct fb_info *g_fb0_inf;
-
-static struct linux_logo* g_chargerlogo[8]= {
-#if defined(CONFIG_LOGO_CHARGER_CLUT224)
-	&logo_charger01_clut224,&logo_charger02_clut224,&logo_charger03_clut224,&logo_charger04_clut224,
-		&logo_charger05_clut224,&logo_charger06_clut224,&logo_charger07_clut224,&logo_charger08_clut224
-#endif
-};
-
-#if 1
-struct wm831x_chg {
-	struct wm831x *wm831x;
-	int logo_id;
-	int flag_chg;
-	int bat_vol;
-	int cnt_on;
-	int cnt_disp;
-	int flag_bl;
-	int flag_suspend;
-	
-};
-
-static int charger_logo_display(struct linux_logo *logo)
-{
-	fb_show_charge_logo(logo);
-	fb_show_logo(g_fb0_inf, 0);
-	return 0;
-}
-
-extern int charger_suspend(void);//xsf
-
-static int charger_backlight_ctrl(int open)
-{
-	DBG("%s:open=%d\n",__FUNCTION__,open);
-	int ret;
-
-#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
-	charger_suspend();
-	return 0;
-#else
-	return rk29_backlight_ctrl(open);
-#endif
-
-
-}
-
-static int wm831x_read_on_pin_status(struct wm831x_chg *wm831x_chg)
-{
-	int ret;
-	
-	if(!wm831x_chg)
-	{
-		printk("err:%s:wm831x_chg address is 0\n",__FUNCTION__);
-		return -1;
-	}
-	
-	ret = wm831x_reg_read(wm831x_chg->wm831x, WM831X_ON_PIN_CONTROL);
-	if (ret < 0)
-		return ret;
-
-	return !(ret & WM831X_ON_PIN_STS) ? 1 : 0;
-}
-
-
-static int wm831x_read_chg_status(struct wm831x_chg *wm831x_chg)
-{
-	int ret, usb_chg = 0, wall_chg = 0;
-	
-	if(!wm831x_chg)
-	{
-		printk("err:%s:wm831x_chg address is 0\n",__FUNCTION__);
-		return -1;
-	}
-	
-	ret = wm831x_reg_read(wm831x_chg->wm831x, WM831X_SYSTEM_STATUS);
-	if (ret < 0)
-		return ret;
-
-	if (ret & WM831X_PWR_USB)
-		usb_chg = 1;
-	if (ret & WM831X_PWR_WALL)
-		wall_chg = 1;
-
-	return ((usb_chg | wall_chg) ? 1 : 0);
-}
-
-static int wm831x_bat_check_status(struct wm831x *wm831x, int *status)
-{
-	int ret;
-
-	ret = wm831x_reg_read(wm831x, WM831X_SYSTEM_STATUS);
-	if (ret < 0)
-		return ret;
-
-	if (ret & WM831X_PWR_SRC_BATT) {
-		*status = POWER_SUPPLY_STATUS_DISCHARGING;
-		return 0;
-	}
-
-	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_STATUS);
-	if (ret < 0)
-		return ret;
-
-	
-	switch (ret & WM831X_CHG_STATE_MASK) {
-	case WM831X_CHG_STATE_OFF:
-		*status = POWER_SUPPLY_STATUS_NOT_CHARGING;
-		break;
-	case WM831X_CHG_STATE_TRICKLE:
-	case WM831X_CHG_STATE_FAST:
-		*status = POWER_SUPPLY_STATUS_CHARGING;
-		break;
-
-	default:
-		*status = POWER_SUPPLY_STATUS_UNKNOWN;
-		break;
-	}
-
-	return 0;
-}
-
-static int wm831x_read_bat_charging_status(struct wm831x_chg *wm831x_chg)
-{
-	int ret, status;
-	
-	if(!wm831x_chg)
-	{
-		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
-		return -1;
-	}
-	
-	ret = wm831x_bat_check_status(wm831x_chg->wm831x, &status);
-	if (ret < 0)
-		return ret;
-	if (status == POWER_SUPPLY_STATUS_CHARGING) 
-		return 1;
-	return 0;
-}
-
-static int wm831x_read_batt_voltage(struct wm831x_chg *wm831x_chg)
-{
-	int ret = 0;
-	
-	if(!wm831x_chg)
-	{
-		printk("err:%s:wm831x_chg address is 0\n",__FUNCTION__);
-		return -1;
-	}
-	
-	ret = wm831x_auxadc_read_uv(wm831x_chg->wm831x, WM831X_AUX_BATT);
-	return ret / 1000;
-}
-
-
-static int get_charger_logo_start_num(struct wm831x_chg *wm831x_chg)
-{
-	int rlogonum, bat_vol;
-
-	/*check charger voltage*/
-	bat_vol = wm831x_read_batt_voltage(wm831x_chg);
-	if(bat_vol <= 3610) {
-		rlogonum = 0;
-	}
-	else if(bat_vol <= 3700) {
-		rlogonum = 1;
-	}
-	else if(bat_vol <= 3760) {
-		rlogonum = 2;
-	}
-	else if(bat_vol <= 3840) {
-		rlogonum = 3;
-	}
-	else if(bat_vol <= 3900) {
-		rlogonum = 4;
-	}
-	else if(bat_vol <= 3990) {
-		rlogonum = 5;
-	}
-	else if(bat_vol <= 4130) {
-		rlogonum = 6;
-	}
-	else if(bat_vol <= 4200) {
-		rlogonum = 7;
-	}
-	else{
-		rlogonum = 7;
-	}
-		
-	return rlogonum;
-}
-
-static int wm831x_check_on_pin(struct wm831x_chg *wm831x_chg)
-{
-	int ret;
-	ret = wm831x_read_on_pin_status(wm831x_chg);
-	if(ret)
-	{
-		if(wm831x_chg->cnt_on++ > 1000)
-			wm831x_chg->cnt_on = 1000;
-	}
-	else
-	{
-		//control backlight if press on pin
-		if(wm831x_chg->cnt_on >= 1)
-		{
-			wm831x_chg->flag_bl = !wm831x_chg->flag_bl;
-			charger_backlight_ctrl(wm831x_chg->flag_bl);
-			wm831x_chg->cnt_on = 0;	
-			if(wm831x_chg->flag_bl)
-			{
-				wm831x_chg->flag_suspend = 0;
-				wm831x_chg->cnt_disp = 0;
-			}
-		}
-	}
-
-	return 0;
-}
-
-static int rk29_charger_display(struct wm831x_chg *wm831x_chg)
-{
-	int status;
-	struct linux_logo* chargerlogo[8];
-	int ret,i;
-	int count = 0;
-	
-	wm831x_chg->flag_chg = wm831x_read_chg_status(wm831x_chg);
-	if(!wm831x_chg->flag_chg)
-		return -1;
-
-	while(1)
-	{
-		wm831x_chg->flag_chg = wm831x_read_chg_status(wm831x_chg);
-		if(!wm831x_chg->flag_chg)
-			kernel_power_off();
-
-		status = wm831x_read_bat_charging_status(wm831x_chg);
-
-		for(i=0; i<8; i++)
-		chargerlogo[i] = g_chargerlogo[i];
-	
-		if(status == BAT_CHARGING)
-		{	
-			for(i=get_charger_logo_start_num(wm831x_chg); i<8; i++ )
-			{
-				wm831x_chg->flag_chg = wm831x_read_chg_status(wm831x_chg);
-				if(!wm831x_chg->flag_chg)
-				kernel_power_off();
-			#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
-				ret = charger_logo_display(chargerlogo[i]);
-			#else
-				if(wm831x_chg->flag_bl != 0)
-				ret = charger_logo_display(chargerlogo[i]);
-			#endif
-				DBG("%s:i=%d\n",__FUNCTION__,i);
-
-				msleep(200);	
-				wm831x_check_on_pin(wm831x_chg);
-				msleep(200);
-				wm831x_check_on_pin(wm831x_chg);
-
-			}
-					
-		}
-		else if(status == BAT_DISCHARGING)
-		{
-
-		#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
-			charger_logo_display(chargerlogo[7]);
-		#else
-			if(wm831x_chg->flag_bl != 0)
-			charger_logo_display(chargerlogo[7]);
-		#endif
-			msleep(200);
-			wm831x_check_on_pin(wm831x_chg);
-			msleep(200);
-			wm831x_check_on_pin(wm831x_chg);
-		}
-		
-		//suspend when timeout(about 50*200ms)
-		if(wm831x_chg->cnt_disp++ > 50)
-		{
-			if(wm831x_chg->flag_suspend == 0)
-			{
-				wm831x_chg->flag_suspend = 1;
-				wm831x_chg->cnt_disp = 0;
-				wm831x_chg->flag_bl = 0;
-				charger_backlight_ctrl(wm831x_chg->flag_bl);
-		#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
-				wm831x_chg->flag_suspend = 0;
-		#endif
-
-			}
-			wm831x_chg->cnt_disp = 0;
-		}
-
-		printk("%s,status=%d,cnt_on=%d,cnt_disp=%d\n",__FUNCTION__,status,wm831x_chg->cnt_on,wm831x_chg->cnt_disp);
-
-		//open system if long time press
-		if(wm831x_chg->cnt_on > 4)
-		{
-			wm831x_chg->cnt_on = 0;
-			wm831x_chg->flag_bl = 1;
-			charger_backlight_ctrl(wm831x_chg->flag_bl);
-			wm831x_chg->flag_suspend = 0;
-			wm831x_chg->cnt_disp = 0;
-			break;
-		}	
-		
-	}
-
-	return 0;
-
-}
-int charge_status;
-static irqreturn_t wm831x_charge_irq(int irq, void *data)
-{
-
-	printk("wm831x_charge_irqxxaddxsf\n");
-	return IRQ_HANDLED;
-
-
-}
-extern struct wm831x_on *g_wm831x_on;
- irqreturn_t wm831x_on_irq(int irq, void *data);
-
-static int __devinit wm831x_chg_probe(struct platform_device *pdev)
-{
-	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);;
-	struct wm831x_chg *wm831x_chg;
-
-//	struct wm831x_on *wm831x_on = container_of(wm831x,struct wm831x_on,*(wm831x));
-
-
-	int ret;
-	
-	wm831x_chg = kzalloc(sizeof(struct wm831x_chg), GFP_KERNEL);
-	if (!wm831x_chg) {
-		dev_err(&pdev->dev, "Can't allocate data\n");
-		return -ENOMEM;
-	}
-	charge_status = 1;
-	printk("%s:start\n",__FUNCTION__);
-	wm831x_chg->wm831x = wm831x;
-	wm831x_chg->flag_chg = 0;
-	wm831x_chg->logo_id = 0;
-	wm831x_chg->flag_bl = 1;
-	wm831x_chg->cnt_on = 0;
-	wm831x_chg->flag_suspend = 0;
-	platform_set_drvdata(pdev, wm831x_chg);
-
-#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
-	wm831x_chg->flag_chg = wm831x_read_chg_status(wm831x_chg);
-	if(wm831x_chg->flag_chg != 0)
-	{
-		free_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON,g_wm831x_on);
-		request_threaded_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON,
-						NULL, wm831x_charge_irq,IRQF_TRIGGER_RISING, "wm831x_charge",
-					   wm831x_chg);
-
-		ret = rk29_charger_display(wm831x_chg);
-
-
-		free_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON,wm831x_chg);
-		request_threaded_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON,
-			NULL, wm831x_on_irq,IRQF_TRIGGER_RISING, "wm831x_on",  g_wm831x_on);
-	}
-#else
-	disable_irq_nosync(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON);
-	ret = rk29_charger_display(wm831x_chg);
-	enable_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON);
-#endif
-	wm831x_chg->flag_chg = 0;
-	wm831x_chg->flag_bl = 1;
-	wm831x_chg->cnt_on = 0;
-	wm831x_chg->flag_suspend = 0;
-	charge_status = 0;
-	printk("%s:exit\n",__FUNCTION__);
-	return 0;
-
-}
-
-
-static int __devexit wm831x_chg_remove(struct platform_device *pdev)
-{
-	struct wm831x_chg *wm831x_chg = platform_get_drvdata(pdev);
-
-	kfree(wm831x_chg);
-
-	return 0;
-}
-
-static struct platform_driver wm831x_chg_driver = {
-	.probe		= wm831x_chg_probe,
-	.remove		= __devexit_p(wm831x_chg_remove),
-	.driver		= {
-		.name	= "wm831x_charger_display",
-		.owner	= THIS_MODULE,
-	},
-};
-
-static int __init wm831x_chg_init(void)
-{
-	return platform_driver_register(&wm831x_chg_driver);
-}
-late_initcall(wm831x_chg_init);
-
-static void __exit wm831x_chg_exit(void)
-{
-	platform_driver_unregister(&wm831x_chg_driver);
-}
-module_exit(wm831x_chg_exit);
-#endif
-
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("linjh<linjh@rock-chips.com>");
-MODULE_DESCRIPTION("charger display");
-- 
2.35.3

