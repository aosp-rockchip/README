From 8ae6fcba5c80f2c384c0300bbca90856f997f912 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E9=99=88=E9=87=91=E6=B3=89?= <jear.chen@rock-chips.com>
Date: Mon, 10 Mar 2014 11:10:43 +0800
Subject: [PATCH] Audio: delete codec_set_spk, update rk616 codec driver

---
 drivers/mfd/rk616-core.c                   |  52 ++-
 drivers/video/hdmi/Makefile                |   2 +-
 drivers/video/hdmi/chips/anx7150/anx7150.c |   2 -
 drivers/video/hdmi/hdmi-codec.c            |  17 -
 drivers/video/rockchip/hdmi/Kconfig        |   8 -
 drivers/video/rockchip/hdmi/rk_hdmi_task.c |  64 ---
 include/linux/mfd/rk616.h                  |   4 -
 sound/soc/codecs/ak4396.c                  |   5 -
 sound/soc/codecs/cx2070x.c                 |   5 -
 sound/soc/codecs/es8323.c                  |  16 -
 sound/soc/codecs/rk2928_codec.c            |  24 -
 sound/soc/codecs/rk3026_codec.c            |  78 +---
 sound/soc/codecs/rk3026_codec.h            |   2 -
 sound/soc/codecs/rk3190_codec.c            |  78 +---
 sound/soc/codecs/rk3190_codec.h            |   2 -
 sound/soc/codecs/rk610_codec.c             |  18 -
 sound/soc/codecs/rk616_codec.c             | 520 ++++++++++++---------
 sound/soc/codecs/rk616_codec.h             |   1 -
 sound/soc/codecs/rt3261.c                  |  24 -
 sound/soc/codecs/rt3261.h                  |   1 -
 sound/soc/codecs/rt5616.c                  |  22 -
 sound/soc/codecs/rt5621.c                  |  26 --
 sound/soc/codecs/rt5631.c                  |  26 --
 sound/soc/codecs/rt5640.c                  |  32 --
 sound/soc/rockchip/rk_rk616.c              |  53 ++-
 sound/soc/rockchip/rk_rt3261.c             |  12 -
 sound/soc/rockchip/rk_rt5512.c             |   2 +-
 sound/soc/rockchip/rk_rt5640.c             |  12 -
 sound/soc/rockchip/rk_wm8994.c             |   7 +-
 sound/soc/soc-core.c                       |   2 +-
 30 files changed, 405 insertions(+), 712 deletions(-)
 delete mode 100755 drivers/video/hdmi/hdmi-codec.c

diff --git a/drivers/mfd/rk616-core.c b/drivers/mfd/rk616-core.c
index b659432013a9..23efc531e740 100755
--- a/drivers/mfd/rk616-core.c
+++ b/drivers/mfd/rk616-core.c
@@ -475,6 +475,53 @@ static int rk616_core_resume(struct device* dev)
 	return 0;
 }
 
+/*
+dts:
+
+/include/ "rk616.dtsi"
+&rk616 {
+        rk616,scl_rate = <100000>;
+        rk616,lcd0_func = <1>;
+        rk616,lcd1_func = <1>;
+        rk616,lvds_ch_nr = <1>;
+        rk616,hdmi_irq_gpio = <&gpio2 GPIO_D6 1>;
+
+	rk616-codec {
+		spk-ctl-gpio = <&gpio2 GPIO_D7 GPIO_ACTIVE_HIGH>;
+		hp-ctl-gpio = <&gpio2 GPIO_D7 GPIO_ACTIVE_HIGH>;
+		//rcv-ctl-gpio = <&gpio2 GPIO_D7 GPIO_ACTIVE_HIGH>;
+		//mic-sel-gpio = <&gpio2 GPIO_D7 GPIO_ACTIVE_HIGH>;
+
+		//delay for MOSFET or SPK power amplifier chip(ms)
+		spk-amplifier-delay = <150>;
+		hp-mosfet-delay = <50>;
+
+		//hp-mic-capture-from-linein; //If hpmic is connected to linein, set this.
+		//hp-mic-capture-from-mic2in; //If hpmic is connected to mic2, set this.
+		//virtual-hp-gnd; //If hp gnd is not connected to gnd(0V), set this.
+
+		//volume setting: 0 ~ 31, -18dB ~ 28.5dB, Step: 1.5dB
+		skp-volume = <24>;
+		hp-volume = <24>;
+		capture-volume = <24>;
+	};
+
+        power_ctr: rk616_power_ctr {
+                rk616_pwren: rk616_pwren {
+                        rockchip,power_type = <GPIO>;
+                        gpios = <&gpio0 GPIO_A3 GPIO_ACTIVE_HIGH>;
+                        rockchip,delay = <0>;
+                };
+
+                rk616_rst: rk616_rst {
+                        rockchip,power_type = <GPIO>;
+                        gpios = <&gpio3 GPIO_B2 GPIO_ACTIVE_HIGH>;
+                        rockchip,delay = <10>;
+                };
+
+        };
+};
+*/
 #ifdef CONFIG_OF
 static struct rk616_platform_data *rk616_parse_dt(struct mfd_rk616 *rk616)
 {
@@ -509,11 +556,6 @@ static struct rk616_platform_data *rk616_parse_dt(struct mfd_rk616 *rk616)
 	if (!gpio_is_valid(gpio))
 		printk("invalid hdmi_irq_gpio: %d\n",gpio);
 	pdata->hdmi_irq = gpio;
-
-	gpio = of_get_named_gpio(rk616_np,"rk616,spk_ctl_gpio", 0);
-	if (!gpio_is_valid(gpio))
-		printk("invalid spk_ctl_gpio: %d\n",gpio);
-	pdata->spk_ctl_gpio = gpio;
 	//TODO Daisen >>pwr gpio wait to add
 
 	return pdata;
diff --git a/drivers/video/hdmi/Makefile b/drivers/video/hdmi/Makefile
index 1b59c50ab27f..cf122847105c 100755
--- a/drivers/video/hdmi/Makefile
+++ b/drivers/video/hdmi/Makefile
@@ -1,2 +1,2 @@
-obj-$(CONFIG_HDMI)	+= hdmi-core.o hdmi-sysfs.o hdmi-fb.o hdmi-codec.o hdmi-backlight.o
+obj-$(CONFIG_HDMI)	+= hdmi-core.o hdmi-sysfs.o hdmi-fb.o hdmi-backlight.o
 obj-$(CONFIG_HDMI)	+= chips/
diff --git a/drivers/video/hdmi/chips/anx7150/anx7150.c b/drivers/video/hdmi/chips/anx7150/anx7150.c
index 0310da6eff12..bef26e40f9f1 100644
--- a/drivers/video/hdmi/chips/anx7150/anx7150.c
+++ b/drivers/video/hdmi/chips/anx7150/anx7150.c
@@ -86,7 +86,6 @@ static int anx7150_insert(struct hdmi *hdmi)
 		dev_dbg(hdmi->dev, "get sense_state error\n");
 		return -1;
 	}
-	hdmi_set_spk(HDMI_DISABLE);
 	hdmi_set_backlight(HDMI_DISABLE);
 	hdmi->scale = hdmi->scale_set;
 	anx7150_param_chg(anx);
@@ -101,7 +100,6 @@ static int anx7150_remove(struct hdmi *hdmi)
 
 	anx7150_unplug(anx->client);
 	hdmi->scale = 100;
-	hdmi_set_spk(HDMI_ENABLE);
 	hdmi_switch_fb(hdmi, HDMI_DISABLE);
 	hdmi_set_backlight(HDMI_ENABLE);
 
diff --git a/drivers/video/hdmi/hdmi-codec.c b/drivers/video/hdmi/hdmi-codec.c
deleted file mode 100755
index a42b0228442f..000000000000
--- a/drivers/video/hdmi/hdmi-codec.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include <linux/hdmi.h>
-#if defined CONFIG_SND_SOC_WM8900 || defined CONFIG_SND_SOC_RT5631 || defined CONFIG_SND_SOC_RT5621 || defined CONFIG_SND_RK29_SOC_RK610
-/* sound/soc/codecs/wm8900.c */
-extern void codec_set_spk(bool on);
-#else
-void codec_set_spk(bool on) 
-{
-	/* please add sound switching-related code here or on your codec driver
-	   parameter: on=1 ==> open spk 
-				  on=0 ==> close spk
-	*/
-}
-#endif
-void hdmi_set_spk(int on)
-{
-	codec_set_spk(on);
-}
diff --git a/drivers/video/rockchip/hdmi/Kconfig b/drivers/video/rockchip/hdmi/Kconfig
index b32cf6c0b23a..27a76ee5f7ab 100755
--- a/drivers/video/rockchip/hdmi/Kconfig
+++ b/drivers/video/rockchip/hdmi/Kconfig
@@ -13,11 +13,3 @@ config RK_HDMI_DEBUG
         default n
 		help
 		  Enableds verbose debugging the the HDMI drivers
-
-config RK_HDMI_CTL_CODEC
-		bool "Mute Codec When HDMI Actived"
-		depends on RK_HDMI
-		default n
-		help
-			If you say y heres, Codec will be mute when hdmi inserted,
-			and unmute when removed. 
diff --git a/drivers/video/rockchip/hdmi/rk_hdmi_task.c b/drivers/video/rockchip/hdmi/rk_hdmi_task.c
index 1963fb893ecc..c98655f2320e 100755
--- a/drivers/video/rockchip/hdmi/rk_hdmi_task.c
+++ b/drivers/video/rockchip/hdmi/rk_hdmi_task.c
@@ -3,28 +3,6 @@
 #include <linux/interrupt.h>
 #include "rk_hdmi.h"
 
-#ifdef CONFIG_RK_HDMI_CTL_CODEC
-#ifdef CONFIG_MACH_RK_FAC
-	#ifdef CONFIG_SND_RK_SOC_ES8323
-		extern void es8323_codec_set_spk(bool on);
-	#endif
-	#ifdef CONFIG_SND_RK_SOC_RT5616
-		extern void rt5616_codec_set_spk(bool on);
-	#endif
-	#ifdef CONFIG_SND_RK_SOC_RK616
-		extern void rk616_codec_set_spk(bool on);
-	#endif
-	#ifdef CONFIG_SND_RK_SOC_RT5631
-		extern void rk610_codec_set_spk(bool on);
-	#endif
-	#ifdef CONFIG_SND_RK_SOC_RK610
-		extern void rk610_codec_set_spk(bool on);
-	#endif	
-#else
-	extern void codec_set_spk(bool on);
-#endif  
-#endif
-
 #define HDMI_MAX_TRY_TIMES	1
 #define HDMI_MAX_ID 1
 
@@ -112,27 +90,6 @@ void hdmi_sys_remove(struct hdmi *hdmi)
 	if(audio_need)
 		switch_set_state(&(hdmi->switch_hdmi), 0);
 	#endif
-	#ifdef CONFIG_RK_HDMI_CTL_CODEC
-#ifdef CONFIG_MACH_RK_FAC
-	#ifdef CONFIG_SND_RK_SOC_ES8323
-		es8323_codec_set_spk(1);
-	#endif
-	#ifdef CONFIG_SND_RK_SOC_RT5616
-		 rt5616_codec_set_spk(1);
-	#endif
-	#ifdef CONFIG_SND_RK_SOC_RK616
-		 rk616_codec_set_spk(1);
-	#endif
-	#ifdef CONFIG_SND_RK_SOC_RK610
-		 rk610_codec_set_spk(1);
-	#endif
-	#ifdef CONFIG_SND_RK_SOC_RT5631
-		 rt5631_codec_set_spk(1);
-	#endif	
-#else
-	codec_set_spk(1);
-#endif
-	#endif
 }
 
 static void hdmi_sys_sleep(struct hdmi *hdmi)
@@ -275,27 +232,6 @@ void hdmi_work(struct work_struct *work)
 					if(hdmi->edid.base_audio_support == 1 &&  hdmi->edid.sink_hdmi == 1)
 						switch_set_state(&(hdmi->switch_hdmi), 1);
 					#endif
-					#ifdef CONFIG_RK_HDMI_CTL_CODEC
-					#ifdef CONFIG_MACH_RK_FAC
-						#if defined(CONFIG_SND_RK29_SOC_ES8323)
-							es8323_codec_set_spk(0);
-						#endif
-						#if defined (CONFIG_SND_RK29_SOC_RT5616)
-							rt5616_codec_set_spk(0);
-						#endif		
-						#if defined (CONFIG_SND_RK_SOC_RK616)
-							rk616_codec_set_spk(0);
-						#endif
-						#ifdef CONFIG_SND_RK_SOC_RK610
-							 rk610_codec_set_spk(1);
-						#endif
-						#ifdef CONFIG_SND_RK_SOC_RT5631
-							 rt5631_codec_set_spk(1);
-						#endif
-					#else
-						codec_set_spk(0);
-					#endif
-					#endif
 				}
 				break;
 			case SYSTEM_CONFIG:
diff --git a/include/linux/mfd/rk616.h b/include/linux/mfd/rk616.h
index 1f05fef8853d..e0928434f4a4 100755
--- a/include/linux/mfd/rk616.h
+++ b/include/linux/mfd/rk616.h
@@ -243,10 +243,6 @@ struct rk616_platform_data {
 	enum lcd_port_func lcd1_func;
 	int lvds_ch_nr;			//the number of used  lvds channel 
 	int hdmi_irq;
-	int spk_ctl_gpio;
-	int hp_ctl_gpio;
-	int rcv_ctl_gpio;
-	int mic_sel_gpio;
 };
 
 struct rk616_route {
diff --git a/sound/soc/codecs/ak4396.c b/sound/soc/codecs/ak4396.c
index 4fd5945ca777..882d7ec8a18f 100755
--- a/sound/soc/codecs/ak4396.c
+++ b/sound/soc/codecs/ak4396.c
@@ -71,11 +71,6 @@ static void on_off_ext_amp(int i)
     #endif
 }
 
-void ak4396_codec_set_spk(bool on)
-{
-	on_off_ext_amp(on);
-}
-
 static int ak4396_fill_cache(struct snd_soc_codec *codec)
 {
 	int i;
diff --git a/sound/soc/codecs/cx2070x.c b/sound/soc/codecs/cx2070x.c
index b9edb1b21b97..1a89c3f2b796 100755
--- a/sound/soc/codecs/cx2070x.c
+++ b/sound/soc/codecs/cx2070x.c
@@ -290,11 +290,6 @@ static struct snd_soc_jack_gpio hs_jack_gpios[] = {
 
 #endif //CONFIG_SND_CX2070X_GPIO_JACKSENSE
 
-void codec_set_spk(bool on)
-{	
-}
-EXPORT_SYMBOL(codec_set_spk);
-
 #if defined(CONFIG_SND_CX2070X_LOAD_FW)
 int I2cWrite( struct snd_soc_codec *codec, unsigned char ChipAddr, unsigned long cbBuf, unsigned char* pBuf);
 int I2cWriteThenRead( struct snd_soc_codec *codec, unsigned char ChipAddr, unsigned long cbBuf,
diff --git a/sound/soc/codecs/es8323.c b/sound/soc/codecs/es8323.c
index b15ceec07289..11bf5bbd5b8e 100755
--- a/sound/soc/codecs/es8323.c
+++ b/sound/soc/codecs/es8323.c
@@ -565,13 +565,6 @@ static void on_off_ext_amp(int i)
     #endif
 }
 
-#if 0
-void es8323_codec_set_spk(bool on)
-{
-	on_off_ext_amp(on);
-}
-#endif
-
 
 
 /*
@@ -1143,15 +1136,6 @@ static int es8323_remove(struct snd_soc_codec *codec)
 	return 0;
 }
 
-void es8323_codec_set_spk(bool on)
-{
-	DBG("Enter::%s----%d--, on = %d\n",__FUNCTION__,__LINE__, on);
-
-        set_spk = on;
-        gpio_set_value(es8323_spk_con_gpio, on);
-	//return;
-}
-
 static struct snd_soc_codec_driver soc_codec_dev_es8323 = {
 	.probe =	es8323_probe,
 	.remove =	es8323_remove,
diff --git a/sound/soc/codecs/rk2928_codec.c b/sound/soc/codecs/rk2928_codec.c
index e67d07040dcf..006228e4404b 100755
--- a/sound/soc/codecs/rk2928_codec.c
+++ b/sound/soc/codecs/rk2928_codec.c
@@ -182,30 +182,6 @@ static int rk2928_write_mask(struct snd_soc_codec *codec, unsigned int reg,
 	return rk2928_write(codec, reg, regvalue);
 }
 
-void codec_set_spk(bool on)
-{
-	if(on == 0) {
-		DBG("%s speaker is disabled\n", __FUNCTION__);
-		rk2928_data.hdmi_enable = 1;
-		if(rk2928_data.mute == 0) {
-			rk2928_write(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(1));
-			if(rk2928_data.spkctl != INVALID_GPIO) {
-				gpio_direction_output(rk2928_data.spkctl, GPIO_LOW);
-			}
-		}
-	}
-	else {
-		DBG("%s speaker is enabled\n", __FUNCTION__);
-		rk2928_data.hdmi_enable = 0;
-		if(rk2928_data.mute == 0) {
-			rk2928_write(NULL, CODEC_REG_DAC_MUTE, v_MUTE_DAC(0));
-			if((rk2928_data.spkctl != INVALID_GPIO) && (rk2928_data.headset_status == HP_OUT)) {
-				gpio_direction_output(rk2928_data.spkctl, GPIO_HIGH);
-			}
-		}
-	}
-}
-
 static void call_delay_work(struct work_struct *work)
 {
 	        struct snd_soc_codec *codec = rk2928_data.codec;
diff --git a/sound/soc/codecs/rk3026_codec.c b/sound/soc/codecs/rk3026_codec.c
index 3546d33c1c62..5a673c21ab56 100755
--- a/sound/soc/codecs/rk3026_codec.c
+++ b/sound/soc/codecs/rk3026_codec.c
@@ -104,7 +104,7 @@ static struct workqueue_struct *rk3026_codec_workq;
 static void rk3026_codec_capture_work(struct work_struct *work);
 static DECLARE_DELAYED_WORK(capture_delayed_work, rk3026_codec_capture_work);
 static int rk3026_codec_work_capture_type = RK3026_CODEC_WORK_NULL;
-static bool rk3026_for_mid = 1, is_hdmi_in = false;
+static bool rk3026_for_mid = 1;
 
 static int rk3026_get_parameter(void)
 {
@@ -444,74 +444,6 @@ int rk3026_headset_mic_detect(bool headset_status)
 }
 EXPORT_SYMBOL(rk3026_headset_mic_detect);
 
-bool get_hdmi_state(void)
-{
-	return is_hdmi_in;
-}
-
-#ifdef CONFIG_MACH_RK_FAC
-void rk3026_codec_set_spk(bool on)
-#else
-void codec_set_spk(bool on)
-#endif
-{
-	struct snd_soc_codec *codec = rk3026_priv->codec;
-
-	DBG("%s : %s\n", __func__, on ? "enable spk" : "disable spk");
-
-	if (!rk3026_priv || !rk3026_priv->codec) {
-		printk("%s : rk3026_priv or rk3026_priv->codec is NULL\n", __func__);
-		return;
-	}
-
-	if (on) {
-		if (rk3026_for_mid)
-		{
-			snd_soc_update_bits(codec, RK3026_HPOUT_CTL,
-				RK3026_HPOUTL_MUTE_MSK, 1);
-			snd_soc_update_bits(codec, RK3026_HPOUT_CTL,
-				RK3026_HPOUTR_MUTE_MSK, RK3026_HPOUTR_MUTE_DIS);
-		}
-		else
-		{
-			snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-			snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-		}
-	} else {
-		if (rk3026_priv->spk_ctl_gpio != INVALID_GPIO) {
-			DBG("%s : set spk ctl gpio LOW\n", __func__);
-			gpio_set_value(rk3026_priv->spk_ctl_gpio, GPIO_LOW);
-		}
-
-		if (rk3026_priv->hp_ctl_gpio != INVALID_GPIO) {
-			DBG("%s : set hp ctl gpio LOW\n", __func__);
-			gpio_set_value(rk3026_priv->hp_ctl_gpio, GPIO_LOW);
-			}
-
-		if (rk3026_for_mid)
-		{
-			snd_soc_update_bits(codec, RK3026_HPOUT_CTL,
-				RK3026_HPOUTL_MUTE_MSK, RK3026_HPOUTL_MUTE_EN);
-			snd_soc_update_bits(codec, RK3026_HPOUT_CTL,
-				RK3026_HPOUTR_MUTE_MSK, RK3026_HPOUTR_MUTE_EN);
-		}
-		else
-		{
-			snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-			snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-		}
-	}
-	snd_soc_dapm_sync(&codec->dapm);
-
-	is_hdmi_in = on ? 0 : 1;
-}
-
-#ifdef CONFIG_MACH_RK_FAC
-EXPORT_SYMBOL_GPL(rk3026_codec_set_spk);
-#else
-EXPORT_SYMBOL_GPL(codec_set_spk);
-#endif
-
 static const DECLARE_TLV_DB_SCALE(out_vol_tlv, -3900, 150, 0);
 static const DECLARE_TLV_DB_SCALE(pga_vol_tlv, -1800, 150, 0);
 static const DECLARE_TLV_DB_SCALE(bst_vol_tlv, 0, 2000, 0);
@@ -758,11 +690,8 @@ static int rk3026_playback_path_put(struct snd_kcontrol *kcontrol,
 	pre_path = rk3026_priv->playback_path;
 	rk3026_priv->playback_path = ucontrol->value.integer.value[0];
 
-	DBG("%s : set playback_path = %ld, hdmi %s\n", __func__,
-		rk3026_priv->playback_path, get_hdmi_state() ? "in" : "out");
-
-	if(get_hdmi_state())
-		return 0;
+	DBG("%s : set playback_path = %ld\n", __func__,
+		rk3026_priv->playback_path);
 
 	switch (rk3026_priv->playback_path) {
 	case OFF:
@@ -1665,7 +1594,6 @@ static int rk3026_codec_power_up(int type)
 			snd_soc_write(codec, playback_power_up_list[i].reg,
 				playback_power_up_list[i].value);
 		}
-		//codec_set_spk(!get_hdmi_state());
 	} else if (type == RK3026_CODEC_CAPTURE) {
 		for (i = 0; i < RK3026_CODEC_CAPTURE_POWER_UP_LIST_LEN; i++) {
 			snd_soc_write(codec, capture_power_up_list[i].reg,
diff --git a/sound/soc/codecs/rk3026_codec.h b/sound/soc/codecs/rk3026_codec.h
index 1b144aa9d17e..af5a4031d46f 100644
--- a/sound/soc/codecs/rk3026_codec.h
+++ b/sound/soc/codecs/rk3026_codec.h
@@ -555,8 +555,6 @@ struct rk3026_init_bit_typ {
 	unsigned int init0_bit;	
 };
 
-bool get_hdmi_state(void);
-
 struct rk3026_codec_pdata {
 	int spk_ctl_gpio;
 	int hp_ctl_gpio;	
diff --git a/sound/soc/codecs/rk3190_codec.c b/sound/soc/codecs/rk3190_codec.c
index c19e086dbe98..068726450655 100755
--- a/sound/soc/codecs/rk3190_codec.c
+++ b/sound/soc/codecs/rk3190_codec.c
@@ -60,6 +60,10 @@
   rk3190_hdmi_ctrl=0;
 #endif
 
+#define GPIO_LOW 0
+#define GPIO_HIGH 1
+#define INVALID_GPIO -1
+
 struct rk3190_codec_priv {
 	struct snd_soc_codec *codec;
 
@@ -92,7 +96,7 @@ static struct rk3190_codec_priv *rk3190_priv = NULL;
 #define RK3190_CODEC_CAPTURE	2
 #define RK3190_CODEC_INCALL	3
 
-static bool rk3190_for_mid = 1, is_hdmi_in = false;
+static bool rk3190_for_mid = 1;
 
 static const unsigned int rk3190_reg_defaults[RK3190_PGA_AGC_CTL5+1] = {
 	[RK3190_RESET] = 0x0003,
@@ -391,74 +395,6 @@ int rk3190_headset_mic_detect(bool headset_status)
 }
 EXPORT_SYMBOL(rk3190_headset_mic_detect);
 
-bool get_hdmi_state(void)
-{
-	return is_hdmi_in;
-}
-
-#ifdef CONFIG_MACH_RK_FAC
-void rk3190_codec_set_spk(bool on)
-#else
-void codec_set_spk(bool on)
-#endif
-{
-	struct snd_soc_codec *codec = rk3190_priv->codec;
-
-	DBG("%s : %s\n", __func__, on ? "enable spk" : "disable spk");
-
-	if (!rk3190_priv || !rk3190_priv->codec) {
-		printk("%s : rk3190_priv or rk3190_priv->codec is NULL\n", __func__);
-		return;
-	}
-
-	if (on) {
-		if (rk3190_for_mid)
-		{
-			snd_soc_update_bits(codec, RK3190_HPOUT_CTL,
-				RK3190_HPOUTL_MUTE_MSK, 1);
-			snd_soc_update_bits(codec, RK3190_HPOUT_CTL,
-				RK3190_HPOUTR_MUTE_MSK, RK3190_HPOUTR_MUTE_DIS);
-		}
-		else
-		{
-			snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-			snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-		}
-	} else {
-		if (rk3190_priv->spk_ctl_gpio != INVALID_GPIO) {
-			DBG("%s : set spk ctl gpio LOW\n", __func__);
-			gpio_set_value(rk3190_priv->spk_ctl_gpio, GPIO_LOW);
-		}
-
-		if (rk3190_priv->hp_ctl_gpio != INVALID_GPIO) {
-			DBG("%s : set hp ctl gpio LOW\n", __func__);
-			gpio_set_value(rk3190_priv->hp_ctl_gpio, GPIO_LOW);
-			}
-
-		if (rk3190_for_mid)
-		{
-			snd_soc_update_bits(codec, RK3190_HPOUT_CTL,
-				RK3190_HPOUTL_MUTE_MSK, RK3190_HPOUTL_MUTE_EN);
-			snd_soc_update_bits(codec, RK3190_HPOUT_CTL,
-				RK3190_HPOUTR_MUTE_MSK, RK3190_HPOUTR_MUTE_EN);
-		}
-		else
-		{
-			snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-			snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-		}
-	}
-	snd_soc_dapm_sync(&codec->dapm);
-
-	is_hdmi_in = on ? 0 : 1;
-}
-
-#ifdef CONFIG_MACH_RK_FAC
-EXPORT_SYMBOL_GPL(rk3190_codec_set_spk);
-#else
-EXPORT_SYMBOL_GPL(codec_set_spk);
-#endif
-
 #if 0
 static const DECLARE_TLV_DB_SCALE(out_vol_tlv, -3900, 150, 0);
 static const DECLARE_TLV_DB_SCALE(pga_vol_tlv, -1800, 150, 0);
@@ -725,9 +661,6 @@ static int rk3190_playback_path_put(struct snd_kcontrol *kcontrol,
 		gpio_set_value(rk3190->hp_ctl_gpio, GPIO_LOW);
 	}
 
-	if(get_hdmi_state())
-		return 0;
-
 	switch (rk3190->playback_path) {
 	case OFF:
 		if (pre_path != OFF)
@@ -1925,7 +1858,6 @@ static int rk3190_codec_power_up(int type)
 				playback_power_up_list[i].value);
          msleep(10);
 		}
-		//codec_set_spk(!get_hdmi_state());
 	} else if (type == RK3190_CODEC_CAPTURE) {
 		for (i = 0; i < RK3190_CODEC_CAPTURE_POWER_UP_LIST_LEN; i++) {
 			snd_soc_write(codec, capture_power_up_list[i].reg,
diff --git a/sound/soc/codecs/rk3190_codec.h b/sound/soc/codecs/rk3190_codec.h
index 31ac86674299..a7847f56f76d 100755
--- a/sound/soc/codecs/rk3190_codec.h
+++ b/sound/soc/codecs/rk3190_codec.h
@@ -580,8 +580,6 @@ struct rk3190_init_bit_typ {
 	unsigned int init0_bit;	
 };
 
-bool get_hdmi_state(void);
-
 struct rk3190_codec_pdata {
 	int spk_ctl_gpio;
 	int hp_ctl_gpio;
diff --git a/sound/soc/codecs/rk610_codec.c b/sound/soc/codecs/rk610_codec.c
index 5b9ba870aa5e..86af3bec7969 100755
--- a/sound/soc/codecs/rk610_codec.c
+++ b/sound/soc/codecs/rk610_codec.c
@@ -135,24 +135,6 @@ static void spk_ctrl_fun(int status)
 	}
 }
 
-void rk610_codec_set_spk(bool on)
-{
-	struct rk610_codec_priv *rk610_codec;
-	if(!rk610_codec_codec)
-		return;
-		
-	rk610_codec=snd_soc_codec_get_drvdata(rk610_codec_codec);
-	if(!rk610_codec)
-		return;
-	
-	rk610_codec->hdmi_ndet = on;
-	if(on)
-		gpio_set_value(rk610_codec->spk_ctrl_io, GPIO_HIGH);
-	else
-		gpio_set_value(rk610_codec->spk_ctrl_io, GPIO_LOW);			
-}
-EXPORT_SYMBOL(rk610_codec_set_spk);
-
 /*
  * read rk610 register cache
  */
diff --git a/sound/soc/codecs/rk616_codec.c b/sound/soc/codecs/rk616_codec.c
index 4cd750105c88..97253c7e6231 100755
--- a/sound/soc/codecs/rk616_codec.c
+++ b/sound/soc/codecs/rk616_codec.c
@@ -13,6 +13,7 @@
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/of_gpio.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -23,7 +24,6 @@
 #include <linux/gpio.h>
 #include <linux/mfd/rk616.h>
 #include "rk616_codec.h"
-#include <mach/board.h>
 
 #if 0
 #define	DBG(x...)	printk(KERN_INFO x)
@@ -31,38 +31,6 @@
 #define	DBG(x...)
 #endif
 
-//#define RK616_HPMIC_FROM_LINEIN
-
-//#define RK616_HPMIC_FROM_MIC2IN
-
-//#define VIRTUAL_HPGND
-
-/* volume setting
- *  0: -39dB
- *  26: 0dB
- *  31: 6dB
- *  Step: 1.5dB
-*/
-#ifdef VIRTUAL_HPGND
-#define  SPKOUT_VOLUME    24 //0~31
-#define  HPOUT_VOLUME     20 //0~31
-#else
-#define  SPKOUT_VOLUME    24 //0~31
-#define  HPOUT_VOLUME     24 //0~31
-#endif
-
-/* volume setting
- *  0: -18dB
- *  12: 0dB
- *  31: 28.5dB
- *  Step: 1.5dB
-*/
-#define   CAPTURE_VOL     24 //0-31
-
-//sleep for MOSFET or SPK power amplifier chip
-#define SPK_AMP_DELAY 150
-#define HP_MOS_DELAY 50
-
 //for route
 #define RK616_CODEC_PLAYBACK	1
 #define RK616_CODEC_CAPTURE	2
@@ -75,6 +43,10 @@
 #define RK616_CODEC_SET_RCV	4
 #define RK616_CODEC_SET_MIC	8
 
+#define GPIO_LOW 0
+#define GPIO_HIGH 1
+#define INVALID_GPIO -1
+
 struct rk616_codec_priv {
 	struct snd_soc_codec *codec;
 
@@ -91,6 +63,17 @@ struct rk616_codec_priv {
 	bool rcv_gpio_level;
 	bool mic_gpio_level;
 
+	unsigned int spk_amp_delay;
+	unsigned int hp_mos_delay;
+
+	unsigned int spk_volume;
+	unsigned int hp_volume;
+	unsigned int capture_volume;
+
+	bool hpmic_from_linein;
+	bool hpmic_from_mic2in;
+	bool virtual_gnd;
+
 	long int playback_path;
 	long int capture_path;
 	long int voice_call_path;
@@ -100,7 +83,7 @@ struct rk616_codec_priv {
 
 static struct rk616_codec_priv *rk616_priv = NULL;
 static struct mfd_rk616 *rk616_mfd = NULL;
-static bool rk616_for_mid = 1, is_hdmi_in = false;
+static bool rk616_for_mid = 1;
 
 bool rk616_get_for_mid(void)
 {
@@ -590,88 +573,13 @@ static int rk616_set_gpio(int gpio, bool level)
 	}
 
 	if (gpio & RK616_CODEC_SET_SPK)
-		mdelay(SPK_AMP_DELAY);
+		mdelay(rk616->spk_amp_delay);
 	else if (gpio & RK616_CODEC_SET_HP)
-		mdelay(HP_MOS_DELAY);
+		mdelay(rk616->hp_mos_delay);
 
 	return 0;
 }
 
-bool get_hdmi_state(void)
-{
-	return is_hdmi_in;
-}
-
-#ifdef CONFIG_MACH_RK_FAC
-void rk616_codec_set_spk(bool on)
-#else
-void codec_set_spk(bool on)
-#endif
-{
-	struct rk616_codec_priv *rk616 = rk616_priv;
-	struct snd_soc_codec *codec;
-
-	DBG("%s : %s\n", __func__, on ? "enable spk" : "disable spk");
-
-	if (!rk616 || !rk616->codec) {
-		printk("%s : rk616_priv or rk616_priv->codec is NULL\n", __func__);
-		return;
-	}
-
-	codec = rk616->codec;
-
-	if (on) {
-		if (rk616_for_mid)
-		{
-			snd_soc_update_bits(codec, RK616_SPKL_CTL,
-				RK616_MUTE, 0);
-			snd_soc_update_bits(codec, RK616_SPKR_CTL,
-				RK616_MUTE, 0);
-			snd_soc_update_bits(codec, RK616_HPL_CTL,
-				RK616_MUTE, 0);
-			snd_soc_update_bits(codec, RK616_HPR_CTL,
-				RK616_MUTE, 0);
-		}
-		else
-		{
-			mutex_lock(&codec->mutex);
-			snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-			snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-			snd_soc_dapm_sync(&codec->dapm);
-			mutex_unlock(&codec->mutex);
-		}
-	} else {
-		rk616_set_gpio(RK616_CODEC_SET_SPK | RK616_CODEC_SET_HP, GPIO_LOW);
-
-		if (rk616_for_mid)
-		{
-			snd_soc_update_bits(codec, RK616_SPKL_CTL,
-				RK616_MUTE, RK616_MUTE);
-			snd_soc_update_bits(codec, RK616_SPKR_CTL,
-				RK616_MUTE, RK616_MUTE);
-			snd_soc_update_bits(codec, RK616_HPL_CTL,
-				RK616_MUTE, RK616_MUTE);
-			snd_soc_update_bits(codec, RK616_HPR_CTL,
-				RK616_MUTE, RK616_MUTE);
-		}
-		else
-		{
-			mutex_lock(&codec->mutex);
-			snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-			snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-			snd_soc_dapm_sync(&codec->dapm);
-			mutex_unlock(&codec->mutex);
-		}
-	}
-
-	is_hdmi_in = on ? 0 : 1;
-}
-#ifdef CONFIG_MACH_RK_FAC
-EXPORT_SYMBOL_GPL(rk616_codec_set_spk);
-#else
-EXPORT_SYMBOL_GPL(codec_set_spk);
-#endif
-
 static struct rk616_reg_val_typ playback_power_up_list[] = {
 	{0x804, 0x46}, //DAC DSM, 0x06: x1, 0x26: x1.25, 0x46: x1.5, 0x66: x1.75
 	{0x868, 0x02}, //power up
@@ -680,22 +588,12 @@ static struct rk616_reg_val_typ playback_power_up_list[] = {
 	{0x86c, 0x30}, //DACL/R INIT
 	{0x874, 0x14}, //Mux HPMIXR from HPMIXR(bit 0), Mux HPMIXL from HPMIXL(bit 1),HPMIXL/R power up
 	{0x878, 0xee}, //HPMIXL/HPMIXR from DACL/DACR(bit 4, bit 0)
-#ifdef VIRTUAL_HPGND
-	{0x898, 3<<5}, //power up HPOUTR (bit 7), volume (bit 0-4)
-	{0x894, 3<<5}, //power up HPOUTL (bit 7), volume (bit 0-4)
-	{0x898, 0x00}, //unmute HPOUTR (bit 5), volume (bit 0-4)
-	{0x894, 0x00}, //unmute HPOUTL (bit 5), volume (bit 0-4)
-#endif
-	{0x88c, 3<<5|SPKOUT_VOLUME},//power up SPKOUTL (bit 7), volume (bit 0-4)
-	{0x890, 3<<5|SPKOUT_VOLUME}, //power up SPKOUTR (bit 7), volume (bit 0-4)
-	{0x88c, SPKOUT_VOLUME}, //unmute SPKOUTL (bit 5), volume (bit 0-4)
-	{0x890, SPKOUT_VOLUME}, //unmute SPKOUTR (bit 5), volume (bit 0-4)
+	{0x88c, 2<<5},//power up SPKOUTL (bit 7)
+	{0x890, 2<<5}, //power up SPKOUTR (bit 7)
 };
 #define RK616_CODEC_PLAYBACK_POWER_UP_LIST_LEN ARRAY_SIZE(playback_power_up_list)
 
 static struct rk616_reg_val_typ playback_power_down_list[] = {
-	{0x898, 0xe0}, //mute HPOUTR (bit 5), volume (bit 0-4)
-	{0x894, 0xe0}, //mute HPOUTL (bit 5), volume (bit 0-4)
 	{0x890, 0xe0}, //mute SPKOUTR (bit 5), volume (bit 0-4)
 	{0x88c, 0xe0}, //mute SPKOUTL (bit 5), volume (bit 0-4)
 	{0x878, 0xff}, //HPMIXL/HPMIXR from DACL/DACR(bit 4, bit 0)
@@ -708,7 +606,7 @@ static struct rk616_reg_val_typ playback_power_down_list[] = {
 static struct rk616_reg_val_typ capture_power_up_list[] = {
 	{0x848, 0x06}, //MIXINL power up and unmute, MININL from MICMUX, MICMUX from BST_L
 	{0x84c, 0x3c}, //MIXINL from MIXMUX volume (bit 3-5)
-	{0x860, CAPTURE_VOL}, //PGAL power up unmute,volume (bit 0-4)
+	{0x860, 0x00}, //PGAL power up unmute
 	{0x828, 0x09}, //Set for Capture pop noise
 	{0x83c, 0x00}, //power up
 	{0x840, 0x69}, //BST_L power up, unmute, and Single-Ended(bit 6), volume 0-20dB(bit 5)
@@ -719,7 +617,7 @@ static struct rk616_reg_val_typ capture_power_up_list[] = {
 
 static struct rk616_reg_val_typ capture_power_down_list[] = {
 	{0x8a8, 0x3f}, //ADCL/R power down, and clear ADCL/R buf
-	{0x860, 0xc0 | CAPTURE_VOL}, //PGAL power down ,mute,volume 0dB(bit 0-4)
+	{0x860, 0xc0}, //PGAL power down ,mute
 	{0x84c, 0x3c}, //MIXINL from MIXMUX volume 0dB(bit 3-5)
 	{0x848, 0x1f}, //MIXINL power down and mute, MININL No selecting, MICMUX from BST_L
 	{0x840, 0x99}, //BST_L power down, mute, and Single-Ended(bit 6), volume 0(bit 5)
@@ -756,11 +654,16 @@ static int rk616_codec_power_up(int type)
 			snd_soc_write(codec, playback_power_up_list[i].reg,
 				playback_power_up_list[i].value);
 		}
-		#ifdef CONFIG_MACH_RK_FAC
-			rk616_codec_set_spk(!get_hdmi_state());
-		#else
-			codec_set_spk(!get_hdmi_state());
-		#endif
+
+		if (rk616->virtual_gnd) {
+			snd_soc_write(codec, 0x894, 0);
+			snd_soc_write(codec, 0x898, 0);
+		}
+
+		snd_soc_update_bits(codec, RK616_SPKL_CTL,
+			RK616_VOL_MASK, rk616->spk_volume); //, volume (bit 0-4)
+		snd_soc_update_bits(codec, RK616_SPKR_CTL,
+			RK616_VOL_MASK, rk616->spk_volume);
 	}
 
 	if (type & RK616_CODEC_CAPTURE) {
@@ -768,6 +671,8 @@ static int rk616_codec_power_up(int type)
 			snd_soc_write(codec, capture_power_up_list[i].reg,
 				capture_power_up_list[i].value);
 		}
+		snd_soc_update_bits(codec, RK616_PGAL_CTL,
+			RK616_VOL_MASK, rk616->capture_volume); //, volume (bit 0-4)
 	}
 
 	if (type & RK616_CODEC_INCALL) {
@@ -833,6 +738,11 @@ static int rk616_codec_power_down(int type)
 	}
 
 	if (type & RK616_CODEC_PLAYBACK) {
+		if (rk616->virtual_gnd) {
+			snd_soc_write(codec, 0x894, 0xe0);
+			snd_soc_write(codec, 0x898, 0xe0);
+		}
+
 		for (i = 0; i < RK616_CODEC_PLAYBACK_POWER_DOWN_LIST_LEN; i++) {
 			snd_soc_write(codec, playback_power_down_list[i].reg,
 				playback_power_down_list[i].value);
@@ -991,7 +901,7 @@ int snd_soc_put_pgal_volsw(struct snd_kcontrol *kcontrol,
 }
 
 //for setting volume pop noise, turn volume step up/down.
-int snd_soc_put_step_volsw_2r(struct snd_kcontrol *kcontrol,
+int snd_soc_put_step_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct soc_mixer_control *mc =
@@ -1146,8 +1056,8 @@ int snd_soc_put_gpio_enum_double(struct snd_kcontrol *kcontrol,
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
 		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
 	.tlv.p = (tlv_array), \
-	.info = snd_soc_info_volsw_2r, \
-	.get = snd_soc_get_volsw_2r, .put = snd_soc_put_step_volsw_2r, \
+	.info = snd_soc_info_volsw, \
+	.get = snd_soc_get_volsw, .put = snd_soc_put_step_volsw, \
 	.private_value = (unsigned long)&(struct soc_mixer_control) \
 		{.reg = reg_left, .rreg = reg_right, .shift = xshift, \
 		.max = xmax, .platform_max = xmax, .invert = xinvert} }
@@ -1158,15 +1068,15 @@ int snd_soc_put_gpio_enum_double(struct snd_kcontrol *kcontrol,
 	.get = snd_soc_get_gpio_enum_double, .put = snd_soc_put_gpio_enum_double, \
 	.private_value = (unsigned long)&xenum }
 
-static const struct snd_kcontrol_new rk616_snd_controls[] = {
+static struct snd_kcontrol_new rk616_snd_controls[] = {
 
 	//add for incall volume setting
 	SOC_DOUBLE_R_STEP_TLV("Speaker Playback Volume", RK616_SPKL_CTL,
-			RK616_SPKR_CTL, RK616_VOL_SFT, SPKOUT_VOLUME, 0, out_vol_tlv),
+			RK616_SPKR_CTL, RK616_VOL_SFT, 31, 0, out_vol_tlv),
 	SOC_DOUBLE_R_STEP_TLV("Headphone Playback Volume", RK616_HPL_CTL,
-			RK616_HPR_CTL, RK616_VOL_SFT, HPOUT_VOLUME, 0, out_vol_tlv),
+			RK616_HPR_CTL, RK616_VOL_SFT, 31, 0, out_vol_tlv),
 	SOC_DOUBLE_R_STEP_TLV("Earpiece Playback Volume", RK616_SPKL_CTL,
-			RK616_SPKR_CTL, RK616_VOL_SFT, SPKOUT_VOLUME, 0, out_vol_tlv),
+			RK616_SPKR_CTL, RK616_VOL_SFT, 31, 0, out_vol_tlv),
 
 	SOC_DOUBLE_R("Speaker Playback Switch", RK616_SPKL_CTL,
 		RK616_SPKR_CTL, RK616_MUTE_SFT, 1, 1),
@@ -1386,9 +1296,6 @@ static int rk616_playback_path_put(struct snd_kcontrol *kcontrol,
 	DBG("%s : set playback_path %ld, pre_path %ld\n", __func__,
 		rk616->playback_path, pre_path);
 
-	if(get_hdmi_state())
-		return 0;
-
 	switch (rk616->playback_path) {
 	case OFF:
 		if (pre_path != OFF)
@@ -1403,9 +1310,9 @@ static int rk616_playback_path_put(struct snd_kcontrol *kcontrol,
 			rk616_codec_power_up(RK616_CODEC_PLAYBACK);
 
 		snd_soc_update_bits(codec, RK616_SPKL_CTL,
-			RK616_VOL_MASK, SPKOUT_VOLUME); //, volume (bit 0-4)
+			RK616_VOL_MASK, rk616->spk_volume); //, volume (bit 0-4)
 		snd_soc_update_bits(codec, RK616_SPKR_CTL,
-			RK616_VOL_MASK, SPKOUT_VOLUME);
+			RK616_VOL_MASK, rk616->spk_volume);
 
 		rk616_set_gpio(RK616_CODEC_SET_SPK, GPIO_HIGH);
 		break;
@@ -1419,9 +1326,9 @@ static int rk616_playback_path_put(struct snd_kcontrol *kcontrol,
 			rk616_codec_power_up(RK616_CODEC_PLAYBACK);
 
 		snd_soc_update_bits(codec, RK616_SPKL_CTL,
-			RK616_VOL_MASK, HPOUT_VOLUME); //, volume (bit 0-4)
+			RK616_VOL_MASK, rk616->hp_volume); //, volume (bit 0-4)
 		snd_soc_update_bits(codec, RK616_SPKR_CTL,
-			RK616_VOL_MASK, HPOUT_VOLUME);
+			RK616_VOL_MASK, rk616->hp_volume);
 
 		rk616_set_gpio(RK616_CODEC_SET_HP, GPIO_HIGH);
 		break;
@@ -1433,9 +1340,9 @@ static int rk616_playback_path_put(struct snd_kcontrol *kcontrol,
 			rk616_codec_power_up(RK616_CODEC_PLAYBACK);
 
 		snd_soc_update_bits(codec, RK616_SPKL_CTL,
-			RK616_VOL_MASK, HPOUT_VOLUME); //, volume (bit 0-4)
+			RK616_VOL_MASK, rk616->hp_volume); //, volume (bit 0-4)
 		snd_soc_update_bits(codec, RK616_SPKR_CTL,
-			RK616_VOL_MASK, HPOUT_VOLUME);
+			RK616_VOL_MASK, rk616->hp_volume);
 
 		rk616_set_gpio(RK616_CODEC_SET_SPK | RK616_CODEC_SET_HP, GPIO_HIGH);
 		break;
@@ -1467,11 +1374,9 @@ static int rk616_capture_path_get(struct snd_kcontrol *kcontrol,
 static int rk616_capture_path_put(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct rk616_codec_priv *rk616 = rk616_priv;
 	long int pre_path;
-#if (defined RK616_HPMIC_FROM_LINEIN) || (defined RK616_HPMIC_FROM_MIC2IN)
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-#endif
 
 	if (!rk616) {
 		printk("%s : rk616_priv is NULL\n", __func__);
@@ -1498,28 +1403,26 @@ static int rk616_capture_path_put(struct snd_kcontrol *kcontrol,
 		if (pre_path == MIC_OFF)
 			rk616_codec_power_up(RK616_CODEC_CAPTURE);
 
-#ifdef RK616_HPMIC_FROM_LINEIN
-		snd_soc_write(codec, 0x848, 0x06); //MIXINL power up and unmute, MININL from MICMUX, MICMUX from BST_L
-#endif
+		if (rk616->hpmic_from_linein)
+			snd_soc_write(codec, 0x848, 0x06); //MIXINL power up and unmute, MININL from MICMUX, MICMUX from BST_L
 
-#ifdef RK616_HPMIC_FROM_MIC2IN
-	snd_soc_write(codec, 0x848, 0x06); //MIXINL power up and unmute, MININL from MICMUX, MICMUX from BST_L
-	snd_soc_write(codec, 0x840, 0x69); //BST_L power up, unmute, and Single-Ended(bit 6), volume 0-20dB(bit 5)
-#endif
+		if (rk616->hpmic_from_mic2in) {
+			snd_soc_write(codec, 0x848, 0x06); //MIXINL power up and unmute, MININL from MICMUX, MICMUX from BST_L
+			snd_soc_write(codec, 0x840, 0x69); //BST_L power up, unmute, and Single-Ended(bit 6), volume 0-20dB(bit 5)
+		}
 		rk616_set_gpio(RK616_CODEC_SET_MIC, GPIO_HIGH);
 		break;
 	case Hands_Free_Mic:
 		if (pre_path == MIC_OFF)
 			rk616_codec_power_up(RK616_CODEC_CAPTURE);
 
-#ifdef RK616_HPMIC_FROM_LINEIN
-		snd_soc_write(codec, 0x848, 0x03); //MIXINL power up and unmute, MININL from MICMUX, MICMUX from IN3L
-#endif
+		if (rk616->hpmic_from_linein)
+			snd_soc_write(codec, 0x848, 0x03); //MIXINL power up and unmute, MININL from MICMUX, MICMUX from IN3L
 
-#ifdef RK616_HPMIC_FROM_MIC2IN
-	snd_soc_write(codec, 0x848, 0x26); //MIXINL power up and unmute, MININL from MICMUX, MICMUX from BST_R
-	snd_soc_write(codec, 0x840, 0x96); //BST_R power up, unmute, and Single-Ended(bit 2), volume 0-20dB(bit 1)
-#endif
+		if (rk616->hpmic_from_mic2in) {
+			snd_soc_write(codec, 0x848, 0x26); //MIXINL power up and unmute, MININL from MICMUX, MICMUX from BST_R
+			snd_soc_write(codec, 0x840, 0x96); //BST_R power up, unmute, and Single-Ended(bit 2), volume 0-20dB(bit 1)
+		}
 		rk616_set_gpio(RK616_CODEC_SET_MIC, GPIO_LOW);
 		break;
 	case BT_Sco_Mic:
@@ -1867,7 +1770,7 @@ static int rk616_modem_input_put(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static const struct snd_kcontrol_new rk616_snd_path_controls[] = {
+static struct snd_kcontrol_new rk616_snd_path_controls[] = {
 	SOC_ENUM_EXT("Playback Path", rk616_playback_path_type,
 		rk616_playback_path_get, rk616_playback_path_put),
 
@@ -1882,12 +1785,12 @@ static const struct snd_kcontrol_new rk616_snd_path_controls[] = {
 
 	//add for incall volume setting
 	SOC_DOUBLE_R_STEP_TLV("Speaker Playback Volume", RK616_SPKL_CTL,
-			RK616_SPKR_CTL, RK616_VOL_SFT, SPKOUT_VOLUME, 0, out_vol_tlv),
+			RK616_SPKR_CTL, RK616_VOL_SFT, 31, 0, out_vol_tlv),
 	SOC_DOUBLE_R_STEP_TLV("Headphone Playback Volume", RK616_SPKL_CTL,
-			RK616_SPKR_CTL, RK616_VOL_SFT, HPOUT_VOLUME, 0, out_vol_tlv),
+			RK616_SPKR_CTL, RK616_VOL_SFT, 31, 0, out_vol_tlv),
 	//Earpiece incall volume is setting by modem
 	//SOC_DOUBLE_R_STEP_TLV("Earpiece Playback Volume", RK616_SPKL_CTL,
-			//RK616_SPKR_CTL, RK616_VOL_SFT, SPKOUT_VOLUME, 0, out_vol_tlv),
+			//RK616_SPKR_CTL, RK616_VOL_SFT, 31, 0, out_vol_tlv),
 
 	/*
 	* When modem connecting, it will make some pop noise.
@@ -2486,7 +2389,7 @@ static int rk616_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_codec *codec =rtd->codec;
 	struct rk616_codec_priv *rk616 = rk616_priv;
 	unsigned int rate = params_rate(params);
-	unsigned int div;
+	unsigned int div, dai_fmt = rtd->card->dai_link->dai_fmt;
 	unsigned int adc_aif1 = 0, adc_aif2  = 0, dac_aif1 = 0, dac_aif2  = 0;
 	u32 mfd_aif1 = 0, mfd_aif2 = 0, mfd_i2s_ctl = 0;
 
@@ -2495,21 +2398,21 @@ static int rk616_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-#ifdef CONFIG_SND_RK29_CODEC_SOC_MASTER
-	// bclk = codec_clk / 4
-	// lrck = bclk / (wl * 2)
-	div = (((rk616->stereo_sysclk / 4) / rate) / 2);
+	if ((dai_fmt & SND_SOC_DAIFMT_MASTER_MASK) == SND_SOC_DAIFMT_CBM_CFM) {
+		// bclk = codec_clk / 4
+		// lrck = bclk / (wl * 2)
+		div = (((rk616->stereo_sysclk / 4) / rate) / 2);
 
-	if ((rk616->stereo_sysclk % (4 * rate * 2) > 0) ||
-	    (div != 16 && div != 20 && div != 24 && div != 32)) {
-		printk("%s : need PLL\n", __func__);
-		return -EINVAL;
+		if ((rk616->stereo_sysclk % (4 * rate * 2) > 0) ||
+		    (div != 16 && div != 20 && div != 24 && div != 32)) {
+			printk("%s : need PLL\n", __func__);
+			return -EINVAL;
+		}
+	} else {
+		//If codec is slave mode, it don't need to set div
+		//according to sysclk and rate.
+		div = 32;
 	}
-#else
-	//If codec is slave mode, it don't need to set div
-	//according to sysclk and rate.
-	div = 32;
-#endif
 
 	switch (div) {
 	case 16:
@@ -2737,56 +2640,20 @@ static int rk616_resume(struct snd_soc_codec *codec)
 
 static int rk616_probe(struct snd_soc_codec *codec)
 {
-	struct rk616_codec_priv *rk616;
-	int ret;
+	struct rk616_codec_priv *rk616 = rk616_priv;
+	struct snd_kcontrol_new *kcontrol;
+	struct soc_mixer_control *mixer;
 	unsigned int val;
+	int ret, i, num_controls;
 
 	DBG("%s\n", __func__);
 
-	rk616 = kzalloc(sizeof(struct rk616_codec_priv), GFP_KERNEL);
 	if (!rk616) {
-		printk("%s : rk616 priv kzalloc failed!\n", __func__);
-		return -ENOMEM;
+		printk("%s : rk616 priv is NULL!\n", __func__);
+		return -EINVAL;
 	}
 
 	rk616->codec = codec;
-
-	if (rk616_mfd && rk616_mfd->pdata && rk616_mfd->pdata->spk_ctl_gpio) {
-		gpio_request(rk616_mfd->pdata->spk_ctl_gpio, NULL);
-		gpio_direction_output(rk616_mfd->pdata->spk_ctl_gpio, GPIO_LOW);
-		rk616->spk_ctl_gpio = rk616_mfd->pdata->spk_ctl_gpio;
-	} else {
-		printk("%s : rk616 or pdata or spk_ctl_gpio is NULL!\n", __func__);
-		rk616->spk_ctl_gpio = INVALID_GPIO;
-	}
-
-	if (rk616_mfd && rk616_mfd->pdata && rk616_mfd->pdata->hp_ctl_gpio) {
-		gpio_request(rk616_mfd->pdata->hp_ctl_gpio, NULL);
-		gpio_direction_output(rk616_mfd->pdata->hp_ctl_gpio, GPIO_LOW);
-		rk616->hp_ctl_gpio = rk616_mfd->pdata->hp_ctl_gpio;
-	} else {
-		printk("%s : rk616 or pdata or hp_ctl_gpio is NULL!\n", __func__);
-		rk616->hp_ctl_gpio = INVALID_GPIO;
-	}
-
-	if (rk616_mfd && rk616_mfd->pdata && rk616_mfd->pdata->rcv_ctl_gpio) {
-		gpio_request(rk616_mfd->pdata->rcv_ctl_gpio, NULL);
-		gpio_direction_output(rk616_mfd->pdata->rcv_ctl_gpio, GPIO_LOW);
-		rk616->rcv_ctl_gpio = rk616_mfd->pdata->rcv_ctl_gpio;
-	} else {
-		printk("%s : rk616 or pdata or rcv_ctl_gpio is NULL!\n", __func__);
-		rk616->rcv_ctl_gpio = INVALID_GPIO;
-	}
-
-	if (rk616_mfd && rk616_mfd->pdata && rk616_mfd->pdata->mic_sel_gpio) {
-		gpio_request(rk616_mfd->pdata->mic_sel_gpio, NULL);
-		gpio_direction_output(rk616_mfd->pdata->mic_sel_gpio, GPIO_LOW);
-		rk616->mic_sel_gpio = rk616_mfd->pdata->mic_sel_gpio;
-	} else {
-		printk("%s : rk616 or pdata or mic_sel_gpio is NULL!\n", __func__);
-		rk616->mic_sel_gpio = INVALID_GPIO;
-	}
-
 	rk616->playback_path = OFF;
 	rk616->capture_path = MIC_OFF;
 	rk616->voice_call_path = OFF;
@@ -2797,7 +2664,9 @@ static int rk616_probe(struct snd_soc_codec *codec)
 	rk616->mic_gpio_level = GPIO_LOW;
 	rk616->modem_input_enable = 1;
 
-	rk616_priv = rk616;
+	//virtual gnd will make hpout a litter louder.
+	if (rk616->virtual_gnd && (rk616->hp_volume >= 4))
+		rk616->hp_volume -= 4;
 
 	ret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_I2C);
 	if (ret != 0) {
@@ -2811,7 +2680,7 @@ static int rk616_probe(struct snd_soc_codec *codec)
 	codec->write = rk616_codec_write;
 
 	val = snd_soc_read(codec, RK616_RESET);
-	if (val != rk616_reg_defaults[RK616_RESET]) {
+	if (val != rk616_reg_defaults[RK616_RESET] && val != 0x43) {
 		printk("%s : codec register 0: %x is not a 0x00000003\n", __func__, val);
 		ret = -ENODEV;
 		goto err__;
@@ -2819,6 +2688,34 @@ static int rk616_probe(struct snd_soc_codec *codec)
 
 	rk616_reset(codec);
 
+	if  (rk616_for_mid) {
+		kcontrol = rk616_snd_path_controls;
+		num_controls = ARRAY_SIZE(rk616_snd_path_controls);
+	} else {
+		kcontrol = rk616_snd_controls;
+		num_controls = ARRAY_SIZE(rk616_snd_controls);
+	}
+
+	//update the max of volume controls for incall
+	for (i = 0; i < num_controls; i++) {
+		if (strcmp(kcontrol[i].name, "Speaker Playback Volume") == 0) {
+			mixer = (struct soc_mixer_control *)kcontrol[i].private_value;
+			printk("Speaker Playback Volume mixer->max %d\n", mixer->max);
+			mixer->max = rk616->spk_volume;
+			mixer->platform_max = rk616->spk_volume;
+		} else if (strcmp(kcontrol[i].name, "Headphone Playback Volume") == 0) {
+			mixer = (struct soc_mixer_control *)kcontrol[i].private_value;
+			printk("Headphone Playback Volume mixer->max %d\n", mixer->max);
+			mixer->max = rk616->hp_volume;
+			mixer->platform_max = rk616->hp_volume;
+		} else if (strcmp(kcontrol[i].name, "Earpiece Playback Volume") == 0) {
+			mixer = (struct soc_mixer_control *)kcontrol[i].private_value;
+			printk("Headphone Playback Volume mixer->max %d\n", mixer->max);
+			mixer->max = rk616->spk_volume;
+			mixer->platform_max = rk616->spk_volume;
+		}
+	}
+
 	if  (rk616_for_mid) {
 		snd_soc_add_codec_controls(codec, rk616_snd_path_controls,
 				ARRAY_SIZE(rk616_snd_path_controls));
@@ -2886,9 +2783,146 @@ static struct snd_soc_codec_driver soc_codec_dev_rk616 = {
 	.readable_register = rk616_codec_register,
 };
 
+static int rk616_codec_parse_gpio(struct device *dev,
+		struct device_node *node, int *gpio, char *name)
+{
+	enum of_gpio_flags flags;
+	int ret;
+
+	*gpio = of_get_named_gpio_flags(node, name, 0, &flags);
+	if (*gpio < 0) {
+		printk("%s : %s is NULL!\n", __func__, name);
+		*gpio = INVALID_GPIO;
+	} else {
+		ret = devm_gpio_request(dev, *gpio, name);
+		if(ret < 0){
+			printk("%s() %s request ERROR\n", __FUNCTION__, name);
+			return ret;
+		}
+		ret = gpio_direction_output(*gpio , flags); //set gpio to low level
+		if(ret < 0){
+			printk("%s() %s set ERROR\n", __FUNCTION__, name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/*
+dts:
+	rk616-codec {
+		spk-ctl-gpio = <&gpio2 GPIO_D7 GPIO_ACTIVE_HIGH>;
+		hp-ctl-gpio = <&gpio2 GPIO_D7 GPIO_ACTIVE_HIGH>;
+		//rcv-ctl-gpio = <&gpio2 GPIO_D7 GPIO_ACTIVE_HIGH>;
+		//mic-sel-gpio = <&gpio2 GPIO_D7 GPIO_ACTIVE_HIGH>;
+
+		//delay for MOSFET or SPK power amplifier chip(ms)
+		spk-amplifier-delay = <150>;
+		hp-mosfet-delay = <50>;
+
+		//hp-mic-capture-from-linein; //If hpmic is connected to linein, set this.
+		//hp-mic-capture-from-mic2in; //If hpmic is connected to mic2, set this.
+		//virtual-hp-gnd; //If hp gnd is not connected to gnd(0V), set this.
+
+		//volume setting: 0 ~ 31, -18dB ~ 28.5dB, Step: 1.5dB
+		skp-volume = <24>;
+		hp-volume = <24>;
+		capture-volume = <24>;
+	};
+*/
+#ifdef CONFIG_OF
+static int rk616_codec_parse_dt_property(struct device *dev,
+				  struct rk616_codec_priv *rk616)
+{
+	struct device_node *node = dev->of_node;
+	int ret;
+
+	DBG("%s()\n", __FUNCTION__);
+
+	if (!node) {
+		printk("%s() dev->of_node is NULL\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	node = of_get_child_by_name(dev->of_node, "rk616-codec");
+	if (!node) {
+		printk("%s() Can not get child: rk616-codec\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	ret = rk616_codec_parse_gpio(dev, node, &rk616->spk_ctl_gpio, "spk-ctl-gpio");
+	if(ret < 0){
+		printk("%s() parse gpio : spk-ctl-gpio ERROR\n", __FUNCTION__);
+		return ret;
+	}
+
+	ret = rk616_codec_parse_gpio(dev, node, &rk616->hp_ctl_gpio, "hp-ctl-gpio");
+	if((ret < 0) && (rk616->hp_ctl_gpio != rk616->spk_ctl_gpio)){
+		printk("%s() parse gpio : hp-ctl-gpio ERROR\n", __FUNCTION__);
+		return ret;
+	}
+
+	ret = rk616_codec_parse_gpio(dev, node, &rk616->rcv_ctl_gpio, "rcv-ctl-gpio");
+	if(ret < 0){
+		printk("%s() parse gpio : rcv-ctl-gpio ERROR\n", __FUNCTION__);
+		return ret;
+	}
+
+	ret = rk616_codec_parse_gpio(dev, node, &rk616->mic_sel_gpio, "mic-sel-gpio");
+	if(ret < 0){
+		printk("%s() parse gpio : mic-sel-gpio ERROR\n", __FUNCTION__);
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "spk-amplifier-delay", &rk616->spk_amp_delay);
+	if (ret < 0) {
+		DBG("%s() Can not read property spk-amplifier-delay\n", __FUNCTION__);
+		rk616->spk_amp_delay = 0;
+	}
+
+	ret = of_property_read_u32(node, "hp-mosfet-delay", &rk616->hp_mos_delay);
+	if (ret < 0) {
+		DBG("%s() Can not read property hp-mosfet-delay\n", __FUNCTION__);
+		rk616->hp_mos_delay = 0;
+	}
+
+	rk616->hpmic_from_linein = !!of_get_property(node, "hp-mic-capture-from-linein", NULL);
+	rk616->hpmic_from_mic2in = !!of_get_property(node, "hp-mic-capture-from-mic2in", NULL);
+	rk616->virtual_gnd = !!of_get_property(node, "virtual-hp-gnd", NULL);
+
+	ret = of_property_read_u32(node, "skp-volume", &rk616->spk_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property skp-volume\n", __FUNCTION__);
+		rk616->spk_volume = 24;
+	}
+
+	ret = of_property_read_u32(node, "hp-volume", &rk616->hp_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property hp-volume\n", __FUNCTION__);
+		rk616->hp_volume = 24;
+	}
+
+	ret = of_property_read_u32(node, "capture-volume", &rk616->capture_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property capture-volume\n", __FUNCTION__);
+		rk616->spk_volume = 24;
+	}
+
+	return 0;
+}
+#else
+static int rk616_codec_parse_dt_property(struct device *dev,
+				  struct rk616_codec_priv *rk616)
+{
+	return -ENOSYS;
+}
+#endif //#ifdef CONFIG_OF
+
 static int rk616_platform_probe(struct platform_device *pdev)
 {
 	struct mfd_rk616 *rk616 = dev_get_drvdata(pdev->dev.parent);
+	int ret;
 
 	DBG("%s\n", __func__);
 
@@ -2899,13 +2933,47 @@ static int rk616_platform_probe(struct platform_device *pdev)
 
 	rk616_mfd = rk616;
 
-	return snd_soc_register_codec(&pdev->dev,
+	rk616_priv = kzalloc(sizeof(struct rk616_codec_priv), GFP_KERNEL);
+	if (!rk616) {
+		printk("%s : rk616 priv kzalloc failed!\n", __func__);
+		return -ENOMEM;
+	}
+
+	//For sound card register(codec_of_node).
+	pdev->dev.of_node = pdev->dev.parent->of_node;
+
+	ret = rk616_codec_parse_dt_property(&pdev->dev, rk616_priv);
+	if (ret < 0) {
+		printk("%s() parse device tree property error %d\n", __FUNCTION__, ret);
+		goto err_;
+	}
+
+	ret = snd_soc_register_codec(&pdev->dev,
 			&soc_codec_dev_rk616, rk616_dai, ARRAY_SIZE(rk616_dai));
+	if (ret < 0) {
+		printk("%s() register codec error %d\n", __FUNCTION__, ret);
+		goto err_;
+	}
+
+	return 0;
+err_:
+	if (rk616_priv)
+		kfree(rk616_priv);
+	rk616_priv = NULL;
+	rk616_mfd = NULL;
+
+	return ret;
 }
 
 static int rk616_platform_remove(struct platform_device *pdev)
 {
 	snd_soc_unregister_codec(&pdev->dev);
+
+	if (rk616_priv)
+		kfree(rk616_priv);
+	rk616_priv = NULL;
+	rk616_mfd = NULL;
+
 	return 0;
 }
 
diff --git a/sound/soc/codecs/rk616_codec.h b/sound/soc/codecs/rk616_codec.h
index 1b45e850055b..8cf2cb89be5b 100755
--- a/sound/soc/codecs/rk616_codec.h
+++ b/sound/soc/codecs/rk616_codec.h
@@ -780,6 +780,5 @@ struct rk616_init_bit_typ {
 };
 
 bool rk616_get_for_mid(void);
-bool get_hdmi_state(void);
 
 #endif //__RK616_CODEC_H__
diff --git a/sound/soc/codecs/rt3261.c b/sound/soc/codecs/rt3261.c
index 7612984be5c2..705148aa9b4d 100755
--- a/sound/soc/codecs/rt3261.c
+++ b/sound/soc/codecs/rt3261.c
@@ -565,30 +565,6 @@ static int rt3261_readable_register(
 	}
 }
 
-void rt3261_codec_set_spk(bool on)
-{
-	struct snd_soc_codec *codec = rt3261_codec;
-	DBG("%s: %d\n", __func__, on);
-
-	if(!codec)
-		return;
-
-	mutex_lock(&codec->mutex);
-	if(on){
-		DBG("snd_soc_dapm_enable_pin\n");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-	}else{
-		DBG("snd_soc_dapm_disable_pin\n");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-	}
-	snd_soc_dapm_sync(&codec->dapm);
-	mutex_unlock(&codec->mutex);
-}
-
-
-
 /**
  * rt3261_headset_mic_detect - Detect headset.
  * @codec: SoC audio codec device.
diff --git a/sound/soc/codecs/rt3261.h b/sound/soc/codecs/rt3261.h
index 76434f5e8931..a462a7f56a3f 100755
--- a/sound/soc/codecs/rt3261.h
+++ b/sound/soc/codecs/rt3261.h
@@ -2166,6 +2166,5 @@ int rt3261_conn_mux_path(struct snd_soc_codec *codec,
 		char *widget_name, char *path_name);
 
 int rt3261_headset_mic_detect(int jack_insert);
-void rt3261_codec_set_spk(bool on);
 
 #endif /* __RT3261_H__ */
diff --git a/sound/soc/codecs/rt5616.c b/sound/soc/codecs/rt5616.c
index d4de5349c7cc..71f56aabfde4 100755
--- a/sound/soc/codecs/rt5616.c
+++ b/sound/soc/codecs/rt5616.c
@@ -1479,28 +1479,6 @@ static int rt5616_set_bias_level(struct snd_soc_codec *codec,
 	return 0;
 }
 
-void rt5616_codec_set_spk(bool on)
-{
-
-	struct snd_soc_codec *codec = rt5616_codec;
-	printk("%s: %d\n", __func__, on);
-
-	if(!codec)
-		return;
-
-	mutex_lock(&codec->mutex);
-	if(on){
-		printk(">>>> snd_soc_dapm_enable_pin\n");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-	}else{
-		printk(">>>> snd_soc_dapm_disable_pin\n");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-	}
-	snd_soc_dapm_sync(&codec->dapm);
-	mutex_unlock(&codec->mutex);
-}
 static int rt5616_probe(struct snd_soc_codec *codec)
 {
 	struct rt5616_priv *rt5616 = snd_soc_codec_get_drvdata(codec);
diff --git a/sound/soc/codecs/rt5621.c b/sound/soc/codecs/rt5621.c
index 5b9160e42279..ef4f006604bd 100644
--- a/sound/soc/codecs/rt5621.c
+++ b/sound/soc/codecs/rt5621.c
@@ -964,32 +964,6 @@ static int rt5621_reg_init(struct snd_soc_codec *codec)
 	return 0;
 }
 
-void rt5621_codec_set_spk(bool on)
-{
-	struct snd_soc_codec *codec = rt5621_codec; 
-
-	DBG("%s: %d\n", __func__, on);
-
-	if(!codec)
-		return;
-
-	if(on){
-		DBG("snd_soc_dapm_enable_pin\n");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-	}
-	else{
-
-		DBG("snd_soc_dapm_disable_pin\n");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-	}
-
-	snd_soc_dapm_sync(&codec->dapm);
-
-	return;
-}
-
 static void rt5621_work(struct work_struct *work)
 {
 	struct snd_soc_codec *codec = rt5621_codec;
diff --git a/sound/soc/codecs/rt5631.c b/sound/soc/codecs/rt5631.c
index 613a6161f22a..dc691fcbcdd1 100755
--- a/sound/soc/codecs/rt5631.c
+++ b/sound/soc/codecs/rt5631.c
@@ -2095,32 +2095,6 @@ static int rt5631_resume(struct snd_soc_codec *codec)
 	return 0;
 }
 
-void rt5631_codec_set_spk(bool on)
-{
-	struct snd_soc_codec *codec = rt5631_codec;	
-
-	DBG("%s: %d\n", __func__, on);
-		
-	if(!codec)
-		return;
-	mutex_lock(&codec->mutex);
-	if(on){
-		DBG("snd_soc_dapm_enable_pin\n");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-	}
-	else{
-		DBG("snd_soc_dapm_disable_pin\n");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-	}
-	snd_soc_dapm_sync(&codec->dapm);
-	mutex_unlock(&codec->mutex);
-
-	return;
-}
-EXPORT_SYMBOL_GPL(rt5631_codec_set_spk);
-
 /*
  * detect short current for mic1
  */
diff --git a/sound/soc/codecs/rt5640.c b/sound/soc/codecs/rt5640.c
index f49e1b54f720..6cba367ae048 100755
--- a/sound/soc/codecs/rt5640.c
+++ b/sound/soc/codecs/rt5640.c
@@ -196,9 +196,6 @@ static const u16 rt5640_reg[RT5640_VENDOR_ID2 + 1] = {
 	[RT5640_VENDOR_ID2] = 0x6231,
 };
 
-/* by magf for codec_set_spk */
-static struct snd_soc_codec *rt5640_codec;
-
 static int rt5640_reset(struct snd_soc_codec *codec)
 {
 	return snd_soc_write(codec, RT5640_RESET, 0);
@@ -3131,32 +3128,6 @@ static int rt5640_set_bias_level(struct snd_soc_codec *codec,
 	return 0;
 }
 
-/* add by magf for CONFIG_.._CTL_CODEC option */
-void rt5640_codec_set_spk(bool on)
-{
-    struct snd_soc_codec *codec = rt5640_codec;
-
-    pr_debug("%s: %d\n", __func__, on);
-
-    if(!codec)
-        return;
-    mutex_lock(&codec->mutex);
-    if(on){
-        pr_debug("snd_soc_dapm_enable_pin\n");
-        snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-        snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-    }
-    else{
-        pr_debug("snd_soc_dapm_disable_pin\n");
-        snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-        snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-    }
-
-    snd_soc_dapm_sync(&codec->dapm);
-    mutex_unlock(&codec->mutex);
-    return;
-}
-
 static int rt5640_probe(struct snd_soc_codec *codec)
 {
 	struct rt5640_priv *rt5640 = snd_soc_codec_get_drvdata(codec);
@@ -3207,9 +3178,6 @@ static int rt5640_probe(struct snd_soc_codec *codec)
 	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
 	rt5640->codec = codec;
 
-	/* by magf for codec_set_spk */
-	rt5640_codec = codec;
-
 	snd_soc_add_codec_controls(codec, rt5640_snd_controls,
 			ARRAY_SIZE(rt5640_snd_controls));
 	snd_soc_dapm_new_controls(&codec->dapm, rt5640_dapm_widgets,
diff --git a/sound/soc/rockchip/rk_rk616.c b/sound/soc/rockchip/rk_rk616.c
index be49e1dfb97a..b852d7f15335 100755
--- a/sound/soc/rockchip/rk_rk616.c
+++ b/sound/soc/rockchip/rk_rk616.c
@@ -31,6 +31,29 @@
 #define	DBG(x...)
 #endif
 
+#ifdef CONFIG_HDMI
+	extern int hdmi_is_insert(void);
+#endif
+
+#ifdef CONFIG_HDMI_RK30
+	extern int hdmi_get_hotplug(void);
+#endif
+
+static bool get_hdmi_state(void)
+{
+#ifdef CONFIG_HDMI
+	if(hdmi_is_insert())
+		return true;
+#endif
+
+#ifdef CONFIG_HDMI_RK30
+	if(hdmi_get_hotplug() == 2/*HDMI_HPD_ACTIVED*/)
+		return true;
+#endif
+
+			return false;
+}
+
 static const struct snd_soc_dapm_widget rk_dapm_widgets[] = {
 	SND_SOC_DAPM_MIC("Mic Jack", NULL),
 	SND_SOC_DAPM_MIC("Headset Jack", NULL),
@@ -263,7 +286,35 @@ static struct snd_soc_card rockchip_rk616_snd_card = {
 	.dai_link = rk_dai,
 	.num_links = 2,
 };
-
+/*
+dts:
+	rockchip-rk616 {
+		compatible = "rockchip-rk616";
+		dais {
+			dai0 {
+				audio-codec = <&rk616>;
+				i2s-controller = <&i2s0>;
+				format = "i2s";
+				//continuous-clock;
+				//bitclock-inversion;
+				//frame-inversion;
+				//bitclock-master;
+				//frame-master;
+			};
+
+			dai1 {
+				audio-codec = <&rk616>;
+				i2s-controller = <&i2s0>;
+				format = "dsp_a";
+				//continuous-clock;
+				bitclock-inversion;
+				//frame-inversion;
+				//bitclock-master;
+				//frame-master;
+			};
+		};
+	};
+*/
 static int rockchip_rk616_audio_probe(struct platform_device *pdev)
 {
 	int ret;
diff --git a/sound/soc/rockchip/rk_rt3261.c b/sound/soc/rockchip/rk_rt3261.c
index 0dbdae131cad..2fc52b17fb0f 100644
--- a/sound/soc/rockchip/rk_rt3261.c
+++ b/sound/soc/rockchip/rk_rt3261.c
@@ -210,18 +210,6 @@ static int rockchip_rt3261_init(struct snd_soc_pcm_runtime *rtd)
 	snd_soc_dapm_enable_pin(dapm, "Headset Jack");
 	snd_soc_dapm_enable_pin(dapm, "Ext Spk");
 	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
-#ifdef CONFIG_HDMI
-	extern int hdmi_is_insert(void);
-	extern void codec_set_spk(bool on);         
-	if(hdmi_is_insert())                 
-		rt3261_codec_set_spk(false);
-#endif
-
-#ifdef CONFIG_HDMI_RK30
-	extern int hdmi_get_hotplug(void);
-	if(hdmi_get_hotplug() == 2/*HDMI_HPD_ACTIVED*/)
-		rt3261_codec_set_spk(false);
-#endif
 
 	snd_soc_dapm_sync(dapm);
 
diff --git a/sound/soc/rockchip/rk_rt5512.c b/sound/soc/rockchip/rk_rt5512.c
index 4fec97e54b77..3737d70ba40d 100755
--- a/sound/soc/rockchip/rk_rt5512.c
+++ b/sound/soc/rockchip/rk_rt5512.c
@@ -36,7 +36,7 @@ static int rk29_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-        unsigned int pll_out = 0, dai_fmt = cpu_dai->card->dai_link[0].dai_fmt;
+        unsigned int pll_out = 0;
         unsigned int pll_div, dai_fmt = rtd->dai_link->dai_fmt;
 	int ret;
 
diff --git a/sound/soc/rockchip/rk_rt5640.c b/sound/soc/rockchip/rk_rt5640.c
index e296ae1821fa..dd0a620b48ad 100755
--- a/sound/soc/rockchip/rk_rt5640.c
+++ b/sound/soc/rockchip/rk_rt5640.c
@@ -210,18 +210,6 @@ static int rk29_rt5640_init(struct snd_soc_pcm_runtime *rtd)
 	snd_soc_dapm_enable_pin(dapm, "Headset Jack");
 	snd_soc_dapm_enable_pin(dapm, "Ext Spk");
 	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
-#ifdef CONFIG_HDMI
-	extern int hdmi_is_insert(void);
-	extern void codec_set_spk(bool on);         
-	if(hdmi_is_insert())                 
-		codec_set_spk(false);
-#endif
-
-#ifdef CONFIG_HDMI_RK30
-	extern int hdmi_get_hotplug(void);
-	if(hdmi_get_hotplug() == 2/*HDMI_HPD_ACTIVED*/)
-		codec_set_spk(false);
-#endif
 
 	snd_soc_dapm_sync(dapm);
 
diff --git a/sound/soc/rockchip/rk_wm8994.c b/sound/soc/rockchip/rk_wm8994.c
index 4139c9b7a26d..d0adf39e0ba8 100755
--- a/sound/soc/rockchip/rk_wm8994.c
+++ b/sound/soc/rockchip/rk_wm8994.c
@@ -312,12 +312,7 @@ static int rk29_wm8994_init(struct snd_soc_pcm_runtime *rtd)
 //	snd_soc_dapm_nc_pin(dapm, "LINEOUT1P");
 	snd_soc_dapm_nc_pin(dapm, "LINEOUT2N");
 	snd_soc_dapm_nc_pin(dapm, "LINEOUT2P");
-#ifdef CONFIG_HDMI
-extern int hdmi_is_insert(void);
-extern void codec_set_spk(bool on);
-	if(hdmi_is_insert())
-		codec_set_spk(false);
-#endif
+
 	snd_soc_dapm_sync(dapm);
 
 	/* Headset jack detection */
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4344a985ced4..65d91b57c7e6 100755
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1722,7 +1722,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	snd_soc_dapm_new_widgets(&card->dapm);
 
-//dai_fmt will and need to be setted in hw_parsms for codecs, so ingore here.
+//dai_fmt will and need to be setted in hw_parsms for codecs, so ignore here.
 #ifndef CONFIG_SND_RK_SOC
 	for (i = 0; i < card->num_links; i++) {
 		dai_link = &card->dai_link[i];
-- 
2.35.3

