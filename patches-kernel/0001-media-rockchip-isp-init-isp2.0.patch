From 8d2efa7f5e50e16239f4ba71d2eaea32c6de3566 Mon Sep 17 00:00:00 2001
From: Cai YiWei <cyw@rock-chips.com>
Date: Thu, 2 Jan 2020 16:02:56 +0800
Subject: [PATCH] media: rockchip: isp: init isp2.0

Change-Id: Ia22c5eefc931280dca77201dea420aff622f1e82
Signed-off-by: Cai YiWei <cyw@rock-chips.com>
---
 drivers/media/platform/rockchip/isp/Makefile  |    4 +-
 drivers/media/platform/rockchip/isp/capture.c | 1250 +++++++++--
 drivers/media/platform/rockchip/isp/capture.h |   33 +-
 drivers/media/platform/rockchip/isp/common.h  |   12 +-
 drivers/media/platform/rockchip/isp/csi.c     |  489 +++++
 drivers/media/platform/rockchip/isp/csi.h     |   69 +
 drivers/media/platform/rockchip/isp/dev.c     |  172 +-
 drivers/media/platform/rockchip/isp/dev.h     |   69 +-
 drivers/media/platform/rockchip/isp/dmarx.c   |  255 ++-
 drivers/media/platform/rockchip/isp/dmarx.h   |   12 +-
 .../media/platform/rockchip/isp/isp_params.c  |   22 +-
 .../media/platform/rockchip/isp/isp_stats.c   |   15 +-
 drivers/media/platform/rockchip/isp/mpfbc.c   |  322 +++
 drivers/media/platform/rockchip/isp/mpfbc.h   |   34 +
 drivers/media/platform/rockchip/isp/regs.c    |    3 +-
 drivers/media/platform/rockchip/isp/regs.h    |   23 +-
 .../media/platform/rockchip/isp/regs_v2x.h    | 1922 +++++++++++++++++
 drivers/media/platform/rockchip/isp/rkisp.c   |  511 +++--
 drivers/media/platform/rockchip/isp/rkisp.h   |    6 +
 include/uapi/linux/rk-camera-module.h         |   52 +
 20 files changed, 4705 insertions(+), 570 deletions(-)
 create mode 100644 drivers/media/platform/rockchip/isp/csi.c
 create mode 100644 drivers/media/platform/rockchip/isp/csi.h
 create mode 100644 drivers/media/platform/rockchip/isp/mpfbc.c
 create mode 100644 drivers/media/platform/rockchip/isp/mpfbc.h
 create mode 100644 drivers/media/platform/rockchip/isp/regs_v2x.h

diff --git a/drivers/media/platform/rockchip/isp/Makefile b/drivers/media/platform/rockchip/isp/Makefile
index d919446b9ada..c9c1c8a2ec08 100644
--- a/drivers/media/platform/rockchip/isp/Makefile
+++ b/drivers/media/platform/rockchip/isp/Makefile
@@ -7,4 +7,6 @@ video_rkisp-objs += rkisp.o \
 			isp_stats.o \
 			isp_params.o \
 			capture.o \
-			dmarx.o
+			dmarx.o \
+			csi.o \
+			mpfbc.o
diff --git a/drivers/media/platform/rockchip/isp/capture.c b/drivers/media/platform/rockchip/isp/capture.c
index 1eb140fa3c48..d3b22af5965f 100644
--- a/drivers/media/platform/rockchip/isp/capture.c
+++ b/drivers/media/platform/rockchip/isp/capture.c
@@ -43,25 +43,6 @@
 #include "dev.h"
 #include "regs.h"
 
-/*
- * NOTE:
- * 1. There are two capture video devices in rkisp, selfpath and mainpath
- * 2. Two capture device have separated memory-interface/crop/scale units.
- * 3. Besides describing stream hardware, this file also contain entries
- *    for pipeline operations.
- * 4. The register read/write operations in this file are put into regs.c.
- */
-
-/*
- * differences between selfpatch and mainpath
- * available mp sink input: isp
- * available sp sink input : isp, dma(TODO)
- * available mp sink pad fmts: yuv422, raw
- * available sp sink pad fmts: yuv422, yuv420......
- * available mp source fmts: yuv, raw, jpeg(TODO)
- * available sp source fmts: yuv, rgb
- */
-
 #define CIF_ISP_REQ_BUFS_MIN			0
 #define CIF_ISP_REQ_BUFS_MAX			8
 
@@ -71,7 +52,7 @@
 #define STREAM_MAX_MP_RSZ_OUTPUT_WIDTH		4416
 #define STREAM_MAX_MP_RSZ_OUTPUT_HEIGHT		3312
 #define STREAM_MAX_SP_RSZ_OUTPUT_WIDTH		1920
-#define STREAM_MAX_SP_RSZ_OUTPUT_HEIGHT		1920
+#define STREAM_MAX_SP_RSZ_OUTPUT_HEIGHT		1080
 #define STREAM_MIN_RSZ_OUTPUT_WIDTH		32
 #define STREAM_MIN_RSZ_OUTPUT_HEIGHT		16
 #define STREAM_OUTPUT_STEP_WISE			8
@@ -81,6 +62,8 @@
 #define STREAM_MIN_MP_SP_INPUT_WIDTH		32
 #define STREAM_MIN_MP_SP_INPUT_HEIGHT		32
 
+static int mi_frame_end(struct rkisp_stream *stream);
+
 /* Get xsubs and ysubs for fourcc formats
  *
  * @xsubs: horizontal color samples in a 4*4 matrix, for yuv
@@ -468,7 +451,7 @@ static const struct capture_fmt sp_fmts[] = {
 	}
 };
 
-static const struct capture_fmt raw_fmts[] = {
+static const struct capture_fmt dmatx_fmts[] = {
 	/* raw */
 	{
 		.fourcc = V4L2_PIX_FMT_SRGGB8,
@@ -541,6 +524,7 @@ static struct stream_config rkisp_mp_stream_config = {
 	.max_rsz_height = STREAM_MAX_MP_RSZ_OUTPUT_HEIGHT,
 	.min_rsz_width = STREAM_MIN_RSZ_OUTPUT_WIDTH,
 	.min_rsz_height = STREAM_MIN_RSZ_OUTPUT_HEIGHT,
+	.frame_end_id = CIF_MI_MP_FRAME,
 	/* registers */
 	.rsz = {
 		.ctrl = CIF_MRSZ_CTRL,
@@ -596,6 +580,7 @@ static struct stream_config rkisp_sp_stream_config = {
 	.max_rsz_height = STREAM_MAX_SP_RSZ_OUTPUT_HEIGHT,
 	.min_rsz_width = STREAM_MIN_RSZ_OUTPUT_WIDTH,
 	.min_rsz_height = STREAM_MIN_RSZ_OUTPUT_HEIGHT,
+	.frame_end_id = CIF_MI_SP_FRAME,
 	/* registers */
 	.rsz = {
 		.ctrl = CIF_SRSZ_CTRL,
@@ -643,11 +628,104 @@ static struct stream_config rkisp_sp_stream_config = {
 	},
 };
 
-static struct stream_config rkisp_raw_stream_config = {
-	.fmts = raw_fmts,
-	.fmt_size = ARRAY_SIZE(raw_fmts),
+static struct stream_config rkisp1_dmatx0_stream_config = {
+	.fmts = dmatx_fmts,
+	.fmt_size = ARRAY_SIZE(dmatx_fmts),
+};
+
+static struct stream_config rkisp2_dmatx0_stream_config = {
+	.fmts = dmatx_fmts,
+	.fmt_size = ARRAY_SIZE(dmatx_fmts),
+	.frame_end_id = MI_RAW0_WR_FRAME,
+	.mi = {
+		.y_size_init = MI_RAW0_WR_SIZE,
+		.y_base_ad_init = MI_RAW0_WR_BASE,
+		.y_base_ad_shd = MI_RAW0_WR_BASE_SHD,
+	},
+	.dma = {
+		.ctrl = CSI2RX_RAW0_WR_CTRL,
+		.pic_size = CSI2RX_RAW0_WR_PIC_SIZE,
+		.pic_offs = CSI2RX_RAW0_WR_PIC_OFF,
+	},
+};
+
+static struct stream_config rkisp2_dmatx1_stream_config = {
+	.fmts = dmatx_fmts,
+	.fmt_size = ARRAY_SIZE(dmatx_fmts),
+	.frame_end_id = MI_RAW1_WR_FRAME,
+	.mi = {
+		.y_size_init = MI_RAW1_WR_SIZE,
+		.y_base_ad_init = MI_RAW1_WR_BASE,
+		.y_base_ad_shd = MI_RAW1_WR_BASE_SHD,
+	},
+	.dma = {
+		.ctrl = CSI2RX_RAW1_WR_CTRL,
+		.pic_size = CSI2RX_RAW1_WR_PIC_SIZE,
+		.pic_offs = CSI2RX_RAW1_WR_PIC_OFF,
+	},
+};
+
+static struct stream_config rkisp2_dmatx2_stream_config = {
+	.fmts = dmatx_fmts,
+	.fmt_size = ARRAY_SIZE(dmatx_fmts),
+	.frame_end_id = MI_RAW2_WR_FRAME,
+	.mi = {
+		.y_size_init = MI_RAW2_WR_SIZE,
+		.y_base_ad_init = MI_RAW2_WR_BASE,
+		.y_base_ad_shd = MI_RAW2_WR_BASE_SHD,
+	},
+	.dma = {
+		.ctrl = CSI2RX_RAW2_WR_CTRL,
+		.pic_size = CSI2RX_RAW2_WR_PIC_SIZE,
+		.pic_offs = CSI2RX_RAW2_WR_PIC_OFF,
+	},
 };
 
+static struct stream_config rkisp2_dmatx3_stream_config = {
+	.fmts = dmatx_fmts,
+	.fmt_size = ARRAY_SIZE(dmatx_fmts),
+	.frame_end_id = MI_RAW3_WR_FRAME,
+	.mi = {
+		.y_size_init = MI_RAW3_WR_SIZE,
+		.y_base_ad_init = MI_RAW3_WR_BASE,
+		.y_base_ad_shd = MI_RAW3_WR_BASE_SHD,
+	},
+	.dma = {
+		.ctrl = CSI2RX_RAW3_WR_CTRL,
+		.pic_size = CSI2RX_RAW3_WR_PIC_SIZE,
+		.pic_offs = CSI2RX_RAW3_WR_PIC_OFF,
+	},
+};
+
+static int hdr_dma_frame(struct rkisp_device *dev)
+{
+	int max_dma;
+
+	switch (dev->hdr.op_mode) {
+	case HDR_FRAMEX2_DDR:
+	case HDR_LINEX2_DDR:
+	case HDR_DBG_FRAME1:
+		max_dma = 1;
+		break;
+	case HDR_FRAMEX3_DDR:
+	case HDR_LINEX3_DDR:
+	case HDR_DBG_FRAME2:
+		max_dma = 2;
+		break;
+	case HDR_DBG_FRAME3:
+		max_dma = HDR_DMA_MAX;
+		break;
+	case HDR_LINEX2_NO_DDR:
+	case HDR_LINEX3_NO_DDR:
+	case HDR_NORMAL:
+	default:
+		max_dma = 0;
+	}
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s %d\n", __func__, max_dma);
+	return max_dma;
+}
+
 static const
 struct capture_fmt *find_fmt(struct rkisp_stream *stream, const u32 pixelfmt)
 {
@@ -703,7 +781,8 @@ static int rkisp_config_rsz(struct rkisp_stream *stream, bool async)
 	u32 xsubs_in = 1, ysubs_in = 1;
 	u32 xsubs_out = 1, ysubs_out = 1;
 
-	if (input_isp_fmt->fmt_type == FMT_BAYER)
+	if (input_isp_fmt->fmt_type == FMT_BAYER ||
+	    dev->mpfbc_dev.en)
 		goto disable;
 
 	/* set input and output sizes for scale calculation */
@@ -774,7 +853,9 @@ static u32 calc_burst_len(struct rkisp_stream *stream)
 
 	/* MI128bit and MI64bit */
 	bus = 8;
-	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13)
+	if (dev->isp_ver == ISP_V12 ||
+	    dev->isp_ver == ISP_V13 ||
+	    dev->isp_ver == ISP_V20)
 		bus = 16;
 
 	/* y/c base addr: burstN * bus alignment */
@@ -804,8 +885,8 @@ static u32 calc_burst_len(struct rkisp_stream *stream)
 
 	stream->burst = burst;
 	for (i = 0; i < RKISP_MAX_STREAM; i++)
-		if (burst > dev->stream[i].burst)
-			burst = dev->stream[i].burst;
+		if (burst > dev->cap_dev.stream[i].burst)
+			burst = dev->cap_dev.stream[i].burst;
 
 	if (stream->interlaced) {
 		if (!stream->out_fmt.width % (bus * 16))
@@ -907,59 +988,216 @@ static int sp_config_mi(struct rkisp_stream *stream)
 	return 0;
 }
 
-/*
- * configure memory interface for rawpath
- * This should only be called when stream-on
- */
-static int raw_config_mi(struct rkisp_stream *stream)
+static int dmatx3_config_mi(struct rkisp_stream *stream)
 {
 	void __iomem *base = stream->ispdev->base_addr;
 	struct rkisp_device *dev = stream->ispdev;
-	struct v4l2_mbus_framefmt *in_frm;
+	struct rkisp_csi_device *csi = &dev->csi_dev;
 	u32 in_size;
+	u8 vc;
+
+	if (!csi->sink[CSI_SRC_CH4 - 1].linked ||
+	    stream->streaming)
+		return -EBUSY;
 
 	if (!dev->active_sensor ||
 	    (dev->active_sensor &&
 	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2)) {
-		if (stream->id == RKISP_STREAM_RAW)
-			v4l2_err(&dev->v4l2_dev,
-				 "only mipi sensor support raw path\n");
+		v4l2_err(&dev->v4l2_dev,
+			 "only mipi sensor support rawwr3\n");
+		return -EINVAL;
+	}
+	atomic_set(&stream->sequence, 0);
+	in_size = stream->out_fmt.plane_fmt[0].sizeimage;
+	raw_wr_set_pic_size(stream,
+			    stream->out_fmt.width,
+			    stream->out_fmt.height);
+	raw_wr_set_pic_offs(stream, 0);
+
+	vc = csi->sink[CSI_SRC_CH4 - 1].index;
+	raw_wr_ctrl(stream,
+		SW_CSI_RAW_WR_CH_EN(vc) |
+		SW_CSI_RAW_WR_SIMG_MODE |
+		SW_CSI_RWA_WR_SIMG_SWP);
+	mi_set_y_size(stream, in_size);
+	mi_frame_end(stream);
+	mi_frame_end_int_enable(stream);
+	mi_wr_ctrl2(base, SW_RAW3_WR_AUTOUPD);
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "rawwr3 %dx%d ctrl:0x%x\n",
+		 stream->out_fmt.width,
+		 stream->out_fmt.height,
+		 readl(base + CSI2RX_RAW3_WR_CTRL));
+	return 0;
+}
+
+static int dmatx2_config_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_csi_device *csi = &dev->csi_dev;
+	u32 val, in_size;
+	u8 vc;
+
+	if (!csi->sink[CSI_SRC_CH3 - 1].linked ||
+	    stream->streaming)
+		return -EBUSY;
+
+	if (!dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2)) {
+		v4l2_err(&dev->v4l2_dev,
+			 "only mipi sensor support rawwr2 path\n");
 		return -EINVAL;
 	}
 
-	if (dev->stream[RKISP_STREAM_RAW].streaming)
-		return 0;
+	if (!stream->u.dmatx.is_config) {
+		atomic_set(&stream->sequence, 0);
+		in_size = stream->out_fmt.plane_fmt[0].sizeimage;
+		raw_wr_set_pic_size(stream,
+				    stream->out_fmt.width,
+				    stream->out_fmt.height);
+		raw_wr_set_pic_offs(stream, 0);
+		vc = csi->sink[CSI_SRC_CH3 - 1].index;
+		val = SW_CSI_RAW_WR_CH_EN(vc);
+		if (IS_HDR_DBG(dev->hdr.op_mode) ||
+		    dev->hdr.op_mode == HDR_NORMAL)
+			val |= SW_CSI_RWA_WR_SIMG_SWP |
+				SW_CSI_RAW_WR_SIMG_MODE;
+		if (dev->hdr.op_mode != HDR_NORMAL)
+			val |= SW_CSI_RAW_WR_EN_ORG;
+		raw_wr_ctrl(stream, val);
+		mi_set_y_size(stream, in_size);
+		mi_frame_end(stream);
+		mi_frame_end_int_enable(stream);
+		mi_wr_ctrl2(base, SW_RAW2_WR_AUTOUPD);
+		stream->u.dmatx.is_config = true;
+	}
+	return 0;
+}
 
-	in_frm = &dev->active_sensor->fmt.format;
+static int dmatx1_config_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_csi_device *csi = &dev->csi_dev;
+	u32 val, in_size;
+	u8 vc;
 
-	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
-		 "stream:%d input %dx%d\n",
-		 stream->id, in_frm->width, in_frm->height);
+	if (!csi->sink[CSI_SRC_CH2 - 1].linked ||
+	    stream->streaming)
+		return -EBUSY;
+
+	if (!dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2)) {
+		if (stream->id == RKISP_STREAM_DMATX1)
+			v4l2_err(&dev->v4l2_dev,
+				 "only mipi sensor support dmatx1 path\n");
+		return -EINVAL;
+	}
 
-	/* raw output size equal to sensor input size */
-	if (stream->id == RKISP_STREAM_RAW) {
+	if (!stream->u.dmatx.is_config) {
+		atomic_set(&stream->sequence, 0);
 		in_size = stream->out_fmt.plane_fmt[0].sizeimage;
+		raw_wr_set_pic_size(stream,
+				    stream->out_fmt.width,
+				    stream->out_fmt.height);
+		raw_wr_set_pic_offs(stream, 0);
+		vc = csi->sink[CSI_SRC_CH2 - 1].index;
+		val = SW_CSI_RAW_WR_CH_EN(vc);
+		if (IS_HDR_DBG(dev->hdr.op_mode) ||
+		    dev->hdr.op_mode == HDR_NORMAL)
+			val |= SW_CSI_RWA_WR_SIMG_SWP |
+				SW_CSI_RAW_WR_SIMG_MODE;
+		if (dev->hdr.op_mode != HDR_NORMAL)
+			val |= SW_CSI_RAW_WR_EN_ORG;
+		raw_wr_ctrl(stream, val);
+		mi_set_y_size(stream, in_size);
+		mi_frame_end(stream);
+		mi_frame_end_int_enable(stream);
+		mi_wr_ctrl2(base, SW_RAW1_WR_AUTOUPD);
+		stream->u.dmatx.is_config = true;
+	}
+	return 0;
+}
+
+static int dmatx0_config_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_csi_device *csi = &dev->csi_dev;
+	struct rkisp_stream *dmatx =
+		&dev->cap_dev.stream[RKISP_STREAM_DMATX0];
+	u32 val, in_size;
+	u8 vc;
+
+	if (!csi->sink[CSI_SRC_CH1 - 1].linked ||
+	    dmatx->streaming)
+		return -EBUSY;
+
+	if (!dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2)) {
+		if (stream->id == RKISP_STREAM_DMATX0)
+			v4l2_err(&dev->v4l2_dev,
+				 "only mipi sensor support rawwr0 path\n");
+		return -EINVAL;
+	}
+
+	/* dmatx0 output size equal to sensor input size */
+	in_size = dmatx->out_fmt.plane_fmt[0].sizeimage;
+	if (dev->isp_ver == ISP_V20) {
+		if (dmatx->u.dmatx.is_config)
+			return 0;
+		atomic_set(&dmatx->sequence, 0);
+		raw_wr_set_pic_size(dmatx,
+				    dmatx->out_fmt.width,
+				    dmatx->out_fmt.height);
+		raw_wr_set_pic_offs(dmatx, 0);
+		raw_rd_set_pic_size(base,
+				    dmatx->out_fmt.width,
+				    dmatx->out_fmt.height);
+		vc = csi->sink[CSI_SRC_CH1 - 1].index;
+		val = SW_CSI_RAW_WR_CH_EN(vc);
+		if (IS_HDR_DBG(dev->hdr.op_mode) ||
+		    dev->hdr.op_mode == HDR_NORMAL)
+			val |= SW_CSI_RWA_WR_SIMG_SWP |
+				SW_CSI_RAW_WR_SIMG_MODE;
+		if (dev->hdr.op_mode != HDR_NORMAL)
+			val |= SW_CSI_RAW_WR_EN_ORG;
+		raw_wr_ctrl(dmatx, val);
+		mi_set_y_size(dmatx, in_size);
+		mi_frame_end(dmatx);
+		mi_frame_end_int_enable(dmatx);
+		mi_wr_ctrl2(base, SW_RAW0_WR_AUTOUPD);
+		dmatx->u.dmatx.is_config = true;
 	} else {
-		struct rkisp_stream *raw = &dev->stream[RKISP_STREAM_RAW];
-
-		in_size = raw->out_fmt.plane_fmt[0].sizeimage;
-	}
-
-	dmatx0_set_pic_size(base, in_frm->width, in_frm->height);
-	dmatx0_set_pic_off(base, 0);
-	dmatx0_ctrl(base,
-		CIF_ISP_CSI0_DMATX0_VC(1) |
-		CIF_ISP_CSI0_DMATX0_SIMG_SWP |
-		CIF_ISP_CSI0_DMATX0_SIMG_MODE);
-	mi_raw0_set_size(base, in_size);
-	mi_raw0_set_offs(base, 0);
-	mi_raw0_set_length(base, 0);
-	mi_raw0_set_irq_offs(base, 0);
-	/* dummy buf for raw first address shadow */
-	mi_raw0_set_addr(base, stream->dummy_buf.dma_addr);
-	mi_ctrl2(base, CIF_MI_CTRL2_MIPI_RAW0_AUTO_UPDATE);
-	if (stream->id == RKISP_STREAM_RAW)
-		stream->u.raw.pre_stop = false;
+		dmatx0_set_pic_size(base,
+				    dmatx->out_fmt.width,
+				    dmatx->out_fmt.height);
+		dmatx0_set_pic_off(base, 0);
+		dmatx0_ctrl(base,
+			    CIF_ISP_CSI0_DMATX0_VC(2) |
+			    CIF_ISP_CSI0_DMATX0_SIMG_SWP |
+			    CIF_ISP_CSI0_DMATX0_SIMG_MODE);
+		mi_raw0_set_size(base, in_size);
+		mi_raw0_set_offs(base, 0);
+		mi_raw0_set_length(base, 0);
+		mi_raw0_set_irq_offs(base, 0);
+		/* dummy buf for dmatx0 first address shadow */
+		mi_raw0_set_addr(base, stream->dummy_buf.dma_addr);
+		mi_ctrl2(base, CIF_MI_CTRL2_MIPI_RAW0_AUTO_UPDATE);
+		if (stream->id == RKISP_STREAM_DMATX0)
+			stream->u.dmatx.pre_stop = false;
+
+		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+			 "rawwr0 %dx%d size:%d ctrl:0x%x\n",
+			 dmatx->out_fmt.width,
+			 dmatx->out_fmt.height, in_size,
+			 readl(base + CIF_ISP_CSI0_DMATX0_CTRL));
+	}
 
 	return 0;
 }
@@ -983,18 +1221,24 @@ static void sp_enable_mi(struct rkisp_stream *stream)
 	mi_ctrl_spyuv_enable(base);
 }
 
-static void raw_enable_mi(struct rkisp_stream *stream)
+static void dmatx_enable_mi(struct rkisp_stream *stream)
 {
-	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
 
-	mi_mipi_raw0_enable(base);
+	if (dev->isp_ver == ISP_V20)
+		raw_wr_enable(stream);
+	else
+		mi_mipi_raw0_enable(base);
 }
 
 static void mp_disable_mi(struct rkisp_stream *stream)
 {
-	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
 
 	mi_ctrl_mp_disable(base);
+	hdr_stop_dmatx(dev);
 }
 
 static void sp_disable_mi(struct rkisp_stream *stream)
@@ -1004,22 +1248,68 @@ static void sp_disable_mi(struct rkisp_stream *stream)
 	mi_ctrl_spyuv_disable(base);
 }
 
-static void update_dmatx0(struct rkisp_stream *stream)
+static void update_dmatx_v1(struct rkisp_stream *stream)
 {
-	void __iomem *base = stream->ispdev->base_addr;
-	struct rkisp_dummy_buffer *dummy_buf = &stream->dummy_buf;
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
 
 	if (stream->next_buf)
 		mi_raw0_set_addr(base,
 			stream->next_buf->buff_addr[RKISP_PLANE_Y]);
 	else
-		mi_raw0_set_addr(base, dummy_buf->dma_addr);
+		mi_raw0_set_addr(base, stream->dummy_buf.dma_addr);
+	v4l2_dbg(2, rkisp_debug, &dev->v4l2_dev,
+		 "%s stream:%d Y:0x%x SHD:0x%x\n",
+		 __func__, stream->id,
+		 readl(base + CIF_MI_RAW0_BASE_AD_INIT),
+		 readl(base + CIF_MI_RAW0_BASE_AS_SHD));
+}
+
+static void update_dmatx_v2(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
+	struct rkisp_dummy_buffer *buf = NULL;
+	u8 index;
+
+	if (stream->next_buf) {
+		mi_set_y_addr(stream,
+			      stream->next_buf->buff_addr[RKISP_PLANE_Y]);
+	} else {
+		if (stream->id == RKISP_STREAM_DMATX0)
+			index = dev->hdr.index[HDR_DMA0];
+		else if (stream->id == RKISP_STREAM_DMATX1)
+			index = dev->hdr.index[HDR_DMA1];
+		else if (stream->id == RKISP_STREAM_DMATX2)
+			index = dev->hdr.index[HDR_DMA2];
+
+		if ((stream->id == RKISP_STREAM_DMATX0 ||
+		     stream->id == RKISP_STREAM_DMATX1 ||
+		     stream->id == RKISP_STREAM_DMATX2)) {
+			buf = hdr_dqbuf(&dev->hdr.q_tx[index]);
+			if (IS_HDR_DBG(dev->hdr.op_mode) &&
+			    !dev->dmarx_dev.trigger)
+				hdr_qbuf(&dev->hdr.q_rx[index], buf);
+			else
+				hdr_qbuf(&dev->hdr.q_tx[index], buf);
+		}
+		if (!buf)
+			buf = &stream->dummy_buf;
+		if (buf->vaddr)
+			mi_set_y_addr(stream, buf->dma_addr);
+	}
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s stream:%d Y:0x%x SHD:0x%x\n",
+		 __func__, stream->id,
+		 readl(base + stream->config->mi.y_base_ad_init),
+		 readl(base + stream->config->mi.y_base_ad_shd));
 }
 
 /* Update buffer info to memory interface, it's called in interrupt */
 static void update_mi(struct rkisp_stream *stream)
 {
 	struct rkisp_dummy_buffer *dummy_buf = &stream->dummy_buf;
+	void __iomem *base = stream->ispdev->base_addr;
 
 	/* The dummy space allocated by dma_alloc_coherent is used, we can
 	 * throw data to it if there is no available buffer.
@@ -1032,8 +1322,6 @@ static void update_mi(struct rkisp_stream *stream)
 		mi_set_cr_addr(stream,
 			stream->next_buf->buff_addr[RKISP_PLANE_CR]);
 	} else {
-		v4l2_dbg(1, rkisp_debug, &stream->ispdev->v4l2_dev,
-			 "stream %d: to dummy buf\n", stream->id);
 		mi_set_y_addr(stream, dummy_buf->dma_addr);
 		mi_set_cb_addr(stream, dummy_buf->dma_addr);
 		mi_set_cr_addr(stream, dummy_buf->dma_addr);
@@ -1042,6 +1330,12 @@ static void update_mi(struct rkisp_stream *stream)
 	mi_set_y_offset(stream, 0);
 	mi_set_cb_offset(stream, 0);
 	mi_set_cr_offset(stream, 0);
+	v4l2_dbg(2, rkisp_debug, &stream->ispdev->v4l2_dev,
+		 "%s stream:%d Y:0x%x CB:0x%x CR:0x%x\n",
+		 __func__, stream->id,
+		 readl(base + stream->config->mi.y_base_ad_init),
+		 readl(base + stream->config->mi.cb_base_ad_init),
+		 readl(base + stream->config->mi.cr_base_ad_init));
 }
 
 static void mp_stop_mi(struct rkisp_stream *stream)
@@ -1060,13 +1354,16 @@ static void sp_stop_mi(struct rkisp_stream *stream)
 	stream->ops->disable_mi(stream);
 }
 
-static void raw_stop_mi(struct rkisp_stream *stream)
+static void dmatx_stop_mi(struct rkisp_stream *stream)
 {
-	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
 
-	if (!stream->streaming)
-		return;
-	mi_mipi_raw0_disable(base);
+	if (dev->isp_ver == ISP_V20)
+		raw_wr_disable(stream);
+	else
+		mi_mipi_raw0_disable(base);
+	stream->u.dmatx.is_config = false;
 }
 
 static struct streams_ops rkisp_mp_streams_ops = {
@@ -1089,11 +1386,43 @@ static struct streams_ops rkisp_sp_streams_ops = {
 	.update_mi = update_mi,
 };
 
-static struct streams_ops rkisp_raw_streams_ops = {
-	.config_mi = raw_config_mi,
-	.enable_mi = raw_enable_mi,
-	.stop_mi = raw_stop_mi,
-	.update_mi = update_dmatx0,
+static struct streams_ops rkisp1_dmatx0_streams_ops = {
+	.config_mi = dmatx0_config_mi,
+	.enable_mi = dmatx_enable_mi,
+	.stop_mi = dmatx_stop_mi,
+	.update_mi = update_dmatx_v1,
+};
+
+static struct streams_ops rkisp2_dmatx0_streams_ops = {
+	.config_mi = dmatx0_config_mi,
+	.enable_mi = dmatx_enable_mi,
+	.stop_mi = dmatx_stop_mi,
+	.is_stream_stopped = dmatx_is_stream_stopped,
+	.update_mi = update_dmatx_v2,
+};
+
+static struct streams_ops rkisp2_dmatx1_streams_ops = {
+	.config_mi = dmatx1_config_mi,
+	.enable_mi = dmatx_enable_mi,
+	.stop_mi = dmatx_stop_mi,
+	.is_stream_stopped = dmatx_is_stream_stopped,
+	.update_mi = update_dmatx_v2,
+};
+
+static struct streams_ops rkisp2_dmatx2_streams_ops = {
+	.config_mi = dmatx2_config_mi,
+	.enable_mi = dmatx_enable_mi,
+	.stop_mi = dmatx_stop_mi,
+	.is_stream_stopped = dmatx_is_stream_stopped,
+	.update_mi = update_dmatx_v2,
+};
+
+static struct streams_ops rkisp2_dmatx3_streams_ops = {
+	.config_mi = dmatx3_config_mi,
+	.enable_mi = dmatx_enable_mi,
+	.stop_mi = dmatx_stop_mi,
+	.is_stream_stopped = dmatx_is_stream_stopped,
+	.update_mi = update_dmatx_v2,
 };
 
 /*
@@ -1124,8 +1453,13 @@ static int mi_frame_end(struct rkisp_stream *stream)
 				&stream->curr_buf->vb.vb2_buf, i,
 				payload_size);
 		}
-		stream->curr_buf->vb.sequence =
+		if (stream->id == RKISP_STREAM_MP ||
+		    stream->id == RKISP_STREAM_SP)
+			stream->curr_buf->vb.sequence =
 				atomic_read(&isp_sd->frm_sync_seq) - 1;
+		else
+			stream->curr_buf->vb.sequence =
+				atomic_read(&stream->sequence) - 1;
 		stream->curr_buf->vb.vb2_buf.timestamp = ns;
 		vb2_buffer_done(&stream->curr_buf->vb.vb2_buf,
 				VB2_BUF_STATE_DONE);
@@ -1175,6 +1509,264 @@ static int mi_frame_end(struct rkisp_stream *stream)
 
 /***************************** vb2 operations*******************************/
 
+static int rkisp_allow_buffer(struct rkisp_device *dev,
+			      struct rkisp_dummy_buffer *buf)
+{
+	int ret = 0;
+
+	buf->vaddr = dma_alloc_coherent(dev->dev, buf->size,
+					&buf->dma_addr, GFP_KERNEL);
+	if (!buf->vaddr)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static void rkisp_free_buffer(struct rkisp_device *dev,
+			       struct rkisp_dummy_buffer *buf)
+{
+	if (buf && buf->vaddr && buf->size) {
+		dma_free_coherent(dev->dev, buf->size,
+				  buf->vaddr, buf->dma_addr);
+		buf->size = 0;
+		buf->vaddr = NULL;
+	}
+}
+
+static int rkisp_create_hdr_buf(struct rkisp_device *dev)
+{
+	int i, j, max_dma, max_buf = 1;
+	struct rkisp_dummy_buffer *buf;
+	struct rkisp_stream *stream;
+	u32 size;
+
+	if (dev->isp_ver != ISP_V20 ||
+	    !dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2))
+		return 0;
+
+	stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX0];
+	size = stream->out_fmt.plane_fmt[0].sizeimage;
+	max_dma = hdr_dma_frame(dev);
+	/* hdr dbg mode using base and shd address
+	 * this support multi-buffer
+	 */
+	if (IS_HDR_DBG(dev->hdr.op_mode) &&
+	    !dev->dmarx_dev.trigger)
+		max_buf = HDR_MAX_DUMMY_BUF;
+	for (i = 0; i < max_dma; i++) {
+		for (j = 0; j < max_buf; j++) {
+			buf = &dev->hdr.dummy_buf[i][j];
+			buf->size = size;
+			if (rkisp_allow_buffer(dev, buf) < 0) {
+				v4l2_err(&dev->v4l2_dev,
+					"Failed to allocate the memory for hdr buffer\n");
+				return -ENOMEM;
+			}
+			hdr_qbuf(&dev->hdr.q_tx[i], buf);
+			v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+				 "hdr buf[%d][%d]:0x%x\n",
+				 i, j, (u32)buf->dma_addr);
+		}
+		dev->hdr.index[i] = i;
+	}
+	/*
+	 * normal: q_tx[0] to dma0
+	 *	   q_tx[1] to dma1
+	 * dbg1: using dma2
+		   q_tx[0] to dma2
+	 * dbg2: using dma0 (as M), dma2 (as S)
+	 *	   q_tx[0] to dma0
+	 *	   q_tx[1] to dma2
+	 * dbg3: using dma0 (as M), dam1 (as L), dma2 (as S)
+	 *	   q_tx[0] to dma0
+	 *	   q_tx[1] to dma1
+	 *	   q_tx[2] to dma2
+	 */
+	if (dev->hdr.op_mode == HDR_DBG_FRAME1) {
+		dev->hdr.index[HDR_DMA2] = 0;
+		dev->hdr.index[HDR_DMA0] = 1;
+		dev->hdr.index[HDR_DMA1] = 2;
+	} else if (dev->hdr.op_mode == HDR_DBG_FRAME2) {
+		dev->hdr.index[HDR_DMA0] = 0;
+		dev->hdr.index[HDR_DMA2] = 1;
+		dev->hdr.index[HDR_DMA1] = 2;
+	}
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "hdr buf index dma0:%d dma1:%d dma2:%d\n",
+		 dev->hdr.index[HDR_DMA0],
+		 dev->hdr.index[HDR_DMA1],
+		 dev->hdr.index[HDR_DMA2]);
+	return 0;
+}
+
+void hdr_destroy_buf(struct rkisp_device *dev)
+{
+	int i, j, max_dma, max_buf = 1;
+	struct rkisp_dummy_buffer *buf;
+
+	if (dev->isp_ver != ISP_V20 ||
+	    !dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2))
+		return;
+	dev->hdr.cnt = 0;
+	max_dma = hdr_dma_frame(dev);
+	if (IS_HDR_DBG(dev->hdr.op_mode) &&
+	    !dev->dmarx_dev.trigger)
+		max_buf = HDR_MAX_DUMMY_BUF;
+	for (i = 0; i < max_dma; i++) {
+		buf = dev->hdr.rx_cur_buf[i];
+		if (buf)
+			rkisp_free_buffer(dev, buf);
+		for (j = 0; j < max_buf; j++) {
+			buf = hdr_dqbuf(&dev->hdr.q_tx[i]);
+			if (buf)
+				rkisp_free_buffer(dev, buf);
+			buf = hdr_dqbuf(&dev->hdr.q_rx[i]);
+			if (buf)
+				rkisp_free_buffer(dev, buf);
+		}
+	}
+}
+
+int hdr_update_dmatx_buf(struct rkisp_device *dev)
+{
+	void __iomem *base = dev->base_addr;
+	struct rkisp_stream *dmatx;
+	struct rkisp_dummy_buffer *buf;
+	u8 index;
+
+	if (dev->isp_ver != ISP_V20 ||
+	    !dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2))
+		return 0;
+
+	dmatx = &dev->cap_dev.stream[RKISP_STREAM_DMATX0];
+	mi_frame_end(dmatx);
+
+	dmatx = &dev->cap_dev.stream[RKISP_STREAM_DMATX1];
+	mi_frame_end(dmatx);
+
+	dmatx = &dev->cap_dev.stream[RKISP_STREAM_DMATX2];
+	mi_frame_end(dmatx);
+
+	if (dev->dmarx_dev.trigger)
+		goto end;
+
+	/* for rawrd auto trigger mode, config first buf */
+	index = dev->hdr.index[HDR_DMA0];
+	buf = hdr_dqbuf(&dev->hdr.q_rx[index]);
+	if (buf) {
+		mi_raw0_rd_set_addr(base, buf->dma_addr);
+		dev->hdr.rx_cur_buf[index] = buf;
+	} else {
+		mi_raw0_rd_set_addr(base,
+			readl(base + MI_RAW0_WR_BASE_SHD));
+	}
+
+	index = dev->hdr.index[HDR_DMA1];
+	buf = hdr_dqbuf(&dev->hdr.q_rx[index]);
+	if (buf) {
+		mi_raw1_rd_set_addr(base, buf->dma_addr);
+		dev->hdr.rx_cur_buf[index] = buf;
+	} else {
+		mi_raw1_rd_set_addr(base,
+			readl(base + MI_RAW1_WR_BASE_SHD));
+	}
+
+	index = dev->hdr.index[HDR_DMA2];
+	buf = hdr_dqbuf(&dev->hdr.q_rx[index]);
+	if (buf) {
+		mi_raw2_rd_set_addr(base, buf->dma_addr);
+		dev->hdr.rx_cur_buf[index] = buf;
+	} else {
+		mi_raw2_rd_set_addr(base,
+			readl(base + MI_RAW2_WR_BASE_SHD));
+	}
+
+end:
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "CSI2RX CTRL0:0x%x CTRL1:0x%x\n"
+		 "WR CTRL RAW0:0x%x RAW1:0x%x RAW2:0x%x\n"
+		 "RD CTRL:0x%x\n",
+		 readl(base + CSI2RX_CTRL0),
+		 readl(base + CSI2RX_CTRL1),
+		 readl(base + CSI2RX_RAW0_WR_CTRL),
+		 readl(base + CSI2RX_RAW1_WR_CTRL),
+		 readl(base + CSI2RX_RAW2_WR_CTRL),
+		 readl(base + CSI2RX_RAW_RD_CTRL));
+	return 0;
+}
+
+int hdr_config_dmatx(struct rkisp_device *dev)
+{
+	if (dev->isp_ver != ISP_V20 ||
+	    dev->hdr.cnt ||
+	    !dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2))
+		return 0;
+	dev->hdr.cnt++;
+	rkisp_create_hdr_buf(dev);
+
+	if (dev->hdr.op_mode == HDR_FRAMEX2_DDR ||
+	    dev->hdr.op_mode == HDR_LINEX2_DDR ||
+	    dev->hdr.op_mode == HDR_FRAMEX3_DDR ||
+	    dev->hdr.op_mode == HDR_LINEX3_DDR ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME2 ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME3)
+		dmatx0_config_mi(&dev->cap_dev.stream[RKISP_STREAM_DMATX0]);
+	if (dev->hdr.op_mode == HDR_FRAMEX3_DDR ||
+	    dev->hdr.op_mode == HDR_LINEX3_DDR ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME3)
+		dmatx1_config_mi(&dev->cap_dev.stream[RKISP_STREAM_DMATX1]);
+	if (dev->hdr.op_mode == HDR_DBG_FRAME1 ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME2 ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME3)
+		dmatx2_config_mi(&dev->cap_dev.stream[RKISP_STREAM_DMATX2]);
+
+	if (IS_HDR_DBG(dev->hdr.op_mode))
+		raw_rd_ctrl(dev->base_addr,
+			SW_CSI_RAW_RD_SIMG_SWP |
+			SW_CSI_RAW_RD_SIMG_MOD);
+	return 0;
+}
+
+void hdr_stop_dmatx(struct rkisp_device *dev)
+{
+	void __iomem *base = dev->base_addr;
+	struct rkisp_stream *stream;
+	int i;
+
+	if (dev->hdr.op_mode == HDR_FRAMEX2_DDR ||
+	    dev->hdr.op_mode == HDR_LINEX2_DDR ||
+	    dev->hdr.op_mode == HDR_FRAMEX3_DDR ||
+	    dev->hdr.op_mode == HDR_LINEX3_DDR ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME2 ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME3)
+		isp_clear_bits(base + CSI2RX_RAW0_WR_CTRL,
+			       SW_CSI_RAW_WR_EN_ORG);
+	if (dev->hdr.op_mode == HDR_FRAMEX3_DDR ||
+	    dev->hdr.op_mode == HDR_LINEX3_DDR ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME3)
+		isp_clear_bits(base + CSI2RX_RAW1_WR_CTRL,
+			       SW_CSI_RAW_WR_EN_ORG);
+	if (dev->hdr.op_mode == HDR_DBG_FRAME1 ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME2 ||
+	    dev->hdr.op_mode == HDR_DBG_FRAME3)
+		isp_clear_bits(base + CSI2RX_RAW2_WR_CTRL,
+			       SW_CSI_RAW_WR_EN_ORG);
+	for (i = RKISP_STREAM_DMATX0; i < RKISP_MAX_STREAM; i++) {
+		stream = &dev->cap_dev.stream[i];
+		if (!stream->streaming &&
+		    stream->u.dmatx.is_config)
+			stream->u.dmatx.is_config = false;
+	}
+}
+
 /*
  * Set flags and wait, it should stop in interrupt.
  * If it didn't, stop it by force.
@@ -1185,6 +1777,20 @@ static void rkisp_stream_stop(struct rkisp_stream *stream)
 	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
 	int ret = 0;
 
+	if (dev->isp_ver == ISP_V20 &&
+	    ((dev->hdr.op_mode == HDR_DBG_FRAME1 &&
+	      stream->id == RKISP_STREAM_DMATX2) ||
+	     (dev->hdr.op_mode == HDR_DBG_FRAME2 &&
+	      (stream->id == RKISP_STREAM_DMATX2 ||
+	       stream->id == RKISP_STREAM_DMATX0)) ||
+	     (dev->hdr.op_mode == HDR_DBG_FRAME3 &&
+	      (stream->id == RKISP_STREAM_DMATX2 ||
+	       stream->id == RKISP_STREAM_DMATX1 ||
+	       stream->id == RKISP_STREAM_DMATX0)))) {
+		stream->streaming = false;
+		return;
+	}
+
 	stream->stopping = true;
 	stream->ops->stop_mi(stream);
 	if (dev->isp_state == ISP_START &&
@@ -1202,7 +1808,8 @@ static void rkisp_stream_stop(struct rkisp_stream *stream)
 		stream->streaming = false;
 	}
 
-	if (stream->id != RKISP_STREAM_RAW) {
+	if (stream->id == RKISP_STREAM_MP ||
+	    stream->id == RKISP_STREAM_SP) {
 		disable_dcrop(stream, true);
 		disable_rsz(stream, true);
 	}
@@ -1224,11 +1831,12 @@ static int rkisp_start(struct rkisp_stream *stream)
 	void __iomem *base = stream->ispdev->base_addr;
 	struct rkisp_device *dev = stream->ispdev;
 	bool other_streaming = false;
-	int i, ret;
+	unsigned int i;
+	int ret;
 
 	for (i = 0; i < RKISP_MAX_STREAM; i++) {
 		if (i != stream->id &&
-			dev->stream[i].streaming) {
+			dev->cap_dev.stream[i].streaming) {
 			other_streaming = true;
 			break;
 		}
@@ -1238,15 +1846,19 @@ static int rkisp_start(struct rkisp_stream *stream)
 	 * config raw in first stream (sp/mp), and enable when raw stream open.
 	 */
 	if (!other_streaming &&
-		stream->id == RKISP_STREAM_RAW) {
+	    (stream->id == RKISP_STREAM_DMATX0 ||
+	     stream->id == RKISP_STREAM_DMATX1 ||
+	     stream->id == RKISP_STREAM_DMATX2 ||
+	     stream->id == RKISP_STREAM_DMATX3)) {
 		v4l2_err(&dev->v4l2_dev,
 			"stream raw only support to open after stream mp/sp");
 		return -EINVAL;
 	}
 
-	if (dev->isp_ver == ISP_V12 ||
-		dev->isp_ver == ISP_V13)
-		raw_config_mi(stream);
+	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13)
+		dmatx0_config_mi(stream);
+
+	hdr_config_dmatx(dev);
 
 	if (stream->ops->set_data_path)
 		stream->ops->set_data_path(base);
@@ -1255,7 +1867,8 @@ static int rkisp_start(struct rkisp_stream *stream)
 		return ret;
 
 	/* for mp/sp Set up an buffer for the next frame */
-	if (stream->id != RKISP_STREAM_RAW)
+	if (stream->id == RKISP_STREAM_MP ||
+	    stream->id == RKISP_STREAM_SP)
 		mi_frame_end(stream);
 	stream->ops->enable_mi(stream);
 	/* It's safe to config ACTIVE and SHADOW regs for the
@@ -1267,9 +1880,10 @@ static int rkisp_start(struct rkisp_stream *stream)
 	 * also required because the sencond FE maybe corrupt especially
 	 * when run at 120fps.
 	 */
-	if (!other_streaming) {
+	if (!other_streaming && !dev->mpfbc_dev.en) {
 		force_cfg_update(base);
 		mi_frame_end(stream);
+		hdr_update_dmatx_buf(dev);
 	}
 	stream->streaming = true;
 
@@ -1323,7 +1937,8 @@ static void rkisp_buf_queue(struct vb2_buffer *vb)
 	memset(ispbuf->buff_addr, 0, sizeof(ispbuf->buff_addr));
 	for (i = 0; i < isp_fmt->mplanes; i++) {
 		ispbuf->buff_addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);
-		if (stream->id ==  RKISP_STREAM_RAW) {
+		if (stream->id ==  RKISP_STREAM_DMATX0 &&
+		    stream->ispdev->isp_ver != ISP_V20) {
 			/* for check dmatx to ddr complete */
 			u32 sizeimage = pixm->plane_fmt[0].sizeimage;
 			u32 *buf = vb2_plane_vaddr(vb, 0);
@@ -1350,13 +1965,20 @@ static void rkisp_buf_queue(struct vb2_buffer *vb)
 		}
 	}
 
+	v4l2_dbg(2, rkisp_debug, &stream->ispdev->v4l2_dev,
+		 "stream:%d queue buf:0x%x\n",
+		 stream->id, ispbuf->buff_addr[0]);
+
 	spin_lock_irqsave(&stream->vbq_lock, lock_flags);
 
 	/* XXX: replace dummy to speed up  */
 	if (stream->streaming &&
 	    !stream->next_buf &&
 	    !stream->interlaced &&
-	    stream->id != RKISP_STREAM_RAW &&
+	    stream->id != RKISP_STREAM_DMATX0 &&
+	    stream->id != RKISP_STREAM_DMATX1 &&
+	    stream->id != RKISP_STREAM_DMATX2 &&
+	    stream->id != RKISP_STREAM_DMATX3 &&
 	    atomic_read(&stream->ispdev->isp_sdev.frm_sync_seq) == 0) {
 		stream->next_buf = ispbuf;
 		stream->ops->update_mi(stream);
@@ -1379,23 +2001,25 @@ static int rkisp_create_dummy_buf(struct rkisp_stream *stream)
 	if (dev->active_sensor &&
 	    dev->active_sensor->mbus.type == V4L2_MBUS_CSI2 &&
 	    (dev->isp_ver == ISP_V12 ||
-	     dev->isp_ver == ISP_V13)) {
+	     dev->isp_ver == ISP_V13 ||
+	     dev->isp_ver == ISP_V20)) {
 		u32 in_size;
-		struct rkisp_stream *raw = &dev->stream[RKISP_STREAM_RAW];
+		struct rkisp_stream *dmatx =
+			&dev->cap_dev.stream[RKISP_STREAM_DMATX0];
 
-		in_size = raw->out_fmt.plane_fmt[0].sizeimage;
+		in_size = dmatx->out_fmt.plane_fmt[0].sizeimage;
 		dummy_buf->size = max(dummy_buf->size, in_size);
 	}
 
-	dummy_buf->vaddr = dma_alloc_coherent(dev->dev, dummy_buf->size,
-					      &dummy_buf->dma_addr,
-					      GFP_KERNEL);
-	if (!dummy_buf->vaddr) {
+	if (rkisp_allow_buffer(dev, dummy_buf) < 0) {
 		v4l2_err(&dev->v4l2_dev,
 			 "Failed to allocate the memory for dummy buffer\n");
 		return -ENOMEM;
 	}
 
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "stream:%d dummy buf:0x%x\n",
+		 stream->id, (u32)dummy_buf->dma_addr);
 	return 0;
 }
 
@@ -1404,8 +2028,8 @@ static void rkisp_destroy_dummy_buf(struct rkisp_stream *stream)
 	struct rkisp_dummy_buffer *dummy_buf = &stream->dummy_buf;
 	struct rkisp_device *dev = stream->ispdev;
 
-	dma_free_coherent(dev->dev, dummy_buf->size,
-			  dummy_buf->vaddr, dummy_buf->dma_addr);
+	rkisp_free_buffer(dev, dummy_buf);
+	hdr_destroy_buf(dev);
 }
 
 static void rkisp_stop_streaming(struct vb2_queue *queue)
@@ -1418,6 +2042,9 @@ static void rkisp_stop_streaming(struct vb2_queue *queue)
 	unsigned long lock_flags = 0;
 	int ret;
 
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s %d\n", __func__, stream->id);
+
 	rkisp_stream_stop(stream);
 	/* call to the other devices */
 	media_pipeline_stop(&node->vdev.entity);
@@ -1456,12 +2083,15 @@ static int rkisp_stream_start(struct rkisp_stream *stream)
 {
 	struct v4l2_device *v4l2_dev = &stream->ispdev->v4l2_dev;
 	struct rkisp_device *dev = stream->ispdev;
-	struct rkisp_stream *other = &dev->stream[stream->id ^ 1];
+	struct rkisp_stream *other = &dev->cap_dev.stream[stream->id ^ 1];
 	bool async = false;
 	int ret;
 
-	/* STREAM RAW don't have rsz and dcrop */
-	if (stream->id == RKISP_STREAM_RAW)
+	/* STREAM DMATX don't have rsz and dcrop */
+	if (stream->id == RKISP_STREAM_DMATX0 ||
+	    stream->id == RKISP_STREAM_DMATX1 ||
+	    stream->id == RKISP_STREAM_DMATX2 ||
+	    stream->id == RKISP_STREAM_DMATX3)
 		goto end;
 
 	if (other->streaming)
@@ -1494,13 +2124,19 @@ rkisp_start_streaming(struct vb2_queue *queue, unsigned int count)
 	struct rkisp_vdev_node *node = &stream->vnode;
 	struct rkisp_device *dev = stream->ispdev;
 	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
-	int ret;
 	unsigned int i;
+	int ret = -1;
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s %d\n", __func__, stream->id);
 
 	if (WARN_ON(stream->streaming))
 		return -EBUSY;
 
-	if (dev->isp_inp != INP_DMARX_ISP) {
+	if (!dev->isp_inp)
+		goto buffer_done;
+	if (dev->isp_inp & INP_CSI ||
+	    dev->isp_inp & INP_DVP) {
 		/* Always update sensor info in case media topology changed */
 		ret = rkisp_update_sensor_info(dev);
 		if (ret < 0) {
@@ -1512,7 +2148,7 @@ rkisp_start_streaming(struct vb2_queue *queue, unsigned int count)
 	}
 
 	if (dev->active_sensor &&
-		dev->active_sensor->fmt.format.field ==
+		dev->active_sensor->fmt[0].format.field ==
 		V4L2_FIELD_INTERLACED) {
 		if (stream->id != RKISP_STREAM_SP) {
 			v4l2_err(v4l2_dev,
@@ -1589,10 +2225,6 @@ static int rkisp_init_vb2_queue(struct vb2_queue *q,
 				struct rkisp_stream *stream,
 				enum v4l2_buf_type buf_type)
 {
-	struct rkisp_vdev_node *node;
-
-	node = queue_to_node(q);
-
 	q->type = buf_type;
 	q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
 	q->drv_priv = stream;
@@ -1630,6 +2262,7 @@ static int rkisp_set_fmt(struct rkisp_stream *stream,
 {
 	const struct capture_fmt *fmt;
 	const struct stream_config *config = stream->config;
+	struct rkisp_device *dev = stream->ispdev;
 	struct rkisp_stream *other_stream;
 	unsigned int imagsize = 0;
 	unsigned int planes;
@@ -1647,11 +2280,13 @@ static int rkisp_set_fmt(struct rkisp_stream *stream,
 		return -EINVAL;
 	}
 
-	if (stream->id != RKISP_STREAM_RAW) {
+	if (stream->id == RKISP_STREAM_MP ||
+	    stream->id == RKISP_STREAM_SP) {
 		struct v4l2_rect max_rsz;
 
-		other_stream =
-			&stream->ispdev->stream[!stream->id ^ 1];
+		other_stream = (stream->id == RKISP_STREAM_MP) ?
+			&dev->cap_dev.stream[RKISP_STREAM_SP] :
+			&dev->cap_dev.stream[RKISP_STREAM_MP];
 		/* do checks on resolution */
 		restrict_rsz_resolution(stream->ispdev, config, &max_rsz);
 		pixm->width = clamp_t(u32, pixm->width,
@@ -1660,7 +2295,7 @@ static int rkisp_set_fmt(struct rkisp_stream *stream,
 				       config->min_rsz_height, max_rsz.height);
 	} else {
 		other_stream =
-			&stream->ispdev->stream[RKISP_STREAM_MP];
+			&stream->ispdev->cap_dev.stream[RKISP_STREAM_MP];
 	}
 	pixm->num_planes = fmt->mplanes;
 	pixm->field = V4L2_FIELD_NONE;
@@ -1767,7 +2402,7 @@ int rkisp_fop_release(struct file *file)
 void rkisp_set_stream_def_fmt(struct rkisp_device *dev, u32 id,
 	u32 width, u32 height, u32 pixelformat)
 {
-	struct rkisp_stream *stream = &dev->stream[id];
+	struct rkisp_stream *stream = &dev->cap_dev.stream[id];
 	struct v4l2_pix_format_mplane pixm;
 
 	memset(&pixm, 0, sizeof(pixm));
@@ -1783,36 +2418,6 @@ void rkisp_set_stream_def_fmt(struct rkisp_device *dev, u32 id,
 }
 
 /************************* v4l2_file_operations***************************/
-void rkisp_stream_init(struct rkisp_device *dev, u32 id)
-{
-	struct rkisp_stream *stream = &dev->stream[id];
-
-	memset(stream, 0, sizeof(*stream));
-	stream->id = id;
-	stream->ispdev = dev;
-
-	INIT_LIST_HEAD(&stream->buf_queue);
-	init_waitqueue_head(&stream->done);
-	spin_lock_init(&stream->vbq_lock);
-	if (stream->id == RKISP_STREAM_SP) {
-		stream->ops = &rkisp_sp_streams_ops;
-		stream->config = &rkisp_sp_stream_config;
-	} else if (stream->id == RKISP_STREAM_RAW) {
-		stream->ops = &rkisp_raw_streams_ops;
-		stream->config = &rkisp_raw_stream_config;
-	} else {
-		stream->ops = &rkisp_mp_streams_ops;
-		stream->config = &rkisp_mp_stream_config;
-	}
-
-	stream->streaming = false;
-	stream->interlaced = false;
-
-	stream->burst =
-		CIF_MI_CTRL_BURST_LEN_LUM_16 |
-		CIF_MI_CTRL_BURST_LEN_CHROM_16;
-}
-
 static const struct v4l2_file_operations rkisp_fops = {
 	.open = rkisp_fh_open,
 	.release = rkisp_fop_release,
@@ -1991,10 +2596,13 @@ static struct v4l2_rect *rkisp_update_crop(struct rkisp_stream *stream,
 					    struct v4l2_rect *sel,
 					    const struct v4l2_rect *in)
 {
-	/* Not crop for MP bayer raw data and RAW path */
+	/* Not crop for MP bayer raw data and dmatx path */
 	if ((stream->id == RKISP_STREAM_MP &&
 	     stream->out_isp_fmt.fmt_type == FMT_BAYER) ||
-	    stream->id == RKISP_STREAM_RAW) {
+	    stream->id == RKISP_STREAM_DMATX0 ||
+	    stream->id == RKISP_STREAM_DMATX1 ||
+	    stream->id == RKISP_STREAM_DMATX2 ||
+	    stream->id == RKISP_STREAM_DMATX3) {
 		sel->left = 0;
 		sel->top = 0;
 		sel->width = in->width;
@@ -2091,51 +2699,15 @@ static void rkisp_unregister_stream_vdev(struct rkisp_stream *stream)
 	video_unregister_device(&stream->vnode.vdev);
 }
 
-void rkisp_unregister_stream_vdevs(struct rkisp_device *dev)
-{
-	struct rkisp_stream *mp_stream = &dev->stream[RKISP_STREAM_MP];
-	struct rkisp_stream *sp_stream = &dev->stream[RKISP_STREAM_SP];
-	struct rkisp_stream *raw_stream = &dev->stream[RKISP_STREAM_RAW];
-
-	rkisp_unregister_stream_vdev(mp_stream);
-
-	if (dev->isp_ver != ISP_V10_1)
-		rkisp_unregister_stream_vdev(sp_stream);
-
-	if (dev->isp_ver == ISP_V12 ||
-		dev->isp_ver == ISP_V13)
-		rkisp_unregister_stream_vdev(raw_stream);
-}
-
 static int rkisp_register_stream_vdev(struct rkisp_stream *stream)
 {
 	struct rkisp_device *dev = stream->ispdev;
 	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
 	struct video_device *vdev = &stream->vnode.vdev;
 	struct rkisp_vdev_node *node;
-	int ret = 0;
-	char *vdev_name;
+	struct media_entity *source, *sink;
+	int ret = 0, pad;
 
-	switch (stream->id) {
-	case RKISP_STREAM_SP:
-		vdev_name = SP_VDEV_NAME;
-		if (dev->isp_ver == ISP_V10_1)
-			return 0;
-		break;
-	case RKISP_STREAM_MP:
-		vdev_name = MP_VDEV_NAME;
-		break;
-	case RKISP_STREAM_RAW:
-		vdev_name = RAW_VDEV_NAME;
-		if (dev->isp_ver != ISP_V12 &&
-			dev->isp_ver != ISP_V13)
-			return 0;
-		break;
-	default:
-		v4l2_err(v4l2_dev, "Invalid stream\n");
-		goto unreg;
-	}
-	strlcpy(vdev->name, vdev_name, sizeof(vdev->name));
 	node = vdev_to_node(vdev);
 
 	vdev->ioctl_ops = &rkisp_v4l2_ioctl_ops;
@@ -2165,33 +2737,216 @@ static int rkisp_register_stream_vdev(struct rkisp_stream *stream)
 	if (ret < 0)
 		goto unreg;
 
+	source = &dev->csi_dev.sd.entity;
+	switch (stream->id) {
+	case RKISP_STREAM_DMATX0:
+		pad = CSI_SRC_CH1;
+		dev->csi_dev.sink[1].linked = true;
+		dev->csi_dev.sink[1].index = BIT(1);
+		break;
+	case RKISP_STREAM_DMATX1:
+		pad = CSI_SRC_CH2;
+		dev->csi_dev.sink[2].linked = true;
+		dev->csi_dev.sink[2].index = BIT(2);
+		break;
+	case RKISP_STREAM_DMATX2:
+		pad = CSI_SRC_CH3;
+		dev->csi_dev.sink[3].linked = true;
+		dev->csi_dev.sink[3].index = BIT(3);
+		break;
+	case RKISP_STREAM_DMATX3:
+		pad = CSI_SRC_CH4;
+		dev->csi_dev.sink[4].linked = true;
+		dev->csi_dev.sink[4].index = BIT(4);
+		break;
+	default:
+		source = &dev->isp_sdev.sd.entity;
+		pad = RKISP_ISP_PAD_SOURCE_PATH;
+	}
+	sink = &vdev->entity;
+	ret = media_create_pad_link(source, pad,
+		sink, 0, MEDIA_LNK_FL_ENABLED);
+	if (ret < 0)
+		goto unreg;
 	return 0;
 unreg:
 	video_unregister_device(vdev);
 	return ret;
 }
 
-int rkisp_register_stream_vdevs(struct rkisp_device *dev)
+static int rkisp_stream_init(struct rkisp_device *dev, u32 id)
 {
+	struct rkisp_capture_device *cap_dev = &dev->cap_dev;
 	struct rkisp_stream *stream;
-	int i, j, ret;
+	struct video_device *vdev;
+	char *name;
+	int ret = 0;
 
-	for (i = 0; i < RKISP_MAX_STREAM; i++) {
-		stream = &dev->stream[i];
-		stream->ispdev = dev;
-		ret = rkisp_register_stream_vdev(stream);
+	stream = &cap_dev->stream[id];
+	stream->id = id;
+	stream->ispdev = dev;
+	vdev = &stream->vnode.vdev;
+
+	INIT_LIST_HEAD(&stream->buf_queue);
+	init_waitqueue_head(&stream->done);
+	spin_lock_init(&stream->vbq_lock);
+
+	switch (id) {
+	case RKISP_STREAM_SP:
+		strlcpy(vdev->name, SP_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp_sp_streams_ops;
+		stream->config = &rkisp_sp_stream_config;
+		break;
+	case RKISP_STREAM_DMATX0:
+		if (dev->isp_ver != ISP_V20) {
+			name = RAW_VDEV_NAME;
+			stream->ops = &rkisp1_dmatx0_streams_ops;
+			stream->config = &rkisp1_dmatx0_stream_config;
+		} else {
+			name = DMATX0_VDEV_NAME;
+			stream->ops = &rkisp2_dmatx0_streams_ops;
+			stream->config = &rkisp2_dmatx0_stream_config;
+		}
+		strlcpy(vdev->name, name,
+			sizeof(vdev->name));
+		break;
+	case RKISP_STREAM_DMATX1:
+		strlcpy(vdev->name, DMATX1_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmatx1_streams_ops;
+		stream->config = &rkisp2_dmatx1_stream_config;
+		break;
+	case RKISP_STREAM_DMATX2:
+		strlcpy(vdev->name, DMATX2_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmatx2_streams_ops;
+		stream->config = &rkisp2_dmatx2_stream_config;
+		break;
+	case RKISP_STREAM_DMATX3:
+		strlcpy(vdev->name, DMATX3_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmatx3_streams_ops;
+		stream->config = &rkisp2_dmatx3_stream_config;
+		break;
+	default:
+		strlcpy(vdev->name, MP_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp_mp_streams_ops;
+		stream->config = &rkisp_mp_stream_config;
+	}
+
+	ret = rkisp_register_stream_vdev(stream);
+	if (ret < 0)
+		return ret;
+
+	stream->streaming = false;
+	stream->interlaced = false;
+	stream->burst =
+		CIF_MI_CTRL_BURST_LEN_LUM_16 |
+		CIF_MI_CTRL_BURST_LEN_CHROM_16;
+	atomic_set(&stream->sequence, 0);
+	return 0;
+}
+
+int rkisp_register_stream_vdevs(struct rkisp_device *dev)
+{
+	struct rkisp_capture_device *cap_dev = &dev->cap_dev;
+	int ret = 0;
+
+	memset(cap_dev, 0, sizeof(*cap_dev));
+	cap_dev->ispdev = dev;
+
+	ret = rkisp_stream_init(dev, RKISP_STREAM_MP);
+	if (ret < 0)
+		goto err;
+	if (dev->isp_ver != ISP_V10_1) {
+		ret = rkisp_stream_init(dev, RKISP_STREAM_SP);
+		if (ret < 0)
+			goto err_free_mp;
+	}
+
+	if (dev->isp_ver == ISP_V12 ||
+	    dev->isp_ver == ISP_V13 ||
+	    dev->isp_ver == ISP_V20) {
+		ret = rkisp_stream_init(dev, RKISP_STREAM_DMATX0);
+		if (ret < 0)
+			goto err_free_sp;
+	}
+
+	if (dev->isp_ver == ISP_V20) {
+		ret = rkisp_stream_init(dev, RKISP_STREAM_DMATX1);
+		if (ret < 0)
+			goto err_free_tx0;
+		ret = rkisp_stream_init(dev, RKISP_STREAM_DMATX2);
+		if (ret < 0)
+			goto err_free_tx1;
+		ret = rkisp_stream_init(dev, RKISP_STREAM_DMATX3);
 		if (ret < 0)
-			goto err;
+			goto err_free_tx2;
 	}
 
 	return 0;
+err_free_tx2:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_DMATX2]);
+err_free_tx1:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_DMATX1]);
+err_free_tx0:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_DMATX0]);
+err_free_sp:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_SP]);
+err_free_mp:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_MP]);
 err:
-	for (j = 0; j < i; j++) {
-		stream = &dev->stream[j];
+	return ret;
+}
+
+void rkisp_unregister_stream_vdevs(struct rkisp_device *dev)
+{
+	struct rkisp_capture_device *cap_dev = &dev->cap_dev;
+	struct rkisp_stream *stream;
+
+	stream = &cap_dev->stream[RKISP_STREAM_MP];
+	rkisp_unregister_stream_vdev(stream);
+	if (dev->isp_ver != ISP_V10_1) {
+		stream = &cap_dev->stream[RKISP_STREAM_SP];
 		rkisp_unregister_stream_vdev(stream);
 	}
 
-	return ret;
+	if (dev->isp_ver == ISP_V12 ||
+	    dev->isp_ver == ISP_V13 ||
+	    dev->isp_ver == ISP_V20) {
+		stream = &cap_dev->stream[RKISP_STREAM_DMATX0];
+		rkisp_unregister_stream_vdev(stream);
+	}
+
+	if (dev->isp_ver == ISP_V20) {
+		stream = &cap_dev->stream[RKISP_STREAM_DMATX1];
+		rkisp_unregister_stream_vdev(stream);
+		stream = &cap_dev->stream[RKISP_STREAM_DMATX2];
+		rkisp_unregister_stream_vdev(stream);
+		stream = &cap_dev->stream[RKISP_STREAM_DMATX3];
+		rkisp_unregister_stream_vdev(stream);
+	}
+}
+
+struct rkisp_dummy_buffer *hdr_dqbuf(struct list_head *q)
+{
+	struct rkisp_dummy_buffer *buf = NULL;
+
+	if (!list_empty(q)) {
+		buf = list_first_entry(q,
+			struct rkisp_dummy_buffer, queue);
+		list_del(&buf->queue);
+	}
+	return buf;
+}
+
+void hdr_qbuf(struct list_head *q,
+	      struct rkisp_dummy_buffer *buf)
+{
+	if (buf)
+		list_add_tail(&buf->queue, q);
 }
 
 /****************  Interrupter Handler ****************/
@@ -2199,16 +2954,29 @@ int rkisp_register_stream_vdevs(struct rkisp_device *dev)
 void rkisp_mi_isr(u32 mis_val, struct rkisp_device *dev)
 {
 	unsigned int i;
+	static u8 end_tx0, end_tx1, end_tx2;
+
+	v4l2_dbg(3, rkisp_debug, &dev->v4l2_dev,
+		 "mi isr:0x%x\n", mis_val);
 
+	if (mis_val & MI_MPFBC_FRAME)
+		rkisp_mpfbc_isr(mis_val, dev);
 	if (mis_val & CIF_MI_DMA_READY)
 		rkisp_dmarx_isr(mis_val, dev);
 
-	for (i = 0; i < ARRAY_SIZE(dev->stream); ++i) {
-		struct rkisp_stream *stream = &dev->stream[i];
+	for (i = 0; i < RKISP_MAX_STREAM; ++i) {
+		struct rkisp_stream *stream = &dev->cap_dev.stream[i];
 
 		if (!(mis_val & CIF_MI_FRAME(stream)))
 			continue;
 
+		if (i == RKISP_STREAM_DMATX0)
+			end_tx0 = true;
+		if (i == RKISP_STREAM_DMATX1)
+			end_tx1 = true;
+		if (i == RKISP_STREAM_DMATX2)
+			end_tx2 = true;
+
 		mi_frame_end_int_clear(stream);
 
 		if (stream->stopping) {
@@ -2225,18 +2993,33 @@ void rkisp_mi_isr(u32 mis_val, struct rkisp_device *dev)
 				stream->streaming = false;
 				wake_up(&stream->done);
 			}
+			if (i == RKISP_STREAM_MP) {
+				end_tx0 = false;
+				end_tx1 = false;
+				end_tx2 = false;
+			}
 		} else {
 			mi_frame_end(stream);
+			if (dev->dmarx_dev.trigger == T_AUTO &&
+			    ((dev->hdr.op_mode == HDR_DBG_FRAME1 && end_tx2) ||
+			     (dev->hdr.op_mode == HDR_DBG_FRAME2 && end_tx2 && end_tx0) ||
+			     (dev->hdr.op_mode == HDR_DBG_FRAME3 && end_tx2 && end_tx1 && end_tx0))) {
+				end_tx0 = false;
+				end_tx1 = false;
+				end_tx2 = false;
+				rkisp_trigger_read_back(&dev->csi_dev, false);
+			}
 		}
 	}
 }
 
 void rkisp_mipi_dmatx0_end(u32 status, struct rkisp_device *dev)
 {
-	struct rkisp_stream *stream = &dev->stream[RKISP_STREAM_RAW];
-	u32 *buf, end, timeout = 100;
+	struct rkisp_stream *stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX0];
+	u32 *buf, end, vc, timeout = 100;
 
-	if (!(status & 0x1) || !stream->streaming)
+	vc = readl(dev->base_addr + CIF_ISP_CSI0_DATA_IDS_1) >> 14 & 0x3;
+	if (!(status & 1 << vc) || !stream->streaming)
 		return;
 
 	dmatx0_enable(dev->base_addr);
@@ -2245,19 +3028,19 @@ void rkisp_mipi_dmatx0_end(u32 status, struct rkisp_device *dev)
 		 * stream don't close, but dmatx is reopen.
 		 * dmatx first buf will write to this.
 		 */
-		if (!stream->u.raw.pre_stop) {
-			int i;
+		if (!stream->u.dmatx.pre_stop) {
+			unsigned int i;
 			struct rkisp_stream *other = NULL;
 
 			for (i = 0; i < RKISP_MAX_STREAM; i++) {
 				if (i != stream->id &&
-					dev->stream[i].streaming) {
-					other = &dev->stream[i];
+					dev->cap_dev.stream[i].streaming) {
+					other = &dev->cap_dev.stream[i];
 					break;
 				}
 			}
 
-			stream->u.raw.pre_stop = true;
+			stream->u.dmatx.pre_stop = true;
 			if (other) {
 				mi_raw0_set_addr(dev->base_addr,
 					other->dummy_buf.dma_addr);
@@ -2265,9 +3048,9 @@ void rkisp_mipi_dmatx0_end(u32 status, struct rkisp_device *dev)
 			}
 		}
 
-		if (stream->u.raw.pre_stop) {
+		if (stream->u.dmatx.pre_stop) {
 			dmatx0_disable(dev->base_addr);
-			stream->u.raw.pre_stop = false;
+			stream->u.dmatx.pre_stop = false;
 			stream->stopping = false;
 			stream->streaming = false;
 			wake_up(&stream->done);
@@ -2300,6 +3083,47 @@ void rkisp_mipi_dmatx0_end(u32 status, struct rkisp_device *dev)
 			}
 		}
 out:
+		atomic_set(&stream->sequence,
+			atomic_read(&stream->ispdev->isp_sdev.frm_sync_seq));
 		mi_frame_end(stream);
 	}
 }
+
+void rkisp_mipi_v20_isr(unsigned int phy, unsigned int packet,
+			 unsigned int overflow, unsigned int state,
+			 struct rkisp_device *dev)
+{
+	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
+	struct rkisp_stream *stream;
+
+	v4l2_dbg(3, rkisp_debug, &dev->v4l2_dev,
+		 "csi state:0x%x\n", state);
+	if (phy)
+		v4l2_warn(v4l2_dev, "MIPI error: phy: 0x%08x\n", phy);
+	if (packet)
+		v4l2_warn(v4l2_dev, "MIPI error: packet: 0x%08x\n", packet);
+	if (overflow)
+		v4l2_warn(v4l2_dev, "MIPI error: overflow: 0x%08x\n", overflow);
+	if (state & 0xeff00)
+		v4l2_warn(v4l2_dev, "MIPI error: size: 0x%08x\n", state);
+	if (state & MIPI_DROP_FRM)
+		v4l2_warn(v4l2_dev, "MIPI drop frame\n");
+
+	if (state & RAW0_WR_FRAME) {
+		stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX0];
+		atomic_inc_return(&stream->sequence);
+	}
+
+	if (state & RAW1_WR_FRAME) {
+		stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX1];
+		atomic_inc_return(&stream->sequence);
+	}
+
+	if (state & RAW2_WR_FRAME) {
+		stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX2];
+		atomic_inc_return(&stream->sequence);
+	}
+
+	if (state & (RAW0_RD_FRAME | RAW1_RD_FRAME | RAW2_RD_FRAME))
+		rkisp2_rawrd_isr(state, dev);
+}
diff --git a/drivers/media/platform/rockchip/isp/capture.h b/drivers/media/platform/rockchip/isp/capture.h
index e9562f590e4e..b54307d06309 100644
--- a/drivers/media/platform/rockchip/isp/capture.h
+++ b/drivers/media/platform/rockchip/isp/capture.h
@@ -88,8 +88,9 @@ struct rkisp_stream_mp {
 	bool raw_enable;
 };
 
-struct rkisp_stream_raw {
+struct rkisp_stream_dmatx {
 	u8 pre_stop;
+	u8 is_config;
 };
 
 struct rkisp_stream_dmarx {
@@ -105,6 +106,7 @@ struct stream_config {
 	const int max_rsz_height;
 	const int min_rsz_width;
 	const int min_rsz_height;
+	const int frame_end_id;
 	/* registers */
 	struct {
 		u32 ctrl;
@@ -149,7 +151,13 @@ struct stream_config {
 		u32 y_offs_cnt_init;
 		u32 cb_offs_cnt_init;
 		u32 cr_offs_cnt_init;
+		u32 y_base_ad_shd;
 	} mi;
+	struct {
+		u32 ctrl;
+		u32 pic_size;
+		u32 pic_offs;
+	} dma;
 };
 
 /* Different reg ops between selfpath and mainpath */
@@ -166,6 +174,8 @@ struct streams_ops {
 /*
  * struct rkisp_stream - ISP capture video device
  *
+ * @id: stream video identify
+ * @interlaced: selfpath interlaced flag
  * @out_isp_fmt: output isp format
  * @out_fmt: output buffer size
  * @dcrop: coordinates of dual-crop
@@ -177,9 +187,12 @@ struct streams_ops {
  * rkisp use shadowsock registers, so it need two buffer at a time
  * @curr_buf: the buffer used for current frame
  * @next_buf: the buffer used for next frame
+ * @done: wait frame end event queue
+ * @burst: burst length for Y and CB/CR
+ * @sequence: damtx video frame sequence
  */
 struct rkisp_stream {
-	unsigned id:2;
+	unsigned int id;
 	unsigned interlaced:1;
 	struct rkisp_device *ispdev;
 	struct rkisp_vdev_node vnode;
@@ -198,22 +211,34 @@ struct rkisp_stream {
 	bool frame_end;
 	wait_queue_head_t done;
 	unsigned int burst;
+	atomic_t sequence;
 	union {
 		struct rkisp_stream_sp sp;
 		struct rkisp_stream_mp mp;
-		struct rkisp_stream_raw raw;
 		struct rkisp_stream_dmarx dmarx;
+		struct rkisp_stream_dmatx dmatx;
 	} u;
 };
 
+struct rkisp_capture_device {
+	struct rkisp_device *ispdev;
+	struct rkisp_stream stream[RKISP_MAX_STREAM];
+};
+
 void rkisp_unregister_stream_vdevs(struct rkisp_device *dev);
 int rkisp_register_stream_vdevs(struct rkisp_device *dev);
 void rkisp_mi_isr(u32 mis_val, struct rkisp_device *dev);
-void rkisp_stream_init(struct rkisp_device *dev, u32 id);
 void rkisp_set_stream_def_fmt(struct rkisp_device *dev, u32 id,
 			       u32 width, u32 height, u32 pixelformat);
 void rkisp_mipi_dmatx0_end(u32 status, struct rkisp_device *dev);
 int fcc_xysubs(u32 fcc, u32 *xsubs, u32 *ysubs);
 int rkisp_fh_open(struct file *filp);
 int rkisp_fop_release(struct file *file);
+
+struct rkisp_dummy_buffer *hdr_dqbuf(struct list_head *q);
+void hdr_qbuf(struct list_head *q, struct rkisp_dummy_buffer *buf);
+int hdr_config_dmatx(struct rkisp_device *dev);
+int hdr_update_dmatx_buf(struct rkisp_device *dev);
+void hdr_stop_dmatx(struct rkisp_device *dev);
+void hdr_destroy_buf(struct rkisp_device *dev);
 #endif /* _RKISP_PATH_VIDEO_H */
diff --git a/drivers/media/platform/rockchip/isp/common.h b/drivers/media/platform/rockchip/isp/common.h
index 5b66bb9b9ff6..29305cc02f21 100644
--- a/drivers/media/platform/rockchip/isp/common.h
+++ b/drivers/media/platform/rockchip/isp/common.h
@@ -47,10 +47,13 @@
 #define RKISP_DEFAULT_WIDTH		800
 #define RKISP_DEFAULT_HEIGHT		600
 
-#define RKISP_MAX_STREAM		3
-#define RKISP_STREAM_MP		0
-#define RKISP_STREAM_SP		1
-#define RKISP_STREAM_RAW		2
+#define RKISP_MAX_STREAM		6
+#define RKISP_STREAM_MP			0
+#define RKISP_STREAM_SP			1
+#define RKISP_STREAM_DMATX0		2
+#define RKISP_STREAM_DMATX1		3
+#define RKISP_STREAM_DMATX2		4
+#define RKISP_STREAM_DMATX3		5
 
 #define RKISP_PLANE_Y			0
 #define RKISP_PLANE_CB			1
@@ -99,6 +102,7 @@ struct rkisp_buffer {
 };
 
 struct rkisp_dummy_buffer {
+	struct list_head queue;
 	void *vaddr;
 	dma_addr_t dma_addr;
 	u32 size;
diff --git a/drivers/media/platform/rockchip/isp/csi.c b/drivers/media/platform/rockchip/isp/csi.c
new file mode 100644
index 000000000000..33096f4f4740
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/csi.c
@@ -0,0 +1,489 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd. */
+
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/dma-iommu.h>
+#include <linux/rk-camera-module.h>
+#include "dev.h"
+#include "regs.h"
+
+static void get_remote_mipi_sensor(struct rkisp_device *dev,
+				  struct v4l2_subdev **sensor_sd)
+{
+	struct media_graph graph;
+	struct media_entity *entity = &dev->isp_sdev.sd.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	int ret;
+
+	/* Walk the graph to locate sensor nodes. */
+	mutex_lock(&mdev->graph_mutex);
+	ret = media_graph_walk_init(&graph, mdev);
+	if (ret) {
+		mutex_unlock(&mdev->graph_mutex);
+		*sensor_sd = NULL;
+		return;
+	}
+
+	media_graph_walk_start(&graph, entity);
+	while ((entity = media_graph_walk_next(&graph))) {
+		if (entity->function == MEDIA_ENT_F_CAM_SENSOR)
+			break;
+	}
+	mutex_unlock(&mdev->graph_mutex);
+	media_graph_walk_cleanup(&graph);
+
+	if (entity)
+		*sensor_sd = media_entity_to_v4l2_subdev(entity);
+	else
+		*sensor_sd = NULL;
+}
+
+static struct v4l2_subdev *get_remote_subdev(struct v4l2_subdev *sd)
+{
+	struct media_pad *local, *remote;
+	struct v4l2_subdev *remote_sd = NULL;
+
+	local = &sd->entity.pads[CSI_SINK];
+	if (!local)
+		goto end;
+	remote = media_entity_remote_pad(local);
+	if (!remote)
+		goto end;
+
+	remote_sd = media_entity_to_v4l2_subdev(remote->entity);
+end:
+	return remote_sd;
+}
+
+static int rkisp_csi_link_setup(struct media_entity *entity,
+				 const struct media_pad *local,
+				 const struct media_pad *remote,
+				 u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct rkisp_csi_device *csi;
+	int ret = 0;
+	u8 id;
+
+	if (!sd)
+		return -ENODEV;
+
+	csi = v4l2_get_subdevdata(sd);
+	if (local->flags & MEDIA_PAD_FL_SOURCE) {
+		id = local->index - 1;
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (csi->sink[id].linked) {
+				ret = -EBUSY;
+				goto out;
+			}
+			csi->sink[id].linked = true;
+			csi->sink[id].index = 1 << id;
+		} else {
+			csi->sink[id].linked = false;
+			csi->sink[id].index = 0;
+		}
+	}
+	return 0;
+out:
+	v4l2_err(sd, "pad%d is already linked\n", local->index);
+	return ret;
+}
+
+static int rkisp_csi_g_mbus_config(struct v4l2_subdev *sd,
+				  struct v4l2_mbus_config *config)
+{
+	struct v4l2_subdev *remote_sd;
+
+	if (!sd)
+		return -ENODEV;
+	remote_sd = get_remote_subdev(sd);
+	return v4l2_subdev_call(remote_sd, video, g_mbus_config, config);
+}
+
+static int rkisp_csi_get_set_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_subdev *remote_sd;
+
+	if (fmt->pad != CSI_SINK)
+		fmt->pad -= 1;
+
+	if (!sd)
+		return -ENODEV;
+	remote_sd = get_remote_subdev(sd);
+	return v4l2_subdev_call(remote_sd, pad, get_fmt, NULL, fmt);
+}
+
+static int rkisp_csi_s_stream(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static int rkisp_csi_s_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static const struct media_entity_operations rkisp_csi_media_ops = {
+	.link_setup = rkisp_csi_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_pad_ops rkisp_csi_pad_ops = {
+	.set_fmt = rkisp_csi_get_set_fmt,
+	.get_fmt = rkisp_csi_get_set_fmt,
+};
+
+static const struct v4l2_subdev_video_ops rkisp_csi_video_ops = {
+	.g_mbus_config = rkisp_csi_g_mbus_config,
+	.s_stream = rkisp_csi_s_stream,
+};
+
+static const struct v4l2_subdev_core_ops rkisp_csi_core_ops = {
+	.s_power = rkisp_csi_s_power,
+};
+
+static struct v4l2_subdev_ops rkisp_csi_ops = {
+	.core = &rkisp_csi_core_ops,
+	.video = &rkisp_csi_video_ops,
+	.pad = &rkisp_csi_pad_ops,
+};
+
+static int csi_config(struct rkisp_csi_device *csi)
+{
+	struct rkisp_device *dev = csi->ispdev;
+	void __iomem *base = dev->base_addr;
+	struct rkisp_sensor_info *sensor = dev->active_sensor;
+	struct v4l2_subdev *mipi_sensor;
+	struct v4l2_ctrl *ctrl;
+	u32 emd_vc, emd_dt, mipi_ctrl;
+	int lanes, ret, i;
+
+	/*
+	 * sensor->mbus is set in isp or d-phy notifier_bound function
+	 */
+	switch (sensor->mbus.flags & V4L2_MBUS_CSI2_LANES) {
+	case V4L2_MBUS_CSI2_4_LANE:
+		lanes = 4;
+		break;
+	case V4L2_MBUS_CSI2_3_LANE:
+		lanes = 3;
+		break;
+	case V4L2_MBUS_CSI2_2_LANE:
+		lanes = 2;
+		break;
+	case V4L2_MBUS_CSI2_1_LANE:
+		lanes = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	emd_vc = 0xFF;
+	emd_dt = 0;
+	dev->hdr.sensor = NULL;
+	get_remote_mipi_sensor(dev, &mipi_sensor);
+	if (mipi_sensor) {
+		ctrl = v4l2_ctrl_find(mipi_sensor->ctrl_handler,
+				      CIFISP_CID_EMB_VC);
+		if (ctrl)
+			emd_vc = v4l2_ctrl_g_ctrl(ctrl);
+
+		ctrl = v4l2_ctrl_find(mipi_sensor->ctrl_handler,
+				      CIFISP_CID_EMB_DT);
+		if (ctrl)
+			emd_dt = v4l2_ctrl_g_ctrl(ctrl);
+		dev->hdr.sensor = mipi_sensor;
+	}
+
+	dev->emd_dt = emd_dt;
+	dev->emd_vc = emd_vc;
+	dev->emd_data_idx = 0;
+	if (emd_vc <= CIF_ISP_ADD_DATA_VC_MAX) {
+		for (i = 0; i < RKISP_EMDDATA_FIFO_MAX; i++) {
+			ret = kfifo_alloc(&dev->emd_data_fifo[i].mipi_kfifo,
+					  CIFISP_ADD_DATA_FIFO_SIZE,
+					  GFP_ATOMIC);
+			if (ret) {
+				v4l2_err(&dev->v4l2_dev,
+					 "kfifo_alloc failed with error %d\n",
+					 ret);
+				return ret;
+			}
+		}
+	}
+
+	if (dev->isp_ver == ISP_V13 ||
+	    dev->isp_ver == ISP_V12) {
+		/* lanes */
+		writel(lanes - 1, base + CIF_ISP_CSI0_CTRL1);
+
+		/* linecnt */
+		writel(0x3FFF, base + CIF_ISP_CSI0_CTRL2);
+
+		/* Configure Data Type and Virtual Channel */
+		writel(csi->mipi_di[0] | csi->mipi_di[1] << 8,
+		       base + CIF_ISP_CSI0_DATA_IDS_1);
+
+		/* clear interrupts state */
+		readl(base + CIF_ISP_CSI0_ERR1);
+		readl(base + CIF_ISP_CSI0_ERR2);
+		readl(base + CIF_ISP_CSI0_ERR3);
+		/* set interrupts mask */
+		writel(0x1FFFFFF0, base + CIF_ISP_CSI0_MASK1);
+		writel(0x03FFFFFF, base + CIF_ISP_CSI0_MASK2);
+		writel(CIF_ISP_CSI0_IMASK_FRAME_END(0x3F) |
+		       CIF_ISP_CSI0_IMASK_RAW0_OUT_V_END |
+		       CIF_ISP_CSI0_IMASK_RAW1_OUT_V_END |
+		       CIF_ISP_CSI0_IMASK_LINECNT,
+		       base + CIF_ISP_CSI0_MASK3);
+
+		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+			 "CSI0_CTRL1 0x%08x\n"
+			 "CSI0_IDS 0x%08x\n"
+			 "CSI0_MASK3 0x%08x\n",
+			 readl(base + CIF_ISP_CSI0_CTRL1),
+			 readl(base + CIF_ISP_CSI0_DATA_IDS_1),
+			 readl(base + CIF_ISP_CSI0_MASK3));
+	} else if (dev->isp_ver == ISP_V20) {
+		struct rkmodule_hdr_cfg hdr_cfg;
+		u32 val;
+
+		dev->hdr.op_mode = HDR_NORMAL;
+		dev->hdr.esp_mode = HDR_NORMAL_VC;
+		if (mipi_sensor) {
+			ret = v4l2_subdev_call(mipi_sensor,
+					       core, ioctl,
+					       RKMODULE_HDR_CFG,
+					       &hdr_cfg);
+			if (!ret) {
+				dev->hdr.op_mode = hdr_cfg.hdr_mode;
+				dev->hdr.esp_mode = hdr_cfg.esp.mode;
+			}
+		}
+#if RKISP_HDR_DBG_MODE
+		switch (dev->hdr.op_mode) {
+		case HDR_FRAMEX2_DDR:
+		case HDR_LINEX2_DDR:
+		case HDR_LINEX2_NO_DDR:
+			dev->hdr.op_mode = HDR_DBG_FRAME2;
+			break;
+		case HDR_FRAMEX3_DDR:
+		case HDR_LINEX3_DDR:
+		case HDR_LINEX3_NO_DDR:
+			dev->hdr.op_mode = HDR_DBG_FRAME3;
+			break;
+		case HDR_NORMAL:
+			dev->hdr.op_mode = HDR_DBG_FRAME1;
+			break;
+		default:
+			break;
+		}
+#endif
+		writel(SW_IBUF_OP_MODE(dev->hdr.op_mode) |
+		       SW_HDR_ESP_MODE(dev->hdr.esp_mode),
+		       base + CSI2RX_CTRL0);
+		writel(lanes - 1, base + CSI2RX_CTRL1);
+		writel(0x3FFF, base + CSI2RX_CTRL2);
+		val = SW_CSI_ID0(csi->mipi_di[0]) |
+		      SW_CSI_ID1(csi->mipi_di[1]) |
+		      SW_CSI_ID2(csi->mipi_di[2]) |
+		      SW_CSI_ID3(csi->mipi_di[3]);
+		writel(val, base + CSI2RX_DATA_IDS_1);
+		val = SW_CSI_ID4(csi->mipi_di[4]);
+		writel(val, base + CSI2RX_DATA_IDS_2);
+		/* clear interrupts state */
+		readl(base + CSI2RX_ERR_PHY);
+		/* set interrupts mask */
+		writel(0xF0FFFF, base + CSI2RX_MASK_PHY);
+		writel(0xF1FFFFF, base + CSI2RX_MASK_PACKET);
+		writel(0x7F7FF1, base + CSI2RX_MASK_OVERFLOW);
+		writel(0x7FFFFF7F, base + CSI2RX_MASK_STAT);
+
+		/* hdr merge */
+		switch (dev->hdr.op_mode) {
+		case HDR_DBG_FRAME2:
+		case HDR_FRAMEX2_DDR:
+		case HDR_LINEX2_DDR:
+		case HDR_LINEX2_NO_DDR:
+			val = SW_HDRMGE_EN |
+			      SW_HDRMGE_MODE_FRAMEX2;
+			break;
+		case HDR_DBG_FRAME3:
+		case HDR_FRAMEX3_DDR:
+		case HDR_LINEX3_DDR:
+		case HDR_LINEX3_NO_DDR:
+			val = SW_HDRMGE_EN |
+			      SW_HDRMGE_MODE_FRAMEX3;
+			break;
+		default:
+			val = 0;
+		}
+		writel(val, base + ISP_HDRMGE_BASE);
+		writel(val & SW_HDRMGE_EN, base + ISP_HDRTMO_BASE);
+
+		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+			 "CSI2RX_IDS 0x%08x 0x%08x\n",
+			 readl(base + CSI2RX_DATA_IDS_1),
+			 readl(base + CSI2RX_DATA_IDS_2));
+	} else {
+		mipi_ctrl = CIF_MIPI_CTRL_NUM_LANES(lanes - 1) |
+			    CIF_MIPI_CTRL_SHUTDOWNLANES(0xf) |
+			    CIF_MIPI_CTRL_ERR_SOT_SYNC_HS_SKIP |
+			    CIF_MIPI_CTRL_CLOCKLANE_ENA;
+
+		writel(mipi_ctrl, base + CIF_MIPI_CTRL);
+
+		/* Configure Data Type and Virtual Channel */
+		writel(csi->mipi_di[0],
+		       base + CIF_MIPI_IMG_DATA_SEL);
+
+		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) |
+		       CIF_MIPI_DATA_SEL_VC(emd_vc),
+		       base + CIF_MIPI_ADD_DATA_SEL_1);
+		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) |
+		       CIF_MIPI_DATA_SEL_VC(emd_vc),
+		       base + CIF_MIPI_ADD_DATA_SEL_2);
+		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) |
+		       CIF_MIPI_DATA_SEL_VC(emd_vc),
+		       base + CIF_MIPI_ADD_DATA_SEL_3);
+		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) |
+		       CIF_MIPI_DATA_SEL_VC(emd_vc),
+		       base + CIF_MIPI_ADD_DATA_SEL_4);
+
+		/* Clear MIPI interrupts */
+		writel(~0, base + CIF_MIPI_ICR);
+		/*
+		 * Disable CIF_MIPI_ERR_DPHY interrupt here temporary for
+		 * isp bus may be dead when switch isp.
+		 */
+		writel(CIF_MIPI_FRAME_END | CIF_MIPI_ERR_CSI |
+		       CIF_MIPI_ERR_DPHY | CIF_MIPI_SYNC_FIFO_OVFLW(0x0F) |
+		       CIF_MIPI_ADD_DATA_OVFLW, base + CIF_MIPI_IMSC);
+
+		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+			 "\n  MIPI_CTRL 0x%08x\n"
+			 "  MIPI_IMG_DATA_SEL 0x%08x\n"
+			 "  MIPI_STATUS 0x%08x\n"
+			 "  MIPI_IMSC 0x%08x\n",
+			 readl(base + CIF_MIPI_CTRL),
+			 readl(base + CIF_MIPI_IMG_DATA_SEL),
+			 readl(base + CIF_MIPI_STATUS),
+			 readl(base + CIF_MIPI_IMSC));
+	}
+
+	return 0;
+}
+
+int rkisp_csi_config_patch(struct rkisp_device *dev)
+{
+	int val = 0, ret = 0;
+
+	if (dev->isp_inp & INP_CSI) {
+		ret = csi_config(&dev->csi_dev);
+	} else {
+		switch (dev->isp_inp & 0x7) {
+		case INP_RAWRD2 | INP_RAWRD0:
+			dev->hdr.op_mode = HDR_DBG_FRAME2;
+			val = SW_HDRMGE_EN |
+				SW_HDRMGE_MODE_FRAMEX2;
+			break;
+		case INP_RAWRD2 | INP_RAWRD1 | INP_RAWRD0:
+			dev->hdr.op_mode = HDR_DBG_FRAME3;
+			val = SW_HDRMGE_EN |
+				SW_HDRMGE_MODE_FRAMEX3;
+			break;
+		default: //INP_RAWRD2
+			dev->hdr.op_mode = HDR_DBG_FRAME1;
+		}
+		writel(SW_IBUF_OP_MODE(dev->hdr.op_mode),
+		       dev->base_addr + CSI2RX_CTRL0);
+		writel(val, dev->base_addr + ISP_HDRMGE_BASE);
+		writel(val & SW_HDRMGE_EN, dev->base_addr + ISP_HDRTMO_BASE);
+		writel(0x7FFFFF7F, dev->base_addr + CSI2RX_MASK_STAT);
+	}
+	return ret;
+}
+
+/*
+ * for hdr debug mode, rawrd read back data
+ * this will update rawrd base addr to shadow.
+ */
+void rkisp_trigger_read_back(struct rkisp_csi_device *csi, u8 dma2frm)
+{
+	struct rkisp_device *dev = csi->ispdev;
+	void __iomem *addr = dev->base_addr + CSI2RX_CTRL0;
+
+	writel(SW_CSI2RX_EN | SW_DMA_2FRM_MODE(dma2frm) | readl(addr), addr);
+}
+
+int rkisp_register_csi_subdev(struct rkisp_device *dev,
+			       struct v4l2_device *v4l2_dev)
+{
+	struct rkisp_csi_device *csi_dev = &dev->csi_dev;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	memset(csi_dev, 0, sizeof(*csi_dev));
+	csi_dev->ispdev = dev;
+	sd = &csi_dev->sd;
+
+	v4l2_subdev_init(sd, &rkisp_csi_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.ops = &rkisp_csi_media_ops;
+	sd->entity.function = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;
+	snprintf(sd->name, sizeof(sd->name), CSI_DEV_NAME);
+
+	csi_dev->pads[CSI_SINK].flags =
+		MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;
+	csi_dev->pads[CSI_SRC_CH0].flags =
+		MEDIA_PAD_FL_SOURCE | MEDIA_PAD_FL_MUST_CONNECT;
+
+	csi_dev->max_pad = CSI_SRC_CH0 + 1;
+	if (dev->isp_ver == ISP_V12 ||
+	    dev->isp_ver == ISP_V13) {
+		csi_dev->max_pad = CSI_SRC_CH1 + 1;
+		csi_dev->pads[CSI_SRC_CH1].flags = MEDIA_PAD_FL_SOURCE;
+	} else if (dev->isp_ver == ISP_V20) {
+		csi_dev->max_pad = CSI_PAD_MAX;
+		csi_dev->pads[CSI_SRC_CH1].flags = MEDIA_PAD_FL_SOURCE;
+		csi_dev->pads[CSI_SRC_CH2].flags = MEDIA_PAD_FL_SOURCE;
+		csi_dev->pads[CSI_SRC_CH3].flags = MEDIA_PAD_FL_SOURCE;
+		csi_dev->pads[CSI_SRC_CH4].flags = MEDIA_PAD_FL_SOURCE;
+	}
+
+	ret = media_entity_pads_init(&sd->entity, csi_dev->max_pad,
+				     csi_dev->pads);
+	if (ret < 0)
+		return ret;
+	sd->owner = THIS_MODULE;
+	v4l2_set_subdevdata(sd, csi_dev);
+	sd->grp_id = GRP_ID_CSI;
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Failed to register csi subdev\n");
+		goto free_media;
+	}
+
+	return 0;
+
+free_media:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+void rkisp_unregister_csi_subdev(struct rkisp_device *dev)
+{
+	struct v4l2_subdev *sd = &dev->csi_dev.sd;
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+}
diff --git a/drivers/media/platform/rockchip/isp/csi.h b/drivers/media/platform/rockchip/isp/csi.h
new file mode 100644
index 000000000000..3f82234e8aac
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/csi.h
@@ -0,0 +1,69 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd. */
+
+#ifndef _RKISP_CSI_H
+#define _RKISP_CSI_H
+
+#define CSI_DEV_NAME DRIVER_NAME "-csi-subdev"
+
+#define RKISP_HDR_DBG_MODE 0
+
+#define HDR_MAX_DUMMY_BUF 3
+/* define max dmatx to use for hdr */
+#define HDR_DMA_MAX 3
+#define HDR_DMA0 0
+#define HDR_DMA1 1
+#define HDR_DMA2 2
+
+#define IS_HDR_DBG(x) ({ \
+	typeof(x) __x = (x); \
+	(__x == HDR_DBG_FRAME1 || \
+	 __x == HDR_DBG_FRAME2 || \
+	 __x == HDR_DBG_FRAME3); \
+})
+
+enum hdr_op_mode {
+	HDR_NORMAL = 0,
+	HDR_DBG_FRAME1 = 4,
+	HDR_DBG_FRAME2 = 5,
+	HDR_DBG_FRAME3 = 6,
+	HDR_FRAMEX2_DDR = 8,
+	HDR_LINEX2_DDR = 9,
+	HDR_LINEX2_NO_DDR = 10,
+	HDR_FRAMEX3_DDR = 12,
+	HDR_LINEX3_DDR = 13,
+	HDR_LINEX3_NO_DDR = 14,
+};
+
+enum rkisp_csi_pad {
+	CSI_SINK,
+	CSI_SRC_CH0,
+	CSI_SRC_CH1,
+	CSI_SRC_CH2,
+	CSI_SRC_CH3,
+	CSI_SRC_CH4,
+	CSI_PAD_MAX
+};
+
+struct sink_info {
+	u8 index;
+	u8 linked;
+};
+
+struct rkisp_csi_device {
+	struct rkisp_device *ispdev;
+	struct v4l2_subdev sd;
+	struct media_pad pads[CSI_PAD_MAX];
+	int max_pad;
+	struct sink_info sink[CSI_PAD_MAX - 1];
+	/* Data Identifier */
+	u8 mipi_di[CSI_PAD_MAX - 1];
+};
+
+int rkisp_register_csi_subdev(struct rkisp_device *dev,
+			      struct v4l2_device *v4l2_dev);
+void rkisp_unregister_csi_subdev(struct rkisp_device *dev);
+
+int rkisp_csi_config_patch(struct rkisp_device *dev);
+void rkisp_trigger_read_back(struct rkisp_csi_device *csi, u8 dma2frm);
+#endif
diff --git a/drivers/media/platform/rockchip/isp/dev.c b/drivers/media/platform/rockchip/isp/dev.c
index 8987b9e250ee..5f019bac6718 100644
--- a/drivers/media/platform/rockchip/isp/dev.c
+++ b/drivers/media/platform/rockchip/isp/dev.c
@@ -92,7 +92,7 @@ static int __isp_pipeline_prepare(struct rkisp_pipeline *p,
 	p->num_subdevs = 0;
 	memset(p->subdevs, 0, sizeof(p->subdevs));
 
-	if (dev->isp_inp == INP_DMARX_ISP)
+	if (!(dev->isp_inp & (INP_CSI | INP_DVP)))
 		return 0;
 
 	while (1) {
@@ -104,7 +104,7 @@ static int __isp_pipeline_prepare(struct rkisp_pipeline *p,
 
 			if (!(spad->flags & MEDIA_PAD_FL_SINK))
 				continue;
-			pad = media_entity_remote_pad(spad);
+			pad = rkisp_media_entity_remote_pad(spad);
 			if (pad)
 				break;
 		}
@@ -135,8 +135,9 @@ static int __isp_pipeline_s_isp_clk(struct rkisp_pipeline *p)
 	u64 data_rate;
 	int i;
 
-	if (dev->isp_inp == INP_DMARX_ISP) {
-		clk_set_rate(dev->clks[0], 400 * 1000000UL);
+	if (!(dev->isp_inp & (INP_CSI | INP_DVP))) {
+		if (dev->clks[0])
+			clk_set_rate(dev->clks[0], 400 * 1000000UL);
 		return 0;
 	}
 
@@ -188,6 +189,7 @@ static int rkisp_pipeline_open(struct rkisp_pipeline *p,
 				bool prepare)
 {
 	int ret;
+	struct rkisp_device *dev = container_of(p, struct rkisp_device, pipe);
 
 	if (WARN_ON(!p || !me))
 		return -EINVAL;
@@ -205,6 +207,8 @@ static int rkisp_pipeline_open(struct rkisp_pipeline *p,
 	if (ret < 0)
 		return ret;
 
+	if (dev->isp_inp & (INP_CSI | INP_RAWRD0 | INP_RAWRD1 | INP_RAWRD2))
+		rkisp_csi_config_patch(dev);
 	return 0;
 }
 
@@ -264,13 +268,13 @@ static int rkisp_pipeline_set_stream(struct rkisp_pipeline *p, bool on)
 
 static int rkisp_create_links(struct rkisp_device *dev)
 {
-	struct media_entity *source, *sink;
-	unsigned int flags, s, pad;
+	unsigned int s, pad;
 	int ret;
 
 	/* sensor links(or mipi-phy) */
 	for (s = 0; s < dev->num_sensors; ++s) {
 		struct rkisp_sensor_info *sensor = &dev->sensors[s];
+		u32 type = sensor->sd->entity.function;
 
 		for (pad = 0; pad < sensor->sd->entity.num_pads; pad++)
 			if (sensor->sd->entity.pads[pad].flags &
@@ -285,11 +289,27 @@ static int rkisp_create_links(struct rkisp_device *dev)
 			return -ENXIO;
 		}
 
-		ret = media_create_pad_link(
-				&sensor->sd->entity, pad,
-				&dev->isp_sdev.sd.entity,
+		/* sensor link -> isp */
+		if (type == MEDIA_ENT_F_CAM_SENSOR) {
+			dev->isp_inp = INP_DVP;
+			ret = media_create_pad_link(&sensor->sd->entity,
+				pad, &dev->isp_sdev.sd.entity,
+				RKISP_ISP_PAD_SINK,
+				s ? 0 : MEDIA_LNK_FL_ENABLED);
+		} else {
+			/* mipi-phy link -> csi -> isp */
+			dev->isp_inp = INP_CSI;
+			ret = media_create_pad_link(&sensor->sd->entity,
+				pad, &dev->csi_dev.sd.entity, CSI_SINK,
+				s ? 0 : MEDIA_LNK_FL_ENABLED);
+			ret |= media_create_pad_link(&dev->csi_dev.sd.entity,
+				CSI_SRC_CH0, &dev->isp_sdev.sd.entity,
 				RKISP_ISP_PAD_SINK,
 				s ? 0 : MEDIA_LNK_FL_ENABLED);
+			dev->csi_dev.sink[0].linked = true;
+			dev->csi_dev.sink[0].index = BIT(0);
+		}
+
 		if (ret) {
 			dev_err(dev->dev,
 				"failed to create link for %s\n",
@@ -297,52 +317,7 @@ static int rkisp_create_links(struct rkisp_device *dev)
 			return ret;
 		}
 	}
-
-	/* params links */
-	source = &dev->params_vdev.vnode.vdev.entity;
-	sink = &dev->isp_sdev.sd.entity;
-	flags = MEDIA_LNK_FL_ENABLED;
-	ret = media_create_pad_link(source, 0, sink,
-				       RKISP_ISP_PAD_SINK_PARAMS, flags);
-	if (ret < 0)
-		return ret;
-
-	/* create isp internal links */
-	if (dev->isp_ver != ISP_V10_1) {
-		/* SP links */
-		source = &dev->isp_sdev.sd.entity;
-		sink = &dev->stream[RKISP_STREAM_SP].vnode.vdev.entity;
-		ret = media_create_pad_link(source,
-					    RKISP_ISP_PAD_SOURCE_PATH,
-					    sink, 0, flags);
-		if (ret < 0)
-			return ret;
-	}
-
-	/* MP links */
-	source = &dev->isp_sdev.sd.entity;
-	sink = &dev->stream[RKISP_STREAM_MP].vnode.vdev.entity;
-	ret = media_create_pad_link(source, RKISP_ISP_PAD_SOURCE_PATH,
-				    sink, 0, flags);
-	if (ret < 0)
-		return ret;
-
-	if (dev->isp_ver == ISP_V12 ||
-		dev->isp_ver == ISP_V13) {
-		/* MIPI RAW links */
-		source = &dev->isp_sdev.sd.entity;
-		sink = &dev->stream[RKISP_STREAM_RAW].vnode.vdev.entity;
-		ret = media_create_pad_link(source,
-			RKISP_ISP_PAD_SOURCE_PATH, sink, 0, flags);
-		if (ret < 0)
-			return ret;
-	}
-
-	/* 3A stats links */
-	source = &dev->isp_sdev.sd.entity;
-	sink = &dev->stats_vdev.vnode.vdev.entity;
-	return media_create_pad_link(source, RKISP_ISP_PAD_SOURCE_STATS,
-					sink, 0, flags);
+	return 0;
 }
 
 static int _set_pipeline_default_fmt(struct rkisp_device *dev)
@@ -356,10 +331,7 @@ static int _set_pipeline_default_fmt(struct rkisp_device *dev)
 
 	isp = &dev->isp_sdev.sd;
 
-	fmt = dev->active_sensor->fmt;
-	ori_width = fmt.format.width;
-	ori_height = fmt.format.height;
-	ori_code = fmt.format.code;
+	fmt = dev->active_sensor->fmt[0];
 
 	if (dev->isp_ver == ISP_V12) {
 		fmt.format.width  = clamp_t(u32, fmt.format.width,
@@ -417,10 +389,32 @@ static int _set_pipeline_default_fmt(struct rkisp_device *dev)
 	if (dev->isp_ver != ISP_V10_1)
 		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_SP,
 					 width, height, V4L2_PIX_FMT_YUYV);
-	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13)
-		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_RAW, ori_width,
-			ori_height, rkisp_mbus_pixelcode_to_v4l2(ori_code));
-
+	if ((dev->isp_ver == ISP_V12 ||
+	     dev->isp_ver == ISP_V13 ||
+	     dev->isp_ver == ISP_V20) &&
+	    dev->active_sensor->mbus.type == V4L2_MBUS_CSI2) {
+		ori_width = dev->active_sensor->fmt[1].format.width;
+		ori_height = dev->active_sensor->fmt[1].format.height;
+		ori_code = dev->active_sensor->fmt[1].format.code;
+		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_DMATX0,
+			ori_width, ori_height,
+			rkisp_mbus_pixelcode_to_v4l2(ori_code));
+	}
+	if (dev->isp_ver == ISP_V20 &&
+	    dev->active_sensor->mbus.type == V4L2_MBUS_CSI2) {
+		ori_width = dev->active_sensor->fmt[2].format.width;
+		ori_height = dev->active_sensor->fmt[2].format.height;
+		ori_code = dev->active_sensor->fmt[2].format.code;
+		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_DMATX1,
+			ori_width, ori_height,
+			rkisp_mbus_pixelcode_to_v4l2(ori_code));
+		ori_width = dev->active_sensor->fmt[3].format.width;
+		ori_height = dev->active_sensor->fmt[3].format.height;
+		ori_code = dev->active_sensor->fmt[3].format.code;
+		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_DMATX2,
+			ori_width, ori_height,
+			rkisp_mbus_pixelcode_to_v4l2(ori_code));
+	}
 	return 0;
 }
 
@@ -539,10 +533,18 @@ static int rkisp_register_platform_subdevs(struct rkisp_device *dev)
 	if (ret < 0)
 		return ret;
 
-	ret = rkisp_register_stream_vdevs(dev);
+	ret = rkisp_register_csi_subdev(dev, &dev->v4l2_dev);
 	if (ret < 0)
 		goto err_unreg_isp_subdev;
 
+	ret = rkisp_register_mpfbc_subdev(dev, &dev->v4l2_dev);
+	if (ret < 0)
+		goto err_unreg_csi_subdev;
+
+	ret = rkisp_register_stream_vdevs(dev);
+	if (ret < 0)
+		goto err_unreg_mpfbc_subdev;
+
 	ret = rkisp_register_dmarx_vdev(dev);
 	if (ret < 0)
 		goto err_unreg_stream_vdev;
@@ -559,6 +561,10 @@ static int rkisp_register_platform_subdevs(struct rkisp_device *dev)
 	if (ret < 0) {
 		v4l2_err(&dev->v4l2_dev,
 			 "Failed to register subdev notifier(%d)\n", ret);
+		/* maybe use dmarx to input image */
+		ret = v4l2_device_register_subdev_nodes(&dev->v4l2_dev);
+		if (ret == 0)
+			return 0;
 		goto err_unreg_params_vdev;
 	}
 
@@ -571,6 +577,10 @@ static int rkisp_register_platform_subdevs(struct rkisp_device *dev)
 	rkisp_unregister_dmarx_vdev(dev);
 err_unreg_stream_vdev:
 	rkisp_unregister_stream_vdevs(dev);
+err_unreg_mpfbc_subdev:
+	rkisp_unregister_mpfbc_subdev(dev);
+err_unreg_csi_subdev:
+	rkisp_unregister_csi_subdev(dev);
 err_unreg_isp_subdev:
 	rkisp_unregister_isp_subdev(dev);
 
@@ -628,21 +638,32 @@ static irqreturn_t rkisp_mipi_irq_hdl(int irq, void *ctx)
 {
 	struct device *dev = ctx;
 	struct rkisp_device *rkisp_dev = dev_get_drvdata(dev);
-	unsigned int mis_val;
-	unsigned int err1, err2, err3;
 
 	if (rkisp_dev->isp_ver == ISP_V13 ||
 		rkisp_dev->isp_ver == ISP_V12) {
+		u32 err1, err2, err3;
+
 		err1 = readl(rkisp_dev->base_addr + CIF_ISP_CSI0_ERR1);
 		err2 = readl(rkisp_dev->base_addr + CIF_ISP_CSI0_ERR2);
 		err3 = readl(rkisp_dev->base_addr + CIF_ISP_CSI0_ERR3);
 
-		if (err3 & 0x1)
+		if (err3 & 0xf)
 			rkisp_mipi_dmatx0_end(err3, rkisp_dev);
 		if (err1 || err2 || err3)
 			rkisp_mipi_v13_isr(err1, err2, err3, rkisp_dev);
+	} else if (rkisp_dev->isp_ver == ISP_V20) {
+		u32 phy, packet, overflow, state;
+
+		state = readl(rkisp_dev->base_addr + CSI2RX_ERR_STAT);
+		phy = readl(rkisp_dev->base_addr + CSI2RX_ERR_PHY);
+		packet = readl(rkisp_dev->base_addr + CSI2RX_ERR_PACKET);
+		overflow = readl(rkisp_dev->base_addr + CSI2RX_ERR_OVERFLOW);
+		if (phy | packet | overflow | state)
+			rkisp_mipi_v20_isr(phy, packet, overflow,
+					    state, rkisp_dev);
 	} else {
-		mis_val = readl(rkisp_dev->base_addr + CIF_MIPI_MIS);
+		u32 mis_val = readl(rkisp_dev->base_addr + CIF_MIPI_MIS);
+
 		if (mis_val)
 			rkisp_mipi_isr(mis_val, rkisp_dev);
 	}
@@ -966,7 +987,9 @@ static int rkisp_plat_probe(struct platform_device *pdev)
 				return ret;
 			}
 
-			if (isp_dev->mipi_irq == irq)
+			if (isp_dev->mipi_irq == irq &&
+			    (isp_dev->isp_ver == ISP_V12 ||
+			     isp_dev->isp_ver == ISP_V13))
 				disable_irq(isp_dev->mipi_irq);
 		}
 	} else {
@@ -1010,9 +1033,12 @@ static int rkisp_plat_probe(struct platform_device *pdev)
 	isp_dev->pipe.close = rkisp_pipeline_close;
 	isp_dev->pipe.set_stream = rkisp_pipeline_set_stream;
 
-	rkisp_stream_init(isp_dev, RKISP_STREAM_SP);
-	rkisp_stream_init(isp_dev, RKISP_STREAM_MP);
-	rkisp_stream_init(isp_dev, RKISP_STREAM_RAW);
+	if (isp_dev->isp_ver == ISP_V20) {
+		for (i = 0; i < HDR_DMA_MAX; i++) {
+			INIT_LIST_HEAD(&isp_dev->hdr.q_tx[i]);
+			INIT_LIST_HEAD(&isp_dev->hdr.q_rx[i]);
+		}
+	}
 
 	strlcpy(isp_dev->media_dev.model, DRIVER_NAME,
 		sizeof(isp_dev->media_dev.model));
@@ -1083,6 +1109,8 @@ static int rkisp_plat_remove(struct platform_device *pdev)
 	rkisp_unregister_params_vdev(&isp_dev->params_vdev);
 	rkisp_unregister_stats_vdev(&isp_dev->stats_vdev);
 	rkisp_unregister_stream_vdevs(isp_dev);
+	rkisp_unregister_mpfbc_subdev(isp_dev);
+	rkisp_unregister_csi_subdev(isp_dev);
 	rkisp_unregister_isp_subdev(isp_dev);
 	media_device_cleanup(&isp_dev->media_dev);
 
diff --git a/drivers/media/platform/rockchip/isp/dev.h b/drivers/media/platform/rockchip/isp/dev.h
index ddaeb100acb0..983de8f3c321 100644
--- a/drivers/media/platform/rockchip/isp/dev.h
+++ b/drivers/media/platform/rockchip/isp/dev.h
@@ -36,17 +36,31 @@
 #define _RKISP_DEV_H
 
 #include "capture.h"
+#include "csi.h"
 #include "dmarx.h"
+#include "mpfbc.h"
 #include "rkisp.h"
 #include "isp_params.h"
 #include "isp_stats.h"
 
+#ifdef VIDEO_ROCKCHIP_ISP1
 #define DRIVER_NAME "rkisp1"
+#else
+#define DRIVER_NAME "rkisp"
+#endif
+
 #define ISP_VDEV_NAME DRIVER_NAME  "_ispdev"
 #define SP_VDEV_NAME DRIVER_NAME   "_selfpath"
 #define MP_VDEV_NAME DRIVER_NAME   "_mainpath"
 #define DMA_VDEV_NAME DRIVER_NAME  "_dmapath"
 #define RAW_VDEV_NAME DRIVER_NAME  "_rawpath"
+#define DMATX0_VDEV_NAME DRIVER_NAME "_rawwr0"
+#define DMATX1_VDEV_NAME DRIVER_NAME "_rawwr1"
+#define DMATX2_VDEV_NAME DRIVER_NAME "_rawwr2"
+#define DMATX3_VDEV_NAME DRIVER_NAME "_rawwr3"
+#define DMARX0_VDEV_NAME DRIVER_NAME "_rawrd0_m"
+#define DMARX1_VDEV_NAME DRIVER_NAME "_rawrd1_l"
+#define DMARX2_VDEV_NAME DRIVER_NAME "_rawrd2_s"
 
 #define GRP_ID_SENSOR			BIT(0)
 #define GRP_ID_MIPIPHY			BIT(1)
@@ -54,10 +68,12 @@
 #define GRP_ID_ISP_MP			BIT(3)
 #define GRP_ID_ISP_SP			BIT(4)
 #define GRP_ID_ISP_DMARX		BIT(5)
+#define GRP_ID_ISP_MPFBC		BIT(6)
+#define GRP_ID_CSI			BIT(7)
 
-#define RKISP_MAX_BUS_CLK	8
-#define RKISP_MAX_SENSOR	2
-#define RKISP_MAX_PIPELINE	4
+#define RKISP_MAX_BUS_CLK		8
+#define RKISP_MAX_SENSOR		2
+#define RKISP_MAX_PIPELINE		4
 
 #define RKISP_MEDIA_BUS_FMT_MASK	0xF000
 #define RKISP_MEDIA_BUS_FMT_BAYER	0x3000
@@ -71,6 +87,7 @@ enum rkisp_isp_ver {
 	ISP_V11 = 0x10,
 	ISP_V12 = 0x20,
 	ISP_V13 = 0x30,
+	ISP_V20 = 0x40,
 };
 
 enum rkisp_isp_state {
@@ -81,9 +98,12 @@ enum rkisp_isp_state {
 
 enum rkisp_isp_inp {
 	INP_INVAL = 0,
-	INP_CSI,
-	INP_DVP,
-	INP_DMARX_ISP,
+	INP_RAWRD0 = BIT(0),
+	INP_RAWRD1 = BIT(1),
+	INP_RAWRD2 = BIT(2),
+	INP_CSI = BIT(4),
+	INP_DVP = BIT(5),
+	INP_DMARX_ISP = BIT(6),
 };
 
 /*
@@ -114,18 +134,43 @@ struct rkisp_pipeline {
 struct rkisp_sensor_info {
 	struct v4l2_subdev *sd;
 	struct v4l2_mbus_config mbus;
-	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev_format fmt[CSI_PAD_MAX - 1];
 	struct v4l2_subdev_pad_config cfg;
 };
 
+/* struct rkisp_hdr - hdr configured
+ * @cnt: open counter
+ * @op_mode: hdr optional mode
+ * @esp_mode: hdr especial mode
+ * @index: hdr dma index
+ * @q_tx: dmatx buf list
+ * @q_rx: dmarx buf list
+ * @rx_cur_buf: rawrd current buf
+ * @dummy_buf: hdr dma internal buf
+ */
+struct rkisp_hdr {
+	u8 cnt;
+	u8 op_mode;
+	u8 esp_mode;
+	u8 index[HDR_DMA_MAX];
+	struct v4l2_subdev *sensor;
+	struct list_head q_tx[HDR_DMA_MAX];
+	struct list_head q_rx[HDR_DMA_MAX];
+	struct rkisp_dummy_buffer *rx_cur_buf[HDR_DMA_MAX];
+	struct rkisp_dummy_buffer dummy_buf[HDR_DMA_MAX][HDR_MAX_DUMMY_BUF];
+};
+
 /*
  * struct rkisp_device - ISP platform device
  * @base_addr: base register address
  * @active_sensor: sensor in-use, set when streaming on
  * @isp_sdev: ISP sub-device
- * @rkisp_stream: capture video device
+ * @cap_dev: image capture device
  * @stats_vdev: ISP statistics output device
  * @params_vdev: ISP input parameters device
+ * @dmarx_dev: image input device
+ * @csi_dev: mipi csi device
+ * @mpfbc_dev: mpfbc output device
  */
 struct rkisp_device {
 	struct list_head list;
@@ -144,10 +189,12 @@ struct rkisp_device {
 	struct rkisp_sensor_info sensors[RKISP_MAX_SENSOR];
 	int num_sensors;
 	struct rkisp_isp_subdev isp_sdev;
-	struct rkisp_stream stream[RKISP_MAX_STREAM];
+	struct rkisp_capture_device cap_dev;
 	struct rkisp_isp_stats_vdev stats_vdev;
 	struct rkisp_isp_params_vdev params_vdev;
 	struct rkisp_dmarx_device dmarx_dev;
+	struct rkisp_csi_device csi_dev;
+	struct rkisp_mpfbc_device mpfbc_dev;
 	struct rkisp_pipeline pipe;
 	struct iommu_domain *domain;
 	enum rkisp_isp_ver isp_ver;
@@ -161,10 +208,10 @@ struct rkisp_device {
 	int vs_irq;
 	int mipi_irq;
 	struct gpio_desc *vs_irq_gpio;
-	struct v4l2_subdev *hdr_sensor;
+	struct rkisp_hdr hdr;
 	enum rkisp_isp_state isp_state;
 	unsigned int isp_err_cnt;
-	enum rkisp_isp_inp isp_inp;
+	unsigned int isp_inp;
 	struct mutex apilock; /* mutex to serialize the calls of stream */
 	struct mutex iqlock; /* mutex to serialize the calls of iq */
 	wait_queue_head_t sync_onoff;
diff --git a/drivers/media/platform/rockchip/isp/dmarx.c b/drivers/media/platform/rockchip/isp/dmarx.c
index 41b122c67820..02f7824ecbd4 100644
--- a/drivers/media/platform/rockchip/isp/dmarx.c
+++ b/drivers/media/platform/rockchip/isp/dmarx.c
@@ -13,7 +13,7 @@
 #include "dev.h"
 #include "regs.h"
 
-#define CIF_ISP_REQ_BUFS_MIN 1
+#define CIF_ISP_REQ_BUFS_MIN 0
 
 static const struct capture_fmt dmarx_fmts[] = {
 	/* bayer raw */
@@ -111,6 +111,36 @@ static struct stream_config rkisp_dmarx_stream_config = {
 	},
 };
 
+static struct stream_config rkisp2_dmarx0_stream_config = {
+	.fmts = dmarx_fmts,
+	.fmt_size = ARRAY_SIZE(dmarx_fmts),
+	.frame_end_id = RAW0_RD_FRAME,
+	.mi = {
+		.y_base_ad_init = MI_RAW0_RD_BASE,
+		.y_base_ad_shd = MI_RAW0_RD_BASE_SHD,
+	},
+};
+
+static struct stream_config rkisp2_dmarx1_stream_config = {
+	.fmts = dmarx_fmts,
+	.fmt_size = ARRAY_SIZE(dmarx_fmts),
+	.frame_end_id = RAW1_RD_FRAME,
+	.mi = {
+		.y_base_ad_init = MI_RAW1_RD_BASE,
+		.y_base_ad_shd = MI_RAW1_RD_BASE_SHD,
+	},
+};
+
+static struct stream_config rkisp2_dmarx2_stream_config = {
+	.fmts = dmarx_fmts,
+	.fmt_size = ARRAY_SIZE(dmarx_fmts),
+	.frame_end_id = RAW2_RD_FRAME,
+	.mi = {
+		.y_base_ad_init = MI_RAW2_RD_BASE,
+		.y_base_ad_shd = MI_RAW2_RD_BASE_SHD,
+	},
+};
+
 static const
 struct capture_fmt *find_fmt(struct rkisp_stream *stream,
 			     const u32 pixelfmt)
@@ -133,7 +163,7 @@ static int dmarx_config_mi(struct rkisp_stream *stream)
 	struct capture_fmt *dmarx_in_fmt = &stream->out_isp_fmt;
 
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
-		 "%s %dx%x y_stride:%d\n", __func__,
+		 "%s %dx%d y_stride:%d\n", __func__,
 		 stream->out_fmt.width,
 		 stream->out_fmt.height,
 		 stream->u.dmarx.y_stride);
@@ -182,6 +212,90 @@ static struct streams_ops rkisp_dmarx_streams_ops = {
 	.update_mi = update_dmarx,
 };
 
+static int rawrd_config_mi(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s id:%d %dx%d\n", __func__,
+		 stream->id,
+		 stream->out_fmt.width,
+		 stream->out_fmt.height);
+
+	raw_rd_set_pic_size(base,
+		stream->out_fmt.width,
+		stream->out_fmt.height);
+	isp_set_bits(base + CSI2RX_RAW_RD_CTRL, 0,
+		     SW_CSI_RAW_RD_SIMG_SWP |
+		     SW_CSI_RAW_RD_SIMG_MOD |
+		     1 << (stream->id - 1));
+
+	return 0;
+}
+
+static void update_rawrd(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
+
+	if (stream->curr_buf) {
+		mi_set_y_addr(stream,
+			stream->curr_buf->buff_addr[RKISP_PLANE_Y]);
+		stream->frame_end = false;
+	} else if (dev->dmarx_dev.trigger == T_AUTO) {
+		/* internal raw wr/rd buf rotate */
+		struct rkisp_dummy_buffer *buf;
+		u32 id, rawwr_addr;
+
+		switch (stream->id) {
+		case RKISP_STREAM_RAWRD2:
+			id = dev->hdr.index[HDR_DMA2];
+			rawwr_addr = MI_RAW2_WR_BASE_SHD;
+			break;
+		case RKISP_STREAM_RAWRD1:
+			id = dev->hdr.index[HDR_DMA1];
+			rawwr_addr = MI_RAW1_WR_BASE_SHD;
+			break;
+		case RKISP_STREAM_RAWRD0:
+		default:
+			id = dev->hdr.index[HDR_DMA0];
+			rawwr_addr = MI_RAW0_WR_BASE_SHD;
+		}
+		if (dev->hdr.rx_cur_buf[id]) {
+			hdr_qbuf(&dev->hdr.q_tx[id], dev->hdr.rx_cur_buf[id]);
+			dev->hdr.rx_cur_buf[id] = NULL;
+		}
+		buf = hdr_dqbuf(&dev->hdr.q_rx[id]);
+		if (buf) {
+			mi_set_y_addr(stream, buf->dma_addr);
+			dev->hdr.rx_cur_buf[id] = buf;
+		} else {
+			mi_set_y_addr(stream,
+				readl(base + rawwr_addr));
+		}
+	}
+	v4l2_dbg(2, rkisp_debug, &dev->v4l2_dev,
+		 "%s stream:%d Y:0x%x SHD:0x%x\n",
+		 __func__, stream->id,
+		 readl(base + stream->config->mi.y_base_ad_init),
+		 readl(base + stream->config->mi.y_base_ad_shd));
+}
+
+static void rawrd_stop_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = &stream->ispdev->base_addr;
+
+	isp_clear_bits(base + CSI2RX_RAW_RD_CTRL,
+		       1 << (stream->id - 1));
+}
+
+static struct streams_ops rkisp2_dmarx_streams_ops = {
+	.config_mi = rawrd_config_mi,
+	.stop_mi = rawrd_stop_mi,
+	.update_mi = update_rawrd,
+};
+
 static int dmarx_frame_end(struct rkisp_stream *stream)
 {
 	unsigned long lock_flags = 0;
@@ -219,7 +333,7 @@ static void dmarx_stop(struct rkisp_stream *stream)
 		!stream->frame_end) {
 		ret = wait_event_timeout(stream->done,
 					 !stream->streaming,
-					 msecs_to_jiffies(500));
+					 msecs_to_jiffies(100));
 		if (!ret)
 			v4l2_warn(v4l2_dev,
 				  "dmarx:%d waiting on event return error %d\n",
@@ -383,10 +497,6 @@ static int rkisp_init_vb2_queue(struct vb2_queue *q,
 				struct rkisp_stream *stream,
 				enum v4l2_buf_type buf_type)
 {
-	struct rkisp_vdev_node *node;
-
-	node = queue_to_node(q);
-
 	q->type = buf_type;
 	q->io_modes = VB2_MMAP | VB2_DMABUF | VB2_USERPTR;
 	q->drv_priv = stream;
@@ -396,6 +506,7 @@ static int rkisp_init_vb2_queue(struct vb2_queue *q,
 	q->min_buffers_needed = CIF_ISP_REQ_BUFS_MIN;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
 	q->lock = &stream->ispdev->apilock;
+	q->dev = stream->ispdev->dev;
 
 	return vb2_queue_init(q);
 }
@@ -607,7 +718,7 @@ static int rkisp_register_dmarx_video(struct rkisp_stream *stream)
 	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
 	if (ret < 0) {
 		v4l2_err(v4l2_dev,
-			 "video register failed with error %d\n", ret);
+			 "%s failed with error %d\n", __func__, ret);
 		return ret;
 	}
 
@@ -643,7 +754,27 @@ void rkisp_dmarx_isr(u32 mis_val, struct rkisp_device *dev)
 	}
 }
 
-int rkisp_register_dmarx_vdev(struct rkisp_device *dev)
+void rkisp2_rawrd_isr(u32 mis_val, struct rkisp_device *dev)
+{
+	struct rkisp_stream *stream;
+	int i;
+
+	for (i = RKISP_STREAM_RAWRD0; i < RKISP_MAX_DMARX_STREAM; i++) {
+		stream = &dev->dmarx_dev.stream[i];
+		if (!(mis_val & CIF_MI_FRAME(stream)))
+			continue;
+		stream->frame_end = true;
+		if (stream->stopping) {
+			stream->stopping = false;
+			stream->streaming = false;
+			wake_up(&stream->done);
+		} else {
+			dmarx_frame_end(stream);
+		}
+	}
+}
+
+static int dmarx_init(struct rkisp_device *dev, u32 id)
 {
 	struct rkisp_dmarx_device *dmarx_dev = &dev->dmarx_dev;
 	struct rkisp_stream *stream;
@@ -651,31 +782,86 @@ int rkisp_register_dmarx_vdev(struct rkisp_device *dev)
 	struct media_entity *source, *sink;
 	int ret = 0;
 
+	stream = &dmarx_dev->stream[id];
+	INIT_LIST_HEAD(&stream->buf_queue);
+	init_waitqueue_head(&stream->done);
+	spin_lock_init(&stream->vbq_lock);
+	stream->id = id;
+	stream->ispdev = dev;
+	vdev = &stream->vnode.vdev;
+
+	switch (id) {
+	case RKISP_STREAM_DMARX:
+		strlcpy(vdev->name, DMA_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp_dmarx_streams_ops;
+		stream->config = &rkisp_dmarx_stream_config;
+		break;
+	case RKISP_STREAM_RAWRD0:
+		strlcpy(vdev->name, DMARX0_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmarx_streams_ops;
+		stream->config = &rkisp2_dmarx0_stream_config;
+		break;
+	case RKISP_STREAM_RAWRD1:
+		strlcpy(vdev->name, DMARX1_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmarx_streams_ops;
+		stream->config = &rkisp2_dmarx1_stream_config;
+		break;
+	case RKISP_STREAM_RAWRD2:
+		strlcpy(vdev->name, DMARX2_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmarx_streams_ops;
+		stream->config = &rkisp2_dmarx2_stream_config;
+		break;
+	default:
+		v4l2_err(&dev->v4l2_dev, "Invalid dmarx\n");
+		return -EINVAL;
+	}
+	ret = rkisp_register_dmarx_video(stream);
+	if (ret < 0)
+		return ret;
+
+	/* dmarx link -> isp subdev */
+	source = &vdev->entity;
+	sink = &dev->isp_sdev.sd.entity;
+	return media_create_pad_link(source, 0, sink,
+				     RKISP_ISP_PAD_SINK, 0);
+}
+
+int rkisp_register_dmarx_vdev(struct rkisp_device *dev)
+{
+	struct rkisp_dmarx_device *dmarx_dev = &dev->dmarx_dev;
+	int ret = 0;
+
 	memset(dmarx_dev, 0, sizeof(*dmarx_dev));
 	dmarx_dev->ispdev = dev;
 
-	if (dev->isp_ver <= ISP_V13) {
-		stream = &dmarx_dev->stream[RKISP_STREAM_DMARX];
-		INIT_LIST_HEAD(&stream->buf_queue);
-		init_waitqueue_head(&stream->done);
-		spin_lock_init(&stream->vbq_lock);
-		stream->id = RKISP_STREAM_DMARX;
-		stream->ispdev = dev;
-		stream->ops = &rkisp_dmarx_streams_ops;
-		stream->config = &rkisp_dmarx_stream_config;
-		vdev = &stream->vnode.vdev;
-		strlcpy(vdev->name, DMA_VDEV_NAME, sizeof(vdev->name));
-		ret = rkisp_register_dmarx_video(stream);
-		if (ret < 0)
-			return ret;
+	ret = dmarx_init(dev, RKISP_STREAM_DMARX);
+	if (ret < 0)
+		goto err;
 
-		/* dmarx links -> isp subdev */
-		source = &vdev->entity;
-		sink = &dev->isp_sdev.sd.entity;
-		ret = media_create_pad_link(source, 0,
-			sink, RKISP_ISP_PAD_SINK, 0);
+	if (dev->isp_ver == ISP_V20) {
+		ret = dmarx_init(dev, RKISP_STREAM_RAWRD0);
+		if (ret < 0)
+			goto err_free_dmarx;
+		ret = dmarx_init(dev, RKISP_STREAM_RAWRD1);
+		if (ret < 0)
+			goto err_free_dmarx0;
+		ret = dmarx_init(dev, RKISP_STREAM_RAWRD2);
+		if (ret < 0)
+			goto err_free_dmarx1;
 	}
 
+	return 0;
+err_free_dmarx1:
+	rkisp_unregister_dmarx_video(&dmarx_dev->stream[RKISP_STREAM_RAWRD1]);
+err_free_dmarx0:
+	rkisp_unregister_dmarx_video(&dmarx_dev->stream[RKISP_STREAM_RAWRD0]);
+err_free_dmarx:
+	rkisp_unregister_dmarx_video(&dmarx_dev->stream[RKISP_STREAM_DMARX]);
+err:
 	return ret;
 }
 
@@ -684,8 +870,17 @@ void rkisp_unregister_dmarx_vdev(struct rkisp_device *dev)
 	struct rkisp_dmarx_device *dmarx_dev = &dev->dmarx_dev;
 	struct rkisp_stream *stream;
 
-	if (dev->isp_ver <= ISP_V13) {
-		stream = &dmarx_dev->stream[RKISP_STREAM_DMARX];
+	stream = &dmarx_dev->stream[RKISP_STREAM_DMARX];
+	rkisp_unregister_dmarx_video(stream);
+
+	if (dev->isp_ver == ISP_V20) {
+		stream = &dmarx_dev->stream[RKISP_STREAM_RAWRD0];
+		rkisp_unregister_dmarx_video(stream);
+
+		stream = &dmarx_dev->stream[RKISP_STREAM_RAWRD1];
+		rkisp_unregister_dmarx_video(stream);
+
+		stream = &dmarx_dev->stream[RKISP_STREAM_RAWRD2];
 		rkisp_unregister_dmarx_video(stream);
 	}
 }
diff --git a/drivers/media/platform/rockchip/isp/dmarx.h b/drivers/media/platform/rockchip/isp/dmarx.h
index cbcf6c31bd9e..a0dd77c4722f 100644
--- a/drivers/media/platform/rockchip/isp/dmarx.h
+++ b/drivers/media/platform/rockchip/isp/dmarx.h
@@ -8,7 +8,10 @@
 #include "common.h"
 
 #define RKISP_STREAM_DMARX		0
-#define RKISP_MAX_DMARX_STREAM		1
+#define RKISP_STREAM_RAWRD0		1
+#define RKISP_STREAM_RAWRD1		2
+#define RKISP_STREAM_RAWRD2		3
+#define RKISP_MAX_DMARX_STREAM		4
 
 struct rkisp_dmarx_device;
 
@@ -18,12 +21,19 @@ enum rkisp_dmarx_pad {
 	RKISP_DMARX_PAD_MAX
 };
 
+enum rkisp_dmarx_trigger {
+	T_AUTO = 0,
+	T_MANUAL,
+};
+
 struct rkisp_dmarx_device {
 	struct rkisp_device *ispdev;
 	struct rkisp_stream stream[RKISP_MAX_DMARX_STREAM];
+	enum rkisp_dmarx_trigger trigger;
 };
 
 void rkisp_dmarx_isr(u32 mis_val, struct rkisp_device *dev);
+void rkisp2_rawrd_isr(u32 mis_val, struct rkisp_device *dev);
 void rkisp_unregister_dmarx_vdev(struct rkisp_device *dev);
 int rkisp_register_dmarx_vdev(struct rkisp_device *dev);
 #endif /* _RKISP_DMARX_H */
diff --git a/drivers/media/platform/rockchip/isp/isp_params.c b/drivers/media/platform/rockchip/isp/isp_params.c
index 11f34eb08f2b..fe0c902ebccc 100644
--- a/drivers/media/platform/rockchip/isp/isp_params.c
+++ b/drivers/media/platform/rockchip/isp/isp_params.c
@@ -41,6 +41,7 @@
 #include "dev.h"
 #include "regs.h"
 
+#define PARAMS_NAME DRIVER_NAME "-input-params"
 #define RKISP_ISP_PARAMS_REQ_BUFS_MIN	2
 #define RKISP_ISP_PARAMS_REQ_BUFS_MAX	8
 
@@ -2123,7 +2124,7 @@ void __preisp_isr_update_hdrae_para(struct rkisp_isp_params_vdev *params_vdev,
 	lsc = &new_params->others.lsc_config;
 	awb_gain = &new_params->others.awb_gain_config;
 
-	if (!params_vdev->dev->hdr_sensor)
+	if (!params_vdev->dev->hdr.sensor)
 		return;
 
 	if ((module_en_update & CIFISP_MODULE_AWB_GAIN) ||
@@ -2160,10 +2161,10 @@ void __preisp_isr_update_hdrae_para(struct rkisp_isp_params_vdev *params_vdev,
 		}
 	}
 
-	ret = v4l2_subdev_call(params_vdev->dev->hdr_sensor, core, ioctl,
+	ret = v4l2_subdev_call(params_vdev->dev->hdr.sensor, core, ioctl,
 			       PREISP_CMD_SAVE_HDRAE_PARAM, hdrae);
 	if (ret)
-		params_vdev->dev->hdr_sensor = NULL;
+		params_vdev->dev->hdr.sensor = NULL;
 }
 
 void rkisp_params_isr(struct rkisp_isp_params_vdev *params_vdev, u32 isp_mis)
@@ -2566,10 +2567,6 @@ static int
 rkisp_params_init_vb2_queue(struct vb2_queue *q,
 			     struct rkisp_isp_params_vdev *params_vdev)
 {
-	struct rkisp_vdev_node *node;
-
-	node = queue_to_node(q);
-
 	q->type = V4L2_BUF_TYPE_META_OUTPUT;
 	q->io_modes = VB2_MMAP | VB2_USERPTR;
 	q->drv_priv = params_vdev;
@@ -2607,11 +2604,12 @@ int rkisp_register_params_vdev(struct rkisp_isp_params_vdev *params_vdev,
 	int ret;
 	struct rkisp_vdev_node *node = &params_vdev->vnode;
 	struct video_device *vdev = &node->vdev;
+	struct media_entity *source, *sink;
 
 	params_vdev->dev = dev;
 	spin_lock_init(&params_vdev->config_lock);
 
-	strlcpy(vdev->name, "rkisp1-input-params", sizeof(vdev->name));
+	strlcpy(vdev->name, PARAMS_NAME, sizeof(vdev->name));
 
 	video_set_drvdata(vdev, params_vdev);
 	vdev->ioctl_ops = &rkisp_params_ioctl;
@@ -2640,6 +2638,14 @@ int rkisp_register_params_vdev(struct rkisp_isp_params_vdev *params_vdev,
 			"could not register Video for Linux device\n");
 		goto err_cleanup_media_entity;
 	}
+
+	source = &params_vdev->vnode.vdev.entity;
+	sink = &params_vdev->dev->isp_sdev.sd.entity;
+	ret = media_create_pad_link(source, 0, sink,
+		RKISP_ISP_PAD_SINK_PARAMS, MEDIA_LNK_FL_ENABLED);
+	if (ret < 0)
+		goto err_cleanup_media_entity;
+
 	return 0;
 err_cleanup_media_entity:
 	media_entity_cleanup(&vdev->entity);
diff --git a/drivers/media/platform/rockchip/isp/isp_stats.c b/drivers/media/platform/rockchip/isp/isp_stats.c
index adca6e54febe..be53941d0ec7 100644
--- a/drivers/media/platform/rockchip/isp/isp_stats.c
+++ b/drivers/media/platform/rockchip/isp/isp_stats.c
@@ -40,6 +40,7 @@
 #include "dev.h"
 #include "regs.h"
 
+#define STATS_NAME DRIVER_NAME "-statistics"
 #define RKISP_ISP_STATS_REQ_BUFS_MIN 2
 #define RKISP_ISP_STATS_REQ_BUFS_MAX 8
 
@@ -200,10 +201,6 @@ static struct vb2_ops rkisp_stats_vb2_ops = {
 static int rkisp_stats_init_vb2_queue(struct vb2_queue *q,
 				       struct rkisp_isp_stats_vdev *stats_vdev)
 {
-	struct rkisp_vdev_node *node;
-
-	node = queue_to_node(q);
-
 	q->type = V4L2_BUF_TYPE_META_CAPTURE;
 	q->io_modes = VB2_MMAP | VB2_USERPTR;
 	q->drv_priv = stats_vdev;
@@ -618,13 +615,14 @@ int rkisp_register_stats_vdev(struct rkisp_isp_stats_vdev *stats_vdev,
 	int ret;
 	struct rkisp_vdev_node *node = &stats_vdev->vnode;
 	struct video_device *vdev = &node->vdev;
+	struct media_entity *source, *sink;
 
 	stats_vdev->dev = dev;
 	INIT_LIST_HEAD(&stats_vdev->stat);
 	spin_lock_init(&stats_vdev->irq_lock);
 	spin_lock_init(&stats_vdev->rd_lock);
 
-	strlcpy(vdev->name, "rkisp1-statistics", sizeof(vdev->name));
+	strlcpy(vdev->name, STATS_NAME, sizeof(vdev->name));
 
 	video_set_drvdata(vdev, stats_vdev);
 	vdev->ioctl_ops = &rkisp_stats_ioctl;
@@ -651,6 +649,13 @@ int rkisp_register_stats_vdev(struct rkisp_isp_stats_vdev *stats_vdev,
 		goto err_cleanup_media_entity;
 	}
 
+	source = &dev->isp_sdev.sd.entity;
+	sink = &stats_vdev->vnode.vdev.entity;
+	ret = media_create_pad_link(source, RKISP_ISP_PAD_SOURCE_STATS,
+		sink, 0, MEDIA_LNK_FL_ENABLED);
+	if (ret < 0)
+		goto err_cleanup_media_entity;
+
 	ret = kfifo_alloc(&stats_vdev->rd_kfifo,
 			  RKISP_READOUT_WORK_SIZE,
 			  GFP_KERNEL);
diff --git a/drivers/media/platform/rockchip/isp/mpfbc.c b/drivers/media/platform/rockchip/isp/mpfbc.c
new file mode 100644
index 000000000000..e7483bd674b7
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/mpfbc.c
@@ -0,0 +1,322 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd. */
+
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/dma-iommu.h>
+#include <linux/rk-camera-module.h>
+#include "dev.h"
+#include "regs.h"
+
+static int mpfbc_get_set_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_pad_config *cfg,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct rkisp_mpfbc_device *mpfbc_dev = v4l2_get_subdevdata(sd);
+	struct rkisp_device *dev = mpfbc_dev->ispdev;
+	int ret;
+
+	/* get isp out format */
+	fmt->pad = RKISP_ISP_PAD_SOURCE_PATH;
+	ret =  v4l2_subdev_call(&dev->isp_sdev.sd, pad, get_fmt, NULL, fmt);
+	mpfbc_dev->fmt = *fmt;
+	return ret;
+}
+
+static int mpfbc_s_rx_buffer(struct v4l2_subdev *sd,
+			     void *buf, unsigned int *size)
+{
+	struct rkisp_mpfbc_device *mpfbc_dev = v4l2_get_subdevdata(sd);
+	struct rkisp_device *dev = mpfbc_dev->ispdev;
+	void __iomem *base = dev->base_addr;
+	u32 w = ALIGN(mpfbc_dev->fmt.format.width, 16);
+	u32 h = ALIGN(mpfbc_dev->fmt.format.height, 16);
+	u32 sizes = (w * h >> 4) + w * h * 2;
+
+	/* picture or gain buffer */
+	if (*size == sizes) {
+		if (mpfbc_dev->pic_cur) {
+			mpfbc_dev->pic_nxt = (u32 *)buf;
+			writel(*mpfbc_dev->pic_nxt,
+				base + ISP_MPFBC_HEAD_PTR2);
+			writel(*mpfbc_dev->pic_nxt + (w * h >> 4),
+				base + ISP_MPFBC_PAYL_PTR2);
+			mpfbc_dev->pingpong = true;
+		} else {
+			mpfbc_dev->pic_cur = (u32 *)buf;
+			writel(*mpfbc_dev->pic_cur,
+				base + ISP_MPFBC_HEAD_PTR);
+			writel(*mpfbc_dev->pic_cur + (w * h >> 4),
+				base + ISP_MPFBC_PAYL_PTR);
+			mpfbc_dev->pingpong = false;
+		}
+	} else {
+		if (mpfbc_dev->gain_cur) {
+			mpfbc_dev->gain_nxt = (u32 *)buf;
+			writel(*mpfbc_dev->gain_nxt,
+				base + MI_GAIN_WR_BASE2);
+			mi_wr_ctrl2(base, SW_GAIN_WR_PINGPONG);
+		} else {
+			mpfbc_dev->gain_cur = (u32 *)buf;
+			writel(*mpfbc_dev->gain_cur,
+				base + MI_GAIN_WR_BASE);
+			isp_clear_bits(base + MI_WR_CTRL2,
+					SW_GAIN_WR_PINGPONG);
+		}
+		writel(*size, base + MI_GAIN_WR_SIZE);
+		writel(w >> 4, base + MI_GAIN_WR_LENGTH);
+		mi_wr_ctrl2(base, SW_GAIN_WR_AUTOUPD);
+	}
+	return 0;
+}
+
+static int mpfbc_start(struct rkisp_mpfbc_device *mpfbc_dev)
+{
+	struct rkisp_device *dev = mpfbc_dev->ispdev;
+	void __iomem *base = dev->base_addr;
+	u32 h = ALIGN(mpfbc_dev->fmt.format.height, 16);
+
+	writel(mpfbc_dev->pingpong << 4 | SW_MPFBC_YUV_MODE(1) |
+		SW_MPFBC_MAINISP_MODE | SW_MPFBC_EN,
+		base + ISP_MPFBC_BASE);
+	writel(0, base + ISP_MPFBC_VIR_WIDTH);
+	writel(h, base + ISP_MPFBC_VIR_HEIGHT);
+	isp_set_bits(base + CTRL_SWS_CFG, 0, SW_ISP2PP_PIPE_EN);
+	isp_set_bits(base + MI_IMSC, 0, MI_MPFBC_FRAME);
+	isp_set_bits(base + MI_WR_CTRL, 0, CIF_MI_CTRL_INIT_BASE_EN);
+	mp_set_data_path(base);
+	force_cfg_update(base);
+	mpfbc_dev->en = true;
+	return 0;
+}
+
+static int mpfbc_stop(struct rkisp_mpfbc_device *mpfbc_dev)
+{
+	struct rkisp_device *dev = mpfbc_dev->ispdev;
+	void __iomem *base = dev->base_addr;
+	int ret;
+
+	mpfbc_dev->stopping = true;
+	writel(SW_MPFBC_YUV_MODE(1),
+		base + ISP_MPFBC_BASE);
+	hdr_stop_dmatx(dev);
+	ret = wait_event_timeout(mpfbc_dev->done,
+				 !mpfbc_dev->en,
+				 msecs_to_jiffies(1000));
+	if (!ret)
+		v4l2_warn(&mpfbc_dev->sd,
+			  "waiting on event return error %d\n", ret);
+	isp_clear_bits(base + MI_IMSC, MI_MPFBC_FRAME);
+	hdr_destroy_buf(dev);
+	mpfbc_dev->en = false;
+	mpfbc_dev->pic_cur = NULL;
+	mpfbc_dev->pic_nxt = NULL;
+	mpfbc_dev->gain_cur = NULL;
+	mpfbc_dev->gain_nxt = NULL;
+	return 0;
+}
+
+static int mpfbc_start_stream(struct v4l2_subdev *sd)
+{
+	struct rkisp_mpfbc_device *mpfbc_dev = v4l2_get_subdevdata(sd);
+	struct rkisp_device *dev = mpfbc_dev->ispdev;
+	int ret;
+
+	if (WARN_ON(mpfbc_dev->en) ||
+	    !dev->isp_inp)
+		return -EBUSY;
+
+	if (dev->isp_inp & INP_CSI ||
+	    dev->isp_inp & INP_DVP) {
+		/* Always update sensor info in case media topology changed */
+		ret = rkisp_update_sensor_info(dev);
+		if (ret < 0) {
+			v4l2_err(&dev->v4l2_dev,
+				 "update sensor info failed %d\n",
+				 ret);
+			return -EBUSY;
+		}
+	}
+
+	/* enable clocks/power-domains */
+	ret = dev->pipe.open(&dev->pipe, &sd->entity, true);
+	if (ret < 0)
+		return ret;
+
+	hdr_config_dmatx(dev);
+	ret = mpfbc_start(mpfbc_dev);
+	if (ret < 0)
+		goto close_pipe;
+	hdr_update_dmatx_buf(dev);
+
+	/* start sub-devices */
+	ret = dev->pipe.set_stream(&dev->pipe, true);
+	if (ret < 0)
+		goto stop_mpfbc;
+
+	ret = media_pipeline_start(&sd->entity, &dev->pipe.pipe);
+	if (ret < 0)
+		goto pipe_stream_off;
+
+	return 0;
+pipe_stream_off:
+	dev->pipe.set_stream(&dev->pipe, false);
+stop_mpfbc:
+	mpfbc_stop(mpfbc_dev);
+close_pipe:
+	dev->pipe.close(&dev->pipe);
+	return ret;
+}
+
+static int mpfbc_stop_stream(struct v4l2_subdev *sd)
+{
+	struct rkisp_mpfbc_device *mpfbc_dev = v4l2_get_subdevdata(sd);
+	struct rkisp_device *dev = mpfbc_dev->ispdev;
+
+	mpfbc_stop(mpfbc_dev);
+	media_pipeline_stop(&sd->entity);
+	dev->pipe.set_stream(&dev->pipe, false);
+	dev->pipe.close(&dev->pipe);
+	return 0;
+}
+
+static int mpfbc_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct rkisp_mpfbc_device *mpfbc_dev = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (on)
+		ret = mpfbc_start_stream(sd);
+	else if (mpfbc_dev->en)
+		ret = mpfbc_stop_stream(sd);
+
+	return ret;
+}
+
+static int mpfbc_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct rkisp_mpfbc_device *mpfbc_dev = v4l2_get_subdevdata(sd);
+	struct rkisp_device *dev = mpfbc_dev->ispdev;
+	int ret;
+
+	if (on) {
+		atomic_inc(&dev->open_cnt);
+		ret = v4l2_pipeline_pm_use(&sd->entity, 1);
+	} else {
+		ret = v4l2_pipeline_pm_use(&sd->entity, 0);
+		atomic_dec(&dev->open_cnt);
+	}
+	return ret;
+}
+
+void rkisp_mpfbc_isr(u32 mis_val, struct rkisp_device *dev)
+{
+	struct rkisp_mpfbc_device *mpfbc_dev = &dev->mpfbc_dev;
+	void __iomem *base = dev->base_addr;
+
+	writel(MI_MPFBC_FRAME, base + CIF_MI_ICR);
+
+	if (mpfbc_dev->stopping) {
+		if (is_mpfbc_stopped(base)) {
+			mpfbc_dev->en = false;
+			mpfbc_dev->stopping = false;
+			wake_up(&mpfbc_dev->done);
+		}
+	}
+}
+
+static const struct v4l2_subdev_pad_ops mpfbc_pad_ops = {
+	.set_fmt = mpfbc_get_set_fmt,
+	.get_fmt = mpfbc_get_set_fmt,
+};
+
+static const struct v4l2_subdev_video_ops mpfbc_video_ops = {
+	.s_rx_buffer = mpfbc_s_rx_buffer,
+	.s_stream = mpfbc_s_stream,
+};
+
+static const struct v4l2_subdev_core_ops mpfbc_core_ops = {
+	.s_power = mpfbc_s_power,
+};
+
+static struct v4l2_subdev_ops mpfbc_v4l2_ops = {
+	.core = &mpfbc_core_ops,
+	.video = &mpfbc_video_ops,
+	.pad = &mpfbc_pad_ops,
+};
+
+int rkisp_register_mpfbc_subdev(struct rkisp_device *dev,
+			       struct v4l2_device *v4l2_dev)
+{
+	struct rkisp_mpfbc_device *mpfbc_dev = &dev->mpfbc_dev;
+	struct v4l2_subdev *sd;
+	struct media_entity *source, *sink;
+	int ret;
+
+	memset(mpfbc_dev, 0, sizeof(*mpfbc_dev));
+	if (dev->isp_ver != ISP_V20)
+		return 0;
+
+	mpfbc_dev->ispdev = dev;
+	sd = &mpfbc_dev->sd;
+
+	v4l2_subdev_init(sd, &mpfbc_v4l2_ops);
+	//sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.obj_type = 0;
+	snprintf(sd->name, sizeof(sd->name), MPFBC_DEV_NAME);
+
+	mpfbc_dev->pad.flags = MEDIA_PAD_FL_SINK;
+
+	ret = media_entity_pads_init(&sd->entity, 1, &mpfbc_dev->pad);
+	if (ret < 0)
+		return ret;
+	sd->owner = THIS_MODULE;
+	v4l2_set_subdevdata(sd, mpfbc_dev);
+	sd->grp_id = GRP_ID_ISP_MPFBC;
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Failed to register mpfbc subdev\n");
+		goto free_media;
+	}
+
+	/* mpfbc links */
+	source = &dev->isp_sdev.sd.entity;
+	sink = &sd->entity;
+	ret = media_create_pad_link(source, RKISP_ISP_PAD_SOURCE_PATH,
+				    sink, 0, MEDIA_LNK_FL_ENABLED);
+
+	init_waitqueue_head(&mpfbc_dev->done);
+	return ret;
+
+free_media:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+void rkisp_unregister_mpfbc_subdev(struct rkisp_device *dev)
+{
+	struct v4l2_subdev *sd = &dev->mpfbc_dev.sd;
+
+	if (dev->isp_ver != ISP_V20)
+		return;
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+}
+
+void rkisp_get_mpfbc_sd(struct platform_device *dev,
+			 struct v4l2_subdev **sd)
+{
+	struct rkisp_device *isp_dev = platform_get_drvdata(dev);
+
+	if (isp_dev)
+		*sd = &isp_dev->mpfbc_dev.sd;
+	else
+		*sd = NULL;
+}
+EXPORT_SYMBOL(rkisp_get_mpfbc_sd);
diff --git a/drivers/media/platform/rockchip/isp/mpfbc.h b/drivers/media/platform/rockchip/isp/mpfbc.h
new file mode 100644
index 000000000000..823bc5fd0e63
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/mpfbc.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd. */
+
+#ifndef _RKISP_mpfbc_H
+#define _RKISP_mpfbc_H
+
+#include "linux/platform_device.h"
+
+#define MPFBC_DEV_NAME DRIVER_NAME "-mpfbc-subdev"
+
+struct rkisp_mpfbc_device;
+
+struct rkisp_mpfbc_device {
+	struct rkisp_device *ispdev;
+	struct v4l2_subdev sd;
+	struct v4l2_subdev_format fmt;
+	struct media_pad pad;
+	wait_queue_head_t done;
+	u32 *pic_cur;
+	u32 *pic_nxt;
+	u32 *gain_cur;
+	u32 *gain_nxt;
+	u8 pingpong;
+	u8 stopping;
+	u8 en;
+};
+
+int rkisp_register_mpfbc_subdev(struct rkisp_device *dev,
+				struct v4l2_device *v4l2_dev);
+void rkisp_unregister_mpfbc_subdev(struct rkisp_device *dev);
+void rkisp_mpfbc_isr(u32 mis_val, struct rkisp_device *dev);
+void rkisp_get_mpfbc_sd(struct platform_device *dev,
+			struct v4l2_subdev **sd);
+#endif
diff --git a/drivers/media/platform/rockchip/isp/regs.c b/drivers/media/platform/rockchip/isp/regs.c
index ac806f7903e0..315de9040e81 100644
--- a/drivers/media/platform/rockchip/isp/regs.c
+++ b/drivers/media/platform/rockchip/isp/regs.c
@@ -51,7 +51,8 @@ void disable_dcrop(struct rkisp_stream *stream, bool async)
 	writel(val, dc_ctrl_addr);
 }
 
-void config_dcrop(struct rkisp_stream *stream, struct v4l2_rect *rect, bool async)
+void config_dcrop(struct rkisp_stream *stream,
+		  struct v4l2_rect *rect, bool async)
 {
 	void __iomem *base = stream->ispdev->base_addr;
 	void __iomem *dc_ctrl_addr = base + stream->config->dual_crop.ctrl;
diff --git a/drivers/media/platform/rockchip/isp/regs.h b/drivers/media/platform/rockchip/isp/regs.h
index 754fc216e3e5..92731141f4f8 100644
--- a/drivers/media/platform/rockchip/isp/regs.h
+++ b/drivers/media/platform/rockchip/isp/regs.h
@@ -35,6 +35,7 @@
 #ifndef _RKISP_REGS_H
 #define _RKISP_REGS_H
 #include "dev.h"
+#include "regs_v2x.h"
 
 #define CIF_ISP_PACK_4BYTE(a, b, c, d)	\
 	(((a) & 0xFF) << 0 | ((b) & 0xFF) << 8 | \
@@ -218,7 +219,13 @@
 #define CIF_RSZ_SCALER_FACTOR			BIT(16)
 
 /* MI_IMSC - MI_MIS - MI_RIS - MI_ICR - MI_ISR */
-#define CIF_MI_FRAME(stream)			BIT((stream)->id)
+#define CIF_MI_FRAME(stream) ({ \
+	typeof(stream) __stream = (stream); \
+	!__stream->config ? 0 : \
+	__stream->config->frame_end_id; \
+})
+#define CIF_MI_MP_FRAME				BIT(0)
+#define CIF_MI_SP_FRAME				BIT(1)
 #define CIF_MI_MBLK_LINE			BIT(2)
 #define CIF_MI_FILL_MP_Y			BIT(3)
 #define CIF_MI_WRAP_MP_Y			BIT(4)
@@ -1628,6 +1635,20 @@ bool sp_is_frame_end_int_masked(void __iomem *base);
 bool mp_is_stream_stopped(void __iomem *base);
 bool sp_is_stream_stopped(void __iomem *base);
 
+static inline void isp_set_bits(void __iomem *addr, u32 bit_mask, u32 val)
+{
+	u32 tmp = readl(addr) & ~bit_mask;
+
+	writel(tmp | val, addr);
+}
+
+static inline void isp_clear_bits(void __iomem *addr, u32 bit_mask)
+{
+	u32 val = readl(addr);
+
+	writel(val & ~bit_mask, addr);
+}
+
 static inline void mi_set_y_size(struct rkisp_stream *stream, int val)
 {
 	void __iomem *base = stream->ispdev->base_addr;
diff --git a/drivers/media/platform/rockchip/isp/regs_v2x.h b/drivers/media/platform/rockchip/isp/regs_v2x.h
new file mode 100644
index 000000000000..9b424de35dde
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/regs_v2x.h
@@ -0,0 +1,1922 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ *
+ * Copyright (C) 2019 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _RKISP1_REGS_V2X_H
+#define _RKISP1_REGS_V2X_H
+
+#define CTRL_BASE					0x00000000
+#define CTRL_VI_ISP_EN					(CTRL_BASE + 0x00000)
+#define CTRL_VI_ISP_PATH				(CTRL_BASE + 0x00004)
+#define CTRL_VI_ID					(CTRL_BASE + 0x00008)
+#define CTRL_VI_ISP_CLK_CTRL				(CTRL_BASE + 0x0000c)
+#define CTRL_VI_ICCL					(CTRL_BASE + 0x00010)
+#define CTRL_VI_IRCL					(CTRL_BASE + 0x00014)
+#define CTRL_VI_DPCL					(CTRL_BASE + 0x00018)
+#define CTRL_SWS_CFG					(CTRL_BASE + 0x0001c)
+
+#define IMG_EFF_BASE					0x00000200
+#define IMG_EFF_CTRL					(IMG_EFF_BASE + 0x00000)
+#define IMG_EFF_COLOR_SEL				(IMG_EFF_BASE + 0x00004)
+#define IMG_EFF_MAT_1					(IMG_EFF_BASE + 0x00008)
+#define IMG_EFF_MAT_2					(IMG_EFF_BASE + 0x0000c)
+#define IMG_EFF_MAT_3					(IMG_EFF_BASE + 0x00010)
+#define IMG_EFF_MAT_4					(IMG_EFF_BASE + 0x00014)
+#define IMG_EFF_MAT_5					(IMG_EFF_BASE + 0x00018)
+#define IMG_EFF_TINT					(IMG_EFF_BASE + 0x0001c)
+#define IMG_EFF_CTRL_SHD				(IMG_EFF_BASE + 0x00020)
+#define IMG_EFF_SHARPEN					(IMG_EFF_BASE + 0x00024)
+#define IMG_EFF_RKSHARP_CTRL				(IMG_EFF_BASE + 0x00030)
+#define IMG_EFF_RKSHARP_YAVG_THR			(IMG_EFF_BASE + 0x00034)
+#define IMG_EFF_RKSHARP_DELTA_P0_P1			(IMG_EFF_BASE + 0x00038)
+#define IMG_EFF_RKSHARP_DELTA_P2_P3			(IMG_EFF_BASE + 0x0003c)
+#define IMG_EFF_RKSHARP_DELTA_P4			(IMG_EFF_BASE + 0x00040)
+#define IMG_EFF_RKSHARP_NPIXEL_P0_P1_P2_P3		(IMG_EFF_BASE + 0x00044)
+#define IMG_EFF_RKSHARP_NPIXEL_P4			(IMG_EFF_BASE + 0x00048)
+#define IMG_EFF_RKSHARP_GAUSS_FLAT_COE1			(IMG_EFF_BASE + 0x0004c)
+#define IMG_EFF_RKSHARP_GAUSS_FLAT_COE2			(IMG_EFF_BASE + 0x00050)
+#define IMG_EFF_RKSHARP_GAUSS_FLAT_COE3			(IMG_EFF_BASE + 0x00054)
+#define IMG_EFF_RKSHARP_GAUSS_NOISE_COE1		(IMG_EFF_BASE + 0x00058)
+#define IMG_EFF_RKSHARP_GAUSS_NOISE_COE2		(IMG_EFF_BASE + 0x0005c)
+#define IMG_EFF_RKSHARP_GAUSS_NOISE_COE3		(IMG_EFF_BASE + 0x00060)
+#define IMG_EFF_RKSHARP_GAUSS_OTHER_COE1		(IMG_EFF_BASE + 0x00064)
+#define IMG_EFF_RKSHARP_GAUSS_OTHER_COE2		(IMG_EFF_BASE + 0x00068)
+#define IMG_EFF_RKSHARP_GAUSS_OTHER_COE3		(IMG_EFF_BASE + 0x0006c)
+#define IMG_EFF_RKSHARP_LINE1_FILTER_COE1		(IMG_EFF_BASE + 0x00070)
+#define IMG_EFF_RKSHARP_LINE1_FILTER_COE2		(IMG_EFF_BASE + 0x00074)
+#define IMG_EFF_RKSHARP_LINE2_FILTER_COE1		(IMG_EFF_BASE + 0x00078)
+#define IMG_EFF_RKSHARP_LINE2_FILTER_COE2		(IMG_EFF_BASE + 0x0007c)
+#define IMG_EFF_RKSHARP_LINE2_FILTER_COE3		(IMG_EFF_BASE + 0x00080)
+#define IMG_EFF_RKSHARP_LINE3_FILTER_COE1		(IMG_EFF_BASE + 0x00084)
+#define IMG_EFF_RKSHARP_LINE3_FILTER_COE2		(IMG_EFF_BASE + 0x00088)
+#define IMG_EFF_RKSHARP_GRAD_SEQ_P0_P1			(IMG_EFF_BASE + 0x0008c)
+#define IMG_EFF_RKSHARP_GRAD_SEQ_P2_P3			(IMG_EFF_BASE + 0x00090)
+#define IMG_EFF_RKSHARP_SHARP_FACTOR_P0_P1_P2		(IMG_EFF_BASE + 0x00094)
+#define IMG_EFF_RKSHARP_SHARP_FACTOR_P3_P4		(IMG_EFF_BASE + 0x00098)
+#define IMG_EFF_RKSHARP_UV_GAUSS_FLAT_COE11_COE14	(IMG_EFF_BASE + 0x0009c)
+#define IMG_EFF_RKSHARP_UV_GAUSS_FLAT_COE15_COE23	(IMG_EFF_BASE + 0x000a0)
+#define IMG_EFF_RKSHARP_UV_GAUSS_FLAT_COE24_COE32	(IMG_EFF_BASE + 0x000a4)
+#define IMG_EFF_RKSHARP_UV_GAUSS_FLAT_COE33_COE35	(IMG_EFF_BASE + 0x000a8)
+#define IMG_EFF_RKSHARP_UV_GAUSS_NOISE_COE11_COE14	(IMG_EFF_BASE + 0x000ac)
+#define IMG_EFF_RKSHARP_UV_GAUSS_NOISE_COE15_COE23	(IMG_EFF_BASE + 0x000b0)
+#define IMG_EFF_RKSHARP_UV_GAUSS_NOISE_COE24_COE32	(IMG_EFF_BASE + 0x000b4)
+#define IMG_EFF_RKSHARP_UV_GAUSS_NOISE_COE33_COE35	(IMG_EFF_BASE + 0x000b8)
+#define IMG_EFF_RKSHARP_UV_GAUSS_OTHER_COE11_COE14	(IMG_EFF_BASE + 0x000bc)
+#define IMG_EFF_RKSHARP_UV_GAUSS_OTHER_COE15_COE23	(IMG_EFF_BASE + 0x000c0)
+#define IMG_EFF_RKSHARP_UV_GAUSS_OTHER_COE24_COE32	(IMG_EFF_BASE + 0x000c4)
+#define IMG_EFF_RKSHARP_UV_GAUSS_OTHER_COE33_COE35	(IMG_EFF_BASE + 0x000c8)
+
+#define SUPER_IMP_BASE				0x00000300
+#define SUPER_IMP_CTRL				(SUPER_IMP_BASE + 0x00000)
+#define SUPER_IMP_OFFSET_X			(SUPER_IMP_BASE + 0x00004)
+#define SUPER_IMP_OFFSET_Y			(SUPER_IMP_BASE + 0x00008)
+#define SUPER_IMP_COLOR_Y			(SUPER_IMP_BASE + 0x0000c)
+#define SUPER_IMP_COLOR_CB			(SUPER_IMP_BASE + 0x00010)
+#define SUPER_IMP_COLOR_CR			(SUPER_IMP_BASE + 0x00014)
+
+#define ISP_BASE				0x00000400
+#define ISP_CTRL				(ISP_BASE + 0x00000)
+#define ISP_ACQ_PROP				(ISP_BASE + 0x00004)
+#define ISP_ACQ_H_OFFS				(ISP_BASE + 0x00008)
+#define ISP_ACQ_V_OFFS				(ISP_BASE + 0x0000c)
+#define ISP_ACQ_H_SIZE				(ISP_BASE + 0x00010)
+#define ISP_ACQ_V_SIZE				(ISP_BASE + 0x00014)
+#define ISP_ACQ_NR_FRAMES			(ISP_BASE + 0x00018)
+#define ISP_GAMMA_DX_LO				(ISP_BASE + 0x0001c)
+#define ISP_GAMMA_DX_HI				(ISP_BASE + 0x00020)
+#define ISP_GAMMA_R_Y_0				(ISP_BASE + 0x00024)
+#define ISP_GAMMA_R_Y_1				(ISP_BASE + 0x00028)
+#define ISP_GAMMA_R_Y_2				(ISP_BASE + 0x0002c)
+#define ISP_GAMMA_R_Y_3				(ISP_BASE + 0x00030)
+#define ISP_GAMMA_R_Y_4				(ISP_BASE + 0x00034)
+#define ISP_GAMMA_R_Y_5				(ISP_BASE + 0x00038)
+#define ISP_GAMMA_R_Y_6				(ISP_BASE + 0x0003c)
+#define ISP_GAMMA_R_Y_7				(ISP_BASE + 0x00040)
+#define ISP_GAMMA_R_Y_8				(ISP_BASE + 0x00044)
+#define ISP_GAMMA_R_Y_9				(ISP_BASE + 0x00048)
+#define ISP_GAMMA_R_Y_10			(ISP_BASE + 0x0004c)
+#define ISP_GAMMA_R_Y_11			(ISP_BASE + 0x00050)
+#define ISP_GAMMA_R_Y_12			(ISP_BASE + 0x00054)
+#define ISP_GAMMA_R_Y_13			(ISP_BASE + 0x00058)
+#define ISP_GAMMA_R_Y_14			(ISP_BASE + 0x0005c)
+#define ISP_GAMMA_R_Y_15			(ISP_BASE + 0x00060)
+#define ISP_GAMMA_R_Y_16			(ISP_BASE + 0x00064)
+#define ISP_GAMMA_G_Y_0				(ISP_BASE + 0x00068)
+#define ISP_GAMMA_G_Y_1				(ISP_BASE + 0x0006c)
+#define ISP_GAMMA_G_Y_2				(ISP_BASE + 0x00070)
+#define ISP_GAMMA_G_Y_3				(ISP_BASE + 0x00074)
+#define ISP_GAMMA_G_Y_4				(ISP_BASE + 0x00078)
+#define ISP_GAMMA_G_Y_5				(ISP_BASE + 0x0007c)
+#define ISP_GAMMA_G_Y_6				(ISP_BASE + 0x00080)
+#define ISP_GAMMA_G_Y_7				(ISP_BASE + 0x00084)
+#define ISP_GAMMA_G_Y_8				(ISP_BASE + 0x00088)
+#define ISP_GAMMA_G_Y_9				(ISP_BASE + 0x0008c)
+#define ISP_GAMMA_G_Y_10			(ISP_BASE + 0x00090)
+#define ISP_GAMMA_G_Y_11			(ISP_BASE + 0x00094)
+#define ISP_GAMMA_G_Y_12			(ISP_BASE + 0x00098)
+#define ISP_GAMMA_G_Y_13			(ISP_BASE + 0x0009c)
+#define ISP_GAMMA_G_Y_14			(ISP_BASE + 0x000a0)
+#define ISP_GAMMA_G_Y_15			(ISP_BASE + 0x000a4)
+#define ISP_GAMMA_G_Y_16			(ISP_BASE + 0x000a8)
+#define ISP_GAMMA_B_Y_0				(ISP_BASE + 0x000ac)
+#define ISP_GAMMA_B_Y_1				(ISP_BASE + 0x000b0)
+#define ISP_GAMMA_B_Y_2				(ISP_BASE + 0x000b4)
+#define ISP_GAMMA_B_Y_3				(ISP_BASE + 0x000b8)
+#define ISP_GAMMA_B_Y_4				(ISP_BASE + 0x000bc)
+#define ISP_GAMMA_B_Y_5				(ISP_BASE + 0x000c0)
+#define ISP_GAMMA_B_Y_6				(ISP_BASE + 0x000c4)
+#define ISP_GAMMA_B_Y_7				(ISP_BASE + 0x000c8)
+#define ISP_GAMMA_B_Y_8				(ISP_BASE + 0x000cc)
+#define ISP_GAMMA_B_Y_9				(ISP_BASE + 0x000d0)
+#define ISP_GAMMA_B_Y_10			(ISP_BASE + 0x000d4)
+#define ISP_GAMMA_B_Y_11			(ISP_BASE + 0x000d8)
+#define ISP_GAMMA_B_Y_12			(ISP_BASE + 0x000dc)
+#define ISP_GAMMA_B_Y_13			(ISP_BASE + 0x000e0)
+#define ISP_GAMMA_B_Y_14			(ISP_BASE + 0x000e4)
+#define ISP_GAMMA_B_Y_15			(ISP_BASE + 0x000e8)
+#define ISP_GAMMA_B_Y_16			(ISP_BASE + 0x000ec)
+
+#define ISP_AWB_PROP				(ISP_BASE + 0x00110)
+#define ISP_AWB_SIZE				(ISP_BASE + 0x00114)
+#define ISP_AWB_OFFS				(ISP_BASE + 0x00118)
+#define ISP_AWB_REF				(ISP_BASE + 0x0011c)
+#define ISP_AWB_THRESH				(ISP_BASE + 0x00120)
+#define ISP_X_COOR_12				(ISP_BASE + 0x00124)
+#define ISP_X_COOR_34				(ISP_BASE + 0x00128)
+#define ISP_AWB_WHITE_CNT			(ISP_BASE + 0x0012c)
+#define ISP_AWB_MEAN				(ISP_BASE + 0x00130)
+#define ISP_DEGAIN				(ISP_BASE + 0x00134)
+#define ISP_AWB_GAIN_G				(ISP_BASE + 0x00138)
+#define ISP_AWB_GAIN_RB				(ISP_BASE + 0x0013c)
+#define ISP_REGION0_LINE0			(ISP_BASE + 0x00140)
+#define ISP_WP_CNT_REGION0			(ISP_BASE + 0x00160)
+#define ISP_WP_CNT_REGION1			(ISP_BASE + 0x00164)
+#define ISP_WP_CNT_REGION2			(ISP_BASE + 0x00168)
+#define ISP_WP_CNT_REGION3			(ISP_BASE + 0x0016c)
+
+#define ISP_CC_COEFF_0				(ISP_BASE + 0x00170)
+#define ISP_CC_COEFF_1				(ISP_BASE + 0x00174)
+#define ISP_CC_COEFF_2				(ISP_BASE + 0x00178)
+#define ISP_CC_COEFF_3				(ISP_BASE + 0x0017c)
+#define ISP_CC_COEFF_4				(ISP_BASE + 0x00180)
+#define ISP_CC_COEFF_5				(ISP_BASE + 0x00184)
+#define ISP_CC_COEFF_6				(ISP_BASE + 0x00188)
+#define ISP_CC_COEFF_7				(ISP_BASE + 0x0018c)
+#define ISP_CC_COEFF_8				(ISP_BASE + 0x00190)
+#define ISP_OUT_H_OFFS				(ISP_BASE + 0x00194)
+#define ISP_OUT_V_OFFS				(ISP_BASE + 0x00198)
+#define ISP_OUT_H_SIZE				(ISP_BASE + 0x0019c)
+#define ISP_OUT_V_SIZE				(ISP_BASE + 0x001a0)
+#define ISP_DEMOSAIC				(ISP_BASE + 0x001a4)
+#define ISP_FLAGS_SHD				(ISP_BASE + 0x001a8)
+#define ISP_OUT_H_OFFS_SHD			(ISP_BASE + 0x001ac)
+#define ISP_OUT_V_OFFS_SHD			(ISP_BASE + 0x001b0)
+#define ISP_OUT_H_SIZE_SHD			(ISP_BASE + 0x001b4)
+#define ISP_OUT_V_SIZE_SHD			(ISP_BASE + 0x001b8)
+#define ISP_ISP_IMSC				(ISP_BASE + 0x001bc)
+#define ISP_ISP_RIS				(ISP_BASE + 0x001c0)
+#define ISP_ISP_MIS				(ISP_BASE + 0x001c4)
+#define ISP_ISP_ICR				(ISP_BASE + 0x001c8)
+#define ISP_ISP_ISR				(ISP_BASE + 0x001cc)
+
+#define ISP_ISP3A_IMSC				(ISP_BASE + 0x001d0)
+#define ISP_ISP3A_RIS				(ISP_BASE + 0x001d4)
+#define ISP_ISP3A_MIS				(ISP_BASE + 0x001d8)
+#define ISP_ISP3A_ICR				(ISP_BASE + 0x001dc)
+
+#define ISP_ERR					(ISP_BASE + 0x0023c)
+#define ISP_ERR_CLR				(ISP_BASE + 0x00240)
+#define ISP_FRAME_COUNT				(ISP_BASE + 0x00244)
+#define ISP_CT_OFFSET_R				(ISP_BASE + 0x00248)
+#define ISP_CT_OFFSET_G				(ISP_BASE + 0x0024c)
+#define ISP_CT_OFFSET_B				(ISP_BASE + 0x00250)
+#define ISP_DEBUG1				(ISP_BASE + 0x00254)
+
+#define ISP_FLASH_BASE				0x00000660
+#define ISP_FLASH_CMD				(ISP_FLASH_BASE + 0x00000)
+#define ISP_FLASH_CONFIG			(ISP_FLASH_BASE + 0x00004)
+#define ISP_FLASH_PREDIV			(ISP_FLASH_BASE + 0x00008)
+#define ISP_FLASH_DELAY				(ISP_FLASH_BASE + 0x0000c)
+#define ISP_FLASH_TIME				(ISP_FLASH_BASE + 0x00010)
+#define ISP_FLASH_MAXP				(ISP_FLASH_BASE + 0x00014)
+
+#define ISP_SHUTTER_BASE			0x00000680
+#define ISP_SHUTTER_CTRL			(ISP_SHUTTER_BASE + 0x00000)
+#define ISP_SHUTTER_PREDIV			(ISP_SHUTTER_BASE + 0x00004)
+#define ISP_SHUTTER_DELAY			(ISP_SHUTTER_BASE + 0x00008)
+#define ISP_SHUTTER_TIME			(ISP_SHUTTER_BASE + 0x0000c)
+
+#define ISP_CCM_BASE				0x00000700
+#define ISP_CCM_CTRL				(ISP_CCM_BASE + 0x00000)
+#define ISP_CCM_COEFF0_R			(ISP_CCM_BASE + 0x00004)
+#define ISP_CCM_COEFF1_R			(ISP_CCM_BASE + 0x00008)
+#define ISP_CCM_COEFF0_G			(ISP_CCM_BASE + 0x0000c)
+#define ISP_CCM_COEFF1_G			(ISP_CCM_BASE + 0x00010)
+#define ISP_CCM_COEFF0_B			(ISP_CCM_BASE + 0x00014)
+#define ISP_CCM_COEFF1_B			(ISP_CCM_BASE + 0x00018)
+#define ISP_CCM_COEFF0_Y			(ISP_CCM_BASE + 0x0001c)
+#define ISP_CCM_COEFF1_Y			(ISP_CCM_BASE + 0x00020)
+#define ISP_CCM_ALP_Y0				(ISP_CCM_BASE + 0x00024)
+#define ISP_CCM_ALP_Y1				(ISP_CCM_BASE + 0x00028)
+#define ISP_CCM_ALP_Y2				(ISP_CCM_BASE + 0x0002c)
+#define ISP_CCM_ALP_Y3				(ISP_CCM_BASE + 0x00030)
+#define ISP_CCM_ALP_Y4				(ISP_CCM_BASE + 0x00034)
+#define ISP_CCM_ALP_Y5				(ISP_CCM_BASE + 0x00038)
+#define ISP_CCM_ALP_Y6				(ISP_CCM_BASE + 0x0003c)
+#define ISP_CCM_ALP_Y7				(ISP_CCM_BASE + 0x00040)
+#define ISP_CCM_ALP_Y8				(ISP_CCM_BASE + 0x00044)
+#define ISP_CCM_BOUND_BIT			(ISP_CCM_BASE + 0x00048)
+
+#define CPROC_BASE				0x00000800
+#define CPROC_CTRL				(CPROC_BASE + 0x00000)
+#define CPROC_CONTRAST				(CPROC_BASE + 0x00004)
+#define CPROC_BRIGHTNESS			(CPROC_BASE + 0x00008)
+#define CPROC_SATURATION			(CPROC_BASE + 0x0000c)
+#define CPROC_HUE				(CPROC_BASE + 0x00010)
+
+#define DUAL_CROP_BASE				0x00000880
+#define DUAL_CROP_CTRL				(DUAL_CROP_BASE + 0x00000)
+#define DUAL_CROP_M_H_OFFS			(DUAL_CROP_BASE + 0x00004)
+#define DUAL_CROP_M_V_OFFS			(DUAL_CROP_BASE + 0x00008)
+#define DUAL_CROP_M_H_SIZE			(DUAL_CROP_BASE + 0x0000c)
+#define DUAL_CROP_M_V_SIZE			(DUAL_CROP_BASE + 0x00010)
+#define DUAL_CROP_S_H_OFFS			(DUAL_CROP_BASE + 0x00014)
+#define DUAL_CROP_S_V_OFFS			(DUAL_CROP_BASE + 0x00018)
+#define DUAL_CROP_S_H_SIZE			(DUAL_CROP_BASE + 0x0001c)
+#define DUAL_CROP_S_V_SIZE			(DUAL_CROP_BASE + 0x00020)
+
+#define ISP_GAMMA_OUT_BASE			0x00000900
+#define ISP_GAMMA_OUT_CTRL			(ISP_GAMMA_OUT_BASE + 0x00000)
+#define ISP_GAMMA_OUT_OFFSET			(ISP_GAMMA_OUT_BASE + 0x00004)
+#define ISP_GAMMA_OUT_Y0			(ISP_GAMMA_OUT_BASE + 0x00010)
+#define ISP_GAMMA_OUT_Y1			(ISP_GAMMA_OUT_BASE + 0x00014)
+#define ISP_GAMMA_OUT_Y2			(ISP_GAMMA_OUT_BASE + 0x00018)
+#define ISP_GAMMA_OUT_Y3			(ISP_GAMMA_OUT_BASE + 0x0001c)
+#define ISP_GAMMA_OUT_Y4			(ISP_GAMMA_OUT_BASE + 0x00020)
+#define ISP_GAMMA_OUT_Y5			(ISP_GAMMA_OUT_BASE + 0x00024)
+#define ISP_GAMMA_OUT_Y6			(ISP_GAMMA_OUT_BASE + 0x00028)
+#define ISP_GAMMA_OUT_Y7			(ISP_GAMMA_OUT_BASE + 0x0002c)
+#define ISP_GAMMA_OUT_Y8			(ISP_GAMMA_OUT_BASE + 0x00030)
+#define ISP_GAMMA_OUT_Y9			(ISP_GAMMA_OUT_BASE + 0x00034)
+#define ISP_GAMMA_OUT_Y10			(ISP_GAMMA_OUT_BASE + 0x00038)
+#define ISP_GAMMA_OUT_Y11			(ISP_GAMMA_OUT_BASE + 0x0003c)
+#define ISP_GAMMA_OUT_Y12			(ISP_GAMMA_OUT_BASE + 0x00040)
+#define ISP_GAMMA_OUT_Y13			(ISP_GAMMA_OUT_BASE + 0x00044)
+#define ISP_GAMMA_OUT_Y14			(ISP_GAMMA_OUT_BASE + 0x00048)
+#define ISP_GAMMA_OUT_Y15			(ISP_GAMMA_OUT_BASE + 0x0004c)
+#define ISP_GAMMA_OUT_Y16			(ISP_GAMMA_OUT_BASE + 0x00050)
+#define ISP_GAMMA_OUT_Y17			(ISP_GAMMA_OUT_BASE + 0x00054)
+#define ISP_GAMMA_OUT_Y18			(ISP_GAMMA_OUT_BASE + 0x00058)
+#define ISP_GAMMA_OUT_Y19			(ISP_GAMMA_OUT_BASE + 0x0005c)
+#define ISP_GAMMA_OUT_Y20			(ISP_GAMMA_OUT_BASE + 0x00060)
+#define ISP_GAMMA_OUT_Y21			(ISP_GAMMA_OUT_BASE + 0x00064)
+#define ISP_GAMMA_OUT_Y22			(ISP_GAMMA_OUT_BASE + 0x00068)
+#define ISP_GAMMA_OUT_Y23			(ISP_GAMMA_OUT_BASE + 0x0006c)
+#define ISP_GAMMA_OUT_Y24			(ISP_GAMMA_OUT_BASE + 0x00070)
+#define ISP_GAMMA_OUT_Y25			(ISP_GAMMA_OUT_BASE + 0x00074)
+#define ISP_GAMMA_OUT_Y26			(ISP_GAMMA_OUT_BASE + 0x00078)
+#define ISP_GAMMA_OUT_Y27			(ISP_GAMMA_OUT_BASE + 0x0007c)
+#define ISP_GAMMA_OUT_Y28			(ISP_GAMMA_OUT_BASE + 0x00080)
+#define ISP_GAMMA_OUT_Y29			(ISP_GAMMA_OUT_BASE + 0x00084)
+#define ISP_GAMMA_OUT_Y30			(ISP_GAMMA_OUT_BASE + 0x00088)
+#define ISP_GAMMA_OUT_Y31			(ISP_GAMMA_OUT_BASE + 0x0008c)
+#define ISP_GAMMA_OUT_Y32			(ISP_GAMMA_OUT_BASE + 0x00090)
+#define ISP_GAMMA_OUT_Y33			(ISP_GAMMA_OUT_BASE + 0x00094)
+#define ISP_GAMMA_OUT_Y34			(ISP_GAMMA_OUT_BASE + 0x00098)
+#define ISP_GAMMA_OUT_Y35			(ISP_GAMMA_OUT_BASE + 0x0009c)
+#define ISP_GAMMA_OUT_Y36			(ISP_GAMMA_OUT_BASE + 0x000a0)
+#define ISP_GAMMA_OUT_Y37			(ISP_GAMMA_OUT_BASE + 0x000a4)
+#define ISP_GAMMA_OUT_Y38			(ISP_GAMMA_OUT_BASE + 0x000a8)
+#define ISP_GAMMA_OUT_Y39			(ISP_GAMMA_OUT_BASE + 0x000ac)
+#define ISP_GAMMA_OUT_Y40			(ISP_GAMMA_OUT_BASE + 0x000b0)
+
+#define SELF_RESIZE_BASE			0x00000C00
+#define SELF_RESIZE_CTRL			(SELF_RESIZE_BASE + 0x00000)
+#define SELF_RESIZE_SCALE_HY			(SELF_RESIZE_BASE + 0x00004)
+#define SELF_RESIZE_SCALE_HCB			(SELF_RESIZE_BASE + 0x00008)
+#define SELF_RESIZE_SCALE_HCR			(SELF_RESIZE_BASE + 0x0000c)
+#define SELF_RESIZE_SCALE_VY			(SELF_RESIZE_BASE + 0x00010)
+#define SELF_RESIZE_SCALE_VC			(SELF_RESIZE_BASE + 0x00014)
+#define SELF_RESIZE_PHASE_HY			(SELF_RESIZE_BASE + 0x00018)
+#define SELF_RESIZE_PHASE_HC			(SELF_RESIZE_BASE + 0x0001c)
+#define SELF_RESIZE_PHASE_VY			(SELF_RESIZE_BASE + 0x00020)
+#define SELF_RESIZE_PHASE_VC			(SELF_RESIZE_BASE + 0x00024)
+#define SELF_RESIZE_SCALE_LUT_ADDR		(SELF_RESIZE_BASE + 0x00028)
+#define SELF_RESIZE_SCALE_LUT			(SELF_RESIZE_BASE + 0x0002c)
+#define SELF_RESIZE_CTRL_SHD			(SELF_RESIZE_BASE + 0x00030)
+#define SELF_RESIZE_SCALE_HY_SHD		(SELF_RESIZE_BASE + 0x00034)
+#define SELF_RESIZE_SCALE_HCB_SHD		(SELF_RESIZE_BASE + 0x00038)
+#define SELF_RESIZE_SCALE_HCR_SHD		(SELF_RESIZE_BASE + 0x0003c)
+#define SELF_RESIZE_SCALE_VY_SHD		(SELF_RESIZE_BASE + 0x00040)
+#define SELF_RESIZE_SCALE_VC_SHD		(SELF_RESIZE_BASE + 0x00044)
+#define SELF_RESIZE_PHASE_HY_SHD		(SELF_RESIZE_BASE + 0x00048)
+#define SELF_RESIZE_PHASE_HC_SHD		(SELF_RESIZE_BASE + 0x0004c)
+#define SELF_RESIZE_PHASE_VY_SHD		(SELF_RESIZE_BASE + 0x00050)
+#define SELF_RESIZE_PHASE_VC_SHD		(SELF_RESIZE_BASE + 0x00054)
+
+#define MAIN_RESIZE_BASE			0x00001000
+#define MAIN_RESIZE_CTRL			(MAIN_RESIZE_BASE + 0x00000)
+#define MAIN_RESIZE_SCALE_HY			(MAIN_RESIZE_BASE + 0x00004)
+#define MAIN_RESIZE_SCALE_HCB			(MAIN_RESIZE_BASE + 0x00008)
+#define MAIN_RESIZE_SCALE_HCR			(MAIN_RESIZE_BASE + 0x0000c)
+#define MAIN_RESIZE_SCALE_VY			(MAIN_RESIZE_BASE + 0x00010)
+#define MAIN_RESIZE_SCALE_VC			(MAIN_RESIZE_BASE + 0x00014)
+#define MAIN_RESIZE_PHASE_HY			(MAIN_RESIZE_BASE + 0x00018)
+#define MAIN_RESIZE_PHASE_HC			(MAIN_RESIZE_BASE + 0x0001c)
+#define MAIN_RESIZE_PHASE_VY			(MAIN_RESIZE_BASE + 0x00020)
+#define MAIN_RESIZE_PHASE_VC			(MAIN_RESIZE_BASE + 0x00024)
+#define MAIN_RESIZE_SCALE_LUT_ADDR		(MAIN_RESIZE_BASE + 0x00028)
+#define MAIN_RESIZE_SCALE_LUT			(MAIN_RESIZE_BASE + 0x0002c)
+#define MAIN_RESIZE_CTRL_SHD			(MAIN_RESIZE_BASE + 0x00030)
+#define MAIN_RESIZE_SCALE_HY_SHD		(MAIN_RESIZE_BASE + 0x00034)
+#define MAIN_RESIZE_SCALE_HCB_SHD		(MAIN_RESIZE_BASE + 0x00038)
+#define MAIN_RESIZE_SCALE_HCR_SHD		(MAIN_RESIZE_BASE + 0x0003c)
+#define MAIN_RESIZE_SCALE_VY_SHD		(MAIN_RESIZE_BASE + 0x00040)
+#define MAIN_RESIZE_SCALE_VC_SHD		(MAIN_RESIZE_BASE + 0x00044)
+#define MAIN_RESIZE_PHASE_HY_SHD		(MAIN_RESIZE_BASE + 0x00048)
+#define MAIN_RESIZE_PHASE_HC_SHD		(MAIN_RESIZE_BASE + 0x0004c)
+#define MAIN_RESIZE_PHASE_VY_SHD		(MAIN_RESIZE_BASE + 0x00050)
+#define MAIN_RESIZE_PHASE_VC_SHD		(MAIN_RESIZE_BASE + 0x00054)
+
+#define MI_BASE					0x00001400
+#define MI_WR_CTRL				(MI_BASE + 0x00000)
+#define MI_WR_INIT				(MI_BASE + 0x00004)
+#define MI_MP_WR_Y_BASE				(MI_BASE + 0x00008)
+#define MI_MP_WR_Y_SIZE				(MI_BASE + 0x0000c)
+#define MI_MP_WR_Y_OFFS_CNT			(MI_BASE + 0x00010)
+#define MI_MP_WR_Y_OFFS_CNT_START		(MI_BASE + 0x00014)
+#define MI_MP_WR_Y_IRQ_OFFS			(MI_BASE + 0x00018)
+#define MI_MP_WR_CB_BASE			(MI_BASE + 0x0001c)
+#define MI_MP_WR_CB_SIZE			(MI_BASE + 0x00020)
+#define MI_MP_WR_CB_OFFS_CNT			(MI_BASE + 0x00024)
+#define MI_MP_WR_CB_OFFS_CNT_START		(MI_BASE + 0x00028)
+#define MI_MP_WR_CR_BASE			(MI_BASE + 0x0002c)
+#define MI_MP_WR_CR_SIZE			(MI_BASE + 0x00030)
+#define MI_MP_WR_CR_OFFS_CNT			(MI_BASE + 0x00034)
+#define MI_MP_WR_CR_OFFS_CNT_START		(MI_BASE + 0x00038)
+#define MI_SP_WR_Y_BASE				(MI_BASE + 0x0003c)
+#define MI_SP_WR_Y_SIZE				(MI_BASE + 0x00040)
+#define MI_SP_WR_Y_OFFS_CNT			(MI_BASE + 0x00044)
+#define MI_SP_WR_Y_OFFS_CNT_START		(MI_BASE + 0x00048)
+#define MI_SP_WR_Y_LLENGTH			(MI_BASE + 0x0004c)
+#define MI_SP_WR_CB_BASE			(MI_BASE + 0x00050)
+#define MI_SP_WR_CB_SIZE			(MI_BASE + 0x00054)
+#define MI_SP_WR_CB_OFFS_CNT			(MI_BASE + 0x00058)
+#define MI_SP_WR_CB_OFFS_CNT_START		(MI_BASE + 0x0005c)
+#define MI_SP_WR_CR_BASE			(MI_BASE + 0x00060)
+#define MI_SP_WR_CR_SIZE			(MI_BASE + 0x00064)
+#define MI_SP_WR_CR_OFFS_CNT			(MI_BASE + 0x00068)
+#define MI_SP_WR_CR_OFFS_CNT_START		(MI_BASE + 0x0006c)
+#define MI_WR_BYTE_CNT				(MI_BASE + 0x00070)
+#define MI_WR_CTRL_SHD				(MI_BASE + 0x00074)
+#define MI_MP_WR_Y_BASE_SHD			(MI_BASE + 0x00078)
+#define MI_MP_WR_Y_SIZE_SHD			(MI_BASE + 0x0007c)
+#define MI_MP_WR_Y_OFFS_CNT_SHD			(MI_BASE + 0x00080)
+#define MI_MP_WR_Y_IRQ_OFFS_SHD			(MI_BASE + 0x00084)
+#define MI_MP_WR_CB_BASE_SHD			(MI_BASE + 0x00088)
+#define MI_MP_WR_CB_SIZE_SHD			(MI_BASE + 0x0008c)
+#define MI_MP_WR_CB_OFFS_CNT_SHD		(MI_BASE + 0x00090)
+#define MI_MP_WR_CR_BASE_SHD			(MI_BASE + 0x00094)
+#define MI_MP_WR_CR_SIZE_SHD			(MI_BASE + 0x00098)
+#define MI_MP_WR_CR_OFFS_CNT_SHD		(MI_BASE + 0x0009c)
+#define MI_SP_WR_Y_BASE_SHD			(MI_BASE + 0x000a0)
+#define MI_SP_WR_Y_SIZE_SHD			(MI_BASE + 0x000a4)
+#define MI_SP_WR_Y_OFFS_CNT_SHD			(MI_BASE + 0x000a8)
+#define MI_SP_WR_CB_BASE_AD_SHD			(MI_BASE + 0x000b0)
+#define MI_SP_WR_CB_SIZE_SHD			(MI_BASE + 0x000b4)
+#define MI_SP_WR_CB_OFFS_CNT_SHD		(MI_BASE + 0x000b8)
+#define MI_SP_WR_CR_BASE_AD_SHD			(MI_BASE + 0x000bc)
+#define MI_SP_WR_CR_SIZE_SHD			(MI_BASE + 0x000c0)
+#define MI_SP_WR_CR_OFFS_CNT_SHD		(MI_BASE + 0x000c4)
+#define MI_RD_Y_PIC_START_AD			(MI_BASE + 0x000c8)
+#define MI_RD_Y_PIC_WIDTH			(MI_BASE + 0x000cc)
+#define MI_RD_Y_LLENGTH				(MI_BASE + 0x000d0)
+#define MI_RD_Y_PIC_SIZE			(MI_BASE + 0x000d4)
+#define MI_RD_CB_PIC_START_AD			(MI_BASE + 0x000d8)
+#define MI_RD_CR_PIC_START_AD			(MI_BASE + 0x000e8)
+#define MI_IMSC					(MI_BASE + 0x000f8)
+#define MI_RIS					(MI_BASE + 0x000fc)
+#define MI_MIS					(MI_BASE + 0x00100)
+#define MI_ICR					(MI_BASE + 0x00104)
+#define MI_ISR					(MI_BASE + 0x00108)
+#define MI_STATUS				(MI_BASE + 0x0010c)
+#define MI_STATUS_CLR				(MI_BASE + 0x00110)
+#define MI_SP_WR_Y_PIC_WIDTH			(MI_BASE + 0x00114)
+#define MI_SP_WR_Y_PIC_HEIGHT			(MI_BASE + 0x00118)
+#define MI_SP_WR_Y_PIC_SIZE			(MI_BASE + 0x0011c)
+#define MI_RD_CTRL				(MI_BASE + 0x00120)
+#define MI_RD_START				(MI_BASE + 0x00124)
+#define MI_RD_STATUS				(MI_BASE + 0x00128)
+#define MI_WR_PIXEL_CNT				(MI_BASE + 0x0012c)
+#define MI_MP_WR_Y_BASE2			(MI_BASE + 0x00130)
+#define MI_MP_WR_CB_BASE2			(MI_BASE + 0x00134)
+#define MI_MP_WR_CR_BASE2			(MI_BASE + 0x00138)
+#define MI_WR_XTD_FORMAT_CTRL			(MI_BASE + 0x00148)
+#define MI_WR_ID				(MI_BASE + 0x00154)
+#define MI_MP_WR_Y_IRQ_OFFS2			(MI_BASE + 0x001e0)
+#define MI_MP_WR_Y_IRQ_OFFS2_SHD		(MI_BASE + 0x001e4)
+#define MI_WR_CTRL2				(MI_BASE + 0x00400)
+#define MI_WR_ID2				(MI_BASE + 0x00404)
+#define MI_RD_CTRL2				(MI_BASE + 0x00408)
+#define MI_RD_ID				(MI_BASE + 0x0040c)
+#define MI_RD_FIFO_LEVEL			(MI_BASE + 0x0041c)
+#define MI_RAW0_WR_BASE				(MI_BASE + 0x00420)
+#define MI_RAW0_WR_SIZE				(MI_BASE + 0x00424)
+#define MI_RAW0_WR_LENGTH			(MI_BASE + 0x00428)
+#define MI_RAW0_WR_BASE_SHD			(MI_BASE + 0x0042c)
+#define MI_RAW1_WR_BASE				(MI_BASE + 0x00430)
+#define MI_RAW1_WR_SIZE				(MI_BASE + 0x00434)
+#define MI_RAW1_WR_LENGTH			(MI_BASE + 0x00438)
+#define MI_RAW1_WR_BASE_SHD			(MI_BASE + 0x0043c)
+#define MI_RAW2_WR_BASE				(MI_BASE + 0x00440)
+#define MI_RAW2_WR_SIZE				(MI_BASE + 0x00444)
+#define MI_RAW2_WR_LENGTH			(MI_BASE + 0x00448)
+#define MI_RAW2_WR_BASE_SHD			(MI_BASE + 0x0044c)
+#define MI_RAW3_WR_BASE				(MI_BASE + 0x00450)
+#define MI_RAW3_WR_SIZE				(MI_BASE + 0x00454)
+#define MI_RAW3_WR_LENGTH			(MI_BASE + 0x00458)
+#define MI_RAW3_WR_BASE_SHD			(MI_BASE + 0x0045c)
+#define MI_RW0_WR_LAST_FRAME_ADDR		(MI_BASE + 0x00460)
+#define MI_RW1_WR_LAST_FRAME_ADDR		(MI_BASE + 0x00464)
+#define MI_RW2_WR_LAST_FRAME_ADDR		(MI_BASE + 0x00468)
+#define MI_RW3_WR_LAST_FRAME_ADDR		(MI_BASE + 0x0046c)
+#define MI_RAW0_RD_BASE				(MI_BASE + 0x00470)
+#define MI_RAW0_RD_LENGTH			(MI_BASE + 0x00474)
+#define MI_RAW0_RD_BASE_SHD			(MI_BASE + 0x00478)
+#define MI_RAW1_RD_BASE				(MI_BASE + 0x00480)
+#define MI_RAW1_RD_LENGTH			(MI_BASE + 0x00484)
+#define MI_RAW1_RD_BASE_SHD			(MI_BASE + 0x00488)
+#define MI_RAW2_RD_BASE				(MI_BASE + 0x00490)
+#define MI_RAW2_RD_LENGTH			(MI_BASE + 0x00494)
+#define MI_RAW2_RD_BASE_SHD			(MI_BASE + 0x00498)
+#define MI_RAWFBC_WR_BURST_LEN			(MI_BASE + 0x00500)
+#define MI_RAWFBC_RD_BURST_LEN			(MI_BASE + 0x00504)
+#define MI_RAW0FBC_WR_BASE			(MI_BASE + 0x00510)
+#define MI_RAW1FBC_WR_BASE			(MI_BASE + 0x00514)
+#define MI_RAW0FBC_RD_BASE			(MI_BASE + 0x00518)
+#define MI_RAW1FBC_RD_BASE			(MI_BASE + 0x0051c)
+#define MI_RAW0FBC_WR_BASE_SHD			(MI_BASE + 0x00520)
+#define MI_RAW1FBC_WR_BASE_SHD			(MI_BASE + 0x00524)
+#define MI_RAW0FBC_RD_BASE_SHD			(MI_BASE + 0x00528)
+#define MI_RAW1FBC_RD_BASE_SHD			(MI_BASE + 0x0052c)
+#define MI_LUT_3D_RD_BASE			(MI_BASE + 0x00540)
+#define MI_LUT_LSC_RD_BASE			(MI_BASE + 0x00544)
+#define MI_LUT_LDCH_RD_BASE			(MI_BASE + 0x00548)
+#define MI_LUT_3D_RD_WSIZE			(MI_BASE + 0x00550)
+#define MI_LUT_LSC_RD_WSIZE			(MI_BASE + 0x00554)
+#define MI_LUT_LDCH_RD_H_WSIZE			(MI_BASE + 0x00558)
+#define MI_LUT_LDCH_RD_V_SIZE			(MI_BASE + 0x0055c)
+#define MI_DBR_WR_BASE				(MI_BASE + 0x00560)
+#define MI_DBR_WR_SIZE				(MI_BASE + 0x00564)
+#define MI_DBR_WR_LENGTH			(MI_BASE + 0x00568)
+#define MI_DBR_WR_BASE_SHD			(MI_BASE + 0x0056c)
+#define MI_DBR_RD_BASE				(MI_BASE + 0x00570)
+#define MI_DBR_RD_LENGTH			(MI_BASE + 0x00574)
+#define MI_DBR_RD_BASE_SHD			(MI_BASE + 0x00578)
+#define MI_GAIN_WR_BASE				(MI_BASE + 0x00580)
+#define MI_GAIN_WR_SIZE				(MI_BASE + 0x00584)
+#define MI_GAIN_WR_LENGTH			(MI_BASE + 0x00588)
+#define MI_GAIN_WR_BASE2			(MI_BASE + 0x0058c)
+#define MI_GAIN_WR_BASE_SHD			(MI_BASE + 0x00590)
+
+#define ISP_MPFBC_BASE				0x000018C0
+#define ISP_MPFBC_CTRL				(ISP_MPFBC_BASE + 0x00000)
+#define ISP_MPFBC_VIR_WIDTH			(ISP_MPFBC_BASE + 0x00004)
+#define ISP_MPFBC_VIR_HEIGHT			(ISP_MPFBC_BASE + 0x00008)
+#define ISP_MPFBC_HEAD_PTR			(ISP_MPFBC_BASE + 0x0000c)
+#define ISP_MPFBC_PAYL_PTR			(ISP_MPFBC_BASE + 0x00010)
+#define ISP_MPFBC_HEAD_PTR2			(ISP_MPFBC_BASE + 0x00014)
+#define ISP_MPFBC_PAYL_PTR2			(ISP_MPFBC_BASE + 0x00018)
+#define ISP_MPFBC_ENC_POS			(ISP_MPFBC_BASE + 0x00030)
+
+#define CSI2RX_BASE				0x00001C00
+#define CSI2RX_CTRL0				(CSI2RX_BASE + 0x00000)
+#define CSI2RX_CTRL1				(CSI2RX_BASE + 0x00004)
+#define CSI2RX_CTRL2				(CSI2RX_BASE + 0x00008)
+#define CSI2RX_CSI2_RESETN			(CSI2RX_BASE + 0x00010)
+#define CSI2RX_PHY_STATE_RO			(CSI2RX_BASE + 0x00014)
+#define CSI2RX_DATA_IDS_1			(CSI2RX_BASE + 0x00018)
+#define CSI2RX_DATA_IDS_2			(CSI2RX_BASE + 0x0001c)
+#define CSI2RX_ERR_PHY				(CSI2RX_BASE + 0x00020)
+#define CSI2RX_ERR_PACKET			(CSI2RX_BASE + 0x00024)
+#define CSI2RX_ERR_OVERFLOW			(CSI2RX_BASE + 0x00028)
+#define CSI2RX_ERR_STAT				(CSI2RX_BASE + 0x0002c)
+#define CSI2RX_MASK_PHY				(CSI2RX_BASE + 0x00030)
+#define CSI2RX_MASK_PACKET			(CSI2RX_BASE + 0x00034)
+#define CSI2RX_MASK_OVERFLOW			(CSI2RX_BASE + 0x00038)
+#define CSI2RX_MASK_STAT			(CSI2RX_BASE + 0x0003c)
+#define CSI2RX_RAW0_WR_CTRL			(CSI2RX_BASE + 0x00040)
+#define CSI2RX_RAW0_WR_LINECNT_RO		(CSI2RX_BASE + 0x00044)
+#define CSI2RX_RAW0_WR_PIC_SIZE			(CSI2RX_BASE + 0x00048)
+#define CSI2RX_RAW0_WR_PIC_OFF			(CSI2RX_BASE + 0x0004c)
+#define CSI2RX_RAW1_WR_CTRL			(CSI2RX_BASE + 0x00050)
+#define CSI2RX_RAW1_WR_LINECNT_RO		(CSI2RX_BASE + 0x00054)
+#define CSI2RX_RAW1_WR_PIC_SIZE			(CSI2RX_BASE + 0x00058)
+#define CSI2RX_RAW1_WR_PIC_OFF			(CSI2RX_BASE + 0x0005c)
+#define CSI2RX_RAW2_WR_CTRL			(CSI2RX_BASE + 0x00060)
+#define CSI2RX_RAW2_WR_LINECNT_RO		(CSI2RX_BASE + 0x00064)
+#define CSI2RX_RAW2_WR_PIC_SIZE			(CSI2RX_BASE + 0x00068)
+#define CSI2RX_RAW2_WR_PIC_OFF			(CSI2RX_BASE + 0x0006c)
+#define CSI2RX_RAW3_WR_CTRL			(CSI2RX_BASE + 0x00070)
+#define CSI2RX_RAW3_WR_LINECNT_RO		(CSI2RX_BASE + 0x00074)
+#define CSI2RX_RAW3_WR_PIC_SIZE			(CSI2RX_BASE + 0x00078)
+#define CSI2RX_RAW3_WR_PIC_OFF			(CSI2RX_BASE + 0x0007c)
+#define CSI2RX_RAW_RD_CTRL			(CSI2RX_BASE + 0x00080)
+#define CSI2RX_RAW_RD_LINECNT_RO		(CSI2RX_BASE + 0x00084)
+#define CSI2RX_RAW_RD_PIC_SIZE			(CSI2RX_BASE + 0x00088)
+#define CSI2RX_RAW2_RD_LINECNT_RO		(CSI2RX_BASE + 0x0008c)
+#define CSI2RX_RAWFBC_CTRL			(CSI2RX_BASE + 0x00090)
+#define CSI2RX_ESPHDR_LCNT			(CSI2RX_BASE + 0x00094)
+#define CSI2RX_ESPHDR_IDCD			(CSI2RX_BASE + 0x00098)
+#define CSI2RX_VC0_FRAME_NUM_RO			(CSI2RX_BASE + 0x000a0)
+#define CSI2RX_VC1_FRAME_NUM_RO			(CSI2RX_BASE + 0x000a4)
+#define CSI2RX_VC2_FRAME_NUM_RO			(CSI2RX_BASE + 0x000a8)
+#define CSI2RX_VC3_FRAME_NUM_RO			(CSI2RX_BASE + 0x000ac)
+#define CSI2RX_ISP_LINECNT_RO			(CSI2RX_BASE + 0x000b0)
+#define CSI2RX_RAW_WR_IBUF_STATUS_RO		(CSI2RX_BASE + 0x000b4)
+#define CSI2RX_RAW_WR_IBUF3_STATUS_RO		(CSI2RX_BASE + 0x000b8)
+#define CSI2RX_CUR_HEADER_RO			(CSI2RX_BASE + 0x000c4)
+#define CSI2RX_RAWFBC_EN_SHD			(CSI2RX_BASE + 0x000c8)
+#define CSI2RX_FPN_CTRL				(CSI2RX_BASE + 0x000d0)
+#define CSI2RX_FPN_TABLE_CTRL			(CSI2RX_BASE + 0x000d4)
+#define CSI2RX_FPN_TABLE_DATA			(CSI2RX_BASE + 0x000d8)
+#define CSI2RX_Y_STAT_CTRL			(CSI2RX_BASE + 0x000f0)
+#define CSI2RX_Y_STAT_RO			(CSI2RX_BASE + 0x000f4)
+#define CSI2RX_VERSION				(CSI2RX_BASE + 0x000fc)
+
+#define ISP_LSC_BASE				0x00002200
+#define ISP_LSC_CTRL				(ISP_LSC_BASE + 0x00000)
+#define ISP_LSC_R_TABLE_ADDR			(ISP_LSC_BASE + 0x00004)
+#define ISP_LSC_GR_TABLE_ADDR			(ISP_LSC_BASE + 0x00008)
+#define ISP_LSC_B_TABLE_ADDR			(ISP_LSC_BASE + 0x0000c)
+#define ISP_LSC_GB_TABLE_ADDR			(ISP_LSC_BASE + 0x00010)
+#define ISP_LSC_R_TABLE_DATA			(ISP_LSC_BASE + 0x00014)
+#define ISP_LSC_GR_TABLE_DATA			(ISP_LSC_BASE + 0x00018)
+#define ISP_LSC_B_TABLE_DATA			(ISP_LSC_BASE + 0x0001c)
+#define ISP_LSC_GB_TABLE_DATA			(ISP_LSC_BASE + 0x00020)
+#define ISP_LSC_XGRAD_01			(ISP_LSC_BASE + 0x00024)
+#define ISP_LSC_XGRAD_23			(ISP_LSC_BASE + 0x00028)
+#define ISP_LSC_XGRAD_45			(ISP_LSC_BASE + 0x0002c)
+#define ISP_LSC_XGRAD_67			(ISP_LSC_BASE + 0x00030)
+#define ISP_LSC_YGRAD_01			(ISP_LSC_BASE + 0x00034)
+#define ISP_LSC_YGRAD_23			(ISP_LSC_BASE + 0x00038)
+#define ISP_LSC_YGRAD_45			(ISP_LSC_BASE + 0x0003c)
+#define ISP_LSC_YGRAD_67			(ISP_LSC_BASE + 0x00040)
+#define ISP_LSC_XSIZE_01			(ISP_LSC_BASE + 0x00044)
+#define ISP_LSC_XSIZE_23			(ISP_LSC_BASE + 0x00048)
+#define ISP_LSC_XSIZE_45			(ISP_LSC_BASE + 0x0004c)
+#define ISP_LSC_XSIZE_67			(ISP_LSC_BASE + 0x00050)
+#define ISP_LSC_YSIZE_01			(ISP_LSC_BASE + 0x00054)
+#define ISP_LSC_YSIZE_23			(ISP_LSC_BASE + 0x00058)
+#define ISP_LSC_YSIZE_45			(ISP_LSC_BASE + 0x0005c)
+#define ISP_LSC_YSIZE_67			(ISP_LSC_BASE + 0x00060)
+#define ISP_LSC_TABLE_SEL			(ISP_LSC_BASE + 0x00064)
+#define ISP_LSC_ISP_LSC_STATUS			(ISP_LSC_BASE + 0x00068)
+
+#define ISP_DEBAYER_BASE			0x00002500
+#define ISP_DEBAYER_CONTROL			(ISP_DEBAYER_BASE + 0x00000)
+#define ISP_DEBAYER_G_INTERP			(ISP_DEBAYER_BASE + 0x00004)
+#define ISP_DEBAYER_G_INTERP_FILTER1		(ISP_DEBAYER_BASE + 0x00008)
+#define ISP_DEBAYER_G_INTERP_FILTER2		(ISP_DEBAYER_BASE + 0x0000c)
+#define ISP_DEBAYER_G_FILTER			(ISP_DEBAYER_BASE + 0x00010)
+#define ISP_DEBAYER_C_FILTER			(ISP_DEBAYER_BASE + 0x00014)
+
+#define ISP_WDR_BASE				0x00002A00
+#define ISP_WDR_WDR_TONECURVE_DYN1		(ISP_WDR_BASE + 0x00004)
+#define ISP_WDR_WDR_TONECURVE_DYN2		(ISP_WDR_BASE + 0x00008)
+#define ISP_WDR_WDR_TONECURVE_DYN3		(ISP_WDR_BASE + 0x0000c)
+#define ISP_WDR_WDR_TONECURVE_DYN4		(ISP_WDR_BASE + 0x00010)
+#define ISP_WDR_TONECURVE_YM_0			(ISP_WDR_BASE + 0x00014)
+#define ISP_WDR_TONECURVE_YM_1			(ISP_WDR_BASE + 0x00018)
+#define ISP_WDR_TONECURVE_YM_2			(ISP_WDR_BASE + 0x0001c)
+#define ISP_WDR_TONECURVE_YM_3			(ISP_WDR_BASE + 0x00020)
+#define ISP_WDR_TONECURVE_YM_4			(ISP_WDR_BASE + 0x00024)
+#define ISP_WDR_TONECURVE_YM_5			(ISP_WDR_BASE + 0x00028)
+#define ISP_WDR_TONECURVE_YM_6			(ISP_WDR_BASE + 0x0002c)
+#define ISP_WDR_TONECURVE_YM_7			(ISP_WDR_BASE + 0x00030)
+#define ISP_WDR_TONECURVE_YM_8			(ISP_WDR_BASE + 0x00034)
+#define ISP_WDR_TONECURVE_YM_9			(ISP_WDR_BASE + 0x00038)
+#define ISP_WDR_TONECURVE_YM_10			(ISP_WDR_BASE + 0x0003c)
+#define ISP_WDR_TONECURVE_YM_11			(ISP_WDR_BASE + 0x00040)
+#define ISP_WDR_TONECURVE_YM_12			(ISP_WDR_BASE + 0x00044)
+#define ISP_WDR_TONECURVE_YM_13			(ISP_WDR_BASE + 0x00048)
+#define ISP_WDR_TONECURVE_YM_14			(ISP_WDR_BASE + 0x0004c)
+#define ISP_WDR_TONECURVE_YM_15			(ISP_WDR_BASE + 0x00050)
+#define ISP_WDR_TONECURVE_YM_16			(ISP_WDR_BASE + 0x00054)
+#define ISP_WDR_TONECURVE_YM_17			(ISP_WDR_BASE + 0x00058)
+#define ISP_WDR_TONECURVE_YM_18			(ISP_WDR_BASE + 0x0005c)
+#define ISP_WDR_TONECURVE_YM_19			(ISP_WDR_BASE + 0x00060)
+#define ISP_WDR_TONECURVE_YM_20			(ISP_WDR_BASE + 0x00064)
+#define ISP_WDR_TONECURVE_YM_21			(ISP_WDR_BASE + 0x00068)
+#define ISP_WDR_TONECURVE_YM_22			(ISP_WDR_BASE + 0x0006c)
+#define ISP_WDR_TONECURVE_YM_23			(ISP_WDR_BASE + 0x00070)
+#define ISP_WDR_TONECURVE_YM_24			(ISP_WDR_BASE + 0x00074)
+#define ISP_WDR_TONECURVE_YM_25			(ISP_WDR_BASE + 0x00078)
+#define ISP_WDR_TONECURVE_YM_26			(ISP_WDR_BASE + 0x0007c)
+#define ISP_WDR_TONECURVE_YM_27			(ISP_WDR_BASE + 0x00080)
+#define ISP_WDR_TONECURVE_YM_28			(ISP_WDR_BASE + 0x00084)
+#define ISP_WDR_TONECURVE_YM_29			(ISP_WDR_BASE + 0x00088)
+#define ISP_WDR_TONECURVE_YM_30			(ISP_WDR_BASE + 0x0008c)
+#define ISP_WDR_TONECURVE_YM_31			(ISP_WDR_BASE + 0x00090)
+#define ISP_WDR_TONECURVE_YM_32			(ISP_WDR_BASE + 0x00094)
+#define ISP_WDR_OFFSET				(ISP_WDR_BASE + 0x00098)
+#define ISP_WDR_CTRL0				(ISP_WDR_BASE + 0x00150)
+#define ISP_WDR_CTRL1				(ISP_WDR_BASE + 0x00154)
+#define ISP_WDR_BLKOFF0				(ISP_WDR_BASE + 0x00158)
+#define ISP_WDR_AVGCLIP				(ISP_WDR_BASE + 0x0015c)
+#define ISP_WDR_COE_0				(ISP_WDR_BASE + 0x00160)
+#define ISP_WDR_COE_1				(ISP_WDR_BASE + 0x00164)
+#define ISP_WDR_COE_2				(ISP_WDR_BASE + 0x00168)
+#define ISP_WDR_COE_OFF				(ISP_WDR_BASE + 0x0016c)
+#define ISP_WDR_BLKOFF1				(ISP_WDR_BASE + 0x00174)
+#define ISP_WDR_BLKMEAN8_ROW0_0TO3		(ISP_WDR_BASE + 0x00180)
+#define ISP_WDR_BLKMEAN8_ROW0_4TO7		(ISP_WDR_BASE + 0x00184)
+#define ISP_WDR_BLKMEAN8_ROW1_0TO3		(ISP_WDR_BASE + 0x00188)
+#define ISP_WDR_BLKMEAN8_ROW1_4TO7		(ISP_WDR_BASE + 0x0018c)
+#define ISP_WDR_BLKMEAN8_ROW2_0TO3		(ISP_WDR_BASE + 0x00190)
+#define ISP_WDR_BLKMEAN8_ROW2_4TO7		(ISP_WDR_BASE + 0x00194)
+#define ISP_WDR_BLKMEAN8_ROW3_0TO3		(ISP_WDR_BASE + 0x00198)
+#define ISP_WDR_BLKMEAN8_ROW3_4TO7		(ISP_WDR_BASE + 0x0019c)
+#define ISP_WDR_BLKMEAN8_ROW4_0TO3		(ISP_WDR_BASE + 0x001a0)
+#define ISP_WDR_BLKMEAN8_ROW4_4TO7		(ISP_WDR_BASE + 0x001a4)
+#define ISP_WDR_BLKMEAN8_ROW5_0TO3		(ISP_WDR_BASE + 0x001a8)
+#define ISP_WDR_BLKMEAN8_ROW5_4TO7		(ISP_WDR_BASE + 0x001ac)
+#define ISP_WDR_BLKMEAN8_ROW6_0TO3		(ISP_WDR_BASE + 0x001b0)
+#define ISP_WDR_BLKMEAN8_ROW6_4TO7		(ISP_WDR_BASE + 0x001b4)
+#define ISP_WDR_BLKMEAN8_ROW7_0TO3		(ISP_WDR_BASE + 0x001b8)
+#define ISP_WDR_BLKMEAN8_ROW7_4TO7		(ISP_WDR_BASE + 0x001bc)
+#define ISP_WDR_BLKMEAN8_ROW8_0TO3		(ISP_WDR_BASE + 0x001c0)
+#define ISP_WDR_BLKMEAN8_ROW8_4TO7		(ISP_WDR_BASE + 0x001c4)
+#define ISP_WDR_BLKMEAN8_ROW9_0TO3		(ISP_WDR_BASE + 0x001c8)
+#define ISP_WDR_BLKMEAN8_ROW9_4TO7		(ISP_WDR_BASE + 0x001cc)
+
+#define ISP_GIC_BASE				0x00002F00
+#define ISP_GIC_CONTROL				(ISP_GIC_BASE + 0x00000)
+#define ISP_GIC_DIFF_PARA1			(ISP_GIC_BASE + 0x00004)
+#define ISP_GIC_DIFF_PARA2			(ISP_GIC_BASE + 0x00008)
+#define ISP_GIC_DIFF_PARA3			(ISP_GIC_BASE + 0x0000c)
+#define ISP_GIC_DIFF_PARA4			(ISP_GIC_BASE + 0x00010)
+#define ISP_GIC_NOISE_PARA1			(ISP_GIC_BASE + 0x00014)
+#define ISP_GIC_NOISE_PARA2			(ISP_GIC_BASE + 0x00018)
+#define ISP_GIC_NOISE_PARA3			(ISP_GIC_BASE + 0x0001c)
+#define ISP_GIC_SIGMA_VALUE0			(ISP_GIC_BASE + 0x00044)
+#define ISP_GIC_SIGMA_VALUE1			(ISP_GIC_BASE + 0x00048)
+#define ISP_GIC_SIGMA_VALUE2			(ISP_GIC_BASE + 0x0004c)
+#define ISP_GIC_SIGMA_VALUE3			(ISP_GIC_BASE + 0x00050)
+#define ISP_GIC_SIGMA_VALUE4			(ISP_GIC_BASE + 0x00054)
+#define ISP_GIC_SIGMA_VALUE5			(ISP_GIC_BASE + 0x00058)
+#define ISP_GIC_SIGMA_VALUE6			(ISP_GIC_BASE + 0x0005c)
+#define ISP_GIC_SIGMA_VALUE7			(ISP_GIC_BASE + 0x00060)
+
+#define ISP_BLS_BASE				0x00003000
+#define ISP_BLS_CTRL				(ISP_BLS_BASE + 0x00000)
+#define ISP_BLS_SAMPLES				(ISP_BLS_BASE + 0x00004)
+#define ISP_BLS_H1_START			(ISP_BLS_BASE + 0x00008)
+#define ISP_BLS_H1_STOP				(ISP_BLS_BASE + 0x0000c)
+#define ISP_BLS_V1_START			(ISP_BLS_BASE + 0x00010)
+#define ISP_BLS_V1_STOP				(ISP_BLS_BASE + 0x00014)
+#define ISP_BLS_H2_START			(ISP_BLS_BASE + 0x00018)
+#define ISP_BLS_H2_STOP				(ISP_BLS_BASE + 0x0001c)
+#define ISP_BLS_V2_START			(ISP_BLS_BASE + 0x00020)
+#define ISP_BLS_V2_STOP				(ISP_BLS_BASE + 0x00024)
+#define ISP_BLS_A_FIXED				(ISP_BLS_BASE + 0x00028)
+#define ISP_BLS_B_FIXED				(ISP_BLS_BASE + 0x0002c)
+#define ISP_BLS_C_FIXED				(ISP_BLS_BASE + 0x00030)
+#define ISP_BLS_D_FIXED				(ISP_BLS_BASE + 0x00034)
+#define ISP_BLS_A_MEASURED			(ISP_BLS_BASE + 0x00038)
+#define ISP_BLS_B_MEASURED			(ISP_BLS_BASE + 0x0003c)
+#define ISP_BLS_C_MEASURED			(ISP_BLS_BASE + 0x00040)
+#define ISP_BLS_D_MEASURED			(ISP_BLS_BASE + 0x00044)
+
+#define ISP_DPCC_BASE				0x00003400
+#define ISP_DPCC_MODE				(ISP_DPCC_BASE + 0x00000)
+#define ISP_DPCC_OUTPUT_MODE			(ISP_DPCC_BASE + 0x00004)
+#define ISP_DPCC_SET_USE			(ISP_DPCC_BASE + 0x00008)
+#define ISP_DPCC_METHODS_SET_1			(ISP_DPCC_BASE + 0x0000c)
+#define ISP_DPCC_METHODS_SET_2			(ISP_DPCC_BASE + 0x00010)
+#define ISP_DPCC_METHODS_SET_3			(ISP_DPCC_BASE + 0x00014)
+#define ISP_DPCC_LINE_THRESH_1			(ISP_DPCC_BASE + 0x00018)
+#define ISP_DPCC_LINE_MAD_FAC_1			(ISP_DPCC_BASE + 0x0001c)
+#define ISP_DPCC_PG_FAC_1			(ISP_DPCC_BASE + 0x00020)
+#define ISP_DPCC_RND_THRESH_1			(ISP_DPCC_BASE + 0x00024)
+#define ISP_DPCC_RG_FAC_1			(ISP_DPCC_BASE + 0x00028)
+#define ISP_DPCC_LINE_THRESH_2			(ISP_DPCC_BASE + 0x0002c)
+#define ISP_DPCC_LINE_MAD_FAC_2			(ISP_DPCC_BASE + 0x00030)
+#define ISP_DPCC_PG_FAC_2			(ISP_DPCC_BASE + 0x00034)
+#define ISP_DPCC_RND_THRESH_2			(ISP_DPCC_BASE + 0x00038)
+#define ISP_DPCC_RG_FAC_2			(ISP_DPCC_BASE + 0x0003c)
+#define ISP_DPCC_LINE_THRESH_3			(ISP_DPCC_BASE + 0x00040)
+#define ISP_DPCC_LINE_MAD_FAC_3			(ISP_DPCC_BASE + 0x00044)
+#define ISP_DPCC_PG_FAC_3			(ISP_DPCC_BASE + 0x00048)
+#define ISP_DPCC_RND_THRESH_3			(ISP_DPCC_BASE + 0x0004c)
+#define ISP_DPCC_RG_FAC_3			(ISP_DPCC_BASE + 0x00050)
+#define ISP_DPCC_RO_LIMITS			(ISP_DPCC_BASE + 0x00054)
+#define ISP_DPCC_RND_OFFS			(ISP_DPCC_BASE + 0x00058)
+#define ISP_DPCC_BPT_CTRL			(ISP_DPCC_BASE + 0x0005c)
+#define ISP_DPCC_BPT_NUMBER			(ISP_DPCC_BASE + 0x00060)
+#define ISP_DPCC_BPT_ADDR			(ISP_DPCC_BASE + 0x00064)
+#define ISP_DPCC_BPT_DATA			(ISP_DPCC_BASE + 0x00068)
+#define ISP_DPCC_BP_CNT				(ISP_DPCC_BASE + 0x0006c)
+#define ISP_DPCC_PDAF_EN			(ISP_DPCC_BASE + 0x00070)
+#define ISP_DPCC_PDAF_POINT_EN			(ISP_DPCC_BASE + 0x00074)
+#define ISP_DPCC_PDAF_OFFSET			(ISP_DPCC_BASE + 0x00078)
+#define ISP_DPCC_PDAF_WRAP			(ISP_DPCC_BASE + 0x0007c)
+#define ISP_DPCC_PDAF_SCOPE			(ISP_DPCC_BASE + 0x00080)
+#define ISP_DPCC_PDAF_POINT_0			(ISP_DPCC_BASE + 0x00084)
+#define ISP_DPCC_PDAF_POINT_1			(ISP_DPCC_BASE + 0x00088)
+#define ISP_DPCC_PDAF_POINT_2			(ISP_DPCC_BASE + 0x0008c)
+#define ISP_DPCC_PDAF_POINT_3			(ISP_DPCC_BASE + 0x00090)
+#define ISP_DPCC_PDAF_POINT_4			(ISP_DPCC_BASE + 0x00094)
+#define ISP_DPCC_PDAF_POINT_5			(ISP_DPCC_BASE + 0x00098)
+#define ISP_DPCC_PDAF_POINT_6			(ISP_DPCC_BASE + 0x0009c)
+#define ISP_DPCC_PDAF_POINT_7			(ISP_DPCC_BASE + 0x000a0)
+#define ISP_DPCC_PDAF_FORWARD_MED		(ISP_DPCC_BASE + 0x000a4)
+
+#define ISP_HDRMGE_BASE				0x00003800
+#define ISP_HDRMGE_CTRL				(ISP_HDRMGE_BASE + 0x00000)
+#define ISP_HDRMGE_GAIN0			(ISP_HDRMGE_BASE + 0x00008)
+#define ISP_HDRMGE_GAIN1			(ISP_HDRMGE_BASE + 0x0000c)
+#define ISP_HDRMGE_GAIN2			(ISP_HDRMGE_BASE + 0x00010)
+#define ISP_HDRMGE_CONS_DIFF			(ISP_HDRMGE_BASE + 0x00014)
+#define ISP_HDRMGE_DIFF_Y0			(ISP_HDRMGE_BASE + 0x00020)
+#define ISP_HDRMGE_DIFF_Y1			(ISP_HDRMGE_BASE + 0x00024)
+#define ISP_HDRMGE_DIFF_Y2			(ISP_HDRMGE_BASE + 0x00028)
+#define ISP_HDRMGE_DIFF_Y3			(ISP_HDRMGE_BASE + 0x0002c)
+#define ISP_HDRMGE_DIFF_Y4			(ISP_HDRMGE_BASE + 0x00030)
+#define ISP_HDRMGE_DIFF_Y5			(ISP_HDRMGE_BASE + 0x00034)
+#define ISP_HDRMGE_DIFF_Y6			(ISP_HDRMGE_BASE + 0x00038)
+#define ISP_HDRMGE_DIFF_Y7			(ISP_HDRMGE_BASE + 0x0003c)
+#define ISP_HDRMGE_DIFF_Y8			(ISP_HDRMGE_BASE + 0x00040)
+#define ISP_HDRMGE_DIFF_Y9			(ISP_HDRMGE_BASE + 0x00044)
+#define ISP_HDRMGE_DIFF_Y10			(ISP_HDRMGE_BASE + 0x00048)
+#define ISP_HDRMGE_DIFF_Y11			(ISP_HDRMGE_BASE + 0x0004c)
+#define ISP_HDRMGE_DIFF_Y12			(ISP_HDRMGE_BASE + 0x00050)
+#define ISP_HDRMGE_DIFF_Y13			(ISP_HDRMGE_BASE + 0x00054)
+#define ISP_HDRMGE_DIFF_Y14			(ISP_HDRMGE_BASE + 0x00058)
+#define ISP_HDRMGE_DIFF_Y15			(ISP_HDRMGE_BASE + 0x0005c)
+#define ISP_HDRMGE_DIFF_Y16			(ISP_HDRMGE_BASE + 0x00060)
+#define ISP_HDRMGE_OVER_Y0			(ISP_HDRMGE_BASE + 0x00070)
+#define ISP_HDRMGE_OVER_Y1			(ISP_HDRMGE_BASE + 0x00074)
+#define ISP_HDRMGE_OVER_Y2			(ISP_HDRMGE_BASE + 0x00078)
+#define ISP_HDRMGE_OVER_Y3			(ISP_HDRMGE_BASE + 0x0007c)
+#define ISP_HDRMGE_OVER_Y4			(ISP_HDRMGE_BASE + 0x00080)
+#define ISP_HDRMGE_OVER_Y5			(ISP_HDRMGE_BASE + 0x00084)
+#define ISP_HDRMGE_OVER_Y6			(ISP_HDRMGE_BASE + 0x00088)
+#define ISP_HDRMGE_OVER_Y7			(ISP_HDRMGE_BASE + 0x0008c)
+#define ISP_HDRMGE_OVER_Y8			(ISP_HDRMGE_BASE + 0x00090)
+#define ISP_HDRMGE_OVER_Y9			(ISP_HDRMGE_BASE + 0x00094)
+#define ISP_HDRMGE_OVER_Y10			(ISP_HDRMGE_BASE + 0x00098)
+#define ISP_HDRMGE_OVER_Y11			(ISP_HDRMGE_BASE + 0x0009c)
+#define ISP_HDRMGE_OVER_Y12			(ISP_HDRMGE_BASE + 0x000a0)
+#define ISP_HDRMGE_OVER_Y13			(ISP_HDRMGE_BASE + 0x000a4)
+#define ISP_HDRMGE_OVER_Y14			(ISP_HDRMGE_BASE + 0x000a8)
+#define ISP_HDRMGE_OVER_Y15			(ISP_HDRMGE_BASE + 0x000ac)
+#define ISP_HDRMGE_OVER_Y16			(ISP_HDRMGE_BASE + 0x000b0)
+
+#define ISP_HDRTMO_BASE				0x00003900
+#define ISP_HDRTMO_CTRL				(ISP_HDRTMO_BASE + 0x00000)
+#define ISP_HDRTMO_CTRL_CFG			(ISP_HDRTMO_BASE + 0x00004)
+#define ISP_HDRTMO_LG_CFG0			(ISP_HDRTMO_BASE + 0x00008)
+#define ISP_HDRTMO_LG_CFG1			(ISP_HDRTMO_BASE + 0x0000c)
+#define ISP_HDRTMO_LG_CFG2			(ISP_HDRTMO_BASE + 0x00010)
+#define ISP_HDRTMO_LG_CFG3			(ISP_HDRTMO_BASE + 0x00014)
+#define ISP_HDRTMO_LG_CFG4			(ISP_HDRTMO_BASE + 0x00018)
+#define ISP_HDRTMO_CLIPRATIO			(ISP_HDRTMO_BASE + 0x00020)
+#define ISP_HDRTMO_LG_SCL			(ISP_HDRTMO_BASE + 0x00024)
+#define ISP_HDRTMO_LG_MAX			(ISP_HDRTMO_BASE + 0x00028)
+#define ISP_HDRTMO_HIST_LOW			(ISP_HDRTMO_BASE + 0x0002c)
+#define ISP_HDRTMO_HIST_HIGH			(ISP_HDRTMO_BASE + 0x00030)
+#define ISP_HDRTMO_PALPHA			(ISP_HDRTMO_BASE + 0x00034)
+#define ISP_HDRTMO_MAXGAIN			(ISP_HDRTMO_BASE + 0x00038)
+#define ISP_HDRTMO_LG_RO0			(ISP_HDRTMO_BASE + 0x00040)
+#define ISP_HDRTMO_LG_RO1			(ISP_HDRTMO_BASE + 0x00044)
+#define ISP_HDRTMO_LG_RO2			(ISP_HDRTMO_BASE + 0x00048)
+#define ISP_HDRTMO_LG_RO3			(ISP_HDRTMO_BASE + 0x0004c)
+#define ISP_HDRTMO_LG_RO4			(ISP_HDRTMO_BASE + 0x00050)
+#define ISP_HDRTMO_LG_RO5			(ISP_HDRTMO_BASE + 0x00054)
+#define ISP_HDRTMO_HIST_RO0			(ISP_HDRTMO_BASE + 0x00060)
+#define ISP_HDRTMO_HIST_RO1			(ISP_HDRTMO_BASE + 0x00064)
+#define ISP_HDRTMO_HIST_RO2			(ISP_HDRTMO_BASE + 0x00068)
+#define ISP_HDRTMO_HIST_RO3			(ISP_HDRTMO_BASE + 0x0006c)
+#define ISP_HDRTMO_HIST_RO4			(ISP_HDRTMO_BASE + 0x00070)
+#define ISP_HDRTMO_HIST_RO5			(ISP_HDRTMO_BASE + 0x00074)
+#define ISP_HDRTMO_HIST_RO6			(ISP_HDRTMO_BASE + 0x00078)
+#define ISP_HDRTMO_HIST_RO7			(ISP_HDRTMO_BASE + 0x0007c)
+#define ISP_HDRTMO_HIST_RO8			(ISP_HDRTMO_BASE + 0x00080)
+#define ISP_HDRTMO_HIST_RO9			(ISP_HDRTMO_BASE + 0x00084)
+#define ISP_HDRTMO_HIST_RO10			(ISP_HDRTMO_BASE + 0x00088)
+#define ISP_HDRTMO_HIST_RO11			(ISP_HDRTMO_BASE + 0x0008c)
+#define ISP_HDRTMO_HIST_RO12			(ISP_HDRTMO_BASE + 0x00090)
+#define ISP_HDRTMO_HIST_RO13			(ISP_HDRTMO_BASE + 0x00094)
+#define ISP_HDRTMO_HIST_RO14			(ISP_HDRTMO_BASE + 0x00098)
+#define ISP_HDRTMO_HIST_RO15			(ISP_HDRTMO_BASE + 0x0009c)
+#define ISP_HDRTMO_HIST_RO16			(ISP_HDRTMO_BASE + 0x000a0)
+#define ISP_HDRTMO_HIST_RO17			(ISP_HDRTMO_BASE + 0x000a4)
+#define ISP_HDRTMO_HIST_RO18			(ISP_HDRTMO_BASE + 0x000a8)
+#define ISP_HDRTMO_HIST_RO19			(ISP_HDRTMO_BASE + 0x000ac)
+#define ISP_HDRTMO_HIST_RO20			(ISP_HDRTMO_BASE + 0x000b0)
+#define ISP_HDRTMO_HIST_RO21			(ISP_HDRTMO_BASE + 0x000b4)
+#define ISP_HDRTMO_HIST_RO22			(ISP_HDRTMO_BASE + 0x000b8)
+#define ISP_HDRTMO_HIST_RO23			(ISP_HDRTMO_BASE + 0x000bc)
+#define ISP_HDRTMO_HIST_RO24			(ISP_HDRTMO_BASE + 0x000c0)
+#define ISP_HDRTMO_HIST_RO25			(ISP_HDRTMO_BASE + 0x000c4)
+#define ISP_HDRTMO_HIST_RO26			(ISP_HDRTMO_BASE + 0x000c8)
+#define ISP_HDRTMO_HIST_RO27			(ISP_HDRTMO_BASE + 0x000cc)
+#define ISP_HDRTMO_HIST_RO28			(ISP_HDRTMO_BASE + 0x000d0)
+#define ISP_HDRTMO_HIST_RO29			(ISP_HDRTMO_BASE + 0x000d4)
+#define ISP_HDRTMO_HIST_RO30			(ISP_HDRTMO_BASE + 0x000d8)
+#define ISP_HDRTMO_HIST_RO31			(ISP_HDRTMO_BASE + 0x000dc)
+
+#define ISP_RAWNR_BASE				0x00003A00
+#define ISP_RAWNR_STS				(ISP_RAWNR_BASE + 0x00004)
+#define ISP_RAWNR_FILTPAR0			(ISP_RAWNR_BASE + 0x00008)
+#define ISP_RAWNR_FILTPAR1			(ISP_RAWNR_BASE + 0x0000c)
+#define ISP_RAWNR_FILTPAR2			(ISP_RAWNR_BASE + 0x00010)
+#define ISP_RAWNR_DGAIN0			(ISP_RAWNR_BASE + 0x00014)
+#define ISP_RAWNR_DGAIN1			(ISP_RAWNR_BASE + 0x00018)
+#define ISP_RAWNR_DGAIN2			(ISP_RAWNR_BASE + 0x0001c)
+#define ISP_RAWNR_LURTION0_1			(ISP_RAWNR_BASE + 0x00020)
+#define ISP_RAWNR_LURTION3_2			(ISP_RAWNR_BASE + 0x00024)
+#define ISP_RAWNR_LURTION5_4			(ISP_RAWNR_BASE + 0x00028)
+#define ISP_RAWNR_LURTION6_7			(ISP_RAWNR_BASE + 0x0002c)
+#define ISP_RAWNR_LULEVEL0_1			(ISP_RAWNR_BASE + 0x00030)
+#define ISP_RAWNR_LULEVEL2_3			(ISP_RAWNR_BASE + 0x00034)
+#define ISP_RAWNR_LULEVEL4_5			(ISP_RAWNR_BASE + 0x00038)
+#define ISP_RAWNR_LULEVEL6_7			(ISP_RAWNR_BASE + 0x0003c)
+#define ISP_RAWNR_GAUSS				(ISP_RAWNR_BASE + 0x00040)
+#define ISP_RAWNR_SIGMA				(ISP_RAWNR_BASE + 0x00044)
+#define ISP_RAWNR_PIX_DIFF			(ISP_RAWNR_BASE + 0x00048)
+#define ISP_RAWNR_HILD_DIFF			(ISP_RAWNR_BASE + 0x0004c)
+#define ISP_RAWNR_THLD_CHANELW			(ISP_RAWNR_BASE + 0x00050)
+#define ISP_RAWNR_LAMDA				(ISP_RAWNR_BASE + 0x00054)
+#define ISP_RAWNR_FIXW0_1			(ISP_RAWNR_BASE + 0x00058)
+#define ISP_RAWNR_FIXW2_3			(ISP_RAWNR_BASE + 0x0005c)
+#define ISP_RAWNR_WLAMDA0			(ISP_RAWNR_BASE + 0x00060)
+#define ISP_RAWNR_WLAMDA1			(ISP_RAWNR_BASE + 0x00064)
+#define ISP_RAWNR_WLAMDA2			(ISP_RAWNR_BASE + 0x00068)
+#define ISP_RAWNR_RGBAIN_FLIP			(ISP_RAWNR_BASE + 0x0006c)
+
+#define ISP_LDCH_BASE				0x00003B00
+#define ISP_LDCH_STS				(ISP_LDCH_BASE + 0x00000)
+
+#define ISP_DHAZ_BASE				0x00003C00
+#define ISP_DHAZ_CTRL				(ISP_DHAZ_BASE + 0x00000)
+#define ISP_DHAZ_ADP0				(ISP_DHAZ_BASE + 0x00004)
+#define ISP_DHAZ_ADP1				(ISP_DHAZ_BASE + 0x00008)
+#define ISP_DHAZ_ADP2				(ISP_DHAZ_BASE + 0x0000c)
+#define ISP_DHAZ_ADP_TMAX			(ISP_DHAZ_BASE + 0x00010)
+#define ISP_DHAZ_ADP_HIST0			(ISP_DHAZ_BASE + 0x00014)
+#define ISP_DHAZ_ADP_HIST1			(ISP_DHAZ_BASE + 0x00018)
+#define ISP_DHAZ_HIST_ENH			(ISP_DHAZ_BASE + 0x0001c)
+#define ISP_DHAZ_IIR0				(ISP_DHAZ_BASE + 0x00020)
+#define ISP_DHAZ_IIR1				(ISP_DHAZ_BASE + 0x00024)
+#define ISP_DHAZ_ALPHA0				(ISP_DHAZ_BASE + 0x00028)
+#define ISP_DHAZ_ALPHA1				(ISP_DHAZ_BASE + 0x0002c)
+#define ISP_DHAZ_BI_DC				(ISP_DHAZ_BASE + 0x00030)
+#define ISP_DHAZ_DC_BF0				(ISP_DHAZ_BASE + 0x00034)
+#define ISP_DHAZ_DC_BF1				(ISP_DHAZ_BASE + 0x00038)
+#define ISP_DHAZ_BI_AIR				(ISP_DHAZ_BASE + 0x0003c)
+#define ISP_DHAZ_AIR_BF				(ISP_DHAZ_BASE + 0x00040)
+#define ISP_DHAZ_GAUS				(ISP_DHAZ_BASE + 0x00044)
+#define ISP_DHAZ_HIST_CONV0			(ISP_DHAZ_BASE + 0x00048)
+#define ISP_DHAZ_HIST_CONV1			(ISP_DHAZ_BASE + 0x0004c)
+#define ISP_DHAZ_HIST_CONV2			(ISP_DHAZ_BASE + 0x00050)
+#define ISP_DHAZ_CTRL_SHD			(ISP_DHAZ_BASE + 0x00060)
+#define ISP_DHAZ_ADP_RD0			(ISP_DHAZ_BASE + 0x00064)
+#define ISP_DHAZ_ADP_RD1			(ISP_DHAZ_BASE + 0x00068)
+#define ISP_DHAZ_HIST_REG0			(ISP_DHAZ_BASE + 0x00070)
+#define ISP_DHAZ_HIST_REG1			(ISP_DHAZ_BASE + 0x00074)
+#define ISP_DHAZ_HIST_REG2			(ISP_DHAZ_BASE + 0x00078)
+#define ISP_DHAZ_HIST_REG3			(ISP_DHAZ_BASE + 0x0007c)
+#define ISP_DHAZ_HIST_REG4			(ISP_DHAZ_BASE + 0x00080)
+#define ISP_DHAZ_HIST_REG5			(ISP_DHAZ_BASE + 0x00084)
+#define ISP_DHAZ_HIST_REG6			(ISP_DHAZ_BASE + 0x00088)
+#define ISP_DHAZ_HIST_REG7			(ISP_DHAZ_BASE + 0x0008c)
+#define ISP_DHAZ_HIST_REG8			(ISP_DHAZ_BASE + 0x00090)
+#define ISP_DHAZ_HIST_REG9			(ISP_DHAZ_BASE + 0x00094)
+#define ISP_DHAZ_HIST_REG10			(ISP_DHAZ_BASE + 0x00098)
+#define ISP_DHAZ_HIST_REG11			(ISP_DHAZ_BASE + 0x0009c)
+#define ISP_DHAZ_HIST_REG12			(ISP_DHAZ_BASE + 0x000a0)
+#define ISP_DHAZ_HIST_REG13			(ISP_DHAZ_BASE + 0x000a4)
+#define ISP_DHAZ_HIST_REG14			(ISP_DHAZ_BASE + 0x000a8)
+#define ISP_DHAZ_HIST_REG15			(ISP_DHAZ_BASE + 0x000ac)
+#define ISP_DHAZ_HIST_REG16			(ISP_DHAZ_BASE + 0x000b0)
+#define ISP_DHAZ_HIST_REG17			(ISP_DHAZ_BASE + 0x000b4)
+#define ISP_DHAZ_HIST_REG18			(ISP_DHAZ_BASE + 0x000b8)
+#define ISP_DHAZ_HIST_REG19			(ISP_DHAZ_BASE + 0x000bc)
+#define ISP_DHAZ_HIST_REG20			(ISP_DHAZ_BASE + 0x000c0)
+#define ISP_DHAZ_HIST_REG21			(ISP_DHAZ_BASE + 0x000c4)
+#define ISP_DHAZ_HIST_REG22			(ISP_DHAZ_BASE + 0x000c8)
+#define ISP_DHAZ_HIST_REG23			(ISP_DHAZ_BASE + 0x000cc)
+#define ISP_DHAZ_HIST_REG24			(ISP_DHAZ_BASE + 0x000d0)
+#define ISP_DHAZ_HIST_REG25			(ISP_DHAZ_BASE + 0x000d4)
+#define ISP_DHAZ_HIST_REG26			(ISP_DHAZ_BASE + 0x000d8)
+#define ISP_DHAZ_HIST_REG27			(ISP_DHAZ_BASE + 0x000dc)
+#define ISP_DHAZ_HIST_REG28			(ISP_DHAZ_BASE + 0x000e0)
+#define ISP_DHAZ_HIST_REG29			(ISP_DHAZ_BASE + 0x000e4)
+#define ISP_DHAZ_HIST_REG30			(ISP_DHAZ_BASE + 0x000e8)
+#define ISP_DHAZ_HIST_REG31			(ISP_DHAZ_BASE + 0x000ec)
+#define ISP_DHAZ_HIST_REG32			(ISP_DHAZ_BASE + 0x000f0)
+#define ISP_DHAZ_HIST_REG33			(ISP_DHAZ_BASE + 0x000f4)
+#define ISP_DHAZ_HIST_REG34			(ISP_DHAZ_BASE + 0x000f8)
+#define ISP_DHAZ_HIST_REG35			(ISP_DHAZ_BASE + 0x000fc)
+#define ISP_DHAZ_HIST_REG36			(ISP_DHAZ_BASE + 0x00100)
+#define ISP_DHAZ_HIST_REG37			(ISP_DHAZ_BASE + 0x00104)
+#define ISP_DHAZ_HIST_REG38			(ISP_DHAZ_BASE + 0x00108)
+#define ISP_DHAZ_HIST_REG39			(ISP_DHAZ_BASE + 0x0010c)
+#define ISP_DHAZ_HIST_REG40			(ISP_DHAZ_BASE + 0x00110)
+#define ISP_DHAZ_HIST_REG41			(ISP_DHAZ_BASE + 0x00114)
+#define ISP_DHAZ_HIST_REG42			(ISP_DHAZ_BASE + 0x00118)
+#define ISP_DHAZ_HIST_REG43			(ISP_DHAZ_BASE + 0x0011c)
+#define ISP_DHAZ_HIST_REG44			(ISP_DHAZ_BASE + 0x00120)
+#define ISP_DHAZ_HIST_REG45			(ISP_DHAZ_BASE + 0x00124)
+#define ISP_DHAZ_HIST_REG46			(ISP_DHAZ_BASE + 0x00128)
+#define ISP_DHAZ_HIST_REG47			(ISP_DHAZ_BASE + 0x0012c)
+#define ISP_DHAZ_HIST_REG48			(ISP_DHAZ_BASE + 0x00130)
+#define ISP_DHAZ_HIST_REG49			(ISP_DHAZ_BASE + 0x00134)
+#define ISP_DHAZ_HIST_REG50			(ISP_DHAZ_BASE + 0x00138)
+#define ISP_DHAZ_HIST_REG51			(ISP_DHAZ_BASE + 0x0013c)
+#define ISP_DHAZ_HIST_REG52			(ISP_DHAZ_BASE + 0x00140)
+#define ISP_DHAZ_HIST_REG53			(ISP_DHAZ_BASE + 0x00144)
+#define ISP_DHAZ_HIST_REG54			(ISP_DHAZ_BASE + 0x00148)
+#define ISP_DHAZ_HIST_REG55			(ISP_DHAZ_BASE + 0x0014c)
+#define ISP_DHAZ_HIST_REG56			(ISP_DHAZ_BASE + 0x00150)
+#define ISP_DHAZ_HIST_REG57			(ISP_DHAZ_BASE + 0x00154)
+#define ISP_DHAZ_HIST_REG58			(ISP_DHAZ_BASE + 0x00158)
+#define ISP_DHAZ_HIST_REG59			(ISP_DHAZ_BASE + 0x0015c)
+#define ISP_DHAZ_HIST_REG60			(ISP_DHAZ_BASE + 0x00160)
+#define ISP_DHAZ_HIST_REG61			(ISP_DHAZ_BASE + 0x00164)
+#define ISP_DHAZ_HIST_REG62			(ISP_DHAZ_BASE + 0x00168)
+#define ISP_DHAZ_HIST_REG63			(ISP_DHAZ_BASE + 0x0016c)
+#define ISP_DHAZ_HIST_REG64			(ISP_DHAZ_BASE + 0x00170)
+#define ISP_DHAZ_HIST_REG65			(ISP_DHAZ_BASE + 0x00174)
+#define ISP_DHAZ_HIST_REG66			(ISP_DHAZ_BASE + 0x00178)
+#define ISP_DHAZ_HIST_REG67			(ISP_DHAZ_BASE + 0x0017c)
+#define ISP_DHAZ_HIST_REG68			(ISP_DHAZ_BASE + 0x00180)
+#define ISP_DHAZ_HIST_REG69			(ISP_DHAZ_BASE + 0x00184)
+#define ISP_DHAZ_HIST_REG70			(ISP_DHAZ_BASE + 0x00188)
+#define ISP_DHAZ_HIST_REG71			(ISP_DHAZ_BASE + 0x0018c)
+#define ISP_DHAZ_HIST_REG72			(ISP_DHAZ_BASE + 0x00190)
+#define ISP_DHAZ_HIST_REG73			(ISP_DHAZ_BASE + 0x00194)
+#define ISP_DHAZ_HIST_REG74			(ISP_DHAZ_BASE + 0x00198)
+#define ISP_DHAZ_HIST_REG75			(ISP_DHAZ_BASE + 0x0019c)
+#define ISP_DHAZ_HIST_REG76			(ISP_DHAZ_BASE + 0x001a0)
+#define ISP_DHAZ_HIST_REG77			(ISP_DHAZ_BASE + 0x001a4)
+#define ISP_DHAZ_HIST_REG78			(ISP_DHAZ_BASE + 0x001a8)
+#define ISP_DHAZ_HIST_REG79			(ISP_DHAZ_BASE + 0x001ac)
+#define ISP_DHAZ_HIST_REG80			(ISP_DHAZ_BASE + 0x001b0)
+#define ISP_DHAZ_HIST_REG81			(ISP_DHAZ_BASE + 0x001b4)
+#define ISP_DHAZ_HIST_REG82			(ISP_DHAZ_BASE + 0x001b8)
+#define ISP_DHAZ_HIST_REG83			(ISP_DHAZ_BASE + 0x001bc)
+#define ISP_DHAZ_HIST_REG84			(ISP_DHAZ_BASE + 0x001c0)
+#define ISP_DHAZ_HIST_REG85			(ISP_DHAZ_BASE + 0x001c4)
+#define ISP_DHAZ_HIST_REG86			(ISP_DHAZ_BASE + 0x001c8)
+#define ISP_DHAZ_HIST_REG87			(ISP_DHAZ_BASE + 0x001cc)
+#define ISP_DHAZ_HIST_REG88			(ISP_DHAZ_BASE + 0x001d0)
+#define ISP_DHAZ_HIST_REG89			(ISP_DHAZ_BASE + 0x001d4)
+#define ISP_DHAZ_HIST_REG90			(ISP_DHAZ_BASE + 0x001d8)
+#define ISP_DHAZ_HIST_REG91			(ISP_DHAZ_BASE + 0x001dc)
+#define ISP_DHAZ_HIST_REG92			(ISP_DHAZ_BASE + 0x001e0)
+#define ISP_DHAZ_HIST_REG93			(ISP_DHAZ_BASE + 0x001e4)
+#define ISP_DHAZ_HIST_REG94			(ISP_DHAZ_BASE + 0x001e8)
+#define ISP_DHAZ_HIST_REG95			(ISP_DHAZ_BASE + 0x001ec)
+
+#define ISP_3DLUT_BASE				0x00003D00
+#define ISP_3DLUT_CTRL				(ISP_3DLUT_BASE + 0x00000)
+#define ISP_3DLUT_UPDATE			(ISP_3DLUT_BASE + 0x00004)
+
+#define ISP_GAIN_BASE				0x00003F00
+#define ISP_GAIN_CTRL				(ISP_GAIN_BASE + 0x00000)
+#define ISP_GAIN_G0				(ISP_GAIN_BASE + 0x00004)
+#define ISP_GAIN_G1_G2				(ISP_GAIN_BASE + 0x00008)
+#define ISP_GAIN_IDX0				(ISP_GAIN_BASE + 0x0000c)
+#define ISP_GAIN_IDX1				(ISP_GAIN_BASE + 0x00010)
+#define ISP_GAIN_IDX2				(ISP_GAIN_BASE + 0x00014)
+#define ISP_GAIN_IDX3				(ISP_GAIN_BASE + 0x00018)
+#define ISP_GAIN_LUT0				(ISP_GAIN_BASE + 0x0001c)
+#define ISP_GAIN_LUT1				(ISP_GAIN_BASE + 0x00020)
+#define ISP_GAIN_LUT2				(ISP_GAIN_BASE + 0x00024)
+#define ISP_GAIN_LUT3				(ISP_GAIN_BASE + 0x00028)
+#define ISP_GAIN_LUT4				(ISP_GAIN_BASE + 0x0002c)
+#define ISP_GAIN_LUT5				(ISP_GAIN_BASE + 0x00030)
+#define ISP_GAIN_LUT6				(ISP_GAIN_BASE + 0x00034)
+#define ISP_GAIN_LUT7				(ISP_GAIN_BASE + 0x00038)
+#define ISP_GAIN_LUT8				(ISP_GAIN_BASE + 0x0003c)
+
+#define ISP_AFM_BASE				0x00004100
+#define ISP_AFM_CTRL				(ISP_AFM_BASE + 0x00000)
+#define ISP_AFM_LT_A				(ISP_AFM_BASE + 0x00004)
+#define ISP_AFM_RB_A				(ISP_AFM_BASE + 0x00008)
+#define ISP_AFM_LT_B				(ISP_AFM_BASE + 0x0000c)
+#define ISP_AFM_RB_B				(ISP_AFM_BASE + 0x00010)
+#define ISP_AFM_LT_C				(ISP_AFM_BASE + 0x00014)
+#define ISP_AFM_RB_C				(ISP_AFM_BASE + 0x00018)
+#define ISP_AFM_THRES				(ISP_AFM_BASE + 0x0001c)
+#define ISP_AFM_VAR_SHIFT			(ISP_AFM_BASE + 0x00020)
+#define ISP_AFM_SUM_A				(ISP_AFM_BASE + 0x00024)
+#define ISP_AFM_SUM_B				(ISP_AFM_BASE + 0x00028)
+#define ISP_AFM_SUM_C				(ISP_AFM_BASE + 0x0002c)
+#define ISP_AFM_LUM_A				(ISP_AFM_BASE + 0x00030)
+#define ISP_AFM_LUM_B				(ISP_AFM_BASE + 0x00034)
+#define ISP_AFM_LUM_C				(ISP_AFM_BASE + 0x00038)
+
+#define ISP_HIST_BASE				0x00004200
+#define ISP_HIST_HIST_CTRL			(ISP_HIST_BASE + 0x00000)
+#define ISP_HIST_HIST_SIZE			(ISP_HIST_BASE + 0x00004)
+#define ISP_HIST_HIST_OFFS			(ISP_HIST_BASE + 0x00008)
+#define ISP_HIST_HIST_DBG1			(ISP_HIST_BASE + 0x0000c)
+#define ISP_HIST_HIST1_CTRL			(ISP_HIST_BASE + 0x00010)
+#define ISP_HIST_HIST1_SIZE			(ISP_HIST_BASE + 0x00014)
+#define ISP_HIST_HIST1_OFFS			(ISP_HIST_BASE + 0x00018)
+#define ISP_HIST_HIST_DBG2			(ISP_HIST_BASE + 0x0001c)
+#define ISP_HIST_HIST2_CTRL			(ISP_HIST_BASE + 0x00020)
+#define ISP_HIST_HIST2_SIZE			(ISP_HIST_BASE + 0x00024)
+#define ISP_HIST_HIST2_OFFS			(ISP_HIST_BASE + 0x00028)
+#define ISP_HIST_HIST_DBG3			(ISP_HIST_BASE + 0x0002c)
+#define ISP_HIST_HIST3_CTRL			(ISP_HIST_BASE + 0x00030)
+#define ISP_HIST_HIST3_SIZE			(ISP_HIST_BASE + 0x00034)
+#define ISP_HIST_HIST3_OFFS			(ISP_HIST_BASE + 0x00038)
+#define ISP_HIST_HIST_WEIGHT_0			(ISP_HIST_BASE + 0x0003c)
+#define ISP_HIST_HIST_BIN			(ISP_HIST_BASE + 0x00120)
+#define ISP_HIST_HIST1_BIN			(ISP_HIST_BASE + 0x00160)
+#define ISP_HIST_HIST2_BIN			(ISP_HIST_BASE + 0x001a0)
+#define ISP_HIST_HIST3_BIN			(ISP_HIST_BASE + 0x001e0)
+#define ISP_HIST_HIST1_DBG1			(ISP_HIST_BASE + 0x00220)
+#define ISP_HIST_HIST1_DBG2			(ISP_HIST_BASE + 0x00224)
+#define ISP_HIST_HIST2_DBG1			(ISP_HIST_BASE + 0x00228)
+#define ISP_HIST_HIST2_DBG2			(ISP_HIST_BASE + 0x0022c)
+#define ISP_HIST_HIST3_DBG1			(ISP_HIST_BASE + 0x00230)
+#define ISP_HIST_HIST3_DBG2			(ISP_HIST_BASE + 0x00234)
+
+#define RAWAE_BIG1_BASE				0x00004400
+#define RAWAE_BIG2_BASE				0x00004600
+#define RAWAE_BIG3_BASE				0x00004700
+#define RAWAE_BIG_CTRL				(0x00000)
+#define RAWAE_BIG_BLK_SIZE			(0x00004)
+#define RAWAE_BIG_OFFSET			(0x00008)
+#define RAWAE_BIG_RAM_CTRL			(0x0000c)
+#define RAWAE_BIG_WND1_SIZE			(0x00010)
+#define RAWAE_BIG_WND1_OFFSET			(0x00014)
+#define RAWAE_BIG_WND2_SIZE			(0x00018)
+#define RAWAE_BIG_WND2_OFFSET			(0x0001c)
+#define RAWAE_BIG_WND3_SIZE			(0x00020)
+#define RAWAE_BIG_WND3_OFFSET			(0x00024)
+#define RAWAE_BIG_WND4_SIZE			(0x00028)
+#define RAWAE_BIG_WND4_OFFSET			(0x0002c)
+#define RAWAE_BIG_WND1_SUMR			(0x00030)
+#define RAWAE_BIG_WND2_SUMR			(0x00034)
+#define RAWAE_BIG_WND3_SUMR			(0x00038)
+#define RAWAE_BIG_WND4_SUMR			(0x0003c)
+#define RAWAE_BIG_WND1_SUMG			(0x00040)
+#define RAWAE_BIG_WND2_SUMG			(0x00044)
+#define RAWAE_BIG_WND3_SUMG			(0x00048)
+#define RAWAE_BIG_WND4_SUMG			(0x0004c)
+#define RAWAE_BIG_WND1_SUMB			(0x00050)
+#define RAWAE_BIG_WND2_SUMB			(0x00054)
+#define RAWAE_BIG_WND3_SUMB			(0x00058)
+#define RAWAE_BIG_WND4_SUMB			(0x0005c)
+#define RAWAE_BIG_RO_DBG1			(0x00060)
+#define RAWAE_BIG_RO_DBG2			(0x00064)
+#define RAWAE_BIG_RO_DBG3			(0x00068)
+#define RAWAE_BIG_RO_MEAN_BASE_ADDR		(0x00080)
+
+#define ISP_RAWAE_LITE_BASE			0x00004500
+#define ISP_RAWAE_LITE_CTRL			(ISP_RAWAE_LITE_BASE + 0x00000)
+#define ISP_RAWAE_LITE_BLK_SIZ			(ISP_RAWAE_LITE_BASE + 0x00004)
+#define ISP_RAWAE_LITE_OFFSET			(ISP_RAWAE_LITE_BASE + 0x00008)
+#define ISP_RAWAE_LITE_R2Y_CC			(ISP_RAWAE_LITE_BASE + 0x0000c)
+#define ISP_RAWAE_LITE_RO_MEAN			(ISP_RAWAE_LITE_BASE + 0x00010)
+#define ISP_RAWAE_LITE_RO_DBG1			(ISP_RAWAE_LITE_BASE + 0x00074)
+#define ISP_RAWAE_LITE_RO_DBG2			(ISP_RAWAE_LITE_BASE + 0x00078)
+
+#define ISP_RAWHIST_LITE_BASE			0x00004900
+#define ISP_RAWHIST_LITE_CTRL			(ISP_RAWHIST_LITE_BASE + 0x00000)
+#define ISP_RAWHIST_LITE_SIZE			(ISP_RAWHIST_LITE_BASE + 0x00004)
+#define ISP_RAWHIST_LITE_OFFS			(ISP_RAWHIST_LITE_BASE + 0x00008)
+#define ISP_RAWHIST_LITE_RAM_CTRL		(ISP_RAWHIST_LITE_BASE + 0x0000c)
+#define ISP_RAWHIST_LITE_RAW2Y_CC		(ISP_RAWHIST_LITE_BASE + 0x00010)
+#define ISP_RAWHIST_LITE_DBG1			(ISP_RAWHIST_LITE_BASE + 0x00020)
+#define ISP_RAWHIST_LITE_DBG2			(ISP_RAWHIST_LITE_BASE + 0x00024)
+#define ISP_RAWHIST_LITE_DBG3			(ISP_RAWHIST_LITE_BASE + 0x00028)
+#define ISP_RAWHIST_LITE_WEIGHT			(ISP_RAWHIST_LITE_BASE + 0x00040)
+#define ISP_RAWHIST_LITE_RO_BASE_BIN		(ISP_RAWHIST_LITE_BASE + 0x00080)
+
+#define ISP_RAWHIST_BIG1_BASE			0x00004800
+#define ISP_RAWHIST_BIG2_BASE			0x00004A00
+#define ISP_RAWHIST_BIG3_BASE			0x00004B00
+#define ISP_RAWHIST_BIG_CTRL			(0x00000)
+#define ISP_RAWHIST_BIG_SIZE			(0x00004)
+#define ISP_RAWHIST_BIG_OFFS			(0x00008)
+#define ISP_RAWHIST_BIG_HRAM_CTRL		(0x0000c)
+#define ISP_RAWHIST_BIG_RAW2Y_CC		(0x00010)
+#define ISP_RAWHIST_BIG_WRAM_CTRL		(0x00014)
+#define ISP_RAWHIST_BIG_DBG1			(0x00020)
+#define ISP_RAWHIST_BIG_DBG2			(0x00024)
+#define ISP_RAWHIST_BIG_DBG3			(0x00028)
+#define ISP_RAWHIST_BIG_WEIGHT_BASE		(0x00040)
+#define ISP_RAWHIST_BIG_RO_BASE_BIN		(0x00080)
+
+#define ISP_YUVAE_BASE				0x00004C00
+#define ISP_YUVAE_CTRL				(ISP_YUVAE_BASE + 0x00000)
+#define ISP_YUVAE_BLK_SIZE			(ISP_YUVAE_BASE + 0x00004)
+#define ISP_YUVAE_OFFSET			(ISP_YUVAE_BASE + 0x00008)
+#define ISP_YUVAE_RAM_CTRL			(ISP_YUVAE_BASE + 0x0000c)
+#define ISP_YUVAE_WND1_SIZE			(ISP_YUVAE_BASE + 0x00010)
+#define ISP_YUVAE_WND1_OFFSET			(ISP_YUVAE_BASE + 0x00014)
+#define ISP_YUVAE_WND2_SIZE			(ISP_YUVAE_BASE + 0x00018)
+#define ISP_YUVAE_WND2_OFFSET			(ISP_YUVAE_BASE + 0x0001c)
+#define ISP_YUVAE_WND3_SIZE			(ISP_YUVAE_BASE + 0x00020)
+#define ISP_YUVAE_WND3_OFFSET			(ISP_YUVAE_BASE + 0x00024)
+#define ISP_YUVAE_WND4_SIZE			(ISP_YUVAE_BASE + 0x00028)
+#define ISP_YUVAE_WND4_OFFSET			(ISP_YUVAE_BASE + 0x0002c)
+#define ISP_YUVAE_WND1_SUMY			(ISP_YUVAE_BASE + 0x00030)
+#define ISP_YUVAE_WND2_SUMY			(ISP_YUVAE_BASE + 0x00034)
+#define ISP_YUVAE_WND3_SUMY			(ISP_YUVAE_BASE + 0x00038)
+#define ISP_YUVAE_WND4_SUMY			(ISP_YUVAE_BASE + 0x0003c)
+#define ISP_YUVAE_RO_DBG1			(ISP_YUVAE_BASE + 0x00040)
+#define ISP_YUVAE_RO_DBG2			(ISP_YUVAE_BASE + 0x00044)
+#define ISP_YUVAE_RO_DBG3			(ISP_YUVAE_BASE + 0x00048)
+#define ISP_YUVAE_RO_MEAN_BASE_ADDR		(ISP_YUVAE_BASE + 0x00080)
+
+#define ISP_RAWAF_BASE				0x00004D00
+#define ISP_RAWAF_CTRL				(ISP_RAWAF_BASE + 0x00000)
+#define ISP_RAWAF_LT_A				(ISP_RAWAF_BASE + 0x00004)
+#define ISP_RAWAF_RB_A				(ISP_RAWAF_BASE + 0x00008)
+#define ISP_RAWAF_LT_B				(ISP_RAWAF_BASE + 0x0000c)
+#define ISP_RAWAF_RB_B				(ISP_RAWAF_BASE + 0x00010)
+#define ISP_RAWAF_INT_LINE			(ISP_RAWAF_BASE + 0x00014)
+#define ISP_RAWAF_GAUS_COE			(ISP_RAWAF_BASE + 0x00018)
+#define ISP_RAWAF_THRES				(ISP_RAWAF_BASE + 0x0001c)
+#define ISP_RAWAF_VAR_SHIFT			(ISP_RAWAF_BASE + 0x00020)
+#define ISP_RAWAF_SUM_A				(ISP_RAWAF_BASE + 0x00024)
+#define ISP_RAWAF_SUM_B				(ISP_RAWAF_BASE + 0x00028)
+#define ISP_RAWAF_LUM_A				(ISP_RAWAF_BASE + 0x0002c)
+#define ISP_RAWAF_LUM_B				(ISP_RAWAF_BASE + 0x00030)
+#define ISP_RAWAF_GAMMA_Y0			(ISP_RAWAF_BASE + 0x00034)
+#define ISP_RAWAF_GAMMA_Y1			(ISP_RAWAF_BASE + 0x00038)
+#define ISP_RAWAF_GAMMA_Y2			(ISP_RAWAF_BASE + 0x0003c)
+#define ISP_RAWAF_GAMMA_Y3			(ISP_RAWAF_BASE + 0x00040)
+#define ISP_RAWAF_GAMMA_Y4			(ISP_RAWAF_BASE + 0x00044)
+#define ISP_RAWAF_GAMMA_Y5			(ISP_RAWAF_BASE + 0x00048)
+#define ISP_RAWAF_GAMMA_Y6			(ISP_RAWAF_BASE + 0x0004c)
+#define ISP_RAWAF_GAMMA_Y7			(ISP_RAWAF_BASE + 0x00050)
+#define ISP_RAWAF_GAMMA_Y8			(ISP_RAWAF_BASE + 0x00054)
+#define ISP_RAWAF_INT_STATE			(ISP_RAWAF_BASE + 0x00058)
+#define ISP_RAWAF_RAM_DATA			(ISP_RAWAF_BASE + 0x0005c)
+
+#define ISP_RAWAWB_BASE				0x00005000
+#define ISP_RAWAWB_CTRL				(ISP_RAWAWB_BASE + 0x00000)
+#define ISP_RAWAWB_BLK_CTRL			(ISP_RAWAWB_BASE + 0x00004)
+#define ISP_RAWAWB_WIN_OFFS			(ISP_RAWAWB_BASE + 0x00008)
+#define ISP_RAWAWB_WIN_SIZE			(ISP_RAWAWB_BASE + 0x0000c)
+#define ISP_RAWAWB_LIMIT_RG_MAX			(ISP_RAWAWB_BASE + 0x00010)
+#define ISP_RAWAWB_LIMIT_BY_MAX			(ISP_RAWAWB_BASE + 0x00014)
+#define ISP_RAWAWB_LIMIT_RG_MIN			(ISP_RAWAWB_BASE + 0x00018)
+#define ISP_RAWAWB_LIMIT_BY_MIN			(ISP_RAWAWB_BASE + 0x0001c)
+#define ISP_RAWAWB_RGB2Y_0			(ISP_RAWAWB_BASE + 0x00020)
+#define ISP_RAWAWB_RGB2Y_1			(ISP_RAWAWB_BASE + 0x00024)
+#define ISP_RAWAWB_RGB2U_0			(ISP_RAWAWB_BASE + 0x00028)
+#define ISP_RAWAWB_RGB2U_1			(ISP_RAWAWB_BASE + 0x0002c)
+#define ISP_RAWAWB_RGB2V_0			(ISP_RAWAWB_BASE + 0x00030)
+#define ISP_RAWAWB_RGB2V_1			(ISP_RAWAWB_BASE + 0x00034)
+#define ISP_RAWAWB_UV_DETC_VERTEX0_0		(ISP_RAWAWB_BASE + 0x00038)
+#define ISP_RAWAWB_UV_DETC_VERTEX1_0		(ISP_RAWAWB_BASE + 0x0003c)
+#define ISP_RAWAWB_UV_DETC_VERTEX2_0		(ISP_RAWAWB_BASE + 0x00040)
+#define ISP_RAWAWB_UV_DETC_VERTEX3_0		(ISP_RAWAWB_BASE + 0x00044)
+#define ISP_RAWAWB_UV_DETC_ISLOPE01_0		(ISP_RAWAWB_BASE + 0x00048)
+#define ISP_RAWAWB_UV_DETC_ISLOPE12_0		(ISP_RAWAWB_BASE + 0x0004c)
+#define ISP_RAWAWB_UV_DETC_ISLOPE23_0		(ISP_RAWAWB_BASE + 0x00050)
+#define ISP_RAWAWB_UV_DETC_ISLOPE30_0		(ISP_RAWAWB_BASE + 0x00054)
+#define ISP_RAWAWB_UV_DETC_VERTEX0_1		(ISP_RAWAWB_BASE + 0x00058)
+#define ISP_RAWAWB_UV_DETC_VERTEX1_1		(ISP_RAWAWB_BASE + 0x0005c)
+#define ISP_RAWAWB_UV_DETC_VERTEX2_1		(ISP_RAWAWB_BASE + 0x00060)
+#define ISP_RAWAWB_UV_DETC_VERTEX3_1		(ISP_RAWAWB_BASE + 0x00064)
+#define ISP_RAWAWB_UV_DETC_ISLOPE01_1		(ISP_RAWAWB_BASE + 0x00068)
+#define ISP_RAWAWB_UV_DETC_ISLOPE12_1		(ISP_RAWAWB_BASE + 0x0006c)
+#define ISP_RAWAWB_UV_DETC_ISLOPE23_1		(ISP_RAWAWB_BASE + 0x00070)
+#define ISP_RAWAWB_UV_DETC_ISLOPE30_1		(ISP_RAWAWB_BASE + 0x00074)
+#define ISP_RAWAWB_UV_DETC_VERTEX0_2		(ISP_RAWAWB_BASE + 0x00078)
+#define ISP_RAWAWB_UV_DETC_VERTEX1_2		(ISP_RAWAWB_BASE + 0x0007c)
+#define ISP_RAWAWB_UV_DETC_VERTEX2_2		(ISP_RAWAWB_BASE + 0x00080)
+#define ISP_RAWAWB_UV_DETC_VERTEX3_2		(ISP_RAWAWB_BASE + 0x00084)
+#define ISP_RAWAWB_UV_DETC_ISLOPE01_2		(ISP_RAWAWB_BASE + 0x00088)
+#define ISP_RAWAWB_UV_DETC_ISLOPE12_2		(ISP_RAWAWB_BASE + 0x0008c)
+#define ISP_RAWAWB_UV_DETC_ISLOPE23_2		(ISP_RAWAWB_BASE + 0x00090)
+#define ISP_RAWAWB_UV_DETC_ISLOPE30_2		(ISP_RAWAWB_BASE + 0x00094)
+#define ISP_RAWAWB_UV_DETC_VERTEX0_3		(ISP_RAWAWB_BASE + 0x00098)
+#define ISP_RAWAWB_UV_DETC_VERTEX1_3		(ISP_RAWAWB_BASE + 0x0009c)
+#define ISP_RAWAWB_UV_DETC_VERTEX2_3		(ISP_RAWAWB_BASE + 0x000a0)
+#define ISP_RAWAWB_UV_DETC_VERTEX3_3		(ISP_RAWAWB_BASE + 0x000a4)
+#define ISP_RAWAWB_UV_DETC_ISLOPE01_3		(ISP_RAWAWB_BASE + 0x000a8)
+#define ISP_RAWAWB_UV_DETC_ISLOPE12_3		(ISP_RAWAWB_BASE + 0x000ac)
+#define ISP_RAWAWB_UV_DETC_ISLOPE23_3		(ISP_RAWAWB_BASE + 0x000b0)
+#define ISP_RAWAWB_UV_DETC_ISLOPE30_3		(ISP_RAWAWB_BASE + 0x000b4)
+#define ISP_RAWAWB_UV_DETC_VERTEX0_4		(ISP_RAWAWB_BASE + 0x000b8)
+#define ISP_RAWAWB_UV_DETC_VERTEX1_4		(ISP_RAWAWB_BASE + 0x000bc)
+#define ISP_RAWAWB_UV_DETC_VERTEX2_4		(ISP_RAWAWB_BASE + 0x000c0)
+#define ISP_RAWAWB_UV_DETC_VERTEX3_4		(ISP_RAWAWB_BASE + 0x000c4)
+#define ISP_RAWAWB_UV_DETC_ISLOPE01_4		(ISP_RAWAWB_BASE + 0x000c8)
+#define ISP_RAWAWB_UV_DETC_ISLOPE12_4		(ISP_RAWAWB_BASE + 0x000cc)
+#define ISP_RAWAWB_UV_DETC_ISLOPE23_4		(ISP_RAWAWB_BASE + 0x000d0)
+#define ISP_RAWAWB_UV_DETC_ISLOPE30_4		(ISP_RAWAWB_BASE + 0x000d4)
+#define ISP_RAWAWB_UV_DETC_VERTEX0_5		(ISP_RAWAWB_BASE + 0x000d8)
+#define ISP_RAWAWB_UV_DETC_VERTEX1_5		(ISP_RAWAWB_BASE + 0x000dc)
+#define ISP_RAWAWB_UV_DETC_VERTEX2_5		(ISP_RAWAWB_BASE + 0x000e0)
+#define ISP_RAWAWB_UV_DETC_VERTEX3_5		(ISP_RAWAWB_BASE + 0x000e4)
+#define ISP_RAWAWB_UV_DETC_ISLOPE01_5		(ISP_RAWAWB_BASE + 0x000e8)
+#define ISP_RAWAWB_UV_DETC_ISLOPE12_5		(ISP_RAWAWB_BASE + 0x000ec)
+#define ISP_RAWAWB_UV_DETC_ISLOPE23_5		(ISP_RAWAWB_BASE + 0x000f0)
+#define ISP_RAWAWB_UV_DETC_ISLOPE30_5		(ISP_RAWAWB_BASE + 0x000f4)
+#define ISP_RAWAWB_UV_DETC_VERTEX0_6		(ISP_RAWAWB_BASE + 0x000f8)
+#define ISP_RAWAWB_UV_DETC_VERTEX1_6		(ISP_RAWAWB_BASE + 0x000fc)
+#define ISP_RAWAWB_UV_DETC_VERTEX2_6		(ISP_RAWAWB_BASE + 0x00100)
+#define ISP_RAWAWB_UV_DETC_VERTEX3_6		(ISP_RAWAWB_BASE + 0x00104)
+#define ISP_RAWAWB_UV_DETC_ISLOPE01_6		(ISP_RAWAWB_BASE + 0x00108)
+#define ISP_RAWAWB_UV_DETC_ISLOPE12_6		(ISP_RAWAWB_BASE + 0x0010c)
+#define ISP_RAWAWB_UV_DETC_ISLOPE23_6		(ISP_RAWAWB_BASE + 0x00110)
+#define ISP_RAWAWB_UV_DETC_ISLOPE30_6		(ISP_RAWAWB_BASE + 0x00114)
+#define ISP_RAWAWB_YUV_DETC_B_UV_0		(ISP_RAWAWB_BASE + 0x00118)
+#define ISP_RAWAWB_YUV_DETC_SLOPE_VTCUV_0	(ISP_RAWAWB_BASE + 0x0011c)
+#define ISP_RAWAWB_YUV_DETC_INV_DSLOPE_0	(ISP_RAWAWB_BASE + 0x00120)
+#define ISP_RAWAWB_YUV_DETC_SLOPE_YDIS_0	(ISP_RAWAWB_BASE + 0x00124)
+#define ISP_RAWAWB_YUV_DETC_B_YDIS_0		(ISP_RAWAWB_BASE + 0x00128)
+#define ISP_RAWAWB_YUV_DETC_B_UV_1		(ISP_RAWAWB_BASE + 0x0012c)
+#define ISP_RAWAWB_YUV_DETC_SLOPE_VTCUV_1	(ISP_RAWAWB_BASE + 0x00130)
+#define ISP_RAWAWB_YUV_DETC_INV_DSLOPE_1	(ISP_RAWAWB_BASE + 0x00134)
+#define ISP_RAWAWB_YUV_DETC_SLOPE_YDIS_1	(ISP_RAWAWB_BASE + 0x00138)
+#define ISP_RAWAWB_YUV_DETC_B_YDIS_1		(ISP_RAWAWB_BASE + 0x0013c)
+#define ISP_RAWAWB_YUV_DETC_B_UV_2		(ISP_RAWAWB_BASE + 0x00140)
+#define ISP_RAWAWB_YUV_DETC_SLOPE_VTCUV_2	(ISP_RAWAWB_BASE + 0x00144)
+#define ISP_RAWAWB_YUV_DETC_INV_DSLOPE_2	(ISP_RAWAWB_BASE + 0x00148)
+#define ISP_RAWAWB_YUV_DETC_SLOPE_YDIS_2	(ISP_RAWAWB_BASE + 0x0014c)
+#define ISP_RAWAWB_YUV_DETC_B_YDIS_2		(ISP_RAWAWB_BASE + 0x00150)
+#define ISP_RAWAWB_YUV_DETC_B_UV_3		(ISP_RAWAWB_BASE + 0x00154)
+#define ISP_RAWAWB_YUV_DETC_SLOPE_VTCUV_3	(ISP_RAWAWB_BASE + 0x00158)
+#define ISP_RAWAWB_YUV_DETC_INV_DSLOPE_3	(ISP_RAWAWB_BASE + 0x0015c)
+#define ISP_RAWAWB_YUV_DETC_SLOPE_YDIS_3	(ISP_RAWAWB_BASE + 0x00160)
+#define ISP_RAWAWB_YUV_DETC_B_YDIS_3		(ISP_RAWAWB_BASE + 0x00164)
+#define ISP_RAWAWB_YUV_DETC_REF_U		(ISP_RAWAWB_BASE + 0x00168)
+#define ISP_RAWAWB_YUV_DETC_REF_V		(ISP_RAWAWB_BASE + 0x0016c)
+#define ISP_RAWAWB_YUV_DETC_DIS01_0		(ISP_RAWAWB_BASE + 0x00170)
+#define ISP_RAWAWB_YUV_DETC_DIS23_0		(ISP_RAWAWB_BASE + 0x00174)
+#define ISP_RAWAWB_YUV_DETC_DIS45_0		(ISP_RAWAWB_BASE + 0x00178)
+#define ISP_RAWAWB_YUV_DETC_TH03_0		(ISP_RAWAWB_BASE + 0x0017c)
+#define ISP_RAWAWB_YUV_DETC_TH45_0		(ISP_RAWAWB_BASE + 0x00180)
+#define ISP_RAWAWB_YUV_DETC_DIS01_1		(ISP_RAWAWB_BASE + 0x00184)
+#define ISP_RAWAWB_YUV_DETC_DIS23_1		(ISP_RAWAWB_BASE + 0x00188)
+#define ISP_RAWAWB_YUV_DETC_DIS45_1		(ISP_RAWAWB_BASE + 0x0018c)
+#define ISP_RAWAWB_YUV_DETC_TH03_1		(ISP_RAWAWB_BASE + 0x00190)
+#define ISP_RAWAWB_YUV_DETC_TH45_1		(ISP_RAWAWB_BASE + 0x00194)
+#define ISP_RAWAWB_YUV_DETC_DIS01_2		(ISP_RAWAWB_BASE + 0x00198)
+#define ISP_RAWAWB_YUV_DETC_DIS23_2		(ISP_RAWAWB_BASE + 0x0019c)
+#define ISP_RAWAWB_YUV_DETC_DIS45_2		(ISP_RAWAWB_BASE + 0x001a0)
+#define ISP_RAWAWB_YUV_DETC_TH03_2		(ISP_RAWAWB_BASE + 0x001a4)
+#define ISP_RAWAWB_YUV_DETC_TH45_2		(ISP_RAWAWB_BASE + 0x001a8)
+#define ISP_RAWAWB_YUV_DETC_DIS01_3		(ISP_RAWAWB_BASE + 0x001ac)
+#define ISP_RAWAWB_YUV_DETC_DIS23_3		(ISP_RAWAWB_BASE + 0x001b0)
+#define ISP_RAWAWB_YUV_DETC_DIS45_3		(ISP_RAWAWB_BASE + 0x001b4)
+#define ISP_RAWAWB_YUV_DETC_TH03_3		(ISP_RAWAWB_BASE + 0x001b8)
+#define ISP_RAWAWB_YUV_DETC_TH45_3		(ISP_RAWAWB_BASE + 0x001bc)
+#define ISP_RAWAWB_RGB2XY_WT01			(ISP_RAWAWB_BASE + 0x001fc)
+#define ISP_RAWAWB_RGB2XY_WT2			(ISP_RAWAWB_BASE + 0x00200)
+#define ISP_RAWAWB_RGB2XY_MAT0_XY		(ISP_RAWAWB_BASE + 0x00204)
+#define ISP_RAWAWB_RGB2XY_MAT1_XY		(ISP_RAWAWB_BASE + 0x00208)
+#define ISP_RAWAWB_RGB2XY_MAT2_XY		(ISP_RAWAWB_BASE + 0x0020c)
+#define ISP_RAWAWB_XY_DETC_NOR_X_0		(ISP_RAWAWB_BASE + 0x00210)
+#define ISP_RAWAWB_XY_DETC_NOR_Y_0		(ISP_RAWAWB_BASE + 0x00214)
+#define ISP_RAWAWB_XY_DETC_BIG_X_0		(ISP_RAWAWB_BASE + 0x00218)
+#define ISP_RAWAWB_XY_DETC_BIG_Y_0		(ISP_RAWAWB_BASE + 0x0021c)
+#define ISP_RAWAWB_XY_DETC_SMA_X_0		(ISP_RAWAWB_BASE + 0x00220)
+#define ISP_RAWAWB_XY_DETC_SMA_Y_0		(ISP_RAWAWB_BASE + 0x00224)
+#define ISP_RAWAWB_XY_DETC_NOR_X_1		(ISP_RAWAWB_BASE + 0x00228)
+#define ISP_RAWAWB_XY_DETC_NOR_Y_1		(ISP_RAWAWB_BASE + 0x0022c)
+#define ISP_RAWAWB_XY_DETC_BIG_X_1		(ISP_RAWAWB_BASE + 0x00230)
+#define ISP_RAWAWB_XY_DETC_BIG_Y_1		(ISP_RAWAWB_BASE + 0x00234)
+#define ISP_RAWAWB_XY_DETC_SMA_X_1		(ISP_RAWAWB_BASE + 0x00238)
+#define ISP_RAWAWB_XY_DETC_SMA_Y_1		(ISP_RAWAWB_BASE + 0x0023c)
+#define ISP_RAWAWB_XY_DETC_NOR_X_2		(ISP_RAWAWB_BASE + 0x00240)
+#define ISP_RAWAWB_XY_DETC_NOR_Y_2		(ISP_RAWAWB_BASE + 0x00244)
+#define ISP_RAWAWB_XY_DETC_BIG_X_2		(ISP_RAWAWB_BASE + 0x00248)
+#define ISP_RAWAWB_XY_DETC_BIG_Y_2		(ISP_RAWAWB_BASE + 0x0024c)
+#define ISP_RAWAWB_XY_DETC_SMA_X_2		(ISP_RAWAWB_BASE + 0x00250)
+#define ISP_RAWAWB_XY_DETC_SMA_Y_2		(ISP_RAWAWB_BASE + 0x00254)
+#define ISP_RAWAWB_XY_DETC_NOR_X_3		(ISP_RAWAWB_BASE + 0x00258)
+#define ISP_RAWAWB_XY_DETC_NOR_Y_3		(ISP_RAWAWB_BASE + 0x0025c)
+#define ISP_RAWAWB_XY_DETC_BIG_X_3		(ISP_RAWAWB_BASE + 0x00260)
+#define ISP_RAWAWB_XY_DETC_BIG_Y_3		(ISP_RAWAWB_BASE + 0x00264)
+#define ISP_RAWAWB_XY_DETC_SMA_X_3		(ISP_RAWAWB_BASE + 0x00268)
+#define ISP_RAWAWB_XY_DETC_SMA_Y_3		(ISP_RAWAWB_BASE + 0x0026c)
+#define ISP_RAWAWB_XY_DETC_NOR_X_4		(ISP_RAWAWB_BASE + 0x00270)
+#define ISP_RAWAWB_XY_DETC_NOR_Y_4		(ISP_RAWAWB_BASE + 0x00274)
+#define ISP_RAWAWB_XY_DETC_BIG_X_4		(ISP_RAWAWB_BASE + 0x00278)
+#define ISP_RAWAWB_XY_DETC_BIG_Y_4		(ISP_RAWAWB_BASE + 0x0027c)
+#define ISP_RAWAWB_XY_DETC_SMA_X_4		(ISP_RAWAWB_BASE + 0x00280)
+#define ISP_RAWAWB_XY_DETC_SMA_Y_4		(ISP_RAWAWB_BASE + 0x00284)
+#define ISP_RAWAWB_XY_DETC_NOR_X_5		(ISP_RAWAWB_BASE + 0x00288)
+#define ISP_RAWAWB_XY_DETC_NOR_Y_5		(ISP_RAWAWB_BASE + 0x0028c)
+#define ISP_RAWAWB_XY_DETC_BIG_X_5		(ISP_RAWAWB_BASE + 0x00290)
+#define ISP_RAWAWB_XY_DETC_BIG_Y_5		(ISP_RAWAWB_BASE + 0x00294)
+#define ISP_RAWAWB_XY_DETC_SMA_X_5		(ISP_RAWAWB_BASE + 0x00298)
+#define ISP_RAWAWB_XY_DETC_SMA_Y_5		(ISP_RAWAWB_BASE + 0x0029c)
+#define ISP_RAWAWB_XY_DETC_NOR_X_6		(ISP_RAWAWB_BASE + 0x002a0)
+#define ISP_RAWAWB_XY_DETC_NOR_Y_6		(ISP_RAWAWB_BASE + 0x002a4)
+#define ISP_RAWAWB_XY_DETC_BIG_X_6		(ISP_RAWAWB_BASE + 0x002a8)
+#define ISP_RAWAWB_XY_DETC_BIG_Y_6		(ISP_RAWAWB_BASE + 0x002ac)
+#define ISP_RAWAWB_XY_DETC_SMA_X_6		(ISP_RAWAWB_BASE + 0x002b0)
+#define ISP_RAWAWB_XY_DETC_SMA_Y_6		(ISP_RAWAWB_BASE + 0x002b4)
+#define ISP_RAWAWB_MULTIWINDOW_EXC_CTRL		(ISP_RAWAWB_BASE + 0x002b8)
+#define ISP_RAWAWB_MULTIWINDOW0_OFFS		(ISP_RAWAWB_BASE + 0x002bc)
+#define ISP_RAWAWB_MULTIWINDOW0_SIZE		(ISP_RAWAWB_BASE + 0x002c0)
+#define ISP_RAWAWB_MULTIWINDOW1_OFFS		(ISP_RAWAWB_BASE + 0x002c4)
+#define ISP_RAWAWB_MULTIWINDOW1_SIZE		(ISP_RAWAWB_BASE + 0x002c8)
+#define ISP_RAWAWB_MULTIWINDOW2_OFFS		(ISP_RAWAWB_BASE + 0x002cc)
+#define ISP_RAWAWB_MULTIWINDOW2_SIZE		(ISP_RAWAWB_BASE + 0x002d0)
+#define ISP_RAWAWB_MULTIWINDOW3_OFFS		(ISP_RAWAWB_BASE + 0x002d4)
+#define ISP_RAWAWB_MULTIWINDOW3_SIZE		(ISP_RAWAWB_BASE + 0x002d8)
+#define ISP_RAWAWB_MULTIWINDOW4_OFFS		(ISP_RAWAWB_BASE + 0x002dc)
+#define ISP_RAWAWB_MULTIWINDOW4_SIZE		(ISP_RAWAWB_BASE + 0x002e0)
+#define ISP_RAWAWB_MULTIWINDOW5_OFFS		(ISP_RAWAWB_BASE + 0x002e4)
+#define ISP_RAWAWB_MULTIWINDOW5_SIZE		(ISP_RAWAWB_BASE + 0x002e8)
+#define ISP_RAWAWB_MULTIWINDOW6_OFFS		(ISP_RAWAWB_BASE + 0x002ec)
+#define ISP_RAWAWB_MULTIWINDOW6_SIZE		(ISP_RAWAWB_BASE + 0x002f0)
+#define ISP_RAWAWB_MULTIWINDOW7_OFFS		(ISP_RAWAWB_BASE + 0x002f4)
+#define ISP_RAWAWB_MULTIWINDOW7_SIZE		(ISP_RAWAWB_BASE + 0x002f8)
+#define ISP_RAWAWB_EXC_WP_REGION0_XU		(ISP_RAWAWB_BASE + 0x002fc)
+#define ISP_RAWAWB_EXC_WP_REGION0_YV		(ISP_RAWAWB_BASE + 0x00300)
+#define ISP_RAWAWB_EXC_WP_REGION1_XU		(ISP_RAWAWB_BASE + 0x00304)
+#define ISP_RAWAWB_EXC_WP_REGION1_YV		(ISP_RAWAWB_BASE + 0x00308)
+#define ISP_RAWAWB_EXC_WP_REGION2_XU		(ISP_RAWAWB_BASE + 0x0030c)
+#define ISP_RAWAWB_EXC_WP_REGION2_YV		(ISP_RAWAWB_BASE + 0x00310)
+#define ISP_RAWAWB_EXC_WP_REGION3_XU		(ISP_RAWAWB_BASE + 0x00314)
+#define ISP_RAWAWB_EXC_WP_REGION3_YV		(ISP_RAWAWB_BASE + 0x00318)
+#define ISP_RAWAWB_EXC_WP_REGION4_XU		(ISP_RAWAWB_BASE + 0x0031c)
+#define ISP_RAWAWB_EXC_WP_REGION4_YV		(ISP_RAWAWB_BASE + 0x00320)
+#define ISP_RAWAWB_EXC_WP_REGION5_XU		(ISP_RAWAWB_BASE + 0x00324)
+#define ISP_RAWAWB_EXC_WP_REGION5_YV		(ISP_RAWAWB_BASE + 0x00328)
+#define ISP_RAWAWB_EXC_WP_REGION6_XU		(ISP_RAWAWB_BASE + 0x0032c)
+#define ISP_RAWAWB_EXC_WP_REGION6_YV		(ISP_RAWAWB_BASE + 0x00330)
+#define ISP_RAWAWB_SUM_R_NOR_0			(ISP_RAWAWB_BASE + 0x00340)
+#define ISP_RAWAWB_SUM_G_NOR_0			(ISP_RAWAWB_BASE + 0x00344)
+#define ISP_RAWAWB_SUM_B_NOR_0			(ISP_RAWAWB_BASE + 0x00348)
+#define ISP_RAWAWB_WP_NUM_NOR_0			(ISP_RAWAWB_BASE + 0x0034c)
+#define ISP_RAWAWB_SUM_R_BIG_0			(ISP_RAWAWB_BASE + 0x00350)
+#define ISP_RAWAWB_SUM_G_BIG_0			(ISP_RAWAWB_BASE + 0x00354)
+#define ISP_RAWAWB_SUM_B_BIG_0			(ISP_RAWAWB_BASE + 0x00358)
+#define ISP_RAWAWB_WP_NUM_BIG_0			(ISP_RAWAWB_BASE + 0x0035c)
+#define ISP_RAWAWB_SUM_R_SMA_0			(ISP_RAWAWB_BASE + 0x00360)
+#define ISP_RAWAWB_SUM_G_SMA_0			(ISP_RAWAWB_BASE + 0x00364)
+#define ISP_RAWAWB_SUM_B_SMA_0			(ISP_RAWAWB_BASE + 0x00368)
+#define ISP_RAWAWB_WP_NUM_SMA_0			(ISP_RAWAWB_BASE + 0x0036c)
+#define ISP_RAWAWB_SUM_R_NOR_1			(ISP_RAWAWB_BASE + 0x00370)
+#define ISP_RAWAWB_SUM_G_NOR_1			(ISP_RAWAWB_BASE + 0x00374)
+#define ISP_RAWAWB_SUM_B_NOR_1			(ISP_RAWAWB_BASE + 0x00378)
+#define ISP_RAWAWB_WP_NUM_NOR_1			(ISP_RAWAWB_BASE + 0x0037c)
+#define ISP_RAWAWB_SUM_R_BIG_1			(ISP_RAWAWB_BASE + 0x00380)
+#define ISP_RAWAWB_SUM_G_BIG_1			(ISP_RAWAWB_BASE + 0x00384)
+#define ISP_RAWAWB_SUM_B_BIG_1			(ISP_RAWAWB_BASE + 0x00388)
+#define ISP_RAWAWB_WP_NUM_BIG_1			(ISP_RAWAWB_BASE + 0x0038c)
+#define ISP_RAWAWB_SUM_R_SMA_1			(ISP_RAWAWB_BASE + 0x00390)
+#define ISP_RAWAWB_SUM_G_SMA_1			(ISP_RAWAWB_BASE + 0x00394)
+#define ISP_RAWAWB_SUM_B_SMA_1			(ISP_RAWAWB_BASE + 0x00398)
+#define ISP_RAWAWB_WP_NUM_SMA_1			(ISP_RAWAWB_BASE + 0x0039c)
+#define ISP_RAWAWB_SUM_R_NOR_2			(ISP_RAWAWB_BASE + 0x003a0)
+#define ISP_RAWAWB_SUM_G_NOR_2			(ISP_RAWAWB_BASE + 0x003a4)
+#define ISP_RAWAWB_SUM_B_NOR_2			(ISP_RAWAWB_BASE + 0x003a8)
+#define ISP_RAWAWB_WP_NUM_NOR_2			(ISP_RAWAWB_BASE + 0x003ac)
+#define ISP_RAWAWB_SUM_R_BIG_2			(ISP_RAWAWB_BASE + 0x003b0)
+#define ISP_RAWAWB_SUM_G_BIG_2			(ISP_RAWAWB_BASE + 0x003b4)
+#define ISP_RAWAWB_SUM_B_BIG_2			(ISP_RAWAWB_BASE + 0x003b8)
+#define ISP_RAWAWB_WP_NUM_BIG_2			(ISP_RAWAWB_BASE + 0x003bc)
+#define ISP_RAWAWB_SUM_R_SMA_2			(ISP_RAWAWB_BASE + 0x003c0)
+#define ISP_RAWAWB_SUM_G_SMA_2			(ISP_RAWAWB_BASE + 0x003c4)
+#define ISP_RAWAWB_SUM_B_SMA_2			(ISP_RAWAWB_BASE + 0x003c8)
+#define ISP_RAWAWB_WP_NUM_SMA_2			(ISP_RAWAWB_BASE + 0x003cc)
+#define ISP_RAWAWB_SUM_R_NOR_3			(ISP_RAWAWB_BASE + 0x003d0)
+#define ISP_RAWAWB_SUM_G_NOR_3			(ISP_RAWAWB_BASE + 0x003d4)
+#define ISP_RAWAWB_SUM_B_NOR_3			(ISP_RAWAWB_BASE + 0x003d8)
+#define ISP_RAWAWB_WP_NUM_NOR_3			(ISP_RAWAWB_BASE + 0x003dc)
+#define ISP_RAWAWB_SUM_R_BIG_3			(ISP_RAWAWB_BASE + 0x003e0)
+#define ISP_RAWAWB_SUM_G_BIG_3			(ISP_RAWAWB_BASE + 0x003e4)
+#define ISP_RAWAWB_SUM_B_BIG_3			(ISP_RAWAWB_BASE + 0x003e8)
+#define ISP_RAWAWB_WP_NUM_BIG_3			(ISP_RAWAWB_BASE + 0x003ec)
+#define ISP_RAWAWB_SUM_R_SMA_3			(ISP_RAWAWB_BASE + 0x003f0)
+#define ISP_RAWAWB_SUM_G_SMA_3			(ISP_RAWAWB_BASE + 0x003f4)
+#define ISP_RAWAWB_SUM_B_SMA_3			(ISP_RAWAWB_BASE + 0x003f8)
+#define ISP_RAWAWB_WP_NUM_SMA_3			(ISP_RAWAWB_BASE + 0x003fc)
+#define ISP_RAWAWB_SUM_R_NOR_4			(ISP_RAWAWB_BASE + 0x00400)
+#define ISP_RAWAWB_SUM_G_NOR_4			(ISP_RAWAWB_BASE + 0x00404)
+#define ISP_RAWAWB_SUM_B_NOR_4			(ISP_RAWAWB_BASE + 0x00408)
+#define ISP_RAWAWB_WP_NUM_NOR_4			(ISP_RAWAWB_BASE + 0x0040c)
+#define ISP_RAWAWB_SUM_R_BIG_4			(ISP_RAWAWB_BASE + 0x00410)
+#define ISP_RAWAWB_SUM_G_BIG_4			(ISP_RAWAWB_BASE + 0x00414)
+#define ISP_RAWAWB_SUM_B_BIG_4			(ISP_RAWAWB_BASE + 0x00418)
+#define ISP_RAWAWB_WP_NUM_BIG_4			(ISP_RAWAWB_BASE + 0x0041c)
+#define ISP_RAWAWB_SUM_R_SMA_4			(ISP_RAWAWB_BASE + 0x00420)
+#define ISP_RAWAWB_SUM_G_SMA_4			(ISP_RAWAWB_BASE + 0x00424)
+#define ISP_RAWAWB_SUM_B_SMA_4			(ISP_RAWAWB_BASE + 0x00428)
+#define ISP_RAWAWB_WP_NUM_SMA_4			(ISP_RAWAWB_BASE + 0x0042c)
+#define ISP_RAWAWB_SUM_R_NOR_5			(ISP_RAWAWB_BASE + 0x00430)
+#define ISP_RAWAWB_SUM_G_NOR_5			(ISP_RAWAWB_BASE + 0x00434)
+#define ISP_RAWAWB_SUM_B_NOR_5			(ISP_RAWAWB_BASE + 0x00438)
+#define ISP_RAWAWB_WP_NUM_NOR_5			(ISP_RAWAWB_BASE + 0x0043c)
+#define ISP_RAWAWB_SUM_R_BIG_5			(ISP_RAWAWB_BASE + 0x00440)
+#define ISP_RAWAWB_SUM_G_BIG_5			(ISP_RAWAWB_BASE + 0x00444)
+#define ISP_RAWAWB_SUM_B_BIG_5			(ISP_RAWAWB_BASE + 0x00448)
+#define ISP_RAWAWB_WP_NUM_BIG_5			(ISP_RAWAWB_BASE + 0x0044c)
+#define ISP_RAWAWB_SUM_R_SMA_5			(ISP_RAWAWB_BASE + 0x00450)
+#define ISP_RAWAWB_SUM_G_SMA_5			(ISP_RAWAWB_BASE + 0x00454)
+#define ISP_RAWAWB_SUM_B_SMA_5			(ISP_RAWAWB_BASE + 0x00458)
+#define ISP_RAWAWB_WP_NUM_SMA_5			(ISP_RAWAWB_BASE + 0x0045c)
+#define ISP_RAWAWB_SUM_R_NOR_6			(ISP_RAWAWB_BASE + 0x00460)
+#define ISP_RAWAWB_SUM_G_NOR_6			(ISP_RAWAWB_BASE + 0x00464)
+#define ISP_RAWAWB_SUM_B_NOR_6			(ISP_RAWAWB_BASE + 0x00468)
+#define ISP_RAWAWB_WP_NUM_NOR_6			(ISP_RAWAWB_BASE + 0x0046c)
+#define ISP_RAWAWB_SUM_R_BIG_6			(ISP_RAWAWB_BASE + 0x00470)
+#define ISP_RAWAWB_SUM_G_BIG_6			(ISP_RAWAWB_BASE + 0x00474)
+#define ISP_RAWAWB_SUM_B_BIG_6			(ISP_RAWAWB_BASE + 0x00478)
+#define ISP_RAWAWB_WP_NUM_BIG_6			(ISP_RAWAWB_BASE + 0x0047c)
+#define ISP_RAWAWB_SUM_R_SMA_6			(ISP_RAWAWB_BASE + 0x00480)
+#define ISP_RAWAWB_SUM_G_SMA_6			(ISP_RAWAWB_BASE + 0x00484)
+#define ISP_RAWAWB_SUM_B_SMA_6			(ISP_RAWAWB_BASE + 0x00488)
+#define ISP_RAWAWB_WP_NUM_SMA_6			(ISP_RAWAWB_BASE + 0x0048c)
+#define ISP_RAWAWB_SUM_R_NOR_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x00490)
+#define ISP_RAWAWB_SUM_G_NOR_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x00494)
+#define ISP_RAWAWB_SUM_B_NOR_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x00498)
+#define ISP_RAWAWB_WP_NM_NOR_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x0049c)
+#define ISP_RAWAWB_SUM_R_BIG_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x004a0)
+#define ISP_RAWAWB_SUM_G_BIG_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x004a4)
+#define ISP_RAWAWB_SUM_B_BIG_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x004a8)
+#define ISP_RAWAWB_WP_NM_BIG_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x004ac)
+#define ISP_RAWAWB_SUM_R_SMA_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x004b0)
+#define ISP_RAWAWB_SUM_G_SMA_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x004b4)
+#define ISP_RAWAWB_SUM_B_SMA_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x004b8)
+#define ISP_RAWAWB_WP_NM_SMA_MULTIWINDOW_0	(ISP_RAWAWB_BASE + 0x004bc)
+#define ISP_RAWAWB_SUM_R_NOR_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004c0)
+#define ISP_RAWAWB_SUM_G_NOR_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004c4)
+#define ISP_RAWAWB_SUM_B_NOR_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004c8)
+#define ISP_RAWAWB_WP_NM_NOR_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004cc)
+#define ISP_RAWAWB_SUM_R_BIG_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004d0)
+#define ISP_RAWAWB_SUM_G_BIG_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004d4)
+#define ISP_RAWAWB_SUM_B_BIG_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004d8)
+#define ISP_RAWAWB_WP_NM_BIG_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004dc)
+#define ISP_RAWAWB_SUM_R_SMA_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004e0)
+#define ISP_RAWAWB_SUM_G_SMA_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004e4)
+#define ISP_RAWAWB_SUM_B_SMA_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004e8)
+#define ISP_RAWAWB_WP_NM_SMA_MULTIWINDOW_1	(ISP_RAWAWB_BASE + 0x004ec)
+#define ISP_RAWAWB_SUM_R_NOR_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x004f0)
+#define ISP_RAWAWB_SUM_G_NOR_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x004f4)
+#define ISP_RAWAWB_SUM_B_NOR_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x004f8)
+#define ISP_RAWAWB_WP_NM_NOR_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x004fc)
+#define ISP_RAWAWB_SUM_R_BIG_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x00500)
+#define ISP_RAWAWB_SUM_G_BIG_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x00504)
+#define ISP_RAWAWB_SUM_B_BIG_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x00508)
+#define ISP_RAWAWB_WP_NM_BIG_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x0050c)
+#define ISP_RAWAWB_SUM_R_SMA_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x00510)
+#define ISP_RAWAWB_SUM_G_SMA_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x00514)
+#define ISP_RAWAWB_SUM_B_SMA_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x00518)
+#define ISP_RAWAWB_WP_NM_SMA_MULTIWINDOW_2	(ISP_RAWAWB_BASE + 0x0051c)
+#define ISP_RAWAWB_SUM_R_NOR_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00520)
+#define ISP_RAWAWB_SUM_G_NOR_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00524)
+#define ISP_RAWAWB_SUM_B_NOR_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00528)
+#define ISP_RAWAWB_WP_NM_NOR_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x0052c)
+#define ISP_RAWAWB_SUM_R_BIG_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00530)
+#define ISP_RAWAWB_SUM_G_BIG_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00534)
+#define ISP_RAWAWB_SUM_B_BIG_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00538)
+#define ISP_RAWAWB_WP_NM_BIG_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x0053c)
+#define ISP_RAWAWB_SUM_R_SMA_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00540)
+#define ISP_RAWAWB_SUM_G_SMA_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00544)
+#define ISP_RAWAWB_SUM_B_SMA_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x00548)
+#define ISP_RAWAWB_WP_NM_SMA_MULTIWINDOW_3	(ISP_RAWAWB_BASE + 0x0054c)
+#define ISP_RAWAWB_SUM_R_NOR_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00550)
+#define ISP_RAWAWB_SUM_G_NOR_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00554)
+#define ISP_RAWAWB_SUM_B_NOR_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00558)
+#define ISP_RAWAWB_WP_NM_NOR_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x0055c)
+#define ISP_RAWAWB_SUM_R_BIG_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00560)
+#define ISP_RAWAWB_SUM_G_BIG_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00564)
+#define ISP_RAWAWB_SUM_B_BIG_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00568)
+#define ISP_RAWAWB_WP_NM_BIG_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x0056c)
+#define ISP_RAWAWB_SUM_R_SMA_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00570)
+#define ISP_RAWAWB_SUM_G_SMA_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00574)
+#define ISP_RAWAWB_SUM_B_SMA_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x00578)
+#define ISP_RAWAWB_WP_NM_SMA_MULTIWINDOW_4	(ISP_RAWAWB_BASE + 0x0057c)
+#define ISP_RAWAWB_SUM_R_NOR_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x00580)
+#define ISP_RAWAWB_SUM_G_NOR_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x00584)
+#define ISP_RAWAWB_SUM_B_NOR_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x00588)
+#define ISP_RAWAWB_WP_NM_NOR_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x0058c)
+#define ISP_RAWAWB_SUM_R_BIG_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x00590)
+#define ISP_RAWAWB_SUM_G_BIG_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x00594)
+#define ISP_RAWAWB_SUM_B_BIG_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x00598)
+#define ISP_RAWAWB_WP_NM_BIG_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x0059c)
+#define ISP_RAWAWB_SUM_R_SMA_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x005a0)
+#define ISP_RAWAWB_SUM_G_SMA_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x005a4)
+#define ISP_RAWAWB_SUM_B_SMA_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x005a8)
+#define ISP_RAWAWB_WP_NM_SMA_MULTIWINDOW_5	(ISP_RAWAWB_BASE + 0x005ac)
+#define ISP_RAWAWB_SUM_R_NOR_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005b0)
+#define ISP_RAWAWB_SUM_G_NOR_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005b4)
+#define ISP_RAWAWB_SUM_B_NOR_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005b8)
+#define ISP_RAWAWB_WP_NM_NOR_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005bc)
+#define ISP_RAWAWB_SUM_R_BIG_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005c0)
+#define ISP_RAWAWB_SUM_G_BIG_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005c4)
+#define ISP_RAWAWB_SUM_B_BIG_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005c8)
+#define ISP_RAWAWB_WP_NM_BIG_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005cc)
+#define ISP_RAWAWB_SUM_R_SMA_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005d0)
+#define ISP_RAWAWB_SUM_G_SMA_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005d4)
+#define ISP_RAWAWB_SUM_B_SMA_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005d8)
+#define ISP_RAWAWB_WP_NM_SMA_MULTIWINDOW_6	(ISP_RAWAWB_BASE + 0x005dc)
+#define ISP_RAWAWB_SUM_R_EXC_0			(ISP_RAWAWB_BASE + 0x005e0)
+#define ISP_RAWAWB_SUM_G_EXC_0			(ISP_RAWAWB_BASE + 0x005e4)
+#define ISP_RAWAWB_SUM_B_EXC_0			(ISP_RAWAWB_BASE + 0x005e8)
+#define ISP_RAWAWB_WP_NM_EXC_0			(ISP_RAWAWB_BASE + 0x005ec)
+#define ISP_RAWAWB_SUM_R_EXC_1			(ISP_RAWAWB_BASE + 0x005f0)
+#define ISP_RAWAWB_SUM_G_EXC_1			(ISP_RAWAWB_BASE + 0x005f4)
+#define ISP_RAWAWB_SUM_B_EXC_1			(ISP_RAWAWB_BASE + 0x005f8)
+#define ISP_RAWAWB_WP_NM_EXC_1			(ISP_RAWAWB_BASE + 0x005fc)
+#define ISP_RAWAWB_SUM_R_EXC_2			(ISP_RAWAWB_BASE + 0x00600)
+#define ISP_RAWAWB_SUM_G_EXC_2			(ISP_RAWAWB_BASE + 0x00604)
+#define ISP_RAWAWB_SUM_B_EXC_2			(ISP_RAWAWB_BASE + 0x00608)
+#define ISP_RAWAWB_WP_NM_EXC_2			(ISP_RAWAWB_BASE + 0x0060c)
+#define ISP_RAWAWB_SUM_R_EXC_3			(ISP_RAWAWB_BASE + 0x00610)
+#define ISP_RAWAWB_SUM_G_EXC_3			(ISP_RAWAWB_BASE + 0x00614)
+#define ISP_RAWAWB_SUM_B_EXC_3			(ISP_RAWAWB_BASE + 0x00618)
+#define ISP_RAWAWB_WP_NM_EXC_3			(ISP_RAWAWB_BASE + 0x0061c)
+#define ISP_RAWAWB_SUM_R_EXC_4			(ISP_RAWAWB_BASE + 0x00620)
+#define ISP_RAWAWB_SUM_G_EXC_4			(ISP_RAWAWB_BASE + 0x00624)
+#define ISP_RAWAWB_SUM_B_EXC_4			(ISP_RAWAWB_BASE + 0x00628)
+#define ISP_RAWAWB_WP_NM_EXC_4			(ISP_RAWAWB_BASE + 0x0062c)
+#define ISP_RAWAWB_SUM_R_EXC_5			(ISP_RAWAWB_BASE + 0x00630)
+#define ISP_RAWAWB_SUM_G_EXC_5			(ISP_RAWAWB_BASE + 0x00634)
+#define ISP_RAWAWB_SUM_B_EXC_5			(ISP_RAWAWB_BASE + 0x00638)
+#define ISP_RAWAWB_WP_NM_EXC_5			(ISP_RAWAWB_BASE + 0x0063c)
+#define ISP_RAWAWB_SUM_R_EXC_6			(ISP_RAWAWB_BASE + 0x00640)
+#define ISP_RAWAWB_SUM_G_EXC_6			(ISP_RAWAWB_BASE + 0x00644)
+#define ISP_RAWAWB_SUM_B_EXC_6			(ISP_RAWAWB_BASE + 0x00648)
+#define ISP_RAWAWB_WP_NM_EXC_6			(ISP_RAWAWB_BASE + 0x0064c)
+#define ISP_RAWAWB_RAM_CTRL			(ISP_RAWAWB_BASE + 0x00650)
+#define ISP_RAWAWB_RAM_DATA			(ISP_RAWAWB_BASE + 0x00660)
+
+/* VI_ISP_EN */
+#define VI_CCL_EN			BIT(0)
+#define VI_ISP_EN_SEL			BIT(1)
+#define VI_ISP_BLS_EN			BIT(5)
+#define VI_ISP_GAMMA_IN_EN		BIT(6)
+#define VI_ISP_HDRMGE_EN		BIT(7)
+#define VI_ISP_RAWNR_EN			BIT(9)
+#define VI_ISP_LSC_EN			BIT(10)
+#define VI_ISP_HDRTMO_EN		BIT(11)
+#define VI_ISP_GIC_EN			BTI(12)
+#define VI_ISP_DEBAYER_EN		BIT(13)
+#define VI_ISP_CCM_EN			BIT(14)
+#define VI_ISP_GAMMA12_EN		BIT(15)
+#define VI_ISP_RKWDR_EN			BIT(16)
+#define VI_ISP_DHAZ_EN			BIT(17)
+#define VI_ISP_3DLUT_EN			BIT(18)
+#define VI_ISP_AWB_EN			BIT(20)
+#define VI_ISP_CP_EN			BIT(21)
+#define VI_ISP_RSZ_EN			BIT(22)
+#define VI_ISP_EFF_EN			BIT(24)
+#define VI_ISP_IMP_EN			BIT(25)
+
+/* VI_ISP_PATH */
+#define SW_3A_RAWAE_SEL(a)		(((a) & 0x3) << 16)
+#define SW_3A_RAWAF_SEL(a)		(((a) & 0x3) << 18)
+#define SW_3A_RAWAWB_SEL(a)		(((a) & 0x3) << 20)
+#define SW_3A_RAWAE_SWAP(a)		(((a) & 0x3) << 22)
+
+/* VI_ISP_CLK_CTRL */
+#define CLK_CTRL_ISP_RAW		BIT(0)
+#define CLK_CTRL_ISP_RGB		BIT(1)
+#define CLK_CTRL_ISP_YUV		BIT(2)
+#define CLK_CTRL_ISP_3A			BIT(3)
+#define CLK_CTRL_MIPI_RAM		BIT(4)
+#define CLK_CTRL_ISP_FIFO_RAM		BIT(5)
+#define CLK_CTRL_ISP_DEM_RAM		BIT(6)
+#define CLK_CTRL_ISP_DPCC_RAM		BIT(7)
+#define CLK_CTRL_ISP_IE_RAM		BIT(8)
+#define CLK_CTRL_RSZ_RAM		BIT(9)
+#define CLK_CTRL_JPEG_RAM		BIT(10)
+#define CLK_CTRL_ACLK_ISP		BIT(11)
+#define CLK_CTRL_LDC_RAM		BIT(12)
+#define CLK_CTRL_MI_LDC			BIT(13)
+#define CLK_CTRL_MI_MP			BIT(14)
+#define CLK_CTRL_MI_JPEG		BIT(15)
+#define CLK_CTRL_MI_DP			BIT(16)
+#define CLK_CTRL_MI_Y12			BIT(17)
+#define CLK_CTRL_MI_SP			BIT(18)
+#define CLK_CTRL_MI_RAW0		BIT(19)
+#define CLK_CTRL_MI_RAW1		BIT(20)
+#define CLK_CTRL_MI_READ		BIT(21)
+#define CLK_CTRL_MI_RAWRD		BIT(22)
+#define CLK_CTRL_CP			BIT(23)
+#define CLK_CTRL_IE			BIT(24)
+#define CLK_CTRL_SI			BIT(25)
+#define CLK_CTRL_RSZM			BIT(26)
+#define CLK_CTRL_DPMUX			BIT(27)
+#define CLK_CTRL_JPEG			BIT(28)
+#define CLK_CTRL_RSZS			BIT(29)
+#define CLK_CTRL_MIPI			BIT(30)
+#define CLK_CTRL_MARVINMI		BIT(31)
+
+/* VI_ICCL */
+#define ICCL_ISP_CLK			BIT(0)
+#define ICCL_CP_CLK			BIT(1)
+#define ICCL_MRSZ_CLK			BIT(3)
+#define ICCL_SRSZ_CLK			BIT(4)
+#define ICCL_JPEG_CLK			BIT(5)
+#define ICCL_MI_CLK			BIT(6)
+#define ICCL_IE_CLK			BIT(8)
+#define ICCL_SIMP_CLK			BIT(9)
+#define ICCL_SMIA_CLK			BIT(10)
+#define ICCL_MIPI_CLK			BIT(11)
+#define ICCL_MPFBC_CLK			BIT(14)
+
+/* VI_IRCL */
+#define IRCL_ISP_SW_RST			BIT(0)
+#define IRCL_CP_SW_RST			BIT(1)
+#define IRCL_YCS_SW_RST			BIT(2)
+#define IRCL_MRSZ_SW_RST		BIT(3)
+#define IRCL_SRSZ_SW_RST		BIT(4)
+#define IRCL_JPEG_SW_RST		BIT(5)
+#define IRCL_MI_SW_RST			BIT(6)
+#define IRCL_MARVIN_RST			BIT(7)
+#define IRCL_IE_SW_RST			BIT(8)
+#define IRCL_SI_SW_RST			BIT(9)
+#define IRCL_MIPI_SW_RST		BIT(11)
+#define IRCL_3A_SW_RST			BIT(13)
+
+/* SWS_CFG */
+#define SW_SWS_EN			BIT(0)
+#define SW_ISP2PP_PIPE_EN		BIT(1)
+#define SW_MPIP_DROP_FRM_DIS		BIT(2)
+#define SW_SENSOR_ID(a)			(((a) & 0x3) << 4)
+#define SW_SWS_TMO_DDR_RD		BIT(8)
+#define SW_SWS_WDR_DDR_RD		BIT(9)
+#define SW_SWS_DHAZ_DDR_RD		BIT(10)
+#define SW_SWS_ISP_DDRLOAD_DIS		BIT(11)
+#define SW_SWS_DMA_START_MODE(a)	(((a) & 0x3) << 12)
+#define SW_ISP2PP_DIFX16(a)		(((a) & 0xff) << 16)
+#define SW_3A_DDR_WRITE_EN		BIT(24)
+#define SW_ISP2PP_HOLD			BIT(31)
+
+/* isp interrupt */
+#define ISP2X_OFF			BIT(0)
+#define ISP2X_FRAME			BIT(1)
+#define ISP2X_DATA_LOSS			BIT(2)
+#define ISP2X_PIC_SIZE_ERROR		BIT(3)
+#define ISP2X_SIAWB_DONE		BIT(4)
+#define ISP2X_FRAME_IN			BIT(5)
+#define ISP2X_V_START			BIT(6)
+#define ISP2X_H_START			BIT(7)
+#define ISP2X_FLASH_ON			BIT(8)
+#define ISP2X_FLASH_OFF			BIT(9)
+#define ISP2X_SHUTTER_ON		BIT(10)
+#define ISP2X_SHUTTER_OFF		BIT(11)
+#define ISP2X_AFM_SUM_OF		BIT(12)
+#define ISP2X_AFM_LUM_OF		BIT(13)
+#define ISP2X_SIAF_FIN			BIT(14)
+#define ISP2X_SIHST_RDY			BIT(15)
+#define ISP2X_FLASH_CAP			BIT(17)
+#define ISP2X_YUVAE_END			BIT(18)
+#define ISP2X_VSM_END			BIT(19)
+#define ISP2X_HDR_DONE			BIT(20)
+#define ISP2X_DHAZ_DONE			BIT(21)
+#define ISP2X_GAIN_DONE			BIT(22)
+
+/* isp3a interrupt */
+#define ISP2X_3A_RAWAE_BIG		BIT(0)
+#define ISP2X_3A_RAWAE_CH0		BIT(1)
+#define ISP2X_3A_RAWAE_CH1		BIT(2)
+#define ISP2X_3A_RAWAE_CH2		BIT(3)
+#define ISP2X_3A_RAWHIST_BIG		BIT(4)
+#define ISP2X_3A_RAWHIST_CH0		BIT(5)
+#define ISP2X_3A_RAWHIST_CH1		BIT(6)
+#define ISP2X_3A_RAWHIST_CH2		BIT(7)
+#define ISP2X_3A_RAWAF_SUM		BIT(8)
+#define ISP2X_3A_RAWAF_LUM		BIT(9)
+#define ISP2X_3A_RAWAF			BIT(10)
+#define ISP2X_3A_RAWAWB			BIT(11)
+
+/* mi interrupt */
+#define MI_MP_FRAME			BIT(0)
+#define MI_SP_FRAME			BIT(1)
+#define MI_MBLK_LINE			BIT(2)
+#define MI_FILL_MP_Y			BIT(3)
+#define MI_WRAP_MP_Y			BIT(4)
+#define MI_WRAP_MP_CB			BIT(5)
+#define MI_WRAP_MP_CR			BIT(6)
+#define MI_WRAP_SP_Y			BIT(7)
+#define MI_WRAP_SP_CB			BIT(8)
+#define MI_WARP_SP_CR			BIT(9)
+#define MI_FILL_MP_Y2			BIT(10)
+#define MI_DMA_READY			BIT(11)
+#define MI_Y12Y_FRAME			BIT(12)
+#define MI_Y12C_FRAME			BIT(13)
+#define MI_ALL_FRAME			BIT(14)
+#define MI_RAW0_WR_FRAME		BIT(16)
+#define MI_RAW1_WR_FRAME		BIT(17)
+#define MI_RAW2_WR_FRAME		BIT(18)
+#define MI_RAW3_WR_FRAME		BIT(19)
+#define MI_DBR_WR_FRAME			BIT(20)
+#define MI_GAIN_WR_FRAME		BIT(21)
+#define MI_MPFBC_FRAME			BIT(31)
+
+/* MI_CTRL2 */
+#define SW_GAIN_WR_AUTOUPD		BIT(13)
+#define SW_GAIN_WR_PINGPONG		BIT(12)
+#define SW_DBR_WR_AUTOUPD		BIT(10)
+#define SW_MIMUX_BYTE_SWAP		BIT(9)
+#define SW_MIMUX_EN			BIT(8)
+#define SW_RAW3_WR_AUTOUPD		BIT(3)
+#define SW_RAW2_WR_AUTOUPD		BIT(2)
+#define SW_RAW1_WR_AUTOUPD		BIT(1)
+#define SW_RAW0_WR_AUTOUPD		BIT(0)
+
+/* MPFBC */
+#define SW_MPFBC_EN			BIT(0)
+#define SW_MPFBC_MAINISP_MODE		BIT(3)
+#define SW_MPFBC_YUV_MODE(a)		(((a) & 0x3) << 1)
+#define SW_MPFBC_PINGPONG_EN		BIT(4)
+
+/* CSI2RX */
+#define SW_CSI2RX_EN			BIT(0)
+#define SW_HDR_ESP_MODE(a)		(((a) & 0x3) << 2)
+#define SW_IBUF_OP_MODE(a)		(((a) & 0x0F) << 8)
+#define SW_DMA_2FRM_MODE(a)		(((a) & 0x3) << 12)
+
+#define SW_CSI_LANE(a)			((a) & 0x3)
+#define SW_CSI_CH0_SEL(a)		(((a) & 0x7) << 4)
+#define SW_CSI_CH1_SEL(a)		(((a) & 0x7) << 8)
+#define SW_CSI_CH2_SEL(a)		(((a) & 0x7) << 12)
+#define SW_CSI_CH3_SEL(a)		(((a) & 0x7) << 16)
+#define SW_LVL0_SEL0_CSI1		BIT(20)
+#define SW_LVL0_SEL1_RAW0		BIT(21)
+#define SW_LVL0_SEL2_RAW1		BIT(22)
+#define SW_LVL0_SEL3_RAW3		BIT(23)
+#define SW_LVL1_SEL0(a)			(((a) & 0x3) << 24)
+#define SW_LVL1_SEL1(a)			(((a) & 0x3) << 26)
+#define SW_LVL1_SEL2(a)			(((a) & 0x3) << 28)
+
+#define SW_CSI_ID0(a)			((a) & 0xff)
+#define SW_CSI_ID1(a)			(((a) & 0xff) << 8)
+#define SW_CSI_ID2(a)			(((a) & 0xff) << 16)
+#define SW_CSI_ID3(a)			(((a) & 0xff) << 24)
+
+#define SW_CSI_ID4(a)			((a) & 0xff)
+#define SW_CSI_ID5(a)			(((a) & 0xff) << 8)
+#define SW_CSI_ID6(a)			(((a) & 0xff) << 16)
+#define SW_CSI_ID7(a)			(((a) & 0xff) << 24)
+
+#define RAW0_WR_FRAME			BIT(0)
+#define RAW1_WR_FRAME			BIT(1)
+#define RAW2_WR_FRAME			BIT(2)
+#define MIPI_DROP_FRM			BIT(3)
+#define RAW0_RD_FRAME			BIT(4)
+#define RAW1_RD_FRAME			BIT(5)
+#define RAW2_RD_FRAME			BIT(6)
+#define RAW0_Y_STATE			BIT(28)
+#define RAW1_Y_STATE			BIT(29)
+#define RAW2_Y_STATE			BIT(30)
+
+#define SW_CSI_RAW_WR_EN_ORG		BIT(0)
+#define SW_CSI_RAW_WR_SIMG_MODE		BIT(1)
+#define SW_CSI_RWA_WR_SIMG_SWP		BIT(2)
+#define SW_CSI_RAW_WR_H_OUT		BIT(3)
+#define SW_CSI_RAW_WR_CRC_OUT		BIT(4)
+#define SW_CSI_RAW_WR_CH_EN(a)		(((a) & 0xff) << 8)
+#define SW_CSI_RAW_WR_EN_SHD		BIT(31)
+
+#define SW_CSI_RAW_PIC_V_SIZE(a)	(((a) & 0x3FFF) << 16)
+#define SW_CSI_RAW_PIC_H_SIZE(a)	((a) & 0x3FFF)
+
+#define SW_CSI_RAW_PIC_V_OFF(a)		(((a) & 0x3FFF) << 16)
+#define SW_CSI_RAW_PIC_H_OFF(a)		((a) & 0x3FFF)
+
+#define SW_CSI_RAW0_RD_EN_ORG		BIT(0)
+#define SW_CSI_RAW1_RD_EN_ORG		BIT(1)
+#define SW_CSI_RAW2_RD_EN_ORG		BIT(2)
+#define SW_CSI_RAW_RD_SIMG_MOD		BIT(3)
+#define SW_CSI_RAW_RD_SIMG_SWP		BIT(4)
+#define SW_CSI_RAW_RD_CH_SEL(a)		(((a) & 0x7) << 5)
+
+#define SW_RAW_OUT_EN			BIT(0)
+#define SW_RAWFBC_EN			BIT(1)
+#define SW_RAWFBC_HEAD_DIFF_EN		BIT(4)
+#define SW_RAWFBC_HEAD_DIFF_NUM(a)	(((a) & 0x3) << 8)
+
+#define SW_CSI_ESP_LCNT_PADPIX(a)	((a) & 0xFFF)
+#define SW_CSI_ESP_LCNT_PADNUM(a)	(((a) & 0x3F) << 12)
+
+#define SW_CSI_ESP_IDCD_OBPIX(a)	((a) & 0x7F)
+#define SW_CSI_ESP_IDCD_EFPIX(a)	(((a) & 0x7F) << 16)
+
+#define SW_Y_STAT_INT_MODE_MASK		GENMASK(3, 2)
+#define SW_Y_STAT_RD_FRM_ID_MASK	GENMASK(5, 4)
+#define SW_Y_STAT_RD_TILE_ID_MASK	GENMASK(7, 6)
+#define SW_Y_STAT_EN			BIT(0)
+#define SW_Y_STAT_RD_EN			BIT(1)
+#define SW_Y_STAT_INT_MODE(a)		(((a) & 0x3) << 2)
+#define SW_Y_STAT_RD_FRM_ID(a)		(((a) & 0x3) << 4)
+#define SW_Y_STAT_RD_TILE_ID(a)		(((a) & 0x3) << 6)
+#define SW_Y_STAT_BLK_R(a)		(((a) & 0x1f) << 8)
+#define SW_Y_STAT_BLK_G(a)		(((a) & 0x1f) << 16)
+#define SW_Y_STAT_BLK_B(a)		(((a) & 0x1f) << 24)
+
+/* DEBAYER */
+#define SW_DEBAYER_EN			BIT(0)
+#define SW_DEBAYER_FILTER_G_EN		BIT(4)
+#define SW_DEBAYER_FILTER_C_EN		BIT(8)
+
+#define SW_DEBAYER_CLIP_EN		BIT(0)
+
+/* HDRMGE */
+#define SW_HDRMGE_EN			BIT(0)
+#define SW_HDRMGE_MODE_NORMAL		(0 << 2)
+#define SW_HDRMGE_MODE_FRAMEX2		BIT(2)
+#define SW_HDRMGE_MODE_FRAMEX3		(2 << 2)
+
+static inline bool dmatx_is_stream_stopped(void __iomem *base)
+{
+	return true;
+}
+
+static inline bool is_mpfbc_stopped(void __iomem *base)
+{
+	u32 ret = readl(base + ISP_MPFBC_CTRL);
+
+	return !(ret & SW_MPFBC_EN);
+}
+
+static inline void mi_wr_ctrl2(void __iomem *base, u32 val)
+{
+	void __iomem *addr = base + MI_WR_CTRL2;
+
+	writel(val | readl(addr), addr);
+}
+
+static inline void raw_wr_set_pic_size(struct rkisp_stream *stream,
+				       u32 width, u32 height)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+
+	writel(height << 16 | width,
+	       base + stream->config->dma.pic_size);
+}
+
+static inline void raw_wr_set_pic_offs(struct rkisp_stream *stream, u32 val)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+
+	writel(val, base + stream->config->dma.pic_offs);
+}
+
+static inline void raw_wr_ctrl(struct rkisp_stream *stream, u32 val)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+
+	writel(val, base + stream->config->dma.ctrl);
+}
+
+static inline void raw_wr_enable(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	void __iomem *addr = base + stream->config->dma.ctrl;
+
+	writel(SW_CSI_RAW_WR_EN_ORG | readl(addr), addr);
+}
+
+static inline void raw_wr_disable(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	void __iomem *addr = base + stream->config->dma.ctrl;
+
+	writel(~SW_CSI_RAW_WR_EN_ORG & readl(addr), addr);
+}
+
+static inline void mi_raw0_rd_set_addr(void __iomem *base, u32 val)
+{
+	writel(val, base + MI_RAW0_RD_BASE);
+}
+
+static inline void mi_raw1_rd_set_addr(void __iomem *base, u32 val)
+{
+	writel(val, base + MI_RAW1_RD_BASE);
+}
+
+static inline void mi_raw2_rd_set_addr(void __iomem *base, u32 val)
+{
+	writel(val, base + MI_RAW2_RD_BASE);
+}
+
+static inline void raw_rd_set_pic_size(void __iomem *base,
+				       u32 width, u32 height)
+{
+	writel(height << 16 | width,
+	       base + CSI2RX_RAW_RD_PIC_SIZE);
+}
+
+static inline void raw_rd_ctrl(void __iomem *base, u32 val)
+{
+	writel(val, base + CSI2RX_RAW_RD_CTRL);
+}
+
+#endif /* _RKISP1_REGS_V2X_H */
diff --git a/drivers/media/platform/rockchip/isp/rkisp.c b/drivers/media/platform/rockchip/isp/rkisp.c
index 5b1ab2518ee5..79e3c0b13767 100644
--- a/drivers/media/platform/rockchip/isp/rkisp.c
+++ b/drivers/media/platform/rockchip/isp/rkisp.c
@@ -48,6 +48,7 @@
 #include "common.h"
 #include "regs.h"
 
+#define ISP_SUBDEV_NAME DRIVER_NAME "-isp-subdev"
 /*
  * NOTE: MIPI controller and input MUX are also configured in this file,
  * because ISP Subdev is not only describe ISP submodule(input size,format, output size, format),
@@ -82,53 +83,72 @@ static inline struct rkisp_device *sd_to_isp_dev(struct v4l2_subdev *sd)
 	return container_of(sd->v4l2_dev, struct rkisp_device, v4l2_dev);
 }
 
+static int mbus_pixelcode_to_mipi_dt(u32 pixelcode)
+{
+	int mipi_dt;
+
+	switch (pixelcode) {
+	case MEDIA_BUS_FMT_Y8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+		mipi_dt = CIF_CSI2_DT_RAW8;
+		break;
+	case MEDIA_BUS_FMT_Y10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+		mipi_dt = CIF_CSI2_DT_RAW10;
+		break;
+	case MEDIA_BUS_FMT_Y12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+		mipi_dt = CIF_CSI2_DT_RAW12;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+	case MEDIA_BUS_FMT_VYUY8_2X8:
+		mipi_dt = CIF_CSI2_DT_YUV422_8b;
+		break;
+	default:
+		mipi_dt = -EINVAL;
+	}
+	return mipi_dt;
+}
+
 /* Get sensor by enabled media link */
 static struct v4l2_subdev *get_remote_sensor(struct v4l2_subdev *sd)
 {
 	struct media_pad *local, *remote;
 	struct media_entity *sensor_me;
+	struct v4l2_subdev *remote_sd = NULL;
 
 	local = &sd->entity.pads[RKISP_ISP_PAD_SINK];
 	if (!local)
-		return NULL;
-	remote = media_entity_remote_pad(local);
+		goto end;
+	remote = rkisp_media_entity_remote_pad(local);
 	if (!remote)
-		return NULL;
-
-	sensor_me = remote->entity;
-
-	return media_entity_to_v4l2_subdev(sensor_me);
-}
-
-static void get_remote_mipi_sensor(struct rkisp_device *dev,
-				  struct v4l2_subdev **sensor_sd)
-{
-	struct media_graph graph;
-	struct media_entity *entity = &dev->isp_sdev.sd.entity;
-	struct media_device *mdev = entity->graph_obj.mdev;
-	int ret;
-
-	/* Walk the graph to locate sensor nodes. */
-	mutex_lock(&mdev->graph_mutex);
-	ret = media_graph_walk_init(&graph, mdev);
-	if (ret) {
-		mutex_unlock(&mdev->graph_mutex);
-		*sensor_sd = NULL;
-		return;
-	}
-
-	media_graph_walk_start(&graph, entity);
-	while ((entity = media_graph_walk_next(&graph))) {
-		if (entity->function == MEDIA_ENT_F_CAM_SENSOR)
-			break;
+		goto end;
+
+	//skip csi subdev
+	if (!strcmp(remote->entity->name, CSI_DEV_NAME)) {
+		local = &remote->entity->pads[CSI_SINK];
+		if (!local)
+			goto end;
+		remote = media_entity_remote_pad(local);
+		if (!remote)
+			goto end;
 	}
-	mutex_unlock(&mdev->graph_mutex);
-	media_graph_walk_cleanup(&graph);
 
-	if (entity)
-		*sensor_sd = media_entity_to_v4l2_subdev(entity);
-	else
-		*sensor_sd = NULL;
+	sensor_me = remote->entity;
+	remote_sd = media_entity_to_v4l2_subdev(sensor_me);
+end:
+	return remote_sd;
 }
 
 static struct rkisp_sensor_info *sd_to_sensor(struct rkisp_device *dev,
@@ -143,12 +163,35 @@ static struct rkisp_sensor_info *sd_to_sensor(struct rkisp_device *dev,
 	return NULL;
 }
 
+struct media_pad *rkisp_media_entity_remote_pad(struct media_pad *pad)
+{
+	struct media_link *link;
+
+	list_for_each_entry(link, &pad->entity->links, list) {
+		if (!(link->flags & MEDIA_LNK_FL_ENABLED) ||
+		    !strcmp(link->source->entity->name,
+			    DMARX0_VDEV_NAME) ||
+		    !strcmp(link->source->entity->name,
+			    DMARX1_VDEV_NAME) ||
+		    !strcmp(link->source->entity->name,
+			    DMARX2_VDEV_NAME))
+			continue;
+		if (link->source == pad)
+			return link->sink;
+		if (link->sink == pad)
+			return link->source;
+	}
+
+	return NULL;
+}
+
 int rkisp_update_sensor_info(struct rkisp_device *dev)
 {
 	struct v4l2_subdev *sd = &dev->isp_sdev.sd;
 	struct rkisp_sensor_info *sensor;
 	struct v4l2_subdev *sensor_sd;
-	int ret = 0;
+	struct v4l2_subdev_format *fmt;
+	int i, ret = 0;
 
 	sensor_sd = get_remote_sensor(sd);
 	if (!sensor_sd)
@@ -159,11 +202,61 @@ int rkisp_update_sensor_info(struct rkisp_device *dev)
 			       &sensor->mbus);
 	if (ret && ret != -ENOIOCTLCMD)
 		return ret;
-	sensor->fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	ret = v4l2_subdev_call(sensor->sd, pad, get_fmt,
-			       &sensor->cfg, &sensor->fmt);
-	if (ret && ret != -ENOIOCTLCMD)
-		return ret;
+
+	if (sensor->mbus.type == V4L2_MBUS_CSI2) {
+		u8 vc = 0;
+
+		memset(dev->csi_dev.mipi_di, 0,
+		       sizeof(dev->csi_dev.mipi_di));
+		memset(sensor->fmt, 0, sizeof(sensor->fmt));
+		for (i = 0; i < dev->csi_dev.max_pad - 1; i++) {
+			fmt = &sensor->fmt[i];
+			fmt->pad = i;
+			fmt->which = V4L2_SUBDEV_FORMAT_ACTIVE;
+			ret = v4l2_subdev_call(sensor->sd, pad, get_fmt,
+					       &sensor->cfg, fmt);
+			if (ret && ret != -ENOIOCTLCMD)
+				return ret;
+			ret = mbus_pixelcode_to_mipi_dt(fmt->format.code);
+			if (ret < 0) {
+				v4l2_err(&dev->v4l2_dev,
+					 "Invalid mipi data type\n");
+				return ret;
+			}
+			/* v4l2_subdev_format reserved[0]
+			 * using as mipi virtual channel
+			 */
+			switch (fmt->reserved[0]) {
+			case V4L2_MBUS_CSI2_CHANNEL_3:
+				vc = 3;
+				break;
+			case V4L2_MBUS_CSI2_CHANNEL_2:
+				vc = 2;
+				break;
+			case V4L2_MBUS_CSI2_CHANNEL_1:
+				vc = 1;
+				break;
+			case V4L2_MBUS_CSI2_CHANNEL_0:
+			default:
+				vc = 0;
+			}
+			dev->csi_dev.mipi_di[i] = CIF_MIPI_DATA_SEL_DT(ret) |
+				CIF_MIPI_DATA_SEL_VC(vc);
+			v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+				  "CSI ch%d vc:%d dt:0x%x %dx%d\n",
+				  i, vc, ret,
+				  fmt->format.width,
+				  fmt->format.height);
+		}
+	} else {
+		sensor->fmt[0].pad = 0;
+		sensor->fmt[0].which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		ret = v4l2_subdev_call(sensor->sd, pad, get_fmt,
+				       &sensor->cfg, &sensor->fmt[0]);
+		if (ret && ret != -ENOIOCTLCMD)
+			return ret;
+	}
+
 	dev->active_sensor = sensor;
 
 	return ret;
@@ -226,6 +319,9 @@ static void rkisp_config_clk(struct rkisp_device *dev, int on)
 		CIF_ICCL_SRSZ_CLK | CIF_ICCL_JPEG_CLK | CIF_ICCL_MI_CLK |
 		CIF_ICCL_IE_CLK | CIF_ICCL_MIPI_CLK | CIF_ICCL_DCROP_CLK;
 
+	if (dev->isp_ver == ISP_V20 && on)
+		val |= ICCL_MPFBC_CLK;
+
 	writel(val, dev->base_addr + CIF_ICCL);
 
 	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13) {
@@ -236,6 +332,14 @@ static void rkisp_config_clk(struct rkisp_device *dev, int on)
 		      CIF_CLK_CTRL_CP | CIF_CLK_CTRL_IE;
 
 		writel(val, dev->base_addr + CIF_VI_ISP_CLK_CTRL_V12);
+	} else if (dev->isp_ver == ISP_V20) {
+		val = !on ? 0 :
+		      CLK_CTRL_MI_LDC | CLK_CTRL_MI_MP |
+		      CLK_CTRL_MI_JPEG | CLK_CTRL_MI_DP |
+		      CLK_CTRL_MI_Y12 | CLK_CTRL_MI_SP |
+		      CLK_CTRL_MI_RAW0 | CLK_CTRL_MI_RAW1 |
+		      CLK_CTRL_MI_READ | CLK_CTRL_MI_RAWRD;
+		writel(val, dev->base_addr + CTRL_VI_ISP_CLK_CTRL);
 	}
 }
 
@@ -250,6 +354,10 @@ static void rkisp_config_ism(struct rkisp_device *dev)
 	struct v4l2_rect *out_crop = &dev->isp_sdev.out_crop;
 	u32 val;
 
+	/* isp2.0 no ism */
+	if (dev->isp_ver == ISP_V20)
+		return;
+
 	writel(0, base + CIF_ISP_IS_RECENTER);
 	writel(0, base + CIF_ISP_IS_MAX_DX);
 	writel(0, base + CIF_ISP_IS_MAX_DY);
@@ -257,7 +365,7 @@ static void rkisp_config_ism(struct rkisp_device *dev)
 	writel(out_crop->left, base + CIF_ISP_IS_H_OFFS);
 	writel(out_crop->top, base + CIF_ISP_IS_V_OFFS);
 	writel(out_crop->width, base + CIF_ISP_IS_H_SIZE);
-	if (dev->stream[RKISP_STREAM_SP].interlaced)
+	if (dev->cap_dev.stream[RKISP_STREAM_SP].interlaced)
 		writel(out_crop->height / 2, base + CIF_ISP_IS_V_SIZE);
 	else
 		writel(out_crop->height, base + CIF_ISP_IS_V_SIZE);
@@ -277,7 +385,7 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 	struct ispsd_in_fmt *in_fmt;
 	struct ispsd_out_fmt *out_fmt;
 	struct v4l2_mbus_framefmt *in_frm;
-	struct v4l2_rect *out_crop, *in_crop;
+	struct v4l2_rect *in_crop;
 	struct rkisp_sensor_info *sensor;
 	void __iomem *base = dev->base_addr;
 	u32 isp_ctrl = 0;
@@ -290,7 +398,6 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 	in_frm = &dev->isp_sdev.in_frm;
 	in_fmt = &dev->isp_sdev.in_fmt;
 	out_fmt = &dev->isp_sdev.out_fmt;
-	out_crop = &dev->isp_sdev.out_crop;
 	in_crop = &dev->isp_sdev.in_crop;
 
 	if (in_fmt->fmt_type == FMT_BAYER) {
@@ -306,13 +413,23 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 			/* demosaicing bypass for grey sensor */
 			if (in_fmt->mbus_code == MEDIA_BUS_FMT_Y8_1X8 ||
 			    in_fmt->mbus_code == MEDIA_BUS_FMT_Y10_1X10 ||
-			    in_fmt->mbus_code == MEDIA_BUS_FMT_Y12_1X12)
-				writel(CIF_ISP_DEMOSAIC_BYPASS |
-				       CIF_ISP_DEMOSAIC_TH(0xc),
-				       base + CIF_ISP_DEMOSAIC);
-			else
-				writel(CIF_ISP_DEMOSAIC_TH(0xc),
-				       base + CIF_ISP_DEMOSAIC);
+			    in_fmt->mbus_code == MEDIA_BUS_FMT_Y12_1X12) {
+				if (dev->isp_ver == ISP_V20)
+					writel(0, base + ISP_DEBAYER_CONTROL);
+				else
+					writel(CIF_ISP_DEMOSAIC_BYPASS |
+					       CIF_ISP_DEMOSAIC_TH(0xc),
+					       base + CIF_ISP_DEMOSAIC);
+			} else {
+				if (dev->isp_ver == ISP_V20)
+					writel(SW_DEBAYER_EN |
+					       SW_DEBAYER_FILTER_G_EN |
+					       SW_DEBAYER_FILTER_C_EN,
+					       base + ISP_DEBAYER_CONTROL);
+				else
+					writel(CIF_ISP_DEMOSAIC_TH(0xc),
+					       base + CIF_ISP_DEMOSAIC);
+			}
 
 			if (sensor && sensor->mbus.type == V4L2_MBUS_BT656)
 				isp_ctrl = CIF_ISP_CTRL_ISP_MODE_BAYER_ITU656;
@@ -372,7 +489,7 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 	writel(in_crop->top, base + CIF_ISP_OUT_V_OFFS);
 	writel(in_crop->width, base + CIF_ISP_OUT_H_SIZE);
 
-	if (dev->stream[RKISP_STREAM_SP].interlaced) {
+	if (dev->cap_dev.stream[RKISP_STREAM_SP].interlaced) {
 		writel(in_frm->height / 2, base + CIF_ISP_ACQ_V_SIZE);
 		writel(in_crop->height / 2, base + CIF_ISP_OUT_V_SIZE);
 	} else {
@@ -432,138 +549,6 @@ static int rkisp_config_dvp(struct rkisp_device *dev)
 	return 0;
 }
 
-static int rkisp_config_mipi(struct rkisp_device *dev)
-{
-	u32 mipi_ctrl;
-	void __iomem *base = dev->base_addr;
-	struct ispsd_in_fmt *in_fmt = &dev->isp_sdev.in_fmt;
-	struct rkisp_sensor_info *sensor = dev->active_sensor;
-	struct v4l2_subdev *mipi_sensor;
-	struct v4l2_ctrl *ctrl;
-	u32 emd_vc, emd_dt;
-	int lanes, ret, i;
-
-	/*
-	 * sensor->mbus is set in isp or d-phy notifier_bound function
-	 */
-	switch (sensor->mbus.flags & V4L2_MBUS_CSI2_LANES) {
-	case V4L2_MBUS_CSI2_4_LANE:
-		lanes = 4;
-		break;
-	case V4L2_MBUS_CSI2_3_LANE:
-		lanes = 3;
-		break;
-	case V4L2_MBUS_CSI2_2_LANE:
-		lanes = 2;
-		break;
-	case V4L2_MBUS_CSI2_1_LANE:
-		lanes = 1;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	emd_vc = 0xFF;
-	emd_dt = 0;
-	dev->hdr_sensor = NULL;
-	get_remote_mipi_sensor(dev, &mipi_sensor);
-	if (mipi_sensor) {
-		ctrl = v4l2_ctrl_find(mipi_sensor->ctrl_handler,
-				      CIFISP_CID_EMB_VC);
-		if (ctrl)
-			emd_vc = v4l2_ctrl_g_ctrl(ctrl);
-
-		ctrl = v4l2_ctrl_find(mipi_sensor->ctrl_handler,
-				      CIFISP_CID_EMB_DT);
-		if (ctrl)
-			emd_dt = v4l2_ctrl_g_ctrl(ctrl);
-		dev->hdr_sensor = mipi_sensor;
-	}
-
-	dev->emd_dt = emd_dt;
-	dev->emd_vc = emd_vc;
-	dev->emd_data_idx = 0;
-	if (emd_vc <= CIF_ISP_ADD_DATA_VC_MAX) {
-		for (i = 0; i < RKISP_EMDDATA_FIFO_MAX; i++) {
-			ret = kfifo_alloc(&dev->emd_data_fifo[i].mipi_kfifo,
-					  CIFISP_ADD_DATA_FIFO_SIZE,
-					  GFP_ATOMIC);
-			if (ret) {
-				v4l2_err(&dev->v4l2_dev,
-					 "kfifo_alloc failed with error %d\n",
-					 ret);
-				return ret;
-			}
-		}
-	}
-
-	if (dev->isp_ver == ISP_V13 ||
-		dev->isp_ver == ISP_V12) {
-		/* lanes */
-		writel(lanes - 1, base + CIF_ISP_CSI0_CTRL1);
-
-		/* linecnt */
-		writel(0x3FFF, base + CIF_ISP_CSI0_CTRL2);
-
-		/* Configure Data Type and Virtual Channel */
-		writel(CIF_MIPI_DATA_SEL_DT(in_fmt->mipi_dt) | CIF_MIPI_DATA_SEL_VC(0),
-		       base + CIF_ISP_CSI0_DATA_IDS_1);
-
-		/* clear interrupts state */
-		readl(base + CIF_ISP_CSI0_ERR1);
-		readl(base + CIF_ISP_CSI0_ERR2);
-		readl(base + CIF_ISP_CSI0_ERR3);
-		/* set interrupts mask */
-		writel(0x1FFFFFF0, base + CIF_ISP_CSI0_MASK1);
-		writel(0x03FFFFFF, base + CIF_ISP_CSI0_MASK2);
-		writel(CIF_ISP_CSI0_IMASK_FRAME_END(0x3F) |
-		       CIF_ISP_CSI0_IMASK_RAW0_OUT_V_END |
-		       CIF_ISP_CSI0_IMASK_RAW1_OUT_V_END |
-		       CIF_ISP_CSI0_IMASK_LINECNT,
-		       base + CIF_ISP_CSI0_MASK3);
-	} else {
-		mipi_ctrl = CIF_MIPI_CTRL_NUM_LANES(lanes - 1) |
-			    CIF_MIPI_CTRL_SHUTDOWNLANES(0xf) |
-			    CIF_MIPI_CTRL_ERR_SOT_SYNC_HS_SKIP |
-			    CIF_MIPI_CTRL_CLOCKLANE_ENA;
-		writel(mipi_ctrl, base + CIF_MIPI_CTRL);
-
-		/* Configure Data Type and Virtual Channel */
-		writel(CIF_MIPI_DATA_SEL_DT(in_fmt->mipi_dt) | CIF_MIPI_DATA_SEL_VC(0),
-		       base + CIF_MIPI_IMG_DATA_SEL);
-
-		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) | CIF_MIPI_DATA_SEL_VC(emd_vc),
-		       base + CIF_MIPI_ADD_DATA_SEL_1);
-		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) | CIF_MIPI_DATA_SEL_VC(emd_vc),
-		       base + CIF_MIPI_ADD_DATA_SEL_2);
-		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) | CIF_MIPI_DATA_SEL_VC(emd_vc),
-		       base + CIF_MIPI_ADD_DATA_SEL_3);
-		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) | CIF_MIPI_DATA_SEL_VC(emd_vc),
-		       base + CIF_MIPI_ADD_DATA_SEL_4);
-
-		/* Clear MIPI interrupts */
-		writel(~0, base + CIF_MIPI_ICR);
-		/*
-		 * Disable CIF_MIPI_ERR_DPHY interrupt here temporary for
-		 * isp bus may be dead when switch isp.
-		 */
-		writel(CIF_MIPI_FRAME_END | CIF_MIPI_ERR_CSI | CIF_MIPI_ERR_DPHY |
-		       CIF_MIPI_SYNC_FIFO_OVFLW(0x0F) | CIF_MIPI_ADD_DATA_OVFLW,
-		       base + CIF_MIPI_IMSC);
-	}
-
-	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev, "\n  MIPI_CTRL 0x%08x\n"
-		 "  MIPI_IMG_DATA_SEL 0x%08x\n"
-		 "  MIPI_STATUS 0x%08x\n"
-		 "  MIPI_IMSC 0x%08x\n",
-		 readl(base + CIF_MIPI_CTRL),
-		 readl(base + CIF_MIPI_IMG_DATA_SEL),
-		 readl(base + CIF_MIPI_STATUS),
-		 readl(base + CIF_MIPI_IMSC));
-
-	return 0;
-}
-
 /* Configure MUX */
 static int rkisp_config_path(struct rkisp_device *dev)
 {
@@ -575,11 +560,10 @@ static int rkisp_config_path(struct rkisp_device *dev)
 		sensor->mbus.type == V4L2_MBUS_PARALLEL)) {
 		ret = rkisp_config_dvp(dev);
 		dpcl |= CIF_VI_DPCL_IF_SEL_PARALLEL;
-		dev->isp_inp = INP_DVP;
-	} else if (sensor && sensor->mbus.type == V4L2_MBUS_CSI2) {
-		ret = rkisp_config_mipi(dev);
+	} else if ((sensor && sensor->mbus.type == V4L2_MBUS_CSI2) ||
+		   dev->isp_inp & (INP_RAWRD0 |
+		   INP_RAWRD1 | INP_RAWRD2)) {
 		dpcl |= CIF_VI_DPCL_IF_SEL_MIPI;
-		dev->isp_inp = INP_CSI;
 	} else if (dev->isp_inp == INP_DMARX_ISP) {
 		dpcl |= CIF_VI_DPCL_DMA_SW_ISP;
 	}
@@ -597,8 +581,8 @@ static int rkisp_config_cif(struct rkisp_device *dev)
 
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "SP streaming = %d, MP streaming = %d\n",
-		 dev->stream[RKISP_STREAM_SP].streaming,
-		 dev->stream[RKISP_STREAM_MP].streaming);
+		 dev->cap_dev.stream[RKISP_STREAM_SP].streaming,
+		 dev->cap_dev.stream[RKISP_STREAM_MP].streaming);
 
 	cif_id = readl(dev->base_addr + CIF_VI_ID);
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev, "CIF_ID 0x%08x\n", cif_id);
@@ -682,8 +666,8 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "SP streaming = %d, MP streaming = %d\n",
-		 dev->stream[RKISP_STREAM_SP].streaming,
-		 dev->stream[RKISP_STREAM_MP].streaming);
+		 dev->cap_dev.stream[RKISP_STREAM_SP].streaming,
+		 dev->cap_dev.stream[RKISP_STREAM_MP].streaming);
 
 	/*
 	 * ISP(mi) stop in mi frame end -> Stop ISP(mipi) ->
@@ -697,6 +681,15 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 		readl(base + CIF_ISP_CSI0_ERR1);
 		readl(base + CIF_ISP_CSI0_ERR2);
 		readl(base + CIF_ISP_CSI0_ERR3);
+	} else if (dev->isp_ver == ISP_V20) {
+		writel(0, base + CSI2RX_MASK_PHY);
+		writel(0, base + CSI2RX_MASK_PACKET);
+		writel(0, base + CSI2RX_MASK_OVERFLOW);
+		writel(0, base + CSI2RX_MASK_STAT);
+		readl(base + CSI2RX_ERR_PHY);
+		readl(base + CSI2RX_ERR_PACKET);
+		readl(base + CSI2RX_ERR_OVERFLOW);
+		readl(base + CSI2RX_ERR_STAT);
 	} else {
 		writel(0, base + CIF_MIPI_IMSC);
 		writel(~0, base + CIF_MIPI_ICR);
@@ -709,7 +702,7 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 	writel(~0, base + CIF_MI_ICR);
 	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13) {
 		writel(0, base + CIF_ISP_CSI0_CTRL0);
-	} else {
+	} else if (dev->isp_ver < ISP_V12) {
 		val = readl(base + CIF_MIPI_CTRL);
 		val = val & (~CIF_MIPI_CTRL_SHUTDOWNLANES(0xf));
 		writel(val & (~CIF_MIPI_CTRL_OUTPUT_ENA), base + CIF_MIPI_CTRL);
@@ -727,8 +720,8 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 				  val, val & CIF_ISP_OFF, 20, 100);
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "streaming(MP:%d, SP:%d), MI_CTRL:%x, ISP_CTRL:%x, MIPI_CTRL:%x\n",
-		 dev->stream[RKISP_STREAM_SP].streaming,
-		 dev->stream[RKISP_STREAM_MP].streaming,
+		 dev->cap_dev.stream[RKISP_STREAM_SP].streaming,
+		 dev->cap_dev.stream[RKISP_STREAM_MP].streaming,
 		 readl(base + CIF_MI_CTRL),
 		 readl(base + CIF_ISP_CTRL),
 		 readl(base + CIF_MIPI_CTRL));
@@ -756,6 +749,8 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 		writel(0, base + CIF_ISP_CSI0_MASK1);
 		writel(0, base + CIF_ISP_CSI0_MASK2);
 		writel(0, base + CIF_ISP_CSI0_MASK3);
+	} else if (dev->isp_ver == ISP_V20) {
+		writel(0, base + CSI2RX_CSI2_RESETN);
 	}
 
 	rkisp_config_clk(dev, true);
@@ -764,8 +759,10 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 
 		domain = iommu_get_domain_for_dev(dev->dev);
 		if (domain) {
+#ifdef CONFIG_IOMMU_API
 			domain->ops->detach_dev(domain, dev->dev);
 			domain->ops->attach_dev(domain, dev->dev);
+#endif
 		}
 	}
 	dev->isp_state = ISP_STOP;
@@ -776,8 +773,8 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 		dev->emd_vc = 0xFF;
 	}
 
-	if (dev->hdr_sensor)
-		dev->hdr_sensor = NULL;
+	if (dev->hdr.sensor)
+		dev->hdr.sensor = NULL;
 
 	return 0;
 }
@@ -791,8 +788,8 @@ static int rkisp_isp_start(struct rkisp_device *dev)
 
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "SP streaming = %d, MP streaming = %d\n",
-		 dev->stream[RKISP_STREAM_SP].streaming,
-		 dev->stream[RKISP_STREAM_MP].streaming);
+		 dev->cap_dev.stream[RKISP_STREAM_SP].streaming,
+		 dev->cap_dev.stream[RKISP_STREAM_MP].streaming);
 
 	/* Activate MIPI */
 	if (sensor && sensor->mbus.type == V4L2_MBUS_CSI2) {
@@ -803,7 +800,7 @@ static int rkisp_isp_start(struct rkisp_device *dev)
 			readl(base + CIF_ISP_CSI0_ERR3);
 			/* csi2host enable */
 			writel(1, base + CIF_ISP_CSI0_CTRL0);
-		} else {
+		} else if (dev->isp_ver < ISP_V12) {
 			val = readl(base + CIF_MIPI_CTRL);
 			writel(val | CIF_MIPI_CTRL_OUTPUT_ENA,
 			       base + CIF_MIPI_CTRL);
@@ -827,8 +824,8 @@ static int rkisp_isp_start(struct rkisp_device *dev)
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "SP streaming = %d, MP streaming = %d MI_CTRL 0x%08x\n"
 		 "  ISP_CTRL 0x%08x MIPI_CTRL 0x%08x\n",
-		 dev->stream[RKISP_STREAM_SP].streaming,
-		 dev->stream[RKISP_STREAM_MP].streaming,
+		 dev->cap_dev.stream[RKISP_STREAM_SP].streaming,
+		 dev->cap_dev.stream[RKISP_STREAM_MP].streaming,
 		 readl(base + CIF_MI_CTRL),
 		 readl(base + CIF_ISP_CTRL),
 		 readl(base + CIF_MIPI_CTRL));
@@ -1079,7 +1076,7 @@ static int rkisp_isp_sd_enum_mbus_code(struct v4l2_subdev *sd,
 					struct v4l2_subdev_pad_config *cfg,
 					struct v4l2_subdev_mbus_code_enum *code)
 {
-	int i = code->index;
+	unsigned int i = code->index;
 
 	if (code->pad == RKISP_ISP_PAD_SINK) {
 		if (i >= ARRAY_SIZE(rkisp_isp_input_formats))
@@ -1200,10 +1197,8 @@ static int rkisp_isp_sd_set_fmt(struct v4l2_subdev *sd,
 	rkisp_isp_sd_try_fmt(sd, fmt->pad, mf);
 
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
-		struct v4l2_mbus_framefmt *try_mf;
-
 		mf = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
-		*try_mf = *mf;
+		fmt->format = *mf;
 		return 0;
 	}
 
@@ -1328,7 +1323,7 @@ static int rkisp_isp_sd_set_selection(struct v4l2_subdev *sd,
 		struct v4l2_rect *try_sel;
 
 		try_sel = v4l2_subdev_get_try_crop(sd, cfg, sel->pad);
-		*try_sel = sel->r;
+		sel->r = *try_sel;
 		return 0;
 	}
 
@@ -1349,6 +1344,10 @@ static void rkisp_isp_read_add_fifo_data(struct rkisp_device *dev)
 	u32 fifo_data = 0;
 	u32 i, idx, cur_frame_id;
 
+	if (dev->isp_ver != ISP_V10 &&
+	    dev->isp_ver != ISP_V10_1)
+		return;
+
 	cur_frame_id = atomic_read(&dev->isp_sdev.frm_sync_seq) - 1;
 	idx = dev->emd_data_idx;
 	dev->emd_data_fifo[idx].frame_id = 0;
@@ -1439,16 +1438,76 @@ static int rkisp_subdev_link_setup(struct media_entity *entity,
 				    u32 flags)
 {
 	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
-	struct rkisp_device *dev = sd_to_isp_dev(sd);
+	struct rkisp_device *dev;
+	u8 rawrd = INP_RAWRD0 | INP_RAWRD1 | INP_RAWRD2;
 
+	if (!sd)
+		return -ENODEV;
+	dev = sd_to_isp_dev(sd);
 	if (!strcmp(remote->entity->name, DMA_VDEV_NAME)) {
-		if (flags & MEDIA_LNK_FL_ENABLED)
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (dev->isp_inp)
+				goto err;
+			if (dev->active_sensor)
+				dev->active_sensor = NULL;
 			dev->isp_inp = INP_DMARX_ISP;
-		else
+		} else {
 			dev->isp_inp = INP_INVAL;
+		}
+	} else if (!strcmp(remote->entity->name, CSI_DEV_NAME)) {
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (dev->isp_inp & ~(INP_CSI | rawrd))
+				goto err;
+			dev->isp_inp |= INP_CSI;
+		} else {
+			dev->isp_inp &= ~INP_CSI;
+		}
+	} else if (!strcmp(remote->entity->name, DMARX0_VDEV_NAME)) {
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (dev->isp_inp == INP_DMARX_ISP)
+				goto err;
+			dev->isp_inp |= INP_RAWRD0;
+		} else {
+			dev->isp_inp &= ~INP_RAWRD0;
+		}
+	} else if (!strcmp(remote->entity->name, DMARX1_VDEV_NAME)) {
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (dev->isp_inp == INP_DMARX_ISP)
+				goto err;
+			dev->isp_inp |= INP_RAWRD1;
+		} else {
+			dev->isp_inp &= ~INP_RAWRD1;
+		}
+	} else if (!strcmp(remote->entity->name, DMARX2_VDEV_NAME)) {
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (dev->isp_inp == INP_DMARX_ISP)
+				goto err;
+			dev->isp_inp |= INP_RAWRD2;
+		} else {
+			dev->isp_inp &= ~INP_RAWRD2;
+		}
+	} else {
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (dev->isp_inp & ~(INP_DVP | rawrd))
+				goto err;
+			dev->isp_inp |= INP_DVP;
+		} else {
+			dev->isp_inp &= ~INP_INVAL;
+		}
 	}
 
+	if (dev->isp_inp & rawrd)
+		dev->dmarx_dev.trigger = T_MANUAL;
+	else
+		dev->dmarx_dev.trigger = T_AUTO;
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "isp input:0x%x\n", dev->isp_inp);
 	return 0;
+err:
+	v4l2_err(sd, "dmaread can't work with other input\n"
+		 "csi dvp can't work together\n");
+	return -EINVAL;
 }
 
 static int rkisp_subdev_link_validate(struct media_link *link)
@@ -1459,6 +1518,7 @@ static int rkisp_subdev_link_validate(struct media_link *link)
 	return v4l2_subdev_link_validate(link);
 }
 
+#ifdef CONFIG_MEDIA_CONTROLLER
 static int rkisp_subdev_fmt_link_validate(struct v4l2_subdev *sd,
 			     struct media_link *link,
 			     struct v4l2_subdev_format *source_fmt,
@@ -1474,9 +1534,10 @@ static int rkisp_subdev_fmt_link_validate(struct v4l2_subdev *sd,
 
 	return 0;
 }
+#endif
 
 static void
-riksp1_isp_queue_event_sof(struct rkisp_isp_subdev *isp)
+rkisp_isp_queue_event_sof(struct rkisp_isp_subdev *isp)
 {
 	struct v4l2_event event = {
 		.type = V4L2_EVENT_FRAME_SYNC,
@@ -1505,7 +1566,9 @@ static const struct v4l2_subdev_pad_ops rkisp_isp_sd_pad_ops = {
 	.set_selection = rkisp_isp_sd_set_selection,
 	.get_fmt = rkisp_isp_sd_get_fmt,
 	.set_fmt = rkisp_isp_sd_set_fmt,
+#ifdef CONFIG_MEDIA_CONTROLLER
 	.link_validate = rkisp_subdev_fmt_link_validate,
+#endif
 };
 
 static const struct media_entity_operations rkisp_isp_sd_media_ops = {
@@ -1563,7 +1626,7 @@ int rkisp_register_isp_subdev(struct rkisp_device *isp_dev,
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
 	sd->entity.ops = &rkisp_isp_sd_media_ops;
 	sd->entity.function = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;
-	snprintf(sd->name, sizeof(sd->name), "rkisp1-isp-subdev");
+	snprintf(sd->name, sizeof(sd->name), ISP_SUBDEV_NAME);
 
 	isp_sdev->pads[RKISP_ISP_PAD_SINK].flags =
 		MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;
@@ -1586,7 +1649,7 @@ int rkisp_register_isp_subdev(struct rkisp_device *isp_dev,
 	}
 
 	rkisp_isp_sd_init_default_fmt(isp_sdev);
-	isp_dev->hdr_sensor = NULL;
+	isp_dev->hdr.sensor = NULL;
 	isp_dev->isp_state = ISP_STOP;
 
 	return 0;
@@ -1611,6 +1674,9 @@ void rkisp_mipi_isr(unsigned int mis, struct rkisp_device *dev)
 	void __iomem *base = dev->base_addr;
 	u32 val;
 
+	v4l2_dbg(3, rkisp_debug, &dev->v4l2_dev,
+		 "mipi isr:0x%x\n", mis);
+
 	writel(~0, base + CIF_MIPI_ICR);
 
 	/*
@@ -1654,6 +1720,10 @@ void rkisp_mipi_v13_isr(unsigned int err1, unsigned int err2,
 	void __iomem *base = dev->base_addr;
 	u32 val, mask;
 
+	v4l2_dbg(3, rkisp_debug, &dev->v4l2_dev,
+		 "mipi isr err1:0x%x err2:0x%x err3:0x%x\n",
+		 err1, err2, err3);
+
 	/*
 	 * Disable DPHY errctrl interrupt, because this dphy
 	 * erctrl signal is asserted until the next changes
@@ -1702,9 +1772,12 @@ void rkisp_isp_isr(unsigned int isp_mis, struct rkisp_device *dev)
 	unsigned int isp_mis_tmp = 0;
 	unsigned int isp_err = 0;
 
+	v4l2_dbg(3, rkisp_debug, &dev->v4l2_dev,
+		 "isp isr:0x%x\n", isp_mis);
+
 	/* start edge of v_sync */
 	if (isp_mis & CIF_ISP_V_START) {
-		if (dev->stream[RKISP_STREAM_SP].interlaced) {
+		if (dev->cap_dev.stream[RKISP_STREAM_SP].interlaced) {
 			/* 0 = ODD 1 = EVEN */
 			if (dev->active_sensor->mbus.type == V4L2_MBUS_CSI2) {
 				void __iomem *addr = NULL;
@@ -1717,16 +1790,16 @@ void rkisp_isp_isr(unsigned int isp_mis, struct rkisp_device *dev)
 					addr = base + CIF_ISP_CSI0_FRAME_NUM_RO;
 
 				if (addr)
-					dev->stream[RKISP_STREAM_SP].u.sp.field =
+					dev->cap_dev.stream[RKISP_STREAM_SP].u.sp.field =
 						(readl(addr) >> 16) % 2;
 			} else {
-				dev->stream[RKISP_STREAM_SP].u.sp.field =
+				dev->cap_dev.stream[RKISP_STREAM_SP].u.sp.field =
 					(readl(base + CIF_ISP_FLAGS_SHD) >> 2) & BIT(0);
 			}
 		}
 
 		if (dev->vs_irq < 0)
-			riksp1_isp_queue_event_sof(&dev->isp_sdev);
+			rkisp_isp_queue_event_sof(&dev->isp_sdev);
 
 		writel(CIF_ISP_V_START, base + CIF_ISP_ICR);
 		isp_mis_tmp = readl(base + CIF_ISP_MIS);
@@ -1809,7 +1882,7 @@ irqreturn_t rkisp_vs_isr_handler(int irq, void *ctx)
 	struct rkisp_device *rkisp_dev = dev_get_drvdata(dev);
 
 	if (rkisp_dev->vs_irq >= 0)
-		riksp1_isp_queue_event_sof(&rkisp_dev->isp_sdev);
+		rkisp_isp_queue_event_sof(&rkisp_dev->isp_sdev);
 
 	return IRQ_HANDLED;
 }
diff --git a/drivers/media/platform/rockchip/isp/rkisp.h b/drivers/media/platform/rockchip/isp/rkisp.h
index 28efb763bdb6..4303db6380dc 100644
--- a/drivers/media/platform/rockchip/isp/rkisp.h
+++ b/drivers/media/platform/rockchip/isp/rkisp.h
@@ -134,10 +134,16 @@ void rkisp_mipi_isr(unsigned int mipi_mis, struct rkisp_device *dev);
 void rkisp_mipi_v13_isr(unsigned int err1, unsigned int err2,
 			       unsigned int err3, struct rkisp_device *dev);
 
+void rkisp_mipi_v20_isr(unsigned int phy, unsigned int packet,
+			 unsigned int overflow, unsigned int state,
+			 struct rkisp_device *dev);
+
 void rkisp_isp_isr(unsigned int isp_mis, struct rkisp_device *dev);
 
 irqreturn_t rkisp_vs_isr_handler(int irq, void *ctx);
 
+struct media_pad *rkisp_media_entity_remote_pad(struct media_pad *pad);
+
 int rkisp_update_sensor_info(struct rkisp_device *dev);
 
 u32 rkisp_mbus_pixelcode_to_v4l2(u32 pixelcode);
diff --git a/include/uapi/linux/rk-camera-module.h b/include/uapi/linux/rk-camera-module.h
index 9883565799e7..36ef98304b6e 100644
--- a/include/uapi/linux/rk-camera-module.h
+++ b/include/uapi/linux/rk-camera-module.h
@@ -29,6 +29,9 @@
 #define RKMODULE_LSC_CFG	\
 	_IOW('V', BASE_VIDIOC_PRIVATE + 3, struct rkmodule_lsc_cfg)
 
+#define RKMODULE_HDR_CFG       \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 4, struct rkmodule_hdr_cfg)
+
 /**
  * struct rkmodule_base_inf - module base information
  *
@@ -143,4 +146,53 @@ struct rkmodule_lsc_cfg {
 	__u32 enable;
 } __attribute__ ((packed));
 
+/**
+ * NO_HDR: linear mode
+ * HDR_X2: hdr two frame or line mode
+ * HDR_X3: hdr three or line mode
+ */
+enum rkmodule_hdr_mode {
+	NO_HDR = 0,
+	HDR_X2 = 5,
+	HDR_X3 = 6,
+};
+
+/**
+ * HDR_NORMAL_VC: hdr frame with diff virtual channels
+ * HDR_LINE_CNT: hdr frame with line counter
+ * HDR_ID_CODE: hdr frame with identification code
+ */
+enum hdr_esp_mode {
+	HDR_NORMAL_VC = 0,
+	HDR_LINE_CNT,
+	HDR_ID_CODE,
+};
+
+/**
+ * lcnt: line counter
+ *     padnum: the pixels of padding row
+ *     padpix: the payload of padding
+ * idcd: identification code
+ *     efpix: identification code of Effective line
+ *     obpix: identification code of OB line
+ */
+struct rkmodule_hdr_esp {
+	enum hdr_esp_mode mode;
+	union {
+		struct {
+			__u32 padnum;
+			__u32 padpix;
+		} lcnt;
+		struct {
+			__u32 efpix;
+			__u32 obpix;
+		} idcd;
+	} val;
+};
+
+struct rkmodule_hdr_cfg {
+	__u32 hdr_mode;
+	struct rkmodule_hdr_esp esp;
+} __attribute__ ((packed));
+
 #endif /* _UAPI_RKMODULE_CAMERA_H */
-- 
2.35.3

