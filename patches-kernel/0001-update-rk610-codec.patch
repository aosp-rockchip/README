From d4ffe5761027b1340a3fc2eeaeed1bea49cef7e1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E9=82=B1=E5=BB=BA=E6=96=8C?= <qjb@rock-chips.com>
Date: Fri, 30 Mar 2012 16:11:53 +0800
Subject: [PATCH] update rk610 codec

---
 arch/arm/mach-rk30/board-rk30-sdk.c  |  34 +-
 drivers/mfd/rk610-core.c             |  88 ++--
 drivers/video/display/tve/rk610_tv.h |  12 +-
 sound/soc/codecs/rk610_codec.c       | 625 ++++++---------------------
 sound/soc/codecs/rk610_codec.h       |   3 +-
 sound/soc/rk29/Kconfig               |  25 +-
 sound/soc/rk29/rk29_jetta_codec.c    | 132 +-----
 7 files changed, 266 insertions(+), 653 deletions(-)
 mode change 100644 => 100755 drivers/mfd/rk610-core.c
 mode change 100644 => 100755 sound/soc/codecs/rk610_codec.c
 mode change 100644 => 100755 sound/soc/rk29/rk29_jetta_codec.c

diff --git a/arch/arm/mach-rk30/board-rk30-sdk.c b/arch/arm/mach-rk30/board-rk30-sdk.c
index fe44cc9b1a95..6840637593ce 100755
--- a/arch/arm/mach-rk30/board-rk30-sdk.c
+++ b/arch/arm/mach-rk30/board-rk30-sdk.c
@@ -974,7 +974,7 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 		.platform_data = &akm8975_info,
 	},
 #endif
-#if defined (CONFIG_GYRO_L3G4200D)
+#if defined (CONFIG_GYRO_L3G4200D1)
 	{
 		.type          = "l3g4200d_gryo",
 		.addr          = 0x69,
@@ -1003,6 +1003,36 @@ static struct i2c_board_info __initdata i2c0_info[] = {
         },
 #endif
 
+#ifdef CONFIG_MFD_RK610
+		{
+			.type			= "rk610_ctl",
+			.addr			= 0x40,
+			.flags			= 0,
+		},
+#ifdef CONFIG_RK610_TVOUT
+		{
+			.type			= "rk610_tvout",
+			.addr			= 0x42,
+			.flags			= 0,
+		},
+#endif
+#ifdef CONFIG_RK610_HDMI
+		{
+			.type			= "rk610_hdmi",
+			.addr			= 0x46,
+			.flags			= 0,
+			.irq			= RK29_PIN5_PA2,
+		},
+#endif
+#ifdef CONFIG_SND_SOC_RK610
+		{//RK610_CODEC addr  from 0x60 to 0x80 (0x60~0x80)
+			.type			= "rk610_i2c_codec",
+			.addr			= 0x60,
+			.flags			= 0,
+		},
+#endif
+#endif
+
 };
 #endif
 
@@ -1036,7 +1066,7 @@ static struct i2c_board_info __initdata i2c2_info[] = {
 #if defined (CONFIG_LS_CM3217)
 	{
 		.type          = "lightsensor",
-		.addr          = 0x10,
+		.addr          = 0x20,
 		.flags         = 0,
 		.irq           = CM3217_IRQ_PIN,
 		.platform_data = &cm3217_info,
diff --git a/drivers/mfd/rk610-core.c b/drivers/mfd/rk610-core.c
old mode 100644
new mode 100755
index 93e24d65c816..94b4c487134d
--- a/drivers/mfd/rk610-core.c
+++ b/drivers/mfd/rk610-core.c
@@ -9,7 +9,20 @@
 #include <mach/iomux.h>
 #include <linux/err.h>
 
+#ifdef CONFIG_ARCH_RK30
+#define RK610_RESET_PIN   RK30_PIN0_PC6
+#else
 #define RK610_RESET_PIN   RK29_PIN6_PC1
+#endif
+
+/*
+ * Debug
+ */
+#if 0
+#define	DBG(x...)	printk(KERN_INFO x)
+#else
+#define	DBG(x...)
+#endif
 
 static struct i2c_client *rk610_control_client = NULL;
 #ifdef CONFIG_RK610_LCD
@@ -20,16 +33,16 @@ int rk610_lcd_init(struct i2c_client *client){}
 int rk610_control_send_byte(const char reg, const char data)
 {
 	int ret;
-	
-	printk("reg = 0x%02x, val=0x%02x\n", reg ,data);
-	
+
+	DBG("reg = 0x%02x, val=0x%02x\n", reg ,data);
+
 	if(rk610_control_client == NULL)
 		return -1;
 	//i2c_master_reg8_send
 	ret = i2c_master_reg8_send(rk610_control_client, reg, &data, 1, 100*1000);
 	if (ret > 0)
 		ret = 0;
-	
+
 	return ret;
 }
 
@@ -40,13 +53,13 @@ int rk610_codec_pll_set(unsigned int rate)
 	char N, M, NO, DIV;
 	unsigned int F;
 	char data;
-	
+
 	if(current_pll_value == rate)
 		return 0;
-	
+
     // Input clock is 12MHz.
 	if(rate == 11289600) {
-		// For 11.2896MHz, N = 2 M= 75 F = 0.264(0x43958) NO = 8 
+		// For 11.2896MHz, N = 2 M= 75 F = 0.264(0x43958) NO = 8
 		N = 2;
 		NO = 3;
 		M = 75;
@@ -54,7 +67,7 @@ int rk610_codec_pll_set(unsigned int rate)
 		DIV = 5;
 	}
 	else if(rate == 12288000) {
-		// For 12.2888MHz, N = 2 M= 75 F = 0.92(0xEB851) NO = 8 
+		// For 12.2888MHz, N = 2 M= 75 F = 0.92(0xEB851) NO = 8
 		N = 2;
 		NO = 3;
 		M = 75;
@@ -65,12 +78,12 @@ int rk610_codec_pll_set(unsigned int rate)
 		printk(KERN_ERR "[%s] not support such frequency\n", __FUNCTION__);
 		return -1;
 	}
-	
+
 	//Enable codec pll fractional number and power down.
     data = 0x00;
     rk610_control_send_byte(RK610_CONTROL_REG_C_PLL_CON5, data);
 	msleep(10);
-	
+
     data = (N << 4) | NO;
     rk610_control_send_byte(RK610_CONTROL_REG_C_PLL_CON0, data);
     // M
@@ -83,20 +96,20 @@ int rk610_codec_pll_set(unsigned int rate)
     rk610_control_send_byte(RK610_CONTROL_REG_C_PLL_CON3, data);
     data = (F >> 16) & 0xFF;
     rk610_control_send_byte(RK610_CONTROL_REG_C_PLL_CON4, data);
-    
+
     // i2s mclk = codec_pll/5;
     i2c_master_reg8_recv(rk610_control_client, RK610_CONTROL_REG_CLOCK_CON1, &data, 1, 100*1000);
     data &= ~CLOCK_CON1_I2S_DVIDER_MASK;
     data |= (DIV - 1);
     rk610_control_send_byte(RK610_CONTROL_REG_CLOCK_CON1, data);
-    
+
     // Power up codec pll.
     data |= C_PLL_POWER_ON;
     rk610_control_send_byte(RK610_CONTROL_REG_C_PLL_CON5, data);
-    
+
     current_pll_value = rate;
-    printk(KERN_ERR "[%s] rate %u\n", __FUNCTION__, rate);
-    
+    DBG("[%s] rate %u\n", __FUNCTION__, rate);
+
     return 0;
 }
 
@@ -105,20 +118,20 @@ void rk610_control_init_codec(void)
     struct i2c_client *client = rk610_control_client;
     char data = 0;
     int ret;
-    
+
     if(rk610_control_client == NULL)
     	return;
-    printk(KERN_ERR "[%s] start\n", __FUNCTION__);
-    
+	DBG("[%s] start\n", __FUNCTION__);
+
     //gpio_set_value(RK610_RESET_PIN, GPIO_LOW); //reset rk601
    // mdelay(100);
     //gpio_set_value(RK610_RESET_PIN, GPIO_HIGH);
     //mdelay(100);
-    
+
    	// Set i2c glitch timeout.
 	data = 0x22;
 	ret = i2c_master_reg8_send(client, RK610_CONTROL_REG_I2C_CON, &data, 1, 20*1000);
-	
+
 //    rk610_codec_pll_set(11289600);
 
     //use internal codec, enable DAC ADC LRCK output.
@@ -127,18 +140,18 @@ void rk610_control_init_codec(void)
 //	data = CODEC_CON_BIT_ADC_LRCK_OUTPUT_DISABLE;
 	data = 0;
    	rk610_control_send_byte(RK610_CONTROL_REG_CODEC_CON, data);
-    
+
     // Select internal i2s clock from codec_pll.
-    i2c_master_reg8_recv(rk610_control_client, RK610_CONTROL_REG_CLOCK_CON1, &data, 1, 100*1000); 
+    i2c_master_reg8_recv(rk610_control_client, RK610_CONTROL_REG_CLOCK_CON1, &data, 1, 100*1000);
 //    data |= CLOCK_CON1_I2S_CLK_CODEC_PLL;
 	data = 0;
     rk610_control_send_byte(RK610_CONTROL_REG_CLOCK_CON1, data);
-    
+
     i2c_master_reg8_recv(client, RK610_CONTROL_REG_CODEC_CON, &data, 1, 100*1000);
-    printk(KERN_ERR "[%s] RK610_CONTROL_REG_CODEC_CON is %x\n", __FUNCTION__, data);
-    
+    DBG("[%s] RK610_CONTROL_REG_CODEC_CON is %x\n", __FUNCTION__, data);
+
     i2c_master_reg8_recv(client, RK610_CONTROL_REG_CLOCK_CON1, &data, 1, 100*1000);
-    printk(KERN_ERR "[%s] RK610_CONTROL_REG_CLOCK_CON1 is %x\n", __FUNCTION__, data);
+    DBG("[%s] RK610_CONTROL_REG_CLOCK_CON1 is %x\n", __FUNCTION__, data);
 }
 #endif
 #ifdef CONFIG_RK610_DEBUG
@@ -177,12 +190,12 @@ static ssize_t rk610_store_reg_attrs(struct device *dev,
 	struct i2c_client *client=NULL;
 	static char val=0,reg=0;
 	client = rk610_control_client;
-	printk("/**********rk610 reg config******/");
+	DBG("/**********rk610 reg config******/");
 
 	sscanf(buf, "%x%x", &val,&reg);
-	printk("reg=%x val=%x\n",reg,val);
+	DBG("reg=%x val=%x\n",reg,val);
 	rk610_write_p0_reg(client, reg,  &val);
-	printk("val=%x\n",val);
+	DBG("val=%x\n",val);
 	return size;
 }
 
@@ -195,28 +208,34 @@ static int rk610_control_probe(struct i2c_client *client,
 {
     int ret;
     struct clk *iis_clk;
-    
+	
+	DBG("[%s] start\n", __FUNCTION__);
+	
 		iis_clk = clk_get_sys("rk29_i2s.0", "i2s");
 		if (IS_ERR(iis_clk)) {
 			printk("failed to get i2s clk\n");
 			ret = PTR_ERR(iis_clk);
 		}else{
-			printk("got i2s clk ok!\n");
+			DBG("got i2s clk ok!\n");
 			clk_enable(iis_clk);
 			clk_set_rate(iis_clk, 11289600);
+			#ifdef CONFIG_ARCH_RK29
 			rk29_mux_api_set(GPIO2D0_I2S0CLK_MIIRXCLKIN_NAME, GPIO2H_I2S0_CLK);
+			#else
+			rk30_mux_api_set(GPIO0B0_I2S8CHCLK_NAME, GPIO0B_I2S_8CH_CLK);
+			#endif
 			clk_put(iis_clk);
 		}
-		
+
     rk610_control_client = client;
     msleep(100);
 	if(RK610_RESET_PIN != INVALID_GPIO) {
 	    ret = gpio_request(RK610_RESET_PIN, "rk610 reset");
-	    if (ret){   
+	    if (ret){
 	        printk(KERN_ERR "rk610_control_probe request gpio fail\n");
 	    }
 	    else {
-	    	printk(KERN_ERR "rk610_control_probe request gpio ok\n");
+	    	DBG("rk610_control_probe request gpio ok\n");
 	    	gpio_direction_output(RK610_RESET_PIN, GPIO_HIGH);
 	    	msleep(100);
 		    gpio_direction_output(RK610_RESET_PIN, GPIO_LOW);
@@ -253,6 +272,7 @@ static struct i2c_driver rk610_control_driver = {
 
 static int __init rk610_control_init(void)
 {
+	DBG("[%s] start\n", __FUNCTION__);
 	return i2c_add_driver(&rk610_control_driver);
 }
 
diff --git a/drivers/video/display/tve/rk610_tv.h b/drivers/video/display/tve/rk610_tv.h
index 95ca56106cc0..35dc0c11527b 100644
--- a/drivers/video/display/tve/rk610_tv.h
+++ b/drivers/video/display/tve/rk610_tv.h
@@ -4,7 +4,9 @@
 #include <linux/fb.h>
 #include <mach/board.h>
 #include <mach/gpio.h>
+#ifdef CONFIG_ARCH_RK29
 #include <mach/rk29_iomap.h>
+#endif
 #include "../screen/screen.h"
 #include "../../rk29_fb.h"
 #include <linux/mfd/rk610_core.h>
@@ -20,7 +22,7 @@
 	#define TVE_VFCR_PAL_M						1
 	#define TVE_VFCR_PAL_B_N					2
 	#define TVE_VFCR_PAL_NC						3
-	
+
 #define TVE_VINCR		0x01
 	#define TVE_VINCR_PIX_DATA_DELAY(n)			(n << 5)
 	#define TVE_VINCR_H_SYNC_POLARITY_NEGTIVE	0 << 4
@@ -36,7 +38,7 @@ enum {
 	#define TVE_VINCR_INPUT_FORMAT(n)			(n << 1)
 	#define TVE_VINCR_VSYNC_FUNCTION_VSYNC		0
 	#define TVE_VINCR_VSYNC_FUNCTION_FIELD		1
-	
+
 #define TVE_VOUTCR		0x02
 	#define TVE_VOUTCR_OUTPUT_CVBS				0 << 6
 	#define TVE_VOUTCR_OUTPUT_YPBPR				1 << 6
@@ -44,14 +46,14 @@ enum {
 	#define TVE_VOUTCR_OUTPUT_ENABLE_BLACK		1 << 4
 	#define TVE_VOUTCR_DISABLE_CVBS_COLOR		1 << 3
 	#define TVE_VOUTCR_CVBS_Y2C_DELAY(n)				(n << 0)
-	
+
 #define TVE_POWERCR		0x03
 	#define TVE_PIX_CLK_INVERSE_ENABLE			1 << 4
 	#define TVE_DAC_CLK_INVERSE_DISABLE			1 << 3
 	#define TVE_DAC_Y_ENABLE					1 << 2
 	#define TVE_DAC_U_ENABLE					1 << 1
 	#define TVE_DAC_V_ENABLE					1 << 0
-	
+
 #define TVE_HDTVCR		0x05
 	#define TVE_RESET							1 << 7
 	#define TVE_FILTER(n)						(n << 5)
@@ -65,7 +67,7 @@ enum {
 	#define TVE_OUTPUT_MODE_576P				1
 	#define TVE_OUTPUT_MODE_480P				2
 	#define TVE_OUTPUT_MODE_720P				3
-	
+
 #define TVE_YADJCR		0x06
 	#define TVE_OUTPUT_MODE_1080P				1 << 6
 	#define TVE_OUTPUT_MODE_1080I				1 << 5
diff --git a/sound/soc/codecs/rk610_codec.c b/sound/soc/codecs/rk610_codec.c
old mode 100644
new mode 100755
index 380309b31080..416b7402fd94
--- a/sound/soc/codecs/rk610_codec.c
+++ b/sound/soc/codecs/rk610_codec.c
@@ -27,27 +27,27 @@
 #include <sound/initval.h>
 #include <mach/gpio.h>
 #include <mach/iomux.h>
-
+#include <linux/workqueue.h>
 #include "rk610_codec.h"
 
+#ifdef CONFIG_ARCH_RK30
+#define RK610_SPK_CTRL_PIN  RK30_PIN4_PC6
+#else
 #define RK610_SPK_CTRL_PIN  RK29_PIN6_PB6
-
+#endif
+//1:set pll from rk610
+#define RK610_CTL_PLL 0
 
 /*
  * Debug
  */
 #if 0
-#define	DBG(x...)	printk(KERN_ERR x)
+#define	DBG(x...)	printk(KERN_INFO x)
 #else
 #define	DBG(x...)
 #endif
 
-#define err(format, arg...) \
-	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
-#define info(format, arg...) \
-	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
-	
-#define OUT_CAPLESS  (0)   //是否为无电容输出，1:无电容输出，0:有电容输出	
+#define OUT_CAPLESS  (1)   //是否为无电容输出，1:无电容输出，0:有电容输出
 
 static u32 gVolReg = 0x00;  ///0x0f; //用于记录音量寄存器
 //static u32 gCodecVol = 0x0f;
@@ -74,17 +74,15 @@ static const u16 rk610_codec_reg[] = {
 static struct snd_soc_codec *rk610_codec_codec;
 /* codec private data */
 struct rk610_codec_priv {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	enum snd_soc_control_type control_type;
-#endif
 	unsigned int sysclk;
 	struct snd_soc_codec codec;
 	struct snd_pcm_hw_constraint_list *sysclk_constraints;
 	u16 reg_cache[RK610_CODEC_NUM_REG];
-};
 
-extern int rk610_control_init_codec(void);
-extern int rk610_codec_pll_set(unsigned int rate);
+	struct delayed_work rk610_delayed_work;
+	unsigned int spk_ctrl_io;
+};
 
 /*
  * read rk610 register cache
@@ -99,7 +97,7 @@ static inline unsigned int rk610_codec_read_reg_cache(struct snd_soc_codec *code
 }
 
 static unsigned int rk610_codec_read(struct snd_soc_codec *codec, unsigned int r)
-{	
+{
 	struct i2c_msg xfer[1];
 	u8 reg = r;
 	int ret;
@@ -119,6 +117,7 @@ static unsigned int rk610_codec_read(struct snd_soc_codec *codec, unsigned int r
 
 	return reg;
 }
+
 /*
  * write rk610 register cache
  */
@@ -141,7 +140,7 @@ static int rk610_codec_write(struct snd_soc_codec *codec, unsigned int reg,
 	rk610_codec_write_reg_cache (codec, reg, value);
 	i2c = (struct i2c_client *)codec->control_data;
 	i2c->addr = (i2c->addr & 0x60)|reg;
-	
+
 	if (codec->hw_write(codec->control_data, data, 1) == 1){
 //		DBG("================%s %d Run OK================\n",__FUNCTION__,__LINE__);
 		return 0;
@@ -159,111 +158,20 @@ void rk610_codec_reg_read(void)
 
     for (i=0; i<=0x1f; i++){
         data = rk610_codec_read(codec, i);
-        DBG("reg[0x%x]=0x%x\n",i,data);
+        printk("reg[0x%x]=0x%x\n",i,data);
     }
 }
 
-static const struct snd_kcontrol_new rk610_codec_snd_controls[] = {
-SOC_DOUBLE_R("Capture Volume", ACCELCODEC_R0C, ACCELCODEC_R0D, 0, 15, 0),
-SOC_DOUBLE_R("Capture Switch", ACCELCODEC_R0C, ACCELCODEC_R0D, 7, 1, 1),
-SOC_DOUBLE_R("PCM Volume", ACCELCODEC_R0D, ACCELCODEC_R0E, 0, 7, 0),
-//SOC_SINGLE("Left ADC Capture Volume", ACCELCODEC_R17, 0, 63, 0),
-//SOC_SINGLE("Right ADC Capture Volume", ACCELCODEC_R18, 0, 63, 0),
-};
-
-/* Left Mixer */
-static const struct snd_kcontrol_new rk610_codec_left_mixer_controls[] = {
-SOC_DAPM_SINGLE("Left Playback Switch", ACCELCODEC_R15, 6, 1, 0),
-SOC_DAPM_SINGLE("Left Bypass Switch", ACCELCODEC_R15, 2, 1, 0),
-};
-
-/* Right Mixer */
-static const struct snd_kcontrol_new rk610_codec_right_mixer_controls[] = {
-SOC_DAPM_SINGLE("Right Playback Switch", ACCELCODEC_R15, 7, 1, 0),
-SOC_DAPM_SINGLE("Right Bypass Switch", ACCELCODEC_R15, 3, 1, 0),
-};
-
-static const struct snd_soc_dapm_widget rk610_codec_dapm_widgets[] = {
-	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
-		&rk610_codec_left_mixer_controls[0],
-		ARRAY_SIZE(rk610_codec_left_mixer_controls)),
-	SND_SOC_DAPM_MIXER("Right Mixer", SND_SOC_NOPM, 0, 0,
-		&rk610_codec_right_mixer_controls[0],
-		ARRAY_SIZE(rk610_codec_right_mixer_controls)),
-    
-	//SND_SOC_DAPM_PGA("Right Out 1", ACCELCODEC_R1E, 0, 0, NULL, 0),
-	//SND_SOC_DAPM_PGA("Left Out 1", ACCELCODEC_R1E, 1, 0, NULL, 0),
-	//SND_SOC_DAPM_DAC("Right DAC", "Right Playback", ACCELCODEC_R1F, 1, 0),
-	//SND_SOC_DAPM_DAC("Left DAC", "Left Playback", ACCELCODEC_R1F, 2, 0),
-    
-	SND_SOC_DAPM_ADC("ADC", "Capture", ACCELCODEC_R1D, 6, 1),
-	SND_SOC_DAPM_ADC("ADC BUFF", "Capture BUFF", ACCELCODEC_R1D, 2, 0),
-    
-     
-	SND_SOC_DAPM_OUTPUT("LOUT1"),
-	SND_SOC_DAPM_OUTPUT("ROUT1"),
-    
-	SND_SOC_DAPM_INPUT("LINPUT1"),
-	SND_SOC_DAPM_INPUT("RINPUT1"),
-};
+static void spk_ctrl_fun(int status)
+{
+	struct rk610_codec_priv *rk610_codec =snd_soc_codec_get_drvdata(rk610_codec_codec);
 
-static const struct snd_soc_dapm_route audio_map[] = {
-	/* left mixer */
-	{"Left Mixer", "Left Playback Switch", "Left DAC"},
-	{"Left Mixer", "Left Bypass Switch", "Left Line Mux"},
-	{"Right Mixer", "Right Playback Switch", "Right DAC"},
-	{"Right Mixer", "Right Bypass Switch", "Right Line Mux"},
-    
-	/* left out 1 */
-	{"Left Out 1", NULL, "Left Mixer"},
-	{"LOUT1", NULL, "Left Out 1"},
-    
-    
-	/* right out 1 */
-	{"Right Out 1", NULL, "Right Mixer"},
-	{"ROUT1", NULL, "Right Out 1"},
-    
-	/* Left Line Mux */
-	{"Left Line Mux", "Line 1", "LINPUT1"},
-	{"Left Line Mux", "PGA", "Left PGA Mux"},
-	{"Left Line Mux", "Differential", "Differential Mux"},
-    
-	/* Right Line Mux */
-	{"Right Line Mux", "Line 1", "RINPUT1"},
-	{"Right Line Mux", "PGA", "Right PGA Mux"},
-	{"Right Line Mux", "Differential", "Differential Mux"},
-    
-	/* Left PGA Mux */
-	{"Left PGA Mux", "Line 1", "LINPUT1"},
-	{"Left PGA Mux", "Line 2", "LINPUT2"},
-	{"Left PGA Mux", "Line 3", "LINPUT3"},
-	{"Left PGA Mux", "Differential", "Differential Mux"},
-    
-	/* Right PGA Mux */
-	{"Right PGA Mux", "Line 1", "RINPUT1"},
-	{"Right PGA Mux", "Differential", "Differential Mux"},
-    
-	/* Differential Mux */
-	{"Differential Mux", "Line 1", "LINPUT1"},
-	{"Differential Mux", "Line 1", "RINPUT1"},
-    
-	/* Left ADC Mux */
-	{"Left ADC Mux", "Stereo", "Left PGA Mux"},
-	{"Left ADC Mux", "Mono (Left)", "Left PGA Mux"},
-	{"Left ADC Mux", "Digital Mono", "Left PGA Mux"},
-    
-	/* Right ADC Mux */
-	{"Right ADC Mux", "Stereo", "Right PGA Mux"},
-	{"Right ADC Mux", "Mono (Right)", "Right PGA Mux"},
-	{"Right ADC Mux", "Digital Mono", "Right PGA Mux"},
-    
-	/* ADC */
-	{"Left ADC", NULL, "Left ADC Mux"},
-	{"Right ADC", NULL, "Right ADC Mux"},
-    
-	/* terminator */
-//	{NULL, NULL, NULL},
-};
+	if(rk610_codec->spk_ctrl_io)
+	{
+		DBG("--------%s----------status = %d\n",__FUNCTION__,status);
+		gpio_set_value(rk610_codec->spk_ctrl_io, status);
+	}
+}
 
 struct _coeff_div {
 	u32 mclk;
@@ -283,52 +191,52 @@ static const struct _coeff_div coeff_div[] = {
 	{16934400, 8000, 2112, 0x17, 0x0,ASC_BCLKDIV_16},
 	{8192000, 8000, 1024, 0x0, 0x0,ASC_BCLKDIV_16},
 	{12000000, 8000, 1500, 0x6, 0x1,ASC_BCLKDIV_16},
-    
+
 	/* 11.025k */
 	{11289600, 11025, 1024, 0x18, 0x0,ASC_BCLKDIV_16},
 	{16934400, 11025, 1536, 0x19, 0x0,ASC_BCLKDIV_16},
 	{12000000, 11025, 1088, 0x19, 0x1,ASC_BCLKDIV_16},
-    
+
     /* 12k */
 	{12288000, 12000, 1024, 0x8, 0x0,ASC_BCLKDIV_16},
 	{18432000, 12000, 1536, 0x9, 0x0,ASC_BCLKDIV_16},
 	{12000000, 12000, 1000, 0x8, 0x1,ASC_BCLKDIV_16},
-    
+
 	/* 16k */
 	{12288000, 16000, 768, 0xa, 0x0,ASC_BCLKDIV_8},
 	{18432000, 16000, 1152, 0xb, 0x0,ASC_BCLKDIV_8},
 	{12000000, 16000, 750, 0xa, 0x1,ASC_BCLKDIV_8},
-    
+
 	/* 22.05k */
 	{11289600, 22050, 512, 0x1a, 0x0,ASC_BCLKDIV_8},
 	{16934400, 22050, 768, 0x1b, 0x0,ASC_BCLKDIV_8},
 	{12000000, 22050, 544, 0x1b, 0x1,ASC_BCLKDIV_8},
-    
+
     /* 24k */
 	{12288000, 24000, 512, 0x1c, 0x0,ASC_BCLKDIV_8},
 	{18432000, 24000, 768, 0x1d, 0x0,ASC_BCLKDIV_8},
 	{12000000, 24000, 500, 0x1c, 0x1,ASC_BCLKDIV_8},
-	
+
 	/* 32k */
 	{12288000, 32000, 384, 0xc, 0x0,ASC_BCLKDIV_8},
 	{18432000, 32000, 576, 0xd, 0x0,ASC_BCLKDIV_8},
 	{12000000, 32000, 375, 0xa, 0x1,ASC_BCLKDIV_8},
-    
+
 	/* 44.1k */
 	{11289600, 44100, 256, 0x10, 0x0,ASC_BCLKDIV_4},
 	{16934400, 44100, 384, 0x11, 0x0,ASC_BCLKDIV_8},
 	{12000000, 44100, 272, 0x11, 0x1,ASC_BCLKDIV_8},
-    
+
 	/* 48k */
 	{12288000, 48000, 256, 0x0, 0x0,ASC_BCLKDIV_4},
 	{18432000, 48000, 384, 0x1, 0x0,ASC_BCLKDIV_4},
 	{12000000, 48000, 250, 0x0, 0x1,ASC_BCLKDIV_4},
-    
+
 	/* 88.2k */
 	{11289600, 88200, 128, 0x1e, 0x0,ASC_BCLKDIV_4},
 	{16934400, 88200, 192, 0x1f, 0x0,ASC_BCLKDIV_4},
 	{12000000, 88200, 136, 0x1f, 0x1,ASC_BCLKDIV_4},
-    
+
 	/* 96k */
 	{12288000, 96000, 128, 0xe, 0x0,ASC_BCLKDIV_4},
 	{18432000, 96000, 192, 0xf, 0x0,ASC_BCLKDIV_4},
@@ -384,16 +292,15 @@ static int rk610_codec_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 		int clk_id, unsigned int freq, int dir)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+
 	struct rk610_codec_priv *rk610_codec =snd_soc_codec_get_drvdata(codec);
-#else
-	struct rk610_codec_priv *rk610_codec = codec->private_data;
-#endif	
+
 	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
-	
-//	if(rk610_codec_pll_set(freq))
-//		return -EINVAL;
-		
+
+#ifdef RK610_CTL_PLL
+	if(rk610_codec_pll_set(freq))
+		return -EINVAL;
+#endif
 	switch (freq) {
 	case 11289600:
 	case 18432000:
@@ -428,6 +335,10 @@ static int rk610_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
 	struct snd_soc_codec *codec = codec_dai->codec;
 	u16 iface = 0;
 
+	spk_ctrl_fun(GPIO_LOW);
+	rk610_codec_write(codec,ACCELCODEC_R1D, 0x2a);  //setup Vmid and Vref, other module power down
+	rk610_codec_write(codec,ACCELCODEC_R1E, 0x40);  ///|ASC_PDASDML_ENABLE);
+
 	/* set master/slave audio interface */
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBM_CFM:
@@ -487,52 +398,15 @@ static int rk610_codec_pcm_hw_params(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	struct snd_soc_codec *codec = rtd->codec;
 	struct rk610_codec_priv *rk610_codec =snd_soc_codec_get_drvdata(codec);
-#else
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_codec *codec = socdev->card->codec;
-	struct rk610_codec_priv *rk610_codec = codec->private_data;
-#endif
+
 	u16 iface = rk610_codec_read_reg_cache(codec, ACCELCODEC_R09) & 0x1f3;
 	u16 srate = rk610_codec_read_reg_cache(codec, ACCELCODEC_R00) & 0x180;
 	int coeff;
-	
-	/*by Vincent Hsiung for EQ Vol Change*/
-	#define HW_PARAMS_FLAG_EQVOL_ON 0x21
-	#define HW_PARAMS_FLAG_EQVOL_OFF 0x22
-	if (params->flags == HW_PARAMS_FLAG_EQVOL_ON)
-	{
-		u16 r17 = rk610_codec_read_reg_cache(codec, ACCELCODEC_R17);
-		u16 r18 = rk610_codec_read_reg_cache(codec, ACCELCODEC_R18);
-		
-		r17 &= (~0x3f); //6db
-		r18 &= (~0x3f); //6db
-		
-		rk610_codec_write(codec, ACCELCODEC_R17, r17);
-		rk610_codec_write(codec, ACCELCODEC_R18, r18);
-		
-		return 0;
-	}
-	else if (params->flags == HW_PARAMS_FLAG_EQVOL_OFF)
-	{
-		u16 r17 = rk610_codec_read_reg_cache(codec, ACCELCODEC_R17);
-		u16 r18 = rk610_codec_read_reg_cache(codec, ACCELCODEC_R18);
-		
-		r17 &= (~0x3f); 
-		r17 |= 0x0f; //0db
-		
-		r18 &= (~0x3f); 
-		r18 |= 0x0f; //0db
-		
-		rk610_codec_write(codec, ACCELCODEC_R17, r17);
-		rk610_codec_write(codec, ACCELCODEC_R18, r18);
-		return 0;
-	} 
-	
+
 	coeff = get_coeff(rk610_codec->sysclk, params_rate(params));
-	DBG("Enter::%s----%d  rk610_codec->sysclk=%d coeff = %d\n",__FUNCTION__,__LINE__,rk610_codec->sysclk, coeff); 
+	DBG("Enter::%s----%d  rk610_codec->sysclk=%d coeff = %d\n",__FUNCTION__,__LINE__,rk610_codec->sysclk, coeff);
 	/* bit size */
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -548,13 +422,13 @@ static int rk610_codec_pcm_hw_params(struct snd_pcm_substream *substream,
 		break;
 	}
 	DBG("Enter::%s----%d  iface=%x srate =%x rate=%d\n",__FUNCTION__,__LINE__,iface,srate,params_rate(params));
-	
-//	rk610_codec_write(codec,ACCELCODEC_R0C, 0x17);  
+
+//	rk610_codec_write(codec,ACCELCODEC_R0C, 0x17);
 	rk610_codec_write(codec,ACCELCODEC_R04, ASC_INT_MUTE_L|ASC_INT_MUTE_R|ASC_SIDETONE_L_OFF|ASC_SIDETONE_R_OFF);   //soft mute
 	//必须先将clk和EN_INT都disable掉，否则切换bclk分频值可能导致codec内部时序混乱掉，
 	//表现出来的现象是，以后的音乐都变成了噪音，而且就算把输入codec的I2S_DATAOUT断开也一样出噪音
 	rk610_codec_write(codec,ACCELCODEC_R0B, ASC_DEC_DISABLE|ASC_INT_DISABLE);  //0x00
-	
+
 	/* set iface & srate */
 	#ifdef CONFIG_SND_RK29_CODEC_SOC_MASTER
 	iface |= ASC_INVERT_BCLK;//翻转BCLK  master状态送出的少了半个时钟，导致未到最大音量的时候破音、
@@ -569,65 +443,45 @@ static int rk610_codec_pcm_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-void PhaseOut(struct snd_soc_codec *codec,u32 nStep, u32 us)
-{
-    DBG("%s[%d]\n",__FUNCTION__,__LINE__); 
-    rk610_codec_write(codec,ACCELCODEC_R17, gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOL
-    rk610_codec_write(codec,ACCELCODEC_R18, gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOR
-    udelay(us);
-}
-
-void PhaseIn(struct snd_soc_codec *codec,u32 nStep, u32 us)
-{
-    DBG("%s[%d]\n",__FUNCTION__,__LINE__); 
-    rk610_codec_write(codec,ACCELCODEC_R17, gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOL gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOL
-    rk610_codec_write(codec,ACCELCODEC_R18, gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN); //gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOR
-    udelay(us);
-}
-
 static int rk610_codec_mute(struct snd_soc_dai *dai, int mute)
 {
     struct snd_soc_codec *codec = dai->codec;
-	
+//	struct rk610_codec_priv *rk610_codec =snd_soc_codec_get_drvdata(codec);
     DBG("Enter::%s----%d--mute=%d\n",__FUNCTION__,__LINE__,mute);
 
     if (mute)
 	{
-        PhaseOut(codec,1, 5000);
+		rk610_codec_write(codec,ACCELCODEC_R17, gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOL
+		rk610_codec_write(codec,ACCELCODEC_R18, gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOR
         rk610_codec_write(codec,ACCELCODEC_R19, 0xFF);  //AOM
-        rk610_codec_write(codec,ACCELCODEC_R04, ASC_INT_MUTE_L|ASC_INT_MUTE_R|ASC_SIDETONE_L_OFF|ASC_SIDETONE_R_OFF);  //soft mute  
+        rk610_codec_write(codec,ACCELCODEC_R04, ASC_INT_MUTE_L|ASC_INT_MUTE_R|ASC_SIDETONE_L_OFF|ASC_SIDETONE_R_OFF);  //soft mute
 	//add for standby
-		if(!dai->capture_active)
-		{
-			rk610_codec_write(codec, ACCELCODEC_R1D, 0xFE);
-			rk610_codec_write(codec, ACCELCODEC_R1E, 0xFF);
-			rk610_codec_write(codec, ACCELCODEC_R1F, 0xFF);	
-		}
+	//	if(!dai->capture_active)
+	//	{
+	//		rk610_codec_write(codec, ACCELCODEC_R1D, 0xFE);
+	//		rk610_codec_write(codec, ACCELCODEC_R1E, 0xFF);
+	//		rk610_codec_write(codec, ACCELCODEC_R1F, 0xFF);
+	//	}
     }
 	else
-	{		
-        rk610_codec_write(codec,ACCELCODEC_R1D, 0x2a);  //setup Vmid and Vref, other module power down
-        rk610_codec_write(codec,ACCELCODEC_R1E, 0x40);  ///|ASC_PDASDML_ENABLE);
-        
-        #if OUT_CAPLESS
+	{
+	//	rk610_codec_write(codec,ACCELCODEC_R1D, 0x2a);  //setup Vmid and Vref, other module power down
+	//	rk610_codec_write(codec,ACCELCODEC_R1E, 0x40);  ///|ASC_PDASDML_ENABLE);
+		rk610_codec_write(codec,ACCELCODEC_R17, gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOL gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOL
+		rk610_codec_write(codec,ACCELCODEC_R18, gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN); //gVolReg|ASC_OUTPUT_ACTIVE|ASC_CROSSZERO_EN);  //AOR
+        rk610_codec_write(codec,ACCELCODEC_R04, ASC_INT_ACTIVE_L|ASC_INT_ACTIVE_R|ASC_SIDETONE_L_OFF|ASC_SIDETONE_R_OFF);
+		rk610_codec_write(codec,ACCELCODEC_R19, 0x7F);  //AOM
+		msleep(300);
+		#if OUT_CAPLESS
     	rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMIXM_ENABLE);
     	#else
     	rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMIXM_ENABLE|ASC_PDPAM_ENABLE);
 		#endif
-
-        PhaseIn(codec,1, 5000);
-        //if(gCodecVol != 0)
-		//{
-        rk610_codec_write(codec,ACCELCODEC_R04, ASC_INT_ACTIVE_L|ASC_INT_ACTIVE_R|ASC_SIDETONE_L_OFF|ASC_SIDETONE_R_OFF);
-        //}
-       rk610_codec_write(codec,ACCELCODEC_R19, 0x7F);  //AOM
-#if 0
-        /*disable speaker */
-        gpio_set_value(RK29_PIN6_PB6, GPIO_LOW);
-#endif
-	rk610_codec_reg_read();
+	//	schedule_delayed_work(&rk610_codec->rk610_delayed_work, 0);
+	//	rk610_codec_reg_read();
+		spk_ctrl_fun(GPIO_HIGH);
     }
-	
+
     return 0;
 }
 
@@ -645,30 +499,38 @@ static int rk610_codec_set_bias_level(struct snd_soc_codec *codec,
 
 	case SND_SOC_BIAS_STANDBY:
 		printk("rk610 standby\n");
+		spk_ctrl_fun(GPIO_LOW);
 		rk610_codec_write(codec, ACCELCODEC_R1D, 0xFE);
 		rk610_codec_write(codec, ACCELCODEC_R1E, 0xFF);
-		rk610_codec_write(codec, ACCELCODEC_R1F, 0xFF);		
+		rk610_codec_write(codec, ACCELCODEC_R1F, 0xFF);
 		break;
 
 	case SND_SOC_BIAS_OFF:
-		printk("rk610 power off\n");	
+		printk("rk610 power off\n");
+		spk_ctrl_fun(GPIO_LOW);
 		rk610_codec_write(codec, ACCELCODEC_R1D, 0xFF);
 		rk610_codec_write(codec, ACCELCODEC_R1E, 0xFF);
 		rk610_codec_write(codec, ACCELCODEC_R1F, 0xFF);
 		break;
 	}
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+
 	codec->dapm.bias_level = level;
-#else
-	codec->bias_level = level;
-#endif
+
 	return 0;
 }
 
-#define RK610_CODEC_RATES SNDRV_PCM_RATE_8000_96000
+static void rk610_delayedwork_fun(struct work_struct *work)
+{
+    struct snd_soc_codec *codec = rk610_codec_codec;
+	DBG("--------%s----------\n",__FUNCTION__);
 
-#define RK610_CODEC_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
-	SNDRV_PCM_FMTBIT_S24_LE)
+	#if OUT_CAPLESS
+	rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMIXM_ENABLE);
+	#else
+	rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMIXM_ENABLE|ASC_PDPAM_ENABLE);
+	#endif
+	spk_ctrl_fun(GPIO_HIGH);
+}
 
 static struct snd_soc_dai_ops rk610_codec_ops = {
 	.hw_params = rk610_codec_pcm_hw_params,
@@ -677,13 +539,12 @@ static struct snd_soc_dai_ops rk610_codec_ops = {
 	.digital_mute = rk610_codec_mute,
 };
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-static struct snd_soc_dai_driver rk610_codec_dai = 
-#else
-struct snd_soc_dai rk610_codec_dai = 
-#endif
-{
-	.name = "rk610_codec_xx",
+#define RK610_CODEC_RATES SNDRV_PCM_RATE_8000_96000
+#define RK610_CODEC_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+							SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_driver rk610_codec_dai = {
+	.name = "rk610_codec",
 	.playback = {
 		.stream_name = "Playback",
 		.channels_min = 1,
@@ -701,67 +562,48 @@ struct snd_soc_dai rk610_codec_dai =
 	.ops = &rk610_codec_ops,
 	.symmetric_rates = 1,
 };
-EXPORT_SYMBOL_GPL(rk610_codec_dai);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 static int rk610_codec_suspend(struct snd_soc_codec *codec, pm_message_t state)
-#else
-static int rk610_codec_suspend(struct platform_device *pdev, pm_message_t state)
-#endif
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))	
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *codec = socdev->card->codec;
-#endif
 	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
 	rk610_codec_set_bias_level(codec, SND_SOC_BIAS_OFF);
-	rk610_codec_reg_read();
-
+//	rk610_codec_reg_read();
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 static int rk610_codec_resume(struct snd_soc_codec *codec)
-#else
-static int rk610_codec_resume(struct platform_device *pdev)
-#endif
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *codec = socdev->card->codec;
-#endif
 	int i;
 	u8 data[2];
 	struct i2c_client *i2c;
 	u16 *cache = codec->reg_cache;
-	
+
 	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
 	/* Sync reg_cache with the hardware */
+/*
 	for (i = 0; i < RK610_CODEC_NUM_REG; i++) {
 		data[0] = cache[i] & 0x00ff;
 		i2c = (struct i2c_client *)codec->control_data;
 		i2c->addr = (i2c->addr & 0x60)|i;
 		codec->hw_write(codec->control_data, data, 1);
 	}
-
+*/
 	rk610_codec_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 
 	return 0;
 }
 
-#if 1
 #define USE_MIC_IN
-#define USE_LPF		1
+#define USE_LPF
 void rk610_codec_reg_set(void)
 {
     struct snd_soc_codec *codec = rk610_codec_codec;
     unsigned int digital_gain;
-	
-	rk610_codec_write(codec,ACCELCODEC_R1D, 0xFF);
-    rk610_codec_write(codec,ACCELCODEC_R1E, 0xFF);
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0xFF);
 
-#if USE_LPF
+	rk610_codec_write(codec,ACCELCODEC_R1D, 0x30);
+	rk610_codec_write(codec,ACCELCODEC_R1E, 0x40);
+
+#ifdef USE_LPF
 	// Route R-LPF->R-Mixer, L-LPF->L-Mixer
 	rk610_codec_write(codec,ACCELCODEC_R15, 0xC1);
 #else
@@ -787,7 +629,7 @@ void rk610_codec_reg_set(void)
 
     //2soft mute
     rk610_codec_write(codec,ACCELCODEC_R04, ASC_INT_MUTE_L|ASC_INT_MUTE_R|ASC_SIDETONE_L_OFF|ASC_SIDETONE_R_OFF);   //soft mute
-    
+
     //2set default SR and clk
     rk610_codec_write(codec,ACCELCODEC_R0A, ASC_NORMAL_MODE|(0x10 << 1)|ASC_CLKNODIV|ASC_CLK_DISABLE);
     gR0AReg = ASC_NORMAL_MODE|(0x10 << 1)|ASC_CLKNODIV|ASC_CLK_DISABLE;
@@ -800,121 +642,25 @@ void rk610_codec_reg_set(void)
     rk610_codec_write(codec,ACCELCODEC_R06, digital_gain & 0xFF);
     rk610_codec_write(codec,ACCELCODEC_R07, (digital_gain >> 8) & 0xFF);
     rk610_codec_write(codec,ACCELCODEC_R08, digital_gain & 0xFF);
-//    rk610_codec_write(codec,ACCELCODEC_R05, 0x0e);
-//    rk610_codec_write(codec,ACCELCODEC_R06, 0x42);
-//    rk610_codec_write(codec,ACCELCODEC_R07, 0x0e);
-//    rk610_codec_write(codec,ACCELCODEC_R08, 0x42);
-    
+
     rk610_codec_write(codec,ACCELCODEC_R0B, ASC_DEC_ENABLE|ASC_INT_ENABLE);
     gR0BReg = ASC_DEC_ENABLE|ASC_INT_ENABLE;  //ASC_DEC_DISABLE|ASC_INT_ENABLE;
-    
-    rk610_codec_write(codec,ACCELCODEC_R1D, 0x30);
-    rk610_codec_write(codec,ACCELCODEC_R1E, 0x40);
-    #if OUT_CAPLESS
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMIXM_ENABLE);
-    #else
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMIXM_ENABLE|ASC_PDPAM_ENABLE);
-	#endif
-}
-#else
-void rk610_codec_reg_set(void)
-{
-    struct snd_soc_codec *codec = rk610_codec_codec;
-    int reg;
-    int i;
-    unsigned int data;
 
-    rk610_codec_write(codec,ACCELCODEC_R1D, 0x00);
-    rk610_codec_write(codec,ACCELCODEC_R17, 0xFF);  //AOL
-    rk610_codec_write(codec,ACCELCODEC_R18, 0xFF);  //AOR
-    rk610_codec_write(codec,ACCELCODEC_R19, 0xFF);  //AOM
-
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0xDF);
-    mdelay(10);
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0x5F);
-    rk610_codec_write(codec,ACCELCODEC_R19, 0x7F);  //AOM
-    rk610_codec_write(codec,ACCELCODEC_R15, 0xC1);//rk610_codec_write(codec,ACCELCODEC_R15, 0xCD);//by Vincent Hsiung
-    rk610_codec_write(codec,ACCELCODEC_R1A, 0x1C);
-    mdelay(100);
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0x09);
-    rk610_codec_write(codec,ACCELCODEC_R1E, 0x00);
-    mdelay(10);
-    rk610_codec_write(codec,ACCELCODEC_R1A, 0x14);
-    rk610_codec_write(codec,ACCELCODEC_R1D, 0xFE);
-    rk610_codec_write(codec,ACCELCODEC_R17, 0xBF);  //AOL
-    rk610_codec_write(codec,ACCELCODEC_R18, 0xBF);  //AOR
-    rk610_codec_write(codec,ACCELCODEC_R19, 0x7F);  //AOM
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0xDF);
 
-    //2soft mute
-    rk610_codec_write(codec,ACCELCODEC_R04, ASC_INT_MUTE_L|ASC_INT_MUTE_R|ASC_SIDETONE_L_OFF|ASC_SIDETONE_R_OFF);   //soft mute
-    
-    //2set default SR and clk
-    rk610_codec_write(codec,ACCELCODEC_R0A, ASC_USB_MODE|FREQ48kHz|ASC_CLKNODIV|ASC_CLK_DISABLE);
-    gR0AReg = ASC_USB_MODE|FREQ48kHz|ASC_CLKNODIV|ASC_CLK_DISABLE;
-    //2Config audio  interface
-    rk610_codec_write(codec,ACCELCODEC_R09, ASC_I2S_MODE|ASC_16BIT_MODE|ASC_NORMAL_LRCLK|ASC_LRSWAP_DISABLE|ASC_MASTER_MODE|ASC_NORMAL_BCLK);
-    rk610_codec_write(codec,ACCELCODEC_R00, ASC_HPF_ENABLE|ASC_DSM_MODE_DISABLE|ASC_SCRAMBLE_ENABLE|ASC_DITHER_ENABLE|ASC_BCLKDIV_8);  //BCLK div 8
-    //2volume,input,outpu
-    rk610_codec_write(codec,ACCELCODEC_R05, 0x0e);
-    rk610_codec_write(codec,ACCELCODEC_R06, 0x42);
-    rk610_codec_write(codec,ACCELCODEC_R07, 0x0e);
-    rk610_codec_write(codec,ACCELCODEC_R08, 0x42);
-    
-    rk610_codec_write(codec,ACCELCODEC_R0C, 0x10|ASC_INPUT_VOL_0DB|ASC_INPUT_MUTE);   //LIL
-    rk610_codec_write(codec,ACCELCODEC_R0D, 0x10|ASC_INPUT_VOL_0DB);   //LIR
-    rk610_codec_write(codec,ACCELCODEC_R0E, 0x10|ASC_INPUT_VOL_0DB);   //MIC
-    rk610_codec_write(codec,ACCELCODEC_R12, 0x4c|ASC_MIC_INPUT|ASC_MIC_BOOST_20DB);  //mic input and boost 20dB
-    rk610_codec_write(codec,ACCELCODEC_R13, ASC_LPGAMX_DISABLE|ASC_ALMX_DISABLE|((LINE_2_MIXER_GAIN & 0x7) << 4)|0x0);
-    rk610_codec_write(codec,ACCELCODEC_R14, ASC_RPGAMX_DISABLE|ASC_ARMX_DISABLE|((LINE_2_MIXER_GAIN & 0x7) << 4)|0x0);
-    gR1314Reg = ASC_RPGAMX_DISABLE|ASC_ARMX_DISABLE|((LINE_2_MIXER_GAIN & 0x7) << 4)|0x0;
-
-    //2other
-    rk610_codec_write(codec,ACCELCODEC_R0B, ASC_DEC_DISABLE|ASC_INT_DISABLE);  //0x00
-    gR0BReg = ASC_DEC_DISABLE|ASC_INT_DISABLE;
-    rk610_codec_write(codec,ACCELCODEC_R15, \
-                    0x01|ASC_RLPFMX_DISABLE|ASC_LLPFMX_DISABLE|ASC_LDAMX_DISABLE|ASC_RDAMX_DISABLE|ASC_LSCF_ACTIVE|ASC_RSCF_ACTIVE);  //0x3c
-    rk610_codec_write(codec,ACCELCODEC_R1B, 0x32);
-    rk610_codec_write(codec,ACCELCODEC_R1C, ASC_DEM_ENABLE);  ///0x00);  //use default value
-    
-    ///dac mode
-    rk610_codec_write(codec,ACCELCODEC_R17, 0xBF);  //AOL  音量最低
-    rk610_codec_write(codec,ACCELCODEC_R18, 0xBF);  //AOR
-        
-    //2power down useless module
-    rk610_codec_write(codec,ACCELCODEC_R1D, 0x2a|ASC_PDSDL_ENABLE|ASC_PDBSTL_ENABLE|ASC_PDPGAL_ENABLE);  //setup Vmid and Vref, other module power down
-    rk610_codec_write(codec,ACCELCODEC_R1E, 0x40|ASC_PDASDML_ENABLE);
-    #if OUT_CAPLESS
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMICB_ENABLE|ASC_PDMIXM_ENABLE);
-    #else
-    rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMICB_ENABLE|ASC_PDMIXM_ENABLE|ASC_PDPAM_ENABLE);
-    #endif
-
-    //2other
-    rk610_codec_write(codec,ACCELCODEC_R0B, ASC_DEC_DISABLE|ASC_INT_DISABLE);
-    gR0BReg = ASC_DEC_ENABLE|ASC_INT_ENABLE;  //ASC_DEC_DISABLE|ASC_INT_ENABLE;
-    rk610_codec_write(codec,ACCELCODEC_R15, 0xC1);//rk610_codec_write(codec,ACCELCODEC_R15, 0xCD);//by Vincent Hsiung
-    rk610_codec_write(codec,ACCELCODEC_R0C, 0x10|ASC_INPUT_VOL_0DB);   //LIL
-    rk610_codec_write(codec,ACCELCODEC_R0D, 0x10|ASC_INPUT_VOL_0DB);   //LIR
-    rk610_codec_write(codec,ACCELCODEC_R0E, 0x10|ASC_INPUT_VOL_0DB);   //MIC
-//    rk610_codec_write(codec,ACCELCODEC_R12, 0x4c|ASC_MIC_INPUT|ASC_MIC_BOOST_20DB);  //mic input and boost 20dB
-    rk610_codec_write(codec,ACCELCODEC_R12, 0x4c);  //line input and boost 20dB
-    rk610_codec_write(codec,ACCELCODEC_R13, 0x00);
-    rk610_codec_write(codec,ACCELCODEC_R14, 0x00);
-    gR1314Reg = 0x00;
-    rk610_codec_write(codec,ACCELCODEC_R1C, ASC_DEM_ENABLE);  //0x00);  //use default value
+//	#if OUT_CAPLESS
+//	rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMIXM_ENABLE);
+//	#else
+//	rk610_codec_write(codec,ACCELCODEC_R1F, 0x09|ASC_PDMIXM_ENABLE|ASC_PDPAM_ENABLE);
+//	#endif
 }
-#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 static int rk610_codec_probe(struct snd_soc_codec *codec)
 {
 	struct rk610_codec_priv *rk610_codec = snd_soc_codec_get_drvdata(codec);
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	int ret;
-	
+
 	rk610_codec_codec = codec;
-	printk(KERN_ERR "[%s] start\n", __FUNCTION__);
+	DBG("[%s] start\n", __FUNCTION__);
 	ret = snd_soc_codec_set_cache_io(codec, 8, 16, rk610_codec->control_type);
 	if (ret != 0) {
 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
@@ -924,97 +670,42 @@ static int rk610_codec_probe(struct snd_soc_codec *codec)
 	codec->write = rk610_codec_write;
 	codec->read = rk610_codec_read;
 	codec->hw_write = (hw_write_t)i2c_master_send;
-#else
-static int rk610_codec_probe(struct platform_device *pdev)
-{
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *codec;
-	int ret = 0;
-#endif
+
 	if (rk610_codec_codec == NULL) {
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 		dev_err(codec->dev, "Codec device not registered\n");
-		#else
-		dev_err(&pdev->dev, "Codec device not registered\n");
-		#endif
 		return -ENODEV;
 	}
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	socdev->card->codec = rk610_codec_codec;
-	codec = rk610_codec_codec;
 
-	/* register pcms */
-	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
-	if (ret < 0) {
-		dev_err(codec->dev, "failed to create pcms: %d\n", ret);
-		goto pcm_err;
-	}
-#endif
-
-	snd_soc_add_controls(codec, rk610_codec_snd_controls,
-				ARRAY_SIZE(rk610_codec_snd_controls));
-				
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	snd_soc_dapm_new_controls(codec, rk610_codec_dapm_widgets,
-				  ARRAY_SIZE(rk610_codec_dapm_widgets));
-	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
-	snd_soc_dapm_new_widgets(codec);
-
-	ret = snd_soc_init_card(socdev);
-	if (ret < 0) {
-		dev_err(codec->dev, "failed to register card: %d\n", ret);
-		goto card_err;
-	}
-#else
-	snd_soc_dapm_new_controls(dapm, rk610_codec_dapm_widgets,
-				  ARRAY_SIZE(rk610_codec_dapm_widgets));
-	snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+	INIT_DELAYED_WORK(&rk610_codec->rk610_delayed_work, rk610_delayedwork_fun);
 
-#endif
-
-#if defined(RK610_SPK_CTRL_PIN)
-	ret = gpio_request(RK610_SPK_CTRL_PIN, "rk610 spk_ctrl");
-    if (ret){   
-        printk("rk610_control request gpio fail\n");
-        //goto err1;
+#ifdef RK610_SPK_CTRL_PIN
+	rk610_codec->spk_ctrl_io = RK610_SPK_CTRL_PIN;
+	ret = gpio_request(rk610_codec->spk_ctrl_io, "rk610 spk_ctrl");
+    if (ret){
+        printk("rk610_control request gpio fail!\n");
+		return ret;
     }
-    gpio_set_value(RK610_SPK_CTRL_PIN, GPIO_HIGH);
-    gpio_direction_output(RK610_SPK_CTRL_PIN, GPIO_HIGH);
+    gpio_direction_output(rk610_codec->spk_ctrl_io, GPIO_LOW);
+    gpio_set_value(rk610_codec->spk_ctrl_io, GPIO_LOW);
+#else
+	rk610_codec->spk_ctrl_io = 0;
 #endif
 
     rk610_control_init_codec();
-    
     rk610_codec_reg_set();
-	rk610_codec_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-	
-	return ret;
-	
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-card_err:
-	snd_soc_free_pcms(socdev);
-	snd_soc_dapm_free(socdev);
-pcm_err:
+//	rk610_codec_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	schedule_delayed_work(&rk610_codec->rk610_delayed_work, msecs_to_jiffies(1000));
+
+	codec->dapm.bias_level = SND_SOC_BIAS_PREPARE;
 	return ret;
-#endif
 }
 
 /* power down chip */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 static int rk610_codec_remove(struct snd_soc_codec *codec)
 {
 	rk610_codec_set_bias_level(codec, SND_SOC_BIAS_OFF);
 	return 0;
 }
-#else
-static int rk610_codec_remove(struct platform_device *pdev)
-{
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-    printk("rk610_codec_remove\n");
-	snd_soc_free_pcms(socdev);
-	snd_soc_dapm_free(socdev);
-	return 0;
-}
-#endif
 
 static struct snd_soc_codec_driver soc_codec_dev_rk610_codec = {
 	.probe =	rk610_codec_probe,
@@ -1026,74 +717,41 @@ static struct snd_soc_codec_driver soc_codec_dev_rk610_codec = {
 	.reg_cache_size = ARRAY_SIZE(rk610_codec_reg),
 	.reg_word_size = sizeof(u16),
 	.reg_cache_default = rk610_codec_reg,
-	.dapm_widgets = rk610_codec_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(rk610_codec_dapm_widgets),
-	.dapm_routes = audio_map,
-	.num_dapm_routes = ARRAY_SIZE(audio_map),
+//	.dapm_widgets = rk610_codec_dapm_widgets,
+//	.num_dapm_widgets = ARRAY_SIZE(rk610_codec_dapm_widgets),
+//	.dapm_routes = audio_map,
+//	.num_dapm_routes = ARRAY_SIZE(audio_map),
 };
 
-EXPORT_SYMBOL_GPL(soc_codec_dev_rk610_codec);
-
-
 #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 static int rk610_codec_i2c_probe(struct i2c_client *i2c,
 			    const struct i2c_device_id *id)
 {
 	struct rk610_codec_priv *rk610_codec;
 	int ret;
-	printk("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ %s start $$$$$$$$$$$$$$$$$$$$$$$$$$$\n", __FUNCTION__);
+	DBG("%s start\n", __FUNCTION__);
 	rk610_codec = kzalloc(sizeof(struct rk610_codec_priv), GFP_KERNEL);
 	if (rk610_codec == NULL)
 		return -ENOMEM;
-		
+
 	i2c_set_clientdata(i2c, rk610_codec);
 	rk610_codec->control_type = SND_SOC_I2C;
-	
+
 	ret =  snd_soc_register_codec(&i2c->dev,
 			&soc_codec_dev_rk610_codec, &rk610_codec_dai, 1);
 	if (ret < 0) {
-		printk("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %s: snd_soc_register_codec error!!!!\n", __FUNCTION__);
 		dev_err(&i2c->dev, "Failed to register codec: %d\n", ret);
 		kfree(rk610_codec);
 	}
 	return ret;
 }
 
-
 static int rk610_codec_i2c_remove(struct i2c_client *client)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	snd_soc_unregister_codec(&client->dev);
 	kfree(i2c_get_clientdata(client));
-#else
-	struct rk610_codec_priv *rk610_codec = i2c_get_clientdata(client);
-	rk610_codec_unregister(rk610_codec);
-#endif
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int rk610_codec_i2c_suspend(struct i2c_client *client, pm_message_t msg)
-{
-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	return 0;
-	#else
-	return snd_soc_suspend_device(&client->dev);
-	#endif
-}
-
-static int rk610_codec_i2c_resume(struct i2c_client *client)
-{
-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	return 0;
-	#else
-	return snd_soc_resume_device(&client->dev);
-	#endif
 }
-#else
-#define rk610_codec_i2c_suspend NULL
-#define rk610_codec_i2c_resume NULL
-#endif
 
 static const struct i2c_device_id rk610_codec_i2c_id[] = {
 	{ "rk610_i2c_codec", 0 },
@@ -1109,8 +767,6 @@ static struct i2c_driver rk610_codec_i2c_driver = {
 	},
 	.probe = rk610_codec_i2c_probe,
 	.remove = rk610_codec_i2c_remove,
-	//.suspend = rk610_codec_i2c_suspend,
-	//.resume = rk610_codec_i2c_resume,
 	.id_table = rk610_codec_i2c_id,
 };
 #endif
@@ -1118,7 +774,7 @@ static struct i2c_driver rk610_codec_i2c_driver = {
 static int __init rk610_codec_modinit(void)
 {
 	int ret;
-//	DBG("[%s] start\n", __FUNCTION__);
+	DBG("[%s] start\n", __FUNCTION__);
 	ret = i2c_add_driver(&rk610_codec_i2c_driver);
 	if (ret != 0)
 		pr_err("rk610 codec: Unable to register I2C driver: %d\n", ret);
@@ -1135,3 +791,4 @@ module_exit(rk610_codec_exit);
 MODULE_DESCRIPTION("ASoC RK610 CODEC driver");
 MODULE_AUTHOR("rk@rock-chips.com");
 MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/codecs/rk610_codec.h b/sound/soc/codecs/rk610_codec.h
index 1e31047c4688..10b7e75f84bd 100644
--- a/sound/soc/codecs/rk610_codec.h
+++ b/sound/soc/codecs/rk610_codec.h
@@ -263,5 +263,6 @@
 extern struct snd_soc_dai rk610_codec_dai;
 extern struct snd_soc_codec_device soc_codec_dev_rk610_codec;
 #endif
-
+extern int rk610_control_init_codec(void);
+extern int rk610_codec_pll_set(unsigned int rate);
 #endif
diff --git a/sound/soc/rk29/Kconfig b/sound/soc/rk29/Kconfig
index fcfb95479a21..f46a4d4cd1f0 100755
--- a/sound/soc/rk29/Kconfig
+++ b/sound/soc/rk29/Kconfig
@@ -7,7 +7,7 @@ config SND_RK29_SOC
 	  to select the audio interfaces to support below.
 
 config SND_RK29_SOC_I2S
-	tristate 
+	tristate
 
 config SND_RK29_SOC_I2S_8CH
         bool "Soc RK29 I2S 8 Channel support(I2S0)"
@@ -15,7 +15,7 @@ config SND_RK29_SOC_I2S_8CH
 	depends on SND_RK29_SOC_I2S
 	help
                 This supports the use of the 8 Channel I2S interface on rk29 processors.
-				
+
 config SND_RK29_SOC_I2S_2CH
         bool "Soc RK29 I2S 2 Channel support(I2S1)"
         default n
@@ -29,7 +29,7 @@ config SND_RK_SOC_I2S2_2CH
 	depends on SND_RK29_SOC_I2S && ARCH_RK30
 	help
 		This supports the use of the 2 Channel I2S2 interface on rk30 processors.
-				
+
 if 	SND_RK29_SOC_I2S_2CH || SND_RK29_SOC_I2S_8CH || SND_RK_SOC_I2S2_2CH
 choice
   bool "Set i2s on DMA event mode"
@@ -114,7 +114,7 @@ config SND_RK29_SOC_WM8994
 	select SND_SOC_WM8994
 	help
 	  Say Y if you want to add support for SoC audio on rockchip
-	  with the WM8994.  
+	  with the WM8994.
 
 config SND_RK29_SOC_CS42L52
 	tristate "SoC I2S Audio support for rockchip - CS42L52"
@@ -133,7 +133,7 @@ config SND_RK29_SOC_AIC3111
 	help
 	  Say Y if you want to add support for SoC audio on rockchip
 	  with the AIC3111.
-  
+
 config SND_RK29_SOC_RK1000
 	tristate "SoC I2S Audio support for rockchip - RK1000"
 	depends on SND_RK29_SOC
@@ -141,23 +141,25 @@ config SND_RK29_SOC_RK1000
 	select SND_SOC_RK1000
 	help
 	  Say Y if you want to add support for SoC audio on rockchip
-	  with the RK1000.	 
+	  with the RK1000.
+
 config SND_RK29_SOC_HDMI
 	tristate "SoC I2S Audio support for rockchip - HDMI"
 	depends on SND_RK29_SOC && HDMI_ITV
 	select SND_RK29_SOC_I2S
 	help
 	  Say Y if you want to add support for SoC audio on rockchip
-	  with the HDMI.	 
+	  with the HDMI.
+
 config SND_RK29_SOC_RK610
 	tristate "SoC I2S Audio support for rockchip - RK610"
-	depends on SND_RK29_SOC && MFD_RK610 && I2C_RK29
+	depends on SND_RK29_SOC && MFD_RK610
 	select SND_RK29_SOC_I2S
 	select SND_SOC_RK610
 	help
 	  Say Y if you want to add support for SoC audio on rockchip
-	  with the RK610(JETTA). 
-	   
+	  with the RK610(JETTA).
+
 if SND_RK29_SOC_WM8988 || SND_RK29_SOC_RK1000 || SND_RK29_SOC_WM8994 || SND_RK29_SOC_WM8900 || SND_RK29_SOC_RT5621 || SND_RK29_SOC_RT5631 || SND_RK29_SOC_RT5625 || SND_RK29_SOC_CS42L52 || SND_RK29_SOC_AIC3111 || SND_RK29_SOC_HDMI || SND_RK29_SOC_RK610
 choice
   bool "Set i2s type"
@@ -180,5 +182,6 @@ config PHONE_INCALL_IS_SUSPEND
     default n
     help
 		set "y" phone incall status cannot into suspend codec
-		
+
 endif
+
diff --git a/sound/soc/rk29/rk29_jetta_codec.c b/sound/soc/rk29/rk29_jetta_codec.c
old mode 100644
new mode 100755
index c657f7a2124d..e46a19353ffb
--- a/sound/soc/rk29/rk29_jetta_codec.c
+++ b/sound/soc/rk29/rk29_jetta_codec.c
@@ -19,7 +19,6 @@
 #include <sound/soc-dapm.h>
 #include <asm/io.h>
 #include <mach/hardware.h>
-#include <mach/rk29_iomap.h>
 #include "../codecs/rk610_codec.h"
 #include "rk29_pcm.h"
 #include "rk29_i2s.h"
@@ -34,13 +33,8 @@ static int rk29_hw_params(struct snd_pcm_substream *substream,
 	struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-#else
-        struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
-        struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
-#endif
 	int ret;
 	unsigned int pll_out = 0; 
 	int div_bclk,div_mclk;
@@ -52,59 +46,32 @@ static int rk29_hw_params(struct snd_pcm_substream *substream,
 	#define HW_PARAMS_FLAG_EQVOL_OFF 0x22
 	if ((params->flags == HW_PARAMS_FLAG_EQVOL_ON)||(params->flags == HW_PARAMS_FLAG_EQVOL_OFF))
 	{
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 		ret = codec_dai->driver->ops->hw_params(substream, params, codec_dai); //by Vincent
-		#else
-		ret = codec_dai->ops->hw_params(substream, params, codec_dai); //by Vincent
-		#endif
-		DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
 	}
 	else
 	{
 		/* set codec DAI configuration */
 		DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
 		#if defined (CONFIG_SND_RK29_CODEC_SOC_SLAVE) 
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-		ret = codec_dai->driver->ops->set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS); 
-		#else
-		ret = codec_dai->ops->set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
 			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS); 
-		#endif
-		#endif	
-		#if defined (CONFIG_SND_RK29_CODEC_SOC_MASTER) 
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-		ret = codec_dai->driver->ops->set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM ); 
-		#else
-		ret = codec_dai->ops->set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		#elif defined (CONFIG_SND_RK29_CODEC_SOC_MASTER) 
+		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
 			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM ); 
 		#endif
-		#endif
 		if (ret < 0)
-			  return ret; 
+			return ret; 
 		/* set cpu DAI configuration */
 		DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
 		#if defined (CONFIG_SND_RK29_CODEC_SOC_SLAVE) 
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-		ret = cpu_dai->driver->ops->set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
 			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-		#else
-		ret = cpu_dai->ops->set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-		#endif
-		#endif	
-		#if defined (CONFIG_SND_RK29_CODEC_SOC_MASTER) 
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-		ret = cpu_dai->driver->ops->set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		#elif defined (CONFIG_SND_RK29_CODEC_SOC_MASTER) 
+		ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
 			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);	
-		#else
-		ret = cpu_dai->ops->set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);	
-		#endif
 		#endif		
 		if (ret < 0)
-			  return ret;
+			return ret;
 	}
 
 	switch(params_rate(params)) {
@@ -143,7 +110,7 @@ static int rk29_hw_params(struct snd_pcm_substream *substream,
 		div_bclk = 63;
 		div_mclk = pll_out/(params_rate(params)*64) - 1;
 		
-		DBG("func is%s,pll_out=%ld,div_mclk=%ld div_bclk=%ld\n",
+		DBG("func is%s,pll_out=%d,div_mclk=%d div_bclk\n",
 				__FUNCTION__,pll_out,div_mclk, div_bclk);
 		snd_soc_dai_set_sysclk(cpu_dai, 0, pll_out, 0);
 		snd_soc_dai_set_clkdiv(cpu_dai, ROCKCHIP_DIV_BCLK,div_bclk);
@@ -153,85 +120,23 @@ static int rk29_hw_params(struct snd_pcm_substream *substream,
     return 0;
 }
 
-static const struct snd_soc_dapm_widget rk29_dapm_widgets[] = {
-	SND_SOC_DAPM_LINE("Audio Out", NULL),
-	SND_SOC_DAPM_LINE("Line in", NULL),
-	SND_SOC_DAPM_MIC("Micn", NULL),
-	SND_SOC_DAPM_MIC("Micp", NULL),
-};
-
-static const struct snd_soc_dapm_route audio_map[]= {
-	
-	{"Audio Out", NULL, "LOUT1"},
-	{"Audio Out", NULL, "ROUT1"},
-	{"Line in", NULL, "RINPUT1"},
-	{"Line in", NULL, "LINPUT1"},
-//	{"Micn", NULL, "RINPUT2"},
-//	{"Micp", NULL, "LINPUT2"},
-};
-
-/*
- * Logic for a RK610 codec as connected on a rockchip board.
- */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-static int rk29_RK610_codec_init(struct snd_soc_pcm_runtime *rtd) {
-	struct snd_soc_codec *codec = rtd->codec;
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-	
-	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
-        /* Add specific widgets */
-	snd_soc_dapm_new_controls(dapm, rk29_dapm_widgets,
-				  ARRAY_SIZE(rk29_dapm_widgets));
-				  
-	/* Set up specific audio path audio_mapnects */
-	snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
-	snd_soc_dapm_sync(dapm);
-	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
-	
-	return 0;
-}
-#else 
-static int rk29_RK610_codec_init(struct snd_soc_codec *codec) {
-//	struct snd_soc_dai *codec_dai = &codec->dai[0];
-	int ret;
-	
-	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
-	
-//	ret = snd_soc_dai_set_sysclk(codec_dai, 0,
-//	                                11289600, SND_SOC_CLOCK_IN);
-//	if (ret < 0) {
-//	        printk(KERN_ERR "Failed to set WM8988 SYSCLK: %d\n", ret);
-//	        return ret;
-//	}
-	
-	/* Add specific widgets */
-	snd_soc_dapm_new_controls(codec, rk29_dapm_widgets,
-			  ARRAY_SIZE(rk29_dapm_widgets));
-	
-	/* Set up specific audio path audio_mapnects */
-	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
-	
-	snd_soc_dapm_sync(codec);
-	
-	return 0;
-}
-#endif
 static struct snd_soc_ops rk29_ops = {
 	.hw_params = rk29_hw_params,
 };
 
 static struct snd_soc_dai_link rk29_dai = {
-	.name = "RK610",
+	.name = "RK610_CODEC",
 	.stream_name = "RK610 CODEC PCM",
-	.codec_name = "RK610_CODEC.1-0060",
+	.codec_name = "RK610_CODEC.0-0060",
 	.platform_name = "rockchip-audio",
 #if defined(CONFIG_SND_RK29_SOC_I2S_8CH)	
 	.cpu_dai_name = "rk29_i2s.0",
 #elif defined(CONFIG_SND_RK29_SOC_I2S_2CH)
 	.cpu_dai_name = "rk29_i2s.1",
+#else	
+	.cpu_dai_name = "rk29_i2s.2",	
 #endif
-	.codec_dai_name = "rk610_codec_xx",
-	.init = rk29_RK610_codec_init,
+	.codec_dai_name = "rk610_codec",
 	.ops = &rk29_ops,
 };
 static struct snd_soc_card snd_soc_card_rk29 = {
@@ -240,27 +145,22 @@ static struct snd_soc_card snd_soc_card_rk29 = {
 	.num_links = 1,
 };
 
+
 static struct platform_device *rk29_snd_device;
 
 static int __init audio_card_init(void)
 {
 	int ret =0;	
 	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
-	printk(KERN_ERR "[%s] start\n", __FUNCTION__);
 	rk29_snd_device = platform_device_alloc("soc-audio", -1);
 	if (!rk29_snd_device) {
 		printk("[%s] platform device allocation failed\n", __FUNCTION__);
 		ret = -ENOMEM;
 		return ret;
 	}
-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	platform_set_drvdata(rk29_snd_device, &snd_soc_card_rk29);
-	#else
-	platform_set_drvdata(rk29_snd_device, &rk29_snd_devdata);
-	rk29_snd_devdata.dev = &rk29_snd_device->dev;
-	#endif
+
 	ret = platform_device_add(rk29_snd_device);
-	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
 	if (ret) {
 		DBG("platform device add failed\n");
 		platform_device_put(rk29_snd_device);
-- 
2.35.3

