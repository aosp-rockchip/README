From 5f69e10aa611d33e2e919c9faac332ac8b5e343d Mon Sep 17 00:00:00 2001
From: lyx <lyx@rock-chips.com>
Date: Wed, 25 Aug 2010 23:32:21 -0700
Subject: [PATCH] display : framebuff && lcd screen reconstruct framebuff and
 lcd code, move board dependence define to board-raho.c and board-infosdk.c

---
 arch/arm/mach-rk2818/board-infosdk.c          | 262 +++++++++++++-----
 arch/arm/mach-rk2818/board-raho.c             | 237 +++++++++++-----
 arch/arm/mach-rk2818/devices.c                |   4 +-
 arch/arm/mach-rk2818/include/mach/board.h     |  47 ++--
 drivers/video/display/screen/lcd_hl070vm4.c   |  88 ++----
 drivers/video/display/screen/lcd_hsd800x480.c |  88 ++----
 drivers/video/display/screen/lcd_hx8357.c     |  29 +-
 drivers/video/display/screen/lcd_nt35580.c    |  38 ++-
 drivers/video/display/screen/lcd_td043mgea1.c |  26 +-
 .../video/display/screen/lcd_tj048nc01ca.c    |  90 ++----
 drivers/video/display/screen/screen.h         |   2 +-
 drivers/video/rk2818_fb.c                     |  76 +++--
 12 files changed, 555 insertions(+), 432 deletions(-)
 mode change 100644 => 100755 drivers/video/display/screen/lcd_hx8357.c
 mode change 100644 => 100755 drivers/video/rk2818_fb.c

diff --git a/arch/arm/mach-rk2818/board-infosdk.c b/arch/arm/mach-rk2818/board-infosdk.c
index 3c4aa368b896..3075720c8d6a 100755
--- a/arch/arm/mach-rk2818/board-infosdk.c
+++ b/arch/arm/mach-rk2818/board-infosdk.c
@@ -667,6 +667,7 @@ struct soc_camera_link rk2818_iclink = {
 #define CHARGEOK_PIN	RK2818_PIN_PA4
 struct rk2818_battery_platform_data rk2818_battery_platdata = {
 	.charge_ok_pin = CHARGEOK_PIN,
+	.charge_ok_level = 0,
 };
 /*****************************************************************************************
  * serial devices
@@ -922,26 +923,193 @@ static struct spi_board_info board_spi_devices[] = {
 #endif
 }; 
 
-/*rk2818_fb gpio information*/
-static struct rk2818_fb_gpio rk2818_fb_gpio_info = {
-    .display_on = (GPIO_LOW<<16)|RK2818_PIN_PB1,
-    .lcd_standby = 0,
-    .mcu_fmk_pin = 0,
-};
+/*****************************************************************************************
+ * lcd  devices
+ * author: zyw@rock-chips.com
+ *****************************************************************************************/
+//#ifdef  CONFIG_LCD_TD043MGEA1
+#define LCD_TXD_PIN          RK2818_PIN_PE6
+#define LCD_CLK_PIN          RK2818_PIN_PE7
+#define LCD_CS_PIN           RK2818_PIN_PH6
+#define LCD_TXD_MUX_NAME     GPIOE_U1IR_I2C1_NAME
+#define LCD_CLK_MUX_NAME     NULL
+#define LCD_CS_MUX_NAME      GPIOH6_IQ_SEL_NAME
+#define LCD_TXD_MUX_MODE     0
+#define LCD_CLK_MUX_MODE     0
+#define LCD_CS_MUX_MODE      0
+//#endif
+static int rk2818_lcd_io_init(void)
+{
+    int ret = 0;
+    
+    rk2818_mux_api_set(LCD_CS_MUX_NAME, LCD_CS_MUX_MODE);
+    if (LCD_CS_PIN != INVALID_GPIO) {
+        ret = gpio_request(LCD_CS_PIN, NULL); 
+        if(ret != 0)
+        {
+            goto err1;
+            printk(">>>>>> lcd cs gpio_request err \n ");                    
+        } 
+    }
+    
+    rk2818_mux_api_set(LCD_CLK_MUX_NAME, LCD_CLK_MUX_MODE);
+    if (LCD_CLK_PIN != INVALID_GPIO) {
+        ret = gpio_request(LCD_CLK_PIN, NULL); 
+        if(ret != 0)
+        {
+            goto err2;
+            printk(">>>>>> lcd clk gpio_request err \n ");             
+        }  
+    }
+    
+    rk2818_mux_api_set(LCD_TXD_MUX_NAME, LCD_TXD_MUX_MODE); 
+    if (LCD_TXD_PIN != INVALID_GPIO) {
+        ret = gpio_request(LCD_TXD_PIN, NULL); 
+        if(ret != 0)
+        {
+            goto err3;
+            printk(">>>>>> lcd txd gpio_request err \n ");             
+        } 
+    }
+
+    return 0;
+    
+err3:
+    if (LCD_CLK_PIN != INVALID_GPIO) {
+        gpio_free(LCD_CLK_PIN);
+    }
+err2:
+    if (LCD_CS_PIN != INVALID_GPIO) {
+        gpio_free(LCD_CS_PIN);
+    }
+err1:
+    return ret;
+}
+
+static int rk2818_lcd_io_deinit(void)
+{
+    int ret = 0;
 
-/*rk2818_fb iomux information*/
-static struct rk2818_fb_iomux rk2818_fb_iomux_info = {
-    .data16     = GPIOC_LCDC16BIT_SEL_NAME,
-    .data18     = GPIOC_LCDC18BIT_SEL_NAME,
-    .data24     = GPIOC_LCDC24BIT_SEL_NAME,
-    .den        = CXGPIO_LCDDEN_SEL_NAME,
-    .vsync      = CXGPIO_LCDVSYNC_SEL_NAME,
-    .mcu_fmk    = 0,
+    gpio_free(LCD_CS_PIN); 
+    rk2818_mux_api_mode_resume(LCD_CS_MUX_NAME);
+    gpio_free(LCD_CLK_PIN);   
+    gpio_free(LCD_TXD_PIN); 
+    rk2818_mux_api_mode_resume(LCD_TXD_MUX_NAME);
+    rk2818_mux_api_mode_resume(LCD_CLK_MUX_NAME);
+    
+    return ret;
+}
+
+struct rk2818lcd_info rk2818_lcd_info = {
+    .txd_pin  = LCD_TXD_PIN,
+    .clk_pin = LCD_CLK_PIN,
+    .cs_pin = LCD_CS_PIN,
+    .io_init   = rk2818_lcd_io_init,
+    .io_deinit = rk2818_lcd_io_deinit, 
 };
-/*rk2818_fb*/
-struct rk2818_fb_mach_info rk2818_fb_mach_info = {
-    .gpio = &rk2818_fb_gpio_info,
-    .iomux = &rk2818_fb_iomux_info,
+
+
+/*****************************************************************************************
+ * frame buffe  devices
+ * author: zyw@rock-chips.com
+ *****************************************************************************************/
+#define FB_ID                       0
+#define FB_DISPLAY_ON_PIN           RK2818_PIN_PB1
+#define FB_LCD_STANDBY_PIN          INVALID_GPIO
+#define FB_MCU_FMK_PIN              INVALID_GPIO
+
+#define FB_DISPLAY_ON_VALUE         GPIO_LOW
+#define FB_LCD_STANDBY_VALUE        0
+
+#define FB_DISPLAY_ON_MUX_NAME      GPIOB1_SMCS1_MMC0PCA_NAME
+#define FB_DISPLAY_ON_MUX_MODE      IOMUXA_GPIO0_B1
+
+#define FB_LCD_STANDBY_MUX_NAME     NULL
+#define FB_LCD_STANDBY_MUX_MODE     1
+
+#define FB_MCU_FMK_PIN_MUX_NAME     NULL
+#define FB_MCU_FMK_MUX_MODE         0
+
+#define FB_DATA0_16_MUX_NAME       GPIOC_LCDC16BIT_SEL_NAME
+#define FB_DATA0_16_MUX_MODE        1
+
+#define FB_DATA17_18_MUX_NAME      GPIOC_LCDC18BIT_SEL_NAME
+#define FB_DATA17_18_MUX_MODE       1
+
+#define FB_DATA19_24_MUX_NAME      GPIOC_LCDC24BIT_SEL_NAME
+#define FB_DATA19_24_MUX_MODE       1
+
+#define FB_DEN_MUX_NAME            CXGPIO_LCDDEN_SEL_NAME
+#define FB_DEN_MUX_MODE             1
+
+#define FB_VSYNC_MUX_NAME          CXGPIO_LCDVSYNC_SEL_NAME
+#define FB_VSYNC_MUX_MODE           1
+
+#define FB_MCU_FMK_MUX_NAME        NULL
+#define FB_MCU_FMK_MUX_MODE         0
+
+static int rk2818_fb_io_init(struct rk2818_fb_setting_info *fb_setting)
+{
+    int ret = 0;
+    if(fb_setting->data_num <=16)
+        rk2818_mux_api_set(FB_DATA0_16_MUX_NAME, FB_DATA0_16_MUX_MODE);
+    if(fb_setting->data_num >16 && fb_setting->data_num<=18)
+        rk2818_mux_api_set(FB_DATA17_18_MUX_NAME, FB_DATA17_18_MUX_MODE);
+    if(fb_setting->data_num >18)
+        rk2818_mux_api_set(FB_DATA19_24_MUX_NAME, FB_DATA19_24_MUX_MODE);
+    
+    if(fb_setting->vsync_en)
+        rk2818_mux_api_set(FB_VSYNC_MUX_NAME, FB_VSYNC_MUX_MODE);
+    
+    if(fb_setting->den_en)
+        rk2818_mux_api_set(FB_DEN_MUX_NAME, FB_DEN_MUX_MODE);
+    
+    if(fb_setting->mcu_fmk_en && FB_MCU_FMK_MUX_NAME && (FB_MCU_FMK_PIN != INVALID_GPIO))
+    {
+        rk2818_mux_api_set(FB_MCU_FMK_MUX_NAME, FB_MCU_FMK_MUX_MODE);
+        ret = gpio_request(FB_MCU_FMK_PIN, NULL);         
+        if(ret != 0)
+        {
+            gpio_free(FB_MCU_FMK_PIN);
+            printk(">>>>>> FB_MCU_FMK_PIN gpio_request err \n ");             
+        } 
+        gpio_direction_input(FB_MCU_FMK_PIN);
+    }
+
+    if(fb_setting->disp_on_en && FB_DISPLAY_ON_MUX_NAME && (FB_DISPLAY_ON_PIN != INVALID_GPIO))
+    {
+        rk2818_mux_api_set(FB_DISPLAY_ON_MUX_NAME, FB_DISPLAY_ON_MUX_MODE);
+        ret = gpio_request(FB_DISPLAY_ON_PIN, NULL);         
+        if(ret != 0)
+        {
+            gpio_free(FB_DISPLAY_ON_PIN);
+            printk(">>>>>> FB_DISPLAY_ON_PIN gpio_request err \n ");             
+        }         
+    }
+
+    if(fb_setting->disp_on_en && FB_LCD_STANDBY_MUX_NAME && (FB_LCD_STANDBY_PIN != INVALID_GPIO))
+    {
+        rk2818_mux_api_set(FB_LCD_STANDBY_MUX_NAME, FB_LCD_STANDBY_MUX_MODE);
+        ret = gpio_request(FB_LCD_STANDBY_PIN, NULL);         
+        if(ret != 0)
+        {
+            gpio_free(FB_LCD_STANDBY_PIN);
+            printk(">>>>>> FB_LCD_STANDBY_PIN gpio_request err \n ");             
+        }
+    }
+
+    return ret;
+}
+
+struct rk2818fb_info rk2818_fb_info = {
+    .fb_id   = FB_ID,  
+    .disp_on_pin = FB_DISPLAY_ON_PIN,
+    .disp_on_value = FB_DISPLAY_ON_VALUE,
+    .standby_pin = FB_LCD_STANDBY_PIN,
+    .standby_value = FB_LCD_STANDBY_VALUE,
+    .mcu_fmk_pin = FB_MCU_FMK_PIN,  
+    .lcd_info = &rk2818_lcd_info,
+    .io_init   = rk2818_fb_io_init,
 };
 
 /*****************************************************************************************
@@ -1220,61 +1388,6 @@ static void rk2818_power_off(void)
 	gpio_set_value(POWER_PIN, 0);/*power down*/
 }
 
-void lcd_set_iomux(u8 enable)
-{
-    int ret=-1;
-    
-    if(enable)
-    {
-        rk2818_mux_api_set(GPIOH6_IQ_SEL_NAME, 0);
-        ret = gpio_request(RK2818_PIN_PH6, NULL);
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PH6);
-            printk(">>>>>> lcd cs gpio_request err \n ");           
-            goto pin_err;
-        }  
-        
-        rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 0);    
-
-        ret = gpio_request(RK2818_PIN_PE7, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE7);
-            printk(">>>>>> lcd clk gpio_request err \n "); 
-            goto pin_err;
-        }  
-        
-        ret = gpio_request(RK2818_PIN_PE6, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE6);
-            printk(">>>>>> lcd txd gpio_request err \n "); 
-            goto pin_err;
-        }        
-    }
-    else
-    {
-         gpio_free(RK2818_PIN_PH6);
-         rk2818_mux_api_mode_resume(GPIOH6_IQ_SEL_NAME);
-
-         gpio_free(RK2818_PIN_PE7);   
-         gpio_free(RK2818_PIN_PE6); 
-         rk2818_mux_api_mode_resume(GPIOE_U1IR_I2C1_NAME);
-    }
-    return ;
-pin_err:
-    return ;
-
-}
-
-struct lcd_td043mgea1_data lcd_td043mgea1 = {
-    .pin_txd    = RK2818_PIN_PE6,
-    .pin_clk    = RK2818_PIN_PE7,
-    .pin_cs     = RK2818_PIN_PH6,
-    .screen_set_iomux = lcd_set_iomux,
-};
-
 //	adc	 ---> key	
 #define PLAY_ON_PIN RK2818_PIN_PE1
 #define PLAY_ON_LEVEL 1
@@ -1342,9 +1455,6 @@ static void __init machine_rk2818_board_init(void)
 #endif
 	platform_add_devices(devices, ARRAY_SIZE(devices));	
 	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
-	//rk2818_mux_api_set(GPIOB4_SPI0CS0_MMC0D4_NAME,IOMUXA_GPIO0_B4); //IOMUXA_SPI0_CSN0);//use for gpio SPI CS0
-	//rk2818_mux_api_set(GPIOB0_SPI0CSN1_MMC1PCA_NAME,IOMUXA_GPIO0_B0); //IOMUXA_SPI0_CSN1);//use for gpio SPI CS1
-	//rk2818_mux_api_set(GPIOB_SPI0_MMC0_NAME,IOMUXA_SPI0);//use for SPI CLK SDI SDO
 }
 
 static void __init machine_rk2818_mapio(void)
diff --git a/arch/arm/mach-rk2818/board-raho.c b/arch/arm/mach-rk2818/board-raho.c
index bf450804ae47..49d81a00e777 100755
--- a/arch/arm/mach-rk2818/board-raho.c
+++ b/arch/arm/mach-rk2818/board-raho.c
@@ -1149,79 +1149,192 @@ static struct spi_board_info board_spi_devices[] = {
 #endif
 }; 
 
-/*rk2818_fb gpio information*/
-static struct rk2818_fb_gpio rk2818_fb_gpio_info = {
-    .display_on = (GPIO_LOW<<16)|RK2818_PIN_PA2,
-    .lcd_standby = 0,
-    .mcu_fmk_pin = 0,
-};
+/*****************************************************************************************
+ * lcd  devices
+ * author: zyw@rock-chips.com
+ *****************************************************************************************/
+//#ifdef  CONFIG_LCD_TD043MGEA1
+#define LCD_TXD_PIN          RK2818_PIN_PE4
+#define LCD_CLK_PIN          RK2818_PIN_PE5
+#define LCD_CS_PIN           RK2818_PIN_PH6
+#define LCD_TXD_MUX_NAME     GPIOE_I2C0_SEL_NAME
+#define LCD_CLK_MUX_NAME     NULL
+#define LCD_CS_MUX_NAME      GPIOH6_IQ_SEL_NAME
+#define LCD_TXD_MUX_MODE     1
+#define LCD_CLK_MUX_MODE     1
+#define LCD_CS_MUX_MODE      0
+//#endif
+static int rk2818_lcd_io_init(void)
+{
+    int ret = 0;
+    
+    rk2818_mux_api_set(LCD_CS_MUX_NAME, LCD_CS_MUX_MODE);
+    if (LCD_CS_PIN != INVALID_GPIO) {
+        ret = gpio_request(LCD_CS_PIN, NULL); 
+        if(ret != 0)
+        {
+            goto err1;
+            printk(">>>>>> lcd cs gpio_request err \n ");                    
+        } 
+    }
+    
+    rk2818_mux_api_set(LCD_CLK_MUX_NAME, LCD_CLK_MUX_MODE);
+    if (LCD_CLK_PIN != INVALID_GPIO) {
+        ret = gpio_request(LCD_CLK_PIN, NULL); 
+        if(ret != 0)
+        {
+            goto err2;
+            printk(">>>>>> lcd clk gpio_request err \n ");             
+        }  
+    }
+    
+    rk2818_mux_api_set(LCD_TXD_MUX_NAME, LCD_TXD_MUX_MODE); 
+    if (LCD_TXD_PIN != INVALID_GPIO) {
+        ret = gpio_request(LCD_TXD_PIN, NULL); 
+        if(ret != 0)
+        {
+            goto err3;
+            printk(">>>>>> lcd txd gpio_request err \n ");             
+        } 
+    }
 
-/*rk2818_fb iomux information*/
-static struct rk2818_fb_iomux rk2818_fb_iomux_info = {
-    .data16     = GPIOC_LCDC16BIT_SEL_NAME,
-    .data18     = GPIOC_LCDC18BIT_SEL_NAME,
-    .data24     = GPIOC_LCDC24BIT_SEL_NAME,
-    .den        = CXGPIO_LCDDEN_SEL_NAME,
-    .vsync      = CXGPIO_LCDVSYNC_SEL_NAME,
-    .mcu_fmk    = 0,
-};
-/*rk2818_fb*/
-struct rk2818_fb_mach_info rk2818_fb_mach_info = {
-    .gpio = &rk2818_fb_gpio_info,
-    .iomux = &rk2818_fb_iomux_info,
-};
+    return 0;
+    
+err3:
+    if (LCD_CLK_PIN != INVALID_GPIO) {
+        gpio_free(LCD_CLK_PIN);
+    }
+err2:
+    if (LCD_CS_PIN != INVALID_GPIO) {
+        gpio_free(LCD_CS_PIN);
+    }
+err1:
+    return ret;
+}
 
-void lcd_set_iomux(u8 enable)
+static int rk2818_lcd_io_deinit(void)
 {
-    int ret=-1;
+    int ret = 0;
+    gpio_free(LCD_CS_PIN); 
+    rk2818_mux_api_mode_resume(LCD_CS_MUX_NAME);
+    gpio_free(LCD_CLK_PIN);   
+    gpio_free(LCD_TXD_PIN); 
+    rk2818_mux_api_mode_resume(LCD_TXD_MUX_NAME);
+    rk2818_mux_api_mode_resume(LCD_CLK_MUX_NAME);
+    
+    return ret;
+}
+
+struct rk2818lcd_info rk2818_lcd_info = {
+    .txd_pin  = LCD_TXD_PIN,
+    .clk_pin = LCD_CLK_PIN,
+    .cs_pin = LCD_CS_PIN,
+    .io_init   = rk2818_lcd_io_init,
+    .io_deinit = rk2818_lcd_io_deinit, 
+};
 
-    if(enable)
+
+/*****************************************************************************************
+ * frame buffe  devices
+ * author: zyw@rock-chips.com
+ *****************************************************************************************/
+#define FB_ID                       0
+#define FB_DISPLAY_ON_PIN           RK2818_PIN_PA2
+#define FB_LCD_STANDBY_PIN          INVALID_GPIO
+#define FB_MCU_FMK_PIN              INVALID_GPIO
+
+#define FB_DISPLAY_ON_VALUE         GPIO_LOW
+#define FB_LCD_STANDBY_VALUE        0
+
+#define FB_DISPLAY_ON_MUX_NAME      GPIOA23_UART2_SEL_NAME
+#define FB_DISPLAY_ON_MUX_MODE      IOMUXB_GPIO0_A23
+
+#define FB_LCD_STANDBY_MUX_NAME     NULL
+#define FB_LCD_STANDBY_MUX_MODE     1
+
+#define FB_MCU_FMK_PIN_MUX_NAME     NULL
+#define FB_MCU_FMK_MUX_MODE         0
+
+#define FB_DATA0_16_MUX_NAME       GPIOC_LCDC16BIT_SEL_NAME
+#define FB_DATA0_16_MUX_MODE        1
+
+#define FB_DATA17_18_MUX_NAME      GPIOC_LCDC18BIT_SEL_NAME
+#define FB_DATA17_18_MUX_MODE       1
+
+#define FB_DATA19_24_MUX_NAME      GPIOC_LCDC24BIT_SEL_NAME
+#define FB_DATA19_24_MUX_MODE       1
+
+#define FB_DEN_MUX_NAME            CXGPIO_LCDDEN_SEL_NAME
+#define FB_DEN_MUX_MODE             1
+
+#define FB_VSYNC_MUX_NAME          CXGPIO_LCDVSYNC_SEL_NAME
+#define FB_VSYNC_MUX_MODE           1
+
+#define FB_MCU_FMK_MUX_NAME        NULL
+#define FB_MCU_FMK_MUX_MODE         0
+
+static int rk2818_fb_io_init(struct rk2818_fb_setting_info *fb_setting)
+{
+    int ret = 0;
+    if(fb_setting->data_num <=16)
+        rk2818_mux_api_set(FB_DATA0_16_MUX_NAME, FB_DATA0_16_MUX_MODE);
+    if(fb_setting->data_num >16 && fb_setting->data_num<=18)
+        rk2818_mux_api_set(FB_DATA17_18_MUX_NAME, FB_DATA17_18_MUX_MODE);
+    if(fb_setting->data_num >18)
+        rk2818_mux_api_set(FB_DATA19_24_MUX_NAME, FB_DATA19_24_MUX_MODE);
+    
+    if(fb_setting->vsync_en)
+        rk2818_mux_api_set(FB_VSYNC_MUX_NAME, FB_VSYNC_MUX_MODE);
+    
+    if(fb_setting->den_en)
+        rk2818_mux_api_set(FB_DEN_MUX_NAME, FB_DEN_MUX_MODE);
+    
+    if(fb_setting->mcu_fmk_en && FB_MCU_FMK_MUX_NAME && (FB_MCU_FMK_PIN != INVALID_GPIO))
     {
-        rk2818_mux_api_set(GPIOH6_IQ_SEL_NAME, 0);
-        ret = gpio_request(RK2818_PIN_PH6, NULL); 
+        rk2818_mux_api_set(FB_MCU_FMK_MUX_NAME, FB_MCU_FMK_MUX_MODE);
+        ret = gpio_request(FB_MCU_FMK_PIN, NULL);         
         if(ret != 0)
         {
-            gpio_free(RK2818_PIN_PH6);
-            printk(">>>>>> lcd cs gpio_request err \n ");           
-            goto pin_err;
-        }  
-        rk2818_mux_api_set(GPIOE_I2C0_SEL_NAME, 1);    
+            gpio_free(FB_MCU_FMK_PIN);
+            printk(">>>>>> FB_MCU_FMK_PIN gpio_request err \n ");             
+        } 
+        gpio_direction_input(FB_MCU_FMK_PIN);
+    }
 
-        ret = gpio_request(RK2818_PIN_PE4, NULL); 
-        if(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE4);
-            printk(">>>>>> lcd clk gpio_request err \n "); 
-            goto pin_err;
-        }  
-        ret = gpio_request(RK2818_PIN_PE5, NULL); 
+    if(fb_setting->disp_on_en && FB_DISPLAY_ON_MUX_NAME && (FB_DISPLAY_ON_PIN != INVALID_GPIO))
+    {
+        rk2818_mux_api_set(FB_DISPLAY_ON_MUX_NAME, FB_DISPLAY_ON_MUX_MODE);
+        ret = gpio_request(FB_DISPLAY_ON_PIN, NULL);         
         if(ret != 0)
         {
-            gpio_free(RK2818_PIN_PE5);
-            printk(">>>>>> lcd txd gpio_request err \n "); 
-            goto pin_err;
-        }        
+            gpio_free(FB_DISPLAY_ON_PIN);
+            printk(">>>>>> FB_DISPLAY_ON_PIN gpio_request err \n ");             
+        }         
     }
-    else
-    {
-         gpio_free(RK2818_PIN_PH6);
-         rk2818_mux_api_mode_resume(GPIOH6_IQ_SEL_NAME);
 
-         gpio_free(RK2818_PIN_PE4);   
-         gpio_free(RK2818_PIN_PE5); 
-         rk2818_mux_api_mode_resume(GPIOE_I2C0_SEL_NAME);
+    if(fb_setting->disp_on_en && FB_LCD_STANDBY_MUX_NAME && (FB_LCD_STANDBY_PIN != INVALID_GPIO))
+    {
+        rk2818_mux_api_set(FB_LCD_STANDBY_MUX_NAME, FB_LCD_STANDBY_MUX_MODE);
+        ret = gpio_request(FB_LCD_STANDBY_PIN, NULL);         
+        if(ret != 0)
+        {
+            gpio_free(FB_LCD_STANDBY_PIN);
+            printk(">>>>>> FB_LCD_STANDBY_PIN gpio_request err \n ");             
+        }
     }
-    return ;
-pin_err:
-    return ;
 
+    return ret;
 }
 
-struct lcd_td043mgea1_data lcd_td043mgea1 = {
-    .pin_txd    = RK2818_PIN_PE4,
-    .pin_clk    = RK2818_PIN_PE5,
-    .pin_cs     = RK2818_PIN_PH6,
-    .screen_set_iomux = lcd_set_iomux,
+struct rk2818fb_info rk2818_fb_info = {
+    .fb_id   = FB_ID,  
+    .disp_on_pin = FB_DISPLAY_ON_PIN,
+    .disp_on_value = FB_DISPLAY_ON_VALUE,
+    .standby_pin = FB_LCD_STANDBY_PIN,
+    .standby_value = FB_LCD_STANDBY_VALUE,
+    .mcu_fmk_pin = FB_MCU_FMK_PIN,  
+    .lcd_info = &rk2818_lcd_info,
+    .io_init   = rk2818_fb_io_init,
 };
 
 /*****************************************************************************************
@@ -1637,16 +1750,6 @@ static void __init machine_rk2818_board_init(void)
 #endif
 	platform_add_devices(devices, ARRAY_SIZE(devices));	
 	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
-	//rk2818_mux_api_set(GPIOB4_SPI0CS0_MMC0D4_NAME,IOMUXA_GPIO0_B4); //IOMUXA_SPI0_CSN0);//use for gpio SPI CS0
-	//rk2818_mux_api_set(GPIOB0_SPI0CSN1_MMC1PCA_NAME,IOMUXA_GPIO0_B0); //IOMUXA_SPI0_CSN1);//use for gpio SPI CS1
-	//rk2818_mux_api_set(GPIOB_SPI0_MMC0_NAME,IOMUXA_SPI0);//use for SPI CLK SDI SDO
-
-	//rk2818_mux_api_set(GPIOF5_APWM3_DPWM3_NAME,IOMUXB_GPIO1_B5);
-	//if(0 != gpio_request(RK2818_PIN_PF5, NULL))
-    //{
-    //    gpio_free(RK2818_PIN_PF5);
-    //    printk(">>>>>> RK2818_PIN_PF5 gpio_request err \n "); 
-    //} 
 }
 
 static void __init machine_rk2818_mapio(void)
diff --git a/arch/arm/mach-rk2818/devices.c b/arch/arm/mach-rk2818/devices.c
index 25ef8e558dc3..4aaf43bfe874 100755
--- a/arch/arm/mach-rk2818/devices.c
+++ b/arch/arm/mach-rk2818/devices.c
@@ -258,7 +258,7 @@ static struct resource rk2818_fb_resource[] = {
 };
 
 /*platform_device*/
-extern struct rk2818_fb_mach_info rk2818_fb_mach_info;
+extern struct rk2818fb_info rk2818_fb_info;
 
 struct platform_device rk2818_device_fb = {
 	.name		  = "rk2818-fb",
@@ -266,7 +266,7 @@ struct platform_device rk2818_device_fb = {
 	.num_resources	  = ARRAY_SIZE(rk2818_fb_resource),
 	.resource	  = rk2818_fb_resource,
 	.dev            = {
-		.platform_data  = &rk2818_fb_mach_info,
+		.platform_data  = &rk2818_fb_info,
 	}
 };
 
diff --git a/arch/arm/mach-rk2818/include/mach/board.h b/arch/arm/mach-rk2818/include/mach/board.h
index 01562fac964d..a12827b85b77 100755
--- a/arch/arm/mach-rk2818/include/mach/board.h
+++ b/arch/arm/mach-rk2818/include/mach/board.h
@@ -61,24 +61,34 @@ struct rk2818_i2c_platform_data {
 	int (*io_deinit)(void);
 };
 
-struct rk2818_fb_gpio{
-    u32 display_on;
-    u32 lcd_standby;
-    u32 mcu_fmk_pin;
+struct rk2818lcd_info{
+    u32 lcd_id;
+    u32 txd_pin;
+    u32 clk_pin;
+    u32 cs_pin;
+    int (*io_init)(void);
+    int (*io_deinit)(void);
 };
 
-struct rk2818_fb_iomux{
-    char *data16;
-    char *data18;
-    char *data24;
-    char *den;
-    char *vsync;
-    char *mcu_fmk;
+struct rk2818_fb_setting_info{
+    u8 data_num;
+    u8 vsync_en;
+    u8 den_en;
+    u8 mcu_fmk_en;
+    u8 disp_on_en;
+    u8 standby_en;
 };
 
-struct rk2818_fb_mach_info {
-    struct rk2818_fb_gpio *gpio;
-    struct rk2818_fb_iomux *iomux;
+struct rk2818fb_info{
+    u32 fb_id;
+    u32 disp_on_pin;
+    u8 disp_on_value;
+    u32 standby_pin;
+    u8 standby_value;
+    u32 mcu_fmk_pin;
+    struct rk2818lcd_info *lcd_info;
+    int (*io_init)(struct rk2818_fb_setting_info *fb_setting);
+    int (*io_deinit)(void);
 };
 
 struct rk2818_bl_info{
@@ -138,15 +148,6 @@ struct tca6424_platform_data {
 	void    (*reseti2cpin)(void);
 };
 
-
-/*lcd*/
-struct lcd_td043mgea1_data{
-    u32 pin_txd;
-    u32 pin_clk;
-    u32 pin_cs;
-    void (*screen_set_iomux)(u8 enable);
-};
-
 /*battery*/
 struct rk2818_battery_platform_data {
 	int (*io_init)(void);
diff --git a/drivers/video/display/screen/lcd_hl070vm4.c b/drivers/video/display/screen/lcd_hl070vm4.c
index 69cf8bb49277..e9e51124141b 100755
--- a/drivers/video/display/screen/lcd_hl070vm4.c
+++ b/drivers/video/display/screen/lcd_hl070vm4.c
@@ -3,6 +3,7 @@
 #include "../../rk2818_fb.h"
 #include <mach/gpio.h>
 #include <mach/iomux.h>
+#include <mach/board.h>
 #include "screen.h"
 
 /* Base */
@@ -25,69 +26,28 @@
 #define DCLK_POL		1 ///0
 #define SWAP_RB			0
 
-#define CS_OUT()        gpio_direction_output(RK2818_PIN_PA4, 0)
-#define CS_SET()        gpio_set_value(RK2818_PIN_PA4, GPIO_HIGH)
-#define CS_CLR()        gpio_set_value(RK2818_PIN_PA4, GPIO_LOW)
-#define CLK_OUT()       gpio_direction_output(RK2818_PIN_PE7, 0)  //I2C1_SCL
-#define CLK_SET()       gpio_set_value(RK2818_PIN_PE7, GPIO_HIGH)
-#define CLK_CLR()       gpio_set_value(RK2818_PIN_PE7, GPIO_LOW)
-#define TXD_OUT()       gpio_direction_output(RK2818_PIN_PE6, 0)  //I2C1_SDA
-#define TXD_SET()       gpio_set_value(RK2818_PIN_PE6, GPIO_HIGH)
-#define TXD_CLR()       gpio_set_value(RK2818_PIN_PE6, GPIO_LOW)
+#define TXD_PORT        gLcd_info->txd_pin
+#define CLK_PORT        gLcd_info->clk_pin
+#define CS_PORT         gLcd_info->cs_pin
+
+#define CS_OUT()        gpio_direction_output(CS_PORT, 0)
+#define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
+#define CS_CLR()        gpio_set_value(CS_PORT, GPIO_LOW)
+#define CLK_OUT()       gpio_direction_output(CLK_PORT, 0) 
+#define CLK_SET()       gpio_set_value(CLK_PORT, GPIO_HIGH)
+#define CLK_CLR()       gpio_set_value(CLK_PORT, GPIO_LOW)
+#define TXD_OUT()       gpio_direction_output(TXD_PORT, 0) 
+#define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
+#define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
+
+static struct rk2818lcd_info *gLcd_info = NULL;
 
 #define DRVDelayUs(i)   udelay(i*2)
 
 int init(void);
 int standby(u8 enable);
 
-void screen_set_iomux(u8 enable)
-{
-    int ret=-1;
-    if(enable)
-    {
-        rk2818_mux_api_set(CXGPIO_HSADC_SEL_NAME, 0);
-        ret = gpio_request(RK2818_PIN_PA4, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PA4);
-            printk(">>>>>> lcd cs gpio_request err \n ");           
-            goto pin_err;
-        }  
-        
-        rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 0);                   
-
-        ret = gpio_request(RK2818_PIN_PE7, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE7);
-            printk(">>>>>> lcd clk gpio_request err \n "); 
-            goto pin_err;
-        }  
-        
-        ret = gpio_request(RK2818_PIN_PE6, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE6);
-            printk(">>>>>> lcd txd gpio_request err \n "); 
-            goto pin_err;
-        }        
-    }
-    else
-    {
-         gpio_free(RK2818_PIN_PA4); 
-         //rk2818_mux_api_set(CXGPIO_HSADC_SEL_NAME, 1);
-
-         gpio_free(RK2818_PIN_PE7);   
-         gpio_free(RK2818_PIN_PE6); 
-         rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 2);
-   }
-    return ;
-pin_err:
-    return ;
-
-}
-
-void set_lcd_info(struct rk28fb_screen *screen)
+void set_lcd_info(struct rk28fb_screen *screen, struct rk2818lcd_info *lcd_info )
 {
     /* screen type & face */
     screen->type = OUT_TYPE;
@@ -122,6 +82,8 @@ void set_lcd_info(struct rk28fb_screen *screen)
     /* Operation function*/
     screen->init = init;
     screen->standby = standby;
+    if(lcd_info)
+        gLcd_info = lcd_info;
 }
 
 
@@ -198,7 +160,8 @@ void spi_screenreg_set(u32 Data)
 
 int init(void)
 {
-    screen_set_iomux(1);   
+    if(gLcd_info)
+        gLcd_info->io_init();
 /*
 r0 00000010 11011011
 r1 00010001 01101111
@@ -213,19 +176,22 @@ r5 01100001 11001110
 	spi_screenreg_set(0x3008);
 	spi_screenreg_set(0x419f);
 	spi_screenreg_set(0x61ce);
-    screen_set_iomux(0);   
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
 int standby(u8 enable)
 {
-    screen_set_iomux(1);   
+    if(gLcd_info)
+        gLcd_info->io_init();
 	if(!enable) {
 		init();
 	} //else {
 //		spi_screenreg_set(0x03, 0x5f);
 //	}
-    screen_set_iomux(0);   
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
diff --git a/drivers/video/display/screen/lcd_hsd800x480.c b/drivers/video/display/screen/lcd_hsd800x480.c
index bf1979ada631..1a3816d5e065 100755
--- a/drivers/video/display/screen/lcd_hsd800x480.c
+++ b/drivers/video/display/screen/lcd_hsd800x480.c
@@ -4,6 +4,7 @@
 #include "../../rk2818_fb.h"
 #include <mach/gpio.h>
 #include <mach/iomux.h>
+#include <mach/board.h>
 #include "screen.h"
 
 
@@ -27,69 +28,28 @@
 #define DCLK_POL		1
 #define SWAP_RB			0
 
-#define CS_OUT()        gpio_direction_output(RK2818_PIN_PA4, 0)
-#define CS_SET()        gpio_set_value(RK2818_PIN_PA4, GPIO_HIGH)
-#define CS_CLR()        gpio_set_value(RK2818_PIN_PA4, GPIO_LOW)
-#define CLK_OUT()       gpio_direction_output(RK2818_PIN_PE7, 0)  //I2C1_SCL
-#define CLK_SET()       gpio_set_value(RK2818_PIN_PE7, GPIO_HIGH)
-#define CLK_CLR()       gpio_set_value(RK2818_PIN_PE7, GPIO_LOW)
-#define TXD_OUT()       gpio_direction_output(RK2818_PIN_PE6, 0)  //I2C1_SDA
-#define TXD_SET()       gpio_set_value(RK2818_PIN_PE6, GPIO_HIGH)
-#define TXD_CLR()       gpio_set_value(RK2818_PIN_PE6, GPIO_LOW)
+#define TXD_PORT        gLcd_info->txd_pin
+#define CLK_PORT        gLcd_info->clk_pin
+#define CS_PORT         gLcd_info->cs_pin
+
+#define CS_OUT()        gpio_direction_output(CS_PORT, 0)
+#define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
+#define CS_CLR()        gpio_set_value(CS_PORT, GPIO_LOW)
+#define CLK_OUT()       gpio_direction_output(CLK_PORT, 0) 
+#define CLK_SET()       gpio_set_value(CLK_PORT, GPIO_HIGH)
+#define CLK_CLR()       gpio_set_value(CLK_PORT, GPIO_LOW)
+#define TXD_OUT()       gpio_direction_output(TXD_PORT, 0) 
+#define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
+#define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
+
+static struct rk2818lcd_info *gLcd_info = NULL;
 
 #define DRVDelayUs(i)   udelay(i*2)
 
 int init(void);
 int standby(u8 enable);
 
-void screen_set_iomux(u8 enable)
-{
-    int ret=-1;
-    if(enable)
-    {
-        rk2818_mux_api_set(CXGPIO_HSADC_SEL_NAME, 0);
-        ret = gpio_request(RK2818_PIN_PA4, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PA4);
-            printk(">>>>>> lcd cs gpio_request err \n ");           
-            goto pin_err;
-        }  
-        
-        rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 0);                   
-
-        ret = gpio_request(RK2818_PIN_PE7, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE7);
-            printk(">>>>>> lcd clk gpio_request err \n "); 
-            goto pin_err;
-        }  
-        
-        ret = gpio_request(RK2818_PIN_PE6, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE6);
-            printk(">>>>>> lcd txd gpio_request err \n "); 
-            goto pin_err;
-        }        
-    }
-    else
-    {
-         gpio_free(RK2818_PIN_PA4); 
-        // rk2818_mux_api_set(CXGPIO_HSADC_SEL_NAME, 1);
- 
-         gpio_free(RK2818_PIN_PE7);   
-         gpio_free(RK2818_PIN_PE6); 
-         rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 2);
-   }
-    return ;
-pin_err:
-    return ;
-
-}
-
-void set_lcd_info(struct rk28fb_screen *screen)
+void set_lcd_info(struct rk28fb_screen *screen, struct rk2818lcd_info *lcd_info )
 {
     /* screen type & face */
     screen->type = OUT_TYPE;
@@ -125,6 +85,8 @@ void set_lcd_info(struct rk28fb_screen *screen)
     /*screen->init = init;*/
     screen->init = NULL; 
     screen->standby = standby;
+    if(lcd_info)
+        gLcd_info = lcd_info;
 }
 //cannot need init,so set screen->init = null at rk28_fb.c file 
 
@@ -199,7 +161,8 @@ void spi_screenreg_set(u32 Addr, u32 Data)
 
 int init(void)
 {
-    screen_set_iomux(1);
+    if(gLcd_info)
+        gLcd_info->io_init();
 
     spi_screenreg_set(0x02, 0x07);
     spi_screenreg_set(0x03, 0x5f);
@@ -237,20 +200,23 @@ int init(void)
     spi_screenreg_set(0x21, 0xF0);
     spi_screenreg_set(0x22, 0x09);
 
-    screen_set_iomux(0);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
 int standby(u8 enable)
 {
 #if 1
-    screen_set_iomux(1);
+    if(gLcd_info)
+        gLcd_info->io_init();
 	if(enable) {
 		spi_screenreg_set(0x03, 0xde);
 	} else {
 		spi_screenreg_set(0x03, 0x5f);
 	}
-    screen_set_iomux(0);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
 #else
     
     GPIOSetPinDirection(GPIOPortB_Pin3, GPIO_OUT);
diff --git a/drivers/video/display/screen/lcd_hx8357.c b/drivers/video/display/screen/lcd_hx8357.c
old mode 100644
new mode 100755
index 7e99e378f964..f32e02c870d8
--- a/drivers/video/display/screen/lcd_hx8357.c
+++ b/drivers/video/display/screen/lcd_hx8357.c
@@ -3,10 +3,9 @@
 #include "../../rk2818_fb.h"
 #include <mach/gpio.h>
 #include <mach/iomux.h>
-#include "screen.h"
 #include <mach/board.h>
+#include "screen.h"
 
-extern struct lcd_td043mgea1_data lcd_td043mgea1;
 
 /* Base */
 #define OUT_TYPE		SCREEN_RGB
@@ -28,13 +27,14 @@ extern struct lcd_td043mgea1_data lcd_td043mgea1;
 #define DCLK_POL		0 
 #define SWAP_RB			0
 
+static struct rk2818lcd_info *gLcd_info = NULL;
 int init(void);
 int standby(u8 enable);
-void set_lcd_info(struct rk28fb_screen *screen);
 
-#define TXD_PORT        lcd_td043mgea1.pin_txd
-#define CLK_PORT        lcd_td043mgea1.pin_clk
-#define CS_PORT         lcd_td043mgea1.pin_cs
+
+#define TXD_PORT        gLcd_info->txd_pin
+#define CLK_PORT        gLcd_info->clk_pin
+#define CS_PORT         gLcd_info->cs_pin
 
 #define CS_OUT()        gpio_direction_output(CS_PORT, 0)
 #define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
@@ -161,7 +161,7 @@ void spi_screenreg_set(u32 Addr, u32 Data)
 	DRVDelayUs(2);
 }
 
-void set_lcd_info(struct rk28fb_screen *screen)
+void set_lcd_info(struct rk28fb_screen *screen, struct rk2818lcd_info *lcd_info )
 {
 	//printk("lcd_hx8357 set_lcd_info \n"); 
     /* screen type & face */
@@ -197,13 +197,15 @@ void set_lcd_info(struct rk28fb_screen *screen)
     /* Operation function*/
     screen->init = init;
     screen->standby = standby;
+    if(lcd_info)
+        gLcd_info = lcd_info;
 }
 
 int init(void)
 { 
 
-	//printk("lcd_hx8357 init \n"); 
-	lcd_td043mgea1.screen_set_iomux(1);
+    if(gLcd_info)
+        gLcd_info->io_init();
 
 #if 0 											//***这句代码是不是写错了 
     spi_screenreg_set(0x02, 0x07);
@@ -329,7 +331,8 @@ int init(void)
 	spi_screenreg_set(0x2d, 0x1f); 
 	spi_screenreg_set(0xe8, 0x90); 
 #endif 
-	lcd_td043mgea1.screen_set_iomux(0);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
 
     return 0;
 }
@@ -337,7 +340,8 @@ int init(void)
 int standby(u8 enable)	//***enable =1 means suspend, 0 means resume 
 {
 	
-     lcd_td043mgea1.screen_set_iomux(1);
+    if(gLcd_info)
+        gLcd_info->io_init();
 	if(enable) {
 		//printk("---------hx8357   screen suspend--------------\n");
 		#if 0 
@@ -382,7 +386,8 @@ int standby(u8 enable)	//***enable =1 means suspend, 0 means resume
 		#endif 
 	}
 
-    lcd_td043mgea1.screen_set_iomux(0);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
diff --git a/drivers/video/display/screen/lcd_nt35580.c b/drivers/video/display/screen/lcd_nt35580.c
index 354f6c1d3da6..aadad64f8426 100755
--- a/drivers/video/display/screen/lcd_nt35580.c
+++ b/drivers/video/display/screen/lcd_nt35580.c
@@ -3,6 +3,7 @@
 #include "../../rk2818_fb.h"
 #include <mach/gpio.h>
 #include <mach/iomux.h>
+#include <mach/board.h>
 #include "screen.h"
 
 
@@ -26,22 +27,25 @@
 #define DCLK_POL		0
 #define SWAP_RB			0
 
+#define TXD_PORT        gLcd_info->txd_pin
+#define CLK_PORT        gLcd_info->clk_pin
+#define CS_PORT         gLcd_info->cs_pin
 
-#define CS_OUT()        gpio_direction_output(RK2818_PIN_PA4, 0)
-#define CS_SET()        gpio_set_value(RK2818_PIN_PA4, GPIO_HIGH)
-#define CS_CLR()        gpio_set_value(RK2818_PIN_PA4, GPIO_LOW)
-#define CLK_OUT()       gpio_direction_output(RK2818_PIN_PE7, 0)  //I2C1_SCL
-#define CLK_SET()       gpio_set_value(RK2818_PIN_PE7, GPIO_HIGH)
-#define CLK_CLR()       gpio_set_value(RK2818_PIN_PE7, GPIO_LOW)
-#define TXD_OUT()       gpio_direction_output(RK2818_PIN_PE6, 0)  //I2C1_SDA
-#define TXD_SET()       gpio_set_value(RK2818_PIN_PE6, GPIO_HIGH)
-#define TXD_CLR()       gpio_set_value(RK2818_PIN_PE6, GPIO_LOW)
-#define TXD_IN()        gpio_direction_input(RK2818_PIN_PE6)
-#define TXD_GET()       gpio_get_value(RK2818_PIN_PE6)
+#define CS_OUT()        gpio_direction_output(CS_PORT, 0)
+#define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
+#define CS_CLR()        gpio_set_value(CS_PORT, GPIO_LOW)
+#define CLK_OUT()       gpio_direction_output(CLK_PORT, 0) 
+#define CLK_SET()       gpio_set_value(CLK_PORT, GPIO_HIGH)
+#define CLK_CLR()       gpio_set_value(CLK_PORT, GPIO_LOW)
+#define TXD_OUT()       gpio_direction_output(TXD_PORT, 0) 
+#define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
+#define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
+#define TXD_IN()        gpio_direction_input(TXD_PORT)
+#define TXD_GET()       gpio_get_value(TXD_PORT)
 
 
 #define delay_us(i)      udelay(i)
-
+static struct rk2818lcd_info *gLcd_info = NULL;
 
 u32 spi_screenreg_get(u32 Addr)
 {
@@ -308,7 +312,8 @@ int lcd_init(void)
     GPIO_SetPinLevel(reset_pin,GPIO_HIGH);
 #endif
 
-    rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, IOMUXA_GPIO1_A67);
+    if(gLcd_info)
+        gLcd_info->io_init();
 
     spi_screenreg_set(0x2E80, 0x0001);
     spi_screenreg_set(0x0680, 0x002D);
@@ -405,7 +410,8 @@ int lcd_init(void)
     }
 #endif
 
-    rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, IOMUXA_I2C1);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
@@ -416,7 +422,7 @@ int lcd_standby(u8 enable)
 }
 
 
-void set_lcd_info(struct rk28fb_screen *screen)
+void set_lcd_info(struct rk28fb_screen *screen, struct rk2818lcd_info *lcd_info )
 {
     /* screen type & face */
     screen->type = OUT_TYPE;
@@ -451,6 +457,8 @@ void set_lcd_info(struct rk28fb_screen *screen)
     /* Operation function*/
     screen->init = lcd_init;
     screen->standby = lcd_standby;
+    if(lcd_info)
+        gLcd_info = lcd_info;
 }
 
 
diff --git a/drivers/video/display/screen/lcd_td043mgea1.c b/drivers/video/display/screen/lcd_td043mgea1.c
index e3e152cd5800..cbaee4902bea 100755
--- a/drivers/video/display/screen/lcd_td043mgea1.c
+++ b/drivers/video/display/screen/lcd_td043mgea1.c
@@ -3,10 +3,9 @@
 #include "../../rk2818_fb.h"
 #include <mach/gpio.h>
 #include <mach/iomux.h>
-#include "screen.h"
 #include <mach/board.h>
+#include "screen.h"
 
-extern struct lcd_td043mgea1_data lcd_td043mgea1;
 
 /* Base */
 #define OUT_TYPE		SCREEN_RGB
@@ -28,9 +27,9 @@ extern struct lcd_td043mgea1_data lcd_td043mgea1;
 #define DCLK_POL		0
 #define SWAP_RB			0
 
-#define TXD_PORT        lcd_td043mgea1.pin_txd
-#define CLK_PORT        lcd_td043mgea1.pin_clk
-#define CS_PORT         lcd_td043mgea1.pin_cs
+#define TXD_PORT        gLcd_info->txd_pin
+#define CLK_PORT        gLcd_info->clk_pin
+#define CS_PORT         gLcd_info->cs_pin
 
 #define CS_OUT()        gpio_direction_output(CS_PORT, 0)
 #define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
@@ -42,10 +41,11 @@ extern struct lcd_td043mgea1_data lcd_td043mgea1;
 #define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
 #define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
 
+static struct rk2818lcd_info *gLcd_info = NULL;
 int init(void);
 int standby(u8 enable);
 
-void set_lcd_info(struct rk28fb_screen *screen)
+void set_lcd_info(struct rk28fb_screen *screen, struct rk2818lcd_info *lcd_info )
 {
     /* screen type & face */
     screen->type = OUT_TYPE;
@@ -80,6 +80,8 @@ void set_lcd_info(struct rk28fb_screen *screen)
     /* Operation function*/
     screen->init = init;
     screen->standby = standby;
+    if(lcd_info)
+        gLcd_info = lcd_info;
 }
 
 
@@ -157,7 +159,8 @@ void spi_screenreg_set(u32 Addr, u32 Data)
 
 int init(void)
 {    
-    lcd_td043mgea1.screen_set_iomux(1);
+    if(gLcd_info)
+        gLcd_info->io_init();
 
     spi_screenreg_set(0x02, 0x07);
     spi_screenreg_set(0x03, 0x5f);
@@ -195,19 +198,22 @@ int init(void)
     spi_screenreg_set(0x21, 0xF0);
     spi_screenreg_set(0x22, 0x09);
 
-    lcd_td043mgea1.screen_set_iomux(0);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
 int standby(u8 enable)
 {       
-    lcd_td043mgea1.screen_set_iomux(1);
+    if(gLcd_info)
+        gLcd_info->io_init();
 	if(enable) {
 		spi_screenreg_set(0x03, 0xde);
 	} else {
 		spi_screenreg_set(0x03, 0x5f);
 	}
-    lcd_td043mgea1.screen_set_iomux(0);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
diff --git a/drivers/video/display/screen/lcd_tj048nc01ca.c b/drivers/video/display/screen/lcd_tj048nc01ca.c
index 717d396563d5..b952281443e6 100755
--- a/drivers/video/display/screen/lcd_tj048nc01ca.c
+++ b/drivers/video/display/screen/lcd_tj048nc01ca.c
@@ -3,6 +3,7 @@
 #include "../../rk2818_fb.h"
 #include <mach/gpio.h>
 #include <mach/iomux.h>
+#include <mach/board.h>
 #include "screen.h"
 
  
@@ -26,69 +27,27 @@
 #define DCLK_POL		1
 #define SWAP_RB			0
 
-#define CS_OUT()        gpio_direction_output(RK2818_PIN_PA4, 0)
-#define CS_SET()        gpio_set_value(RK2818_PIN_PA4, GPIO_HIGH)
-#define CS_CLR()        gpio_set_value(RK2818_PIN_PA4, GPIO_LOW)
-#define CLK_OUT()       gpio_direction_output(RK2818_PIN_PE7, 0)  //I2C1_SCL
-#define CLK_SET()       gpio_set_value(RK2818_PIN_PE7, GPIO_HIGH)
-#define CLK_CLR()       gpio_set_value(RK2818_PIN_PE7, GPIO_LOW)
-#define TXD_OUT()       gpio_direction_output(RK2818_PIN_PE6, 0)  //I2C1_SDA
-#define TXD_SET()       gpio_set_value(RK2818_PIN_PE6, GPIO_HIGH)
-#define TXD_CLR()       gpio_set_value(RK2818_PIN_PE6, GPIO_LOW)
+#define TXD_PORT        gLcd_info->txd_pin
+#define CLK_PORT        gLcd_info->clk_pin
+#define CS_PORT         gLcd_info->cs_pin
+
+#define CS_OUT()        gpio_direction_output(CS_PORT, 0)
+#define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
+#define CS_CLR()        gpio_set_value(CS_PORT, GPIO_LOW)
+#define CLK_OUT()       gpio_direction_output(CLK_PORT, 0) 
+#define CLK_SET()       gpio_set_value(CLK_PORT, GPIO_HIGH)
+#define CLK_CLR()       gpio_set_value(CLK_PORT, GPIO_LOW)
+#define TXD_OUT()       gpio_direction_output(TXD_PORT, 0) 
+#define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
+#define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
 
 #define DRVDelayUs(i)   udelay(i*2)
 
+static struct rk2818lcd_info *gLcd_info = NULL;
 int lcd_init(void);
 int lcd_standby(u8 enable);
 
-void screen_set_iomux(u8 enable)
-{
-    int ret=-1;
-    if(enable)
-    {
-        rk2818_mux_api_set(CXGPIO_HSADC_SEL_NAME, 0);
-        ret = gpio_request(RK2818_PIN_PA4, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PA4);
-            printk(">>>>>> lcd cs gpio_request err \n ");           
-            goto pin_err;
-        }  
-        
-        rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 0);                   
-
-        ret = gpio_request(RK2818_PIN_PE7, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE7);
-            printk(">>>>>> lcd clk gpio_request err \n "); 
-            goto pin_err;
-        }  
-        
-        ret = gpio_request(RK2818_PIN_PE6, NULL); 
-        if(0)//(ret != 0)
-        {
-            gpio_free(RK2818_PIN_PE6);
-            printk(">>>>>> lcd txd gpio_request err \n "); 
-            goto pin_err;
-        }        
-    }
-    else
-    {
-         gpio_free(RK2818_PIN_PA4); 
-        // rk2818_mux_api_set(CXGPIO_HSADC_SEL_NAME, 1);
-
-         gpio_free(RK2818_PIN_PE7);   
-         gpio_free(RK2818_PIN_PE6); 
-         rk2818_mux_api_set(GPIOE_U1IR_I2C1_NAME, 2);
-   }
-    return ;
-pin_err:
-    return ;
-
-}
-
-void set_lcd_info(struct rk28fb_screen *screen)
+void set_lcd_info(struct rk28fb_screen *screen, struct rk2818lcd_info *lcd_info )
 {
     /* screen type & face */
     screen->type = OUT_TYPE;
@@ -121,9 +80,10 @@ void set_lcd_info(struct rk28fb_screen *screen)
     screen->swap_dumy = 0;
 
     /* Operation function*/
-    //screen->init = lcd_init;
+    screen->init = lcd_init;
     screen->standby = lcd_standby;
-
+    if(lcd_info)
+        gLcd_info = lcd_info;
 }
 
 void spi_screenreg_set(u32 Addr, u32 Data)
@@ -188,7 +148,8 @@ void spi_screenreg_set(u32 Addr, u32 Data)
 
 int lcd_init(void)
 {
-    screen_set_iomux(1);
+    if(gLcd_info)
+        gLcd_info->io_init();
 	//R(0xess (A5~A0) Data(D7~D0)
 #if 0
     spi_screenreg_set(0x03, 0x86);
@@ -219,19 +180,22 @@ int lcd_init(void)
     spi_screenreg_set(0x26, 0xFF);
 #endif
 
-    screen_set_iomux(0);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
 int lcd_standby(u8 enable)
 {
-    screen_set_iomux(1);
+    if(gLcd_info)
+        gLcd_info->io_init();
 	if(enable) {
 		spi_screenreg_set(0x43, 0x20);
 	} else {
 		spi_screenreg_set(0x43, 0xE0);
 	}
-    screen_set_iomux(0);
+    if(gLcd_info)
+        gLcd_info->io_deinit();
     return 0;
 }
 
diff --git a/drivers/video/display/screen/screen.h b/drivers/video/display/screen/screen.h
index 5b051facc9a5..5794c3d708db 100755
--- a/drivers/video/display/screen/screen.h
+++ b/drivers/video/display/screen/screen.h
@@ -79,7 +79,7 @@ struct rk28fb_screen {
 
 };
 
-extern void set_lcd_info(struct rk28fb_screen *screen);
+extern void set_lcd_info(struct rk28fb_screen *screen, struct rk2818lcd_info *lcd_info);
 extern void set_tv_info(struct rk28fb_screen *screen);
 extern void set_hdmi_info(struct rk28fb_screen *screen);
 
diff --git a/drivers/video/rk2818_fb.c b/drivers/video/rk2818_fb.c
old mode 100644
new mode 100755
index 1748ff095b03..fa16dab75d88
--- a/drivers/video/rk2818_fb.c
+++ b/drivers/video/rk2818_fb.c
@@ -206,44 +206,29 @@ static int wq_condition = 0;
 void set_lcd_pin(struct platform_device *pdev, int enable)
 {
     int ret =0;
-	struct rk2818_fb_mach_info *mach_info = pdev->dev.platform_data;
+	struct rk2818fb_info *mach_info = pdev->dev.platform_data;
 
-	unsigned display_on = mach_info->gpio->display_on&0xffff;
-	unsigned lcd_standby = mach_info->gpio->lcd_standby&0xffff;
+	unsigned display_on = mach_info->disp_on_pin;
+	unsigned lcd_standby = mach_info->standby_pin;
     
-	int display_on_pol = (mach_info->gpio->display_on>>16)&0xffff;
-	int lcd_standby_pol = (mach_info->gpio->lcd_standby>>16)&0xffff;
+	int display_on_pol = mach_info->disp_on_value;
+	int lcd_standby_pol = mach_info->standby_value;
 
 	fbprintk(">>>>>> %s : %s \n", __FILE__, __FUNCTION__);
 	fbprintk(">>>>>> display_on(%d) = %d \n", display_on, enable ? display_on_pol : !display_on_pol);
 	fbprintk(">>>>>> lcd_standby(%d) = %d \n", lcd_standby, enable ? lcd_standby_pol : !lcd_standby_pol);
 
     // set display_on   
-    if(mach_info->gpio->display_on) 
-    {
-        ret = gpio_request(display_on, NULL); 
-        if(ret != 0)
+
+    if(display_on != INVALID_GPIO) 
         {
-            gpio_free(display_on);
-            printk(KERN_ERR ">>>>>> display_on gpio_request err \n ");
-            goto pin_err;
-        }
         gpio_direction_output(display_on, 0);
 		gpio_set_value(display_on, enable ? display_on_pol : !display_on_pol);
-        gpio_free(display_on);
     }
-    if(mach_info->gpio->lcd_standby) 
+    if(lcd_standby != INVALID_GPIO) 
     {
-        ret = gpio_request(lcd_standby, NULL); 
-        if(ret != 0)
-        {
-            gpio_free(lcd_standby);
-            printk(KERN_ERR ">>>>>> lcd_standby gpio_request err \n ");
-            goto pin_err;
-        }
         gpio_direction_output(lcd_standby, 0);
 		gpio_set_value(lcd_standby, enable ? lcd_standby_pol : !lcd_standby_pol);
-        gpio_free(lcd_standby);
     }	
     
     return;
@@ -1896,7 +1881,7 @@ static int win1fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *inf
 static int win1fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 {
     struct rk2818fb_inf *inf = dev_get_drvdata(info->device);
-    struct rk2818_fb_mach_info *mach_info = info->device->platform_data;
+    struct rk2818fb_info *mach_info = info->device->platform_data;
     unsigned display_on;    
     int display_on_pol;
 
@@ -1928,10 +1913,10 @@ static int win1fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long ar
             // operate the display_on pin to power down the lcd
             if(SCREEN_RGB==inf->cur_screen->type || SCREEN_MCU==inf->cur_screen->type) 
             {
-                if(mach_info && mach_info->gpio && mach_info->gpio->display_on)
+                if(mach_info && mach_info->disp_on_pin)
                 {
-                    display_on = mach_info->gpio->display_on&0xffff;    
-                    display_on_pol = (mach_info->gpio->display_on>>16)&0xffff;                    
+                    display_on = mach_info->disp_on_pin;    
+                    display_on_pol = mach_info->disp_on_value;                    
                     gpio_direction_output(display_on, 0);
             		gpio_set_value(display_on, !display_on_pol);
                 }
@@ -2129,7 +2114,8 @@ static int __init rk2818fb_probe (struct platform_device *pdev)
     struct rk2818fb_inf *inf = NULL;
     struct resource *res = NULL;
     struct resource *mem = NULL;
-    struct rk2818_fb_mach_info *mach_info = NULL;
+    struct rk2818_fb_setting_info *fb_setting = NULL;
+    struct rk2818fb_info *mach_info = NULL;
     struct rk28fb_screen *screen = NULL;
 	int irq = 0;
     int ret = 0;
@@ -2148,9 +2134,10 @@ static int __init rk2818fb_probe (struct platform_device *pdev)
     memset(inf, 0, sizeof(struct rk2818fb_inf));
 	platform_set_drvdata(pdev, inf);
 
+    mach_info = pdev->dev.platform_data;
     /* Fill screen info and set current screen */
     fbprintk(">> Fill screen info and set current screen \n");
-    set_lcd_info(&inf->lcd_info);
+    set_lcd_info(&inf->lcd_info, mach_info->lcd_info);
     set_tv_info(&inf->tv_info[0]);
     set_hdmi_info(&inf->hdmi_info[0]);
     inf->cur_screen = &inf->lcd_info;
@@ -2350,22 +2337,30 @@ static int __init rk2818fb_probe (struct platform_device *pdev)
   #endif
 	fbprintk("got clock\n");  
     
-	mach_info = pdev->dev.platform_data;
 	if(mach_info)
     {
+        fb_setting = kmalloc(sizeof(struct rk2818_fb_setting_info), GFP_KERNEL);
         if( OUT_P888==inf->lcd_info.face ||
             OUT_P888==inf->tv_info[0].face ||
             OUT_P888==inf->hdmi_info[0].face )     // set lcdc iomux
         {
-            printk("set iomux\n");  
-            rk2818_mux_api_set(mach_info->iomux->data24, 1);        
+            fb_setting->data_num = 24;     
         } 
+        else if(OUT_P666 == inf->lcd_info.face )
+        {
+            fb_setting->data_num = 18; 
+        }        
         else 
         {
-            rk2818_mux_api_set(mach_info->iomux->data18, 1);
+            fb_setting->data_num = 16; 
         }        
-        rk2818_mux_api_set(mach_info->iomux->den, 1);
-        rk2818_mux_api_set(mach_info->iomux->vsync, 1);
+        fb_setting->den_en = 1;
+        fb_setting->vsync_en = 1;
+        fb_setting->disp_on_en = 1;
+        fb_setting->standby_en = 1;
+        if( inf->lcd_info.mcu_usefmk )
+            fb_setting->mcu_fmk_en =1;        
+        mach_info->io_init(fb_setting);
     }
     
 	set_lcd_pin(pdev, 1);
@@ -2415,10 +2410,9 @@ static int __init rk2818fb_probe (struct platform_device *pdev)
         goto release_irq;
     }
     
-    if((mach_info->iomux->mcu_fmk) && (mach_info->gpio->mcu_fmk_pin))
+    if( inf->lcd_info.mcu_usefmk && (mach_info->mcu_fmk_pin != -1) )
     {
-        rk2818_mux_api_set(mach_info->iomux->mcu_fmk, mach_info->gpio->mcu_fmk_pin);
-        ret = request_irq(gpio_to_irq(mach_info->gpio->mcu_fmk_pin), mcu_irqfmk, GPIOEdgelFalling, pdev->name, pdev);
+        ret = request_irq(gpio_to_irq(mach_info->mcu_fmk_pin), mcu_irqfmk, GPIOEdgelFalling, pdev->name, pdev);
         if (ret) 
         {
             dev_err(&pdev->dev, "cannot get fmk irq %d - err %d\n", irq, ret);
@@ -2462,7 +2456,7 @@ static int rk2818fb_remove(struct platform_device *pdev)
     struct rk2818fb_inf *inf = platform_get_drvdata(pdev);
     struct fb_info *info = NULL;
 	//pm_message_t msg;
-    struct rk2818_fb_mach_info *mach_info = NULL;
+    struct rk2818fb_info *mach_info = NULL;
     int irq = 0;
     
 	fbprintk(">>>>>> %s : %s\n", __FILE__, __FUNCTION__);
@@ -2479,9 +2473,9 @@ static int rk2818fb_remove(struct platform_device *pdev)
     }
      
     mach_info = pdev->dev.platform_data;
-    if(mach_info->gpio->mcu_fmk_pin)
+    if(mach_info->mcu_fmk_pin)
     {
-        free_irq(gpio_to_irq(mach_info->gpio->mcu_fmk_pin), pdev);
+        free_irq(gpio_to_irq(mach_info->mcu_fmk_pin), pdev);
     }
 
 	set_lcd_pin(pdev, 0);
-- 
2.35.3

