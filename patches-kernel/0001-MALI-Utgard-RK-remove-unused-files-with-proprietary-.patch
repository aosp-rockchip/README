From 469e3ee54b84417dd5605ecee685518e8c069f9f Mon Sep 17 00:00:00 2001
From: Zhen Chen <chenzhen@rock-chips.com>
Date: Wed, 31 Jan 2018 19:50:34 +0800
Subject: [PATCH] MALI Utgard: RK: remove unused files with proprietary
 announcement

Change-Id: Iffe6df7c406dff1efad10934fc09ca7fd2f101ec
Signed-off-by: Zhen Chen <chenzhen@rock-chips.com>
---
 drivers/gpu/arm/mali400/include/ump/ump.h     | 262 -----------
 .../gpu/arm/mali400/include/ump/ump_debug.h   | 281 ------------
 .../include/ump/ump_kernel_interface.h        | 235 ----------
 .../ump/ump_kernel_interface_ref_drv.h        |  31 --
 .../mali400/include/ump/ump_kernel_platform.h |  48 --
 drivers/gpu/arm/mali400/include/ump/ump_osu.h | 423 ------------------
 .../arm/mali400/include/ump/ump_platform.h    |  62 ---
 .../gpu/arm/mali400/include/ump/ump_ref_drv.h | 106 -----
 .../arm/mali400/include/ump/ump_uk_types.h    | 194 --------
 .../gpu/arm/mali400/mali/common/mali_dma.c    | 202 ---------
 .../gpu/arm/mali400/mali/common/mali_dma.h    | 190 --------
 .../mali400/mali/common/mali_gp_scheduler.h   | 101 -----
 .../mali400/mali/common/mali_pp_scheduler.h   | 130 ------
 .../license/proprietary/mali_kernel_license.h |  30 --
 .../mali400/mali/platform/tcc8900/tcc8900.c   |  99 ----
 .../ump/arch-pb-virtex5-m400-4/config.h       |  17 -
 .../license/proprietary/ump_kernel_license.h  |  30 --
 17 files changed, 2441 deletions(-)
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump.h
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump_debug.h
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump_kernel_interface.h
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump_kernel_interface_ref_drv.h
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump_kernel_platform.h
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump_osu.h
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump_platform.h
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump_ref_drv.h
 delete mode 100755 drivers/gpu/arm/mali400/include/ump/ump_uk_types.h
 delete mode 100755 drivers/gpu/arm/mali400/mali/common/mali_dma.c
 delete mode 100755 drivers/gpu/arm/mali400/mali/common/mali_dma.h
 delete mode 100755 drivers/gpu/arm/mali400/mali/common/mali_gp_scheduler.h
 delete mode 100755 drivers/gpu/arm/mali400/mali/common/mali_pp_scheduler.h
 delete mode 100755 drivers/gpu/arm/mali400/mali/linux/license/proprietary/mali_kernel_license.h
 delete mode 100755 drivers/gpu/arm/mali400/mali/platform/tcc8900/tcc8900.c
 delete mode 100755 drivers/gpu/arm/mali400/ump/arch-pb-virtex5-m400-4/config.h
 delete mode 100755 drivers/gpu/arm/mali400/ump/linux/license/proprietary/ump_kernel_license.h

diff --git a/drivers/gpu/arm/mali400/include/ump/ump.h b/drivers/gpu/arm/mali400/include/ump/ump.h
deleted file mode 100755
index ce593c7d54c0..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump.h
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2008-2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump.h
- *
- * This file contains the user space part of the UMP API.
- */
-
-#ifndef _UNIFIED_MEMORY_PROVIDER_H_
-#define _UNIFIED_MEMORY_PROVIDER_H_
-
-
-/** @defgroup ump_user_space_api UMP User Space API
- * @{ */
-
-
-#include "ump_platform.h"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/**
- * External representation of a UMP handle in user space.
- */
-typedef void *ump_handle;
-
-/**
- * Typedef for a secure ID, a system wide identificator for UMP memory buffers.
- */
-typedef unsigned int ump_secure_id;
-
-/**
- * Value to indicate an invalid UMP memory handle.
- */
-#define UMP_INVALID_MEMORY_HANDLE ((ump_handle)0)
-
-/**
- * Value to indicate an invalid secure Id.
- */
-#define UMP_INVALID_SECURE_ID     ((ump_secure_id)-1)
-
-/**
- * UMP error codes for user space.
- */
-typedef enum
-{
-	UMP_OK = 0, /**< indicates success */
-	UMP_ERROR,  /**< indicates failure */
-} ump_result;
-
-
-/**
- * Opens and initializes the UMP library.
- *
- * This function must be called at least once before calling any other UMP API functions.
- * Each open is reference counted and must be matched with a call to @ref ump_close "ump_close".
- *
- * @see ump_close
- *
- * @return UMP_OK indicates success, UMP_ERROR indicates failure.
- */
-UMP_API_EXPORT ump_result ump_open(void);
-
-
-/**
- * Terminate the UMP library.
- *
- * This must be called once for every successful @ref ump_open "ump_open". The UMP library is
- * terminated when, and only when, the last open reference to the UMP interface is closed.
- *
- * @see ump_open
- */
-UMP_API_EXPORT void ump_close(void);
-
-
-/**
- * Retrieves the secure ID for the specified UMP memory.
- *
- * This identificator is unique across the entire system, and uniquely identifies
- * the specified UMP memory. This identificator can later be used through the
- * @ref ump_handle_create_from_secure_id "ump_handle_create_from_secure_id" or
- * @ref ump_dd_handle_create_from_secure_id "ump_dd_handle_create_from_secure_id"
- * functions in order to access this UMP memory, for instance from another process.
- *
- * @note There is a kernel space equivalent function called @ref ump_dd_secure_id_get "ump_dd_secure_id_get"
- *
- * @see ump_handle_create_from_secure_id
- * @see ump_dd_handle_create_from_secure_id
- * @see ump_dd_secure_id_get
- *
- * @param mem Handle to UMP memory.
- *
- * @return Returns the secure ID for the specified UMP memory.
- */
-UMP_API_EXPORT ump_secure_id ump_secure_id_get(ump_handle mem);
-
-
-/**
- * Retrieves a handle to allocated UMP memory.
- *
- * The usage of UMP memory is reference counted, so this will increment the reference
- * count by one for the specified UMP memory.
- * Use @ref ump_reference_release "ump_reference_release" when there is no longer any
- * use for the retrieved handle.
- *
- * @note There is a kernel space equivalent function called @ref ump_dd_handle_create_from_secure_id "ump_dd_handle_create_from_secure_id"
- *
- * @see ump_reference_release
- * @see ump_dd_handle_create_from_secure_id
- *
- * @param secure_id The secure ID of the UMP memory to open, that can be retrieved using the @ref ump_secure_id_get "ump_secure_id_get " function.
- *
- * @return UMP_INVALID_MEMORY_HANDLE indicates failure, otherwise a valid handle is returned.
- */
-UMP_API_EXPORT ump_handle ump_handle_create_from_secure_id(ump_secure_id secure_id);
-
-
-/**
- * Retrieves the actual size of the specified UMP memory.
- *
- * The size is reported in bytes, and is typically page aligned.
- *
- * @note There is a kernel space equivalent function called @ref ump_dd_size_get "ump_dd_size_get"
- *
- * @see ump_dd_size_get
- *
- * @param mem Handle to UMP memory.
- *
- * @return Returns the allocated size of the specified UMP memory, in bytes.
- */
-UMP_API_EXPORT unsigned long ump_size_get(ump_handle mem);
-
-
-/**
- * Read from specified UMP memory.
- *
- * Another way of reading from (and writing to) UMP memory is to use the
- * @ref ump_mapped_pointer_get "ump_mapped_pointer_get" to retrieve
- * a CPU mapped pointer to the memory.
- *
- * @see ump_mapped_pointer_get
- *
- * @param dst Destination buffer.
- * @param src Handle to UMP memory to read from.
- * @param offset Where to start reading, given in bytes.
- * @param length How much to read, given in bytes.
- */
-UMP_API_EXPORT void ump_read(void *dst, ump_handle src, unsigned long offset, unsigned long length);
-
-
-/**
- * Write to specified UMP memory.
- *
- * Another way of writing to (and reading from) UMP memory is to use the
- * @ref ump_mapped_pointer_get "ump_mapped_pointer_get" to retrieve
- * a CPU mapped pointer to the memory.
- *
- * @see ump_mapped_pointer_get
- *
- * @param dst Handle to UMP memory to write to.
- * @param offset Where to start writing, given in bytes.
- * @param src Buffer to read from.
- * @param length How much to write, given in bytes.
- */
-UMP_API_EXPORT void ump_write(ump_handle dst, unsigned long offset, const void *src, unsigned long length);
-
-
-/**
- * Retrieves a memory mapped pointer to the specified UMP memory.
- *
- * This function retrieves a memory mapped pointer to the specified UMP memory,
- * that can be used by the CPU. Every successful call to
- * @ref ump_mapped_pointer_get "ump_mapped_pointer_get" is reference counted,
- * and must therefore be followed by a call to
- * @ref ump_mapped_pointer_release "ump_mapped_pointer_release " when the
- * memory mapping is no longer needed.
- *
- * @note Systems without a MMU for the CPU only return the physical address, because no mapping is required.
- *
- * @see ump_mapped_pointer_release
- *
- * @param mem Handle to UMP memory.
- *
- * @return NULL indicates failure, otherwise a CPU mapped pointer is returned.
- */
-UMP_API_EXPORT void *ump_mapped_pointer_get(ump_handle mem);
-
-
-/**
- * Releases a previously mapped pointer to the specified UMP memory.
- *
- * The CPU mapping of the specified UMP memory memory is reference counted,
- * so every call to @ref ump_mapped_pointer_get "ump_mapped_pointer_get" must
- * be matched with a call to this function when the mapping is no longer needed.
- *
- * The CPU mapping is not removed before all references to the mapping is released.
- *
- * @note Systems without a MMU must still implement this function, even though no unmapping should be needed.
- *
- * @param mem Handle to UMP memory.
- */
-UMP_API_EXPORT void ump_mapped_pointer_release(ump_handle mem);
-
-
-/**
- * Adds an extra reference to the specified UMP memory.
- *
- * This function adds an extra reference to the specified UMP memory. This function should
- * be used every time a UMP memory handle is duplicated, that is, assigned to another ump_handle
- * variable. The function @ref ump_reference_release "ump_reference_release" must then be used
- * to release each copy of the UMP memory handle.
- *
- * @note You are not required to call @ref ump_reference_add "ump_reference_add"
- * for UMP handles returned from
- * @ref ump_handle_create_from_secure_id "ump_handle_create_from_secure_id",
- * because these handles are already reference counted by this function.
- *
- * @note There is a kernel space equivalent function called @ref ump_dd_reference_add "ump_dd_reference_add"
- *
- * @see ump_dd_reference_add
- *
- * @param mem Handle to UMP memory.
- */
-UMP_API_EXPORT void ump_reference_add(ump_handle mem);
-
-
-/**
- * Releases a reference from the specified UMP memory.
- *
- * This function should be called once for every reference to the UMP memory handle.
- * When the last reference is released, all resources associated with this UMP memory
- * handle are freed.
- *
- * @note There is a kernel space equivalent function called @ref ump_dd_reference_release "ump_dd_reference_release"
- *
- * @see ump_dd_reference_release
- *
- * @param mem Handle to UMP memory.
- */
-UMP_API_EXPORT void ump_reference_release(ump_handle mem);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/** @} */ /* end group ump_user_space_api */
-
-
-#endif /*_UNIFIED_MEMORY_PROVIDER_H_ */
diff --git a/drivers/gpu/arm/mali400/include/ump/ump_debug.h b/drivers/gpu/arm/mali400/include/ump/ump_debug.h
deleted file mode 100755
index c9d129c975b7..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump_debug.h
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2005-2011, 2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_debug.h
- *
- * The file include several useful macros for debugging and printing.
- * - UMP_PRINTF(...)           Do not use this function: Will be included in Release builds.
- * - UMP_DEBUG_TRACE()         Prints current location in code.
- * - UMP_DEBUG_PRINT(nr, (X) ) Prints the second argument if nr<=UMP_DEBUG_LEVEL.
- * - UMP_DEBUG_TPRINT(nr, X )  Prints the source trace and second argument if nr<=UMP_DEBUG_LEVEL.
- * - UMP_DEBUG_ERROR( (X) )    Prints an errortext, a source trace, and the given error message.
- * - UMP_DEBUG_ASSERT(exp,(X)) If the asserted expr is false, the program will exit.
- * - UMP_DEBUG_ASSERT_RANGE(x, min, max) Triggers if variable x is not between or equal to max and min.
- * - UMP_DEBUG_ASSERT_LEQ(x, max) Triggers if variable x is not less than equal to max.
- * - UMP_DEBUG_ASSERT_POINTER(pointer)  Triggers if the pointer is a zero pointer.
- * - UMP_DEBUG_CODE( X )       The code inside the macro is only copiled in Debug builds.
- *
- * The (X) means that you must add an extra parantese around the argumentlist.
- *
- * The  printf function: UMP_PRINTF(...) is routed to _ump_sys_printf
- *
- * Suggested range for the DEBUG-LEVEL is [1:6] where
- * [1:2] Is messages with highest priority, indicate possible errors.
- * [3:4] Is messages with medium priority, output important variables.
- * [5:6] Is messages with low priority, used during extensive debugging.
- *
- */
-#ifndef _UMP_DEBUG_H_
-#define _UMP_DEBUG_H_
-
-#include <stdio.h>
-#include <stdlib.h>
-
-/* START: Configuration */
-#ifndef UMP_PRINTF
-#define UMP_PRINTF printf
-#endif /* UMP_PRINTF */
-
-#ifndef UMP_PRINT_FLUSH
-#define UMP_PRINT_FLUSH do {} while (0)
-#endif /* UMP_PRINT_FLUSH */
-
-#ifndef UMP_DEBUG_LEVEL
-#define UMP_DEBUG_LEVEL 1
-#endif /* UMP_DEBUG_LEVEL */
-
-#ifndef UMP_DEBUG_ERROR_START_MSG
-#define UMP_DEBUG_ERROR_START_MSG do {\
-		UMP_PRINTF("*********************************************************************\n");\
-		UMP_PRINT_FLUSH; } while (0)
-#endif /* UMP_DEBUG_ERROR_START_MSG */
-
-#ifndef UMP_DEBUG_ERROR_STOP_MSG
-#define UMP_DEBUG_ERROR_STOP_MSG  do { UMP_PRINTF("\n"); UMP_PRINT_FLUSH; } while (0)
-#endif /* UMP_DEBUG_ERROR_STOP_MSG */
-
-#ifndef UMP_ASSERT_QUIT_CMD
-#define UMP_ASSERT_QUIT_CMD    abort()
-#endif /* UMP_ASSERT_QUIT_CMD */
-/* STOP: Configuration */
-
-/**
- *  The macro UMP_FUNCTION evaluates to the name of the function enclosing
- *  this macro's usage, or "<unknown>" if not supported.
- */
-#if (defined(__SYMBIAN32__) && defined(__ARMCC__)) || defined(_MSC_VER)
-#   define UMP_FUNCTION __FUNCTION__
-#elif __STDC__  && __STDC_VERSION__ >= 199901L
-#   define UMP_FUNCTION __FUNCTION__
-#elif defined(__GNUC__) && __GNUC__ >= 2
-#   define UMP_FUNCTION __FUNCTION__
-#elif defined(__func__)
-#   define UMP_FUNCTION __func__
-#else
-#   define UMP_FUNCTION "<unknown>"
-#endif
-
-/**
- *  Explicitly ignore a parameter passed into a function, to suppress compiler warnings.
- *  Should only be used with parameter names.
- */
-#define UMP_IGNORE(x) (void)x
-
-/**
- * @def     UMP_DEBUG_TRACE()
- * @brief   Prints current location in code.
- *          Can be turned off by defining UMP_DEBUG_SKIP_TRACE
- */
-
-#ifndef UMP_DEBUG_SKIP_TRACE
-#ifndef UMP_DEBUG_SKIP_PRINT_FUNCTION_NAME
-#define UMP_DEBUG_TRACE()  do { UMP_PRINTF( "In file: "__FILE__ \
-	        "  function: %s()   line:%4d\n" , UMP_FUNCTION, __LINE__);  UMP_PRINT_FLUSH; } while (0)
-#else
-#define UMP_DEBUG_TRACE()  do { UMP_PRINTF( "In file: "__FILE__ "  line:%4d\n" , __LINE__);  UMP_PRINT_FLUSH; } while (0)
-#endif /* UMP_DEBUG_SKIP_PRINT_FUNCTION_NAME */
-#else
-#define UMP_DEBUG_TRACE()
-#endif /* UMP_DEBUG_SKIP_TRACE */
-
-/**
- * @def     UMP_DEBUG_PRINT(nr, (X) )
- * @brief   Prints the second argument if nr<=UMP_DEBUG_LEVEL.
- *          Can be turned off by defining UMP_DEBUG_SKIP_PRINT
- * @param   nr   If nr <= UMP_DEBUG_LEVEL, we print the text.
- * @param   X  A parantese with the contents to be sent to UMP_PRINTF
- */
-#ifndef UMP_DEBUG_SKIP_PRINT
-#define UMP_DEBUG_PRINT(nr, X )  do { if ( nr<=UMP_DEBUG_LEVEL ) { UMP_PRINTF X ; UMP_PRINT_FLUSH; } } while (0)
-#else
-#define UMP_DEBUG_PRINT(nr, X )
-#endif /* UMP_DEBUG_SKIP_PRINT */
-
-/**
- * @def     UMP_DEBUG_TPRINT(nr, (X) )
- * @brief   Prints the second argument if nr<=UMP_DEBUG_LEVEL.
- *          Can be turned off by defining UMP_DEBUG_SKIP_TPRINT.
- *          Can be shortened by defining UMP_DEBUG_TPRINT_SKIP_FUNCTION.
- * @param   nr   If nr <= UMP_DEBUG_LEVEL, we print the text.
- * @param   X  A parantese with the contents to be sent to UMP_PRINTF
- */
-
-/* helper to handle if the function name should be included or not */
-#ifndef UMP_DEBUG_TPRINT_SKIP_FUNCTION
-#define UMP_DEBUG_TPRINT_INTERN do {UMP_PRINTF( ""__FILE__" %s()%4d " , UMP_FUNCTION, __LINE__); UMP_PRINT_FLUSH; }  while (0)
-#else
-#define UMP_DEBUG_TPRINT_INTERN do {UMP_PRINTF( ""__FILE__ "%4d " , __LINE__); UMP_PRINT_FLUSH; }  while (0)
-#endif /* UMP_DEBUG_TPRINT_SKIP_FUNCTION */
-
-#ifndef UMP_DEBUG_SKIP_TPRINT
-#define UMP_DEBUG_TPRINT(nr, X ) \
-	do{\
-		if ( nr<=UMP_DEBUG_LEVEL )\
-		{\
-			UMP_DEBUG_TPRINT_INTERN;\
-			UMP_PRINTF X ;\
-			UMP_PRINT_FLUSH;\
-		}\
-	} while (0)
-#else
-#define UMP_DEBUG_TPRINT(nr, X )
-#endif /* UMP_DEBUG_SKIP_TPRINT */
-
-/**
- * @def     UMP_DEBUG_ERROR( (X) )
- * @brief   Prints an errortext, a source Trace, and the given error message.
- *          Prints filename, function, linenr, and the given error message.
- *          The error message must be inside a second parantese.
- *          The error message is written on a separate line, and a NL char is added.
- *          Can be turned of by defining UMP_DEBUG_SKIP_ERROR;
- *          You do not need to type the words ERROR in the message, since it will
- *          be added anyway.
- *
- * @note    You should not end the text with a newline, since it is added by the macro.
- * @note    You should not write "ERROR" in the text, since it is added by the macro.
- * @param    X  A parantese with the contents to be sent to UMP_PRINTF
- */
-
-#ifndef UMP_DEBUG_SKIP_ERROR
-#define UMP_DEBUG_ERROR( X )  \
-	do{ \
-		UMP_DEBUG_ERROR_START_MSG;\
-		UMP_PRINTF("ERROR: ");\
-		UMP_PRINT_FLUSH;\
-		UMP_DEBUG_TRACE(); \
-		UMP_PRINTF X ; \
-		UMP_PRINT_FLUSH;\
-		UMP_DEBUG_ERROR_STOP_MSG;\
-	} while (0)
-#else
-#define UMP_DEBUG_ERROR( X ) do{ ; } while ( 0 )
-#endif /* UMP_DEBUG_SKIP_ERROR */
-
-/**
- * @def     UMP_DEBUG_ASSERT(expr, (X) )
- * @brief   If the asserted expr is false, the program will exit.
- *          Prints filename, function, linenr, and the given error message.
- *          The error message must be inside a second parantese.
- *          The error message is written on a separate line, and a NL char is added.
- *          Can be turned of by defining UMP_DEBUG_SKIP_ERROR;
- *          You do not need to type the words ASSERT in the message, since it will
- *          be added anyway.
- *
- * @param    X  A parantese with the contents to be sent to UMP_PRINTF
- *          Prints filename, function, linenr, and the error message
- *          on a separte line. A newline char is added at the end.
- *          Can be turned of by defining UMP_DEBUG_SKIP_ASSERT
- * @param   expr  Will exit program if \a expr is false;
- * @param   (X)  Text that will be written if the assertion toggles.
- */
-
-#ifndef UMP_DEBUG_SKIP_ASSERT
-#define UMP_DEBUG_ASSERT(expr, X ) \
-	do{\
-		if ( !(expr) ) \
-		{ \
-			UMP_DEBUG_ERROR_START_MSG;\
-			UMP_PRINTF("ASSERT EXIT: ");\
-			UMP_PRINT_FLUSH;\
-			UMP_DEBUG_TRACE(); \
-			UMP_PRINTF X ; \
-			UMP_PRINT_FLUSH;\
-			UMP_DEBUG_ERROR_STOP_MSG;\
-			UMP_ASSERT_QUIT_CMD;\
-		}\
-	} while (0)
-#else
-#define UMP_DEBUG_ASSERT(expr, X)
-#endif /* UMP_DEBUG_SKIP_ASSERT */
-
-
-/**
- * @def     UMP_DEBUG_ASSERT_POINTER(pointer)
- * @brief   If the asserted pointer is NULL, the program terminates and TRACE info is printed
- *          The checking is disabled if "UMP_DEBUG_SKIP_ASSERT" is defined.
- */
-#define UMP_DEBUG_ASSERT_POINTER(pointer) UMP_DEBUG_ASSERT(pointer, ("Null pointer " #pointer) )
-
-/**
- * @def     UMP_DEBUG_ASSERT_HANDLE(handle)
- * @brief   If the asserted handle is not a valid handle, the program terminates and TRACE info is printed
- *          The checking is disabled if "UMP_DEBUG_SKIP_ASSERT" is defined.
- */
-#define UMP_DEBUG_ASSERT_HANDLE(handle) UMP_DEBUG_ASSERT(UMP_NO_HANDLE != (handle), ("Invalid handle" #handle) )
-
-/**
- * @def     UMP_DEBUG_ASSERT_ALIGNMENT(ptr, align)
- * @brief   If the asserted pointer is  not aligned to align, the program terminates with trace info printed.
- *          The checking is disabled if "UMP_DEBUG_SKIP_ASSERT" is defined.
- */
-#ifndef UMP_DEBUG_SKIP_ASSERT
-#define UMP_DEBUG_ASSERT_ALIGNMENT(ptr, align) do {                                                    \
-		UMP_DEBUG_ASSERT(0 == (align & (align - 1)), ("align %d is not a power-of-two", align));           \
-		UMP_DEBUG_ASSERT(0 == (((u32)(ptr)) & (align - 1)), ("ptr %p not aligned to %d bytes", (void*)ptr, align)); \
-	} while (0)
-#else
-#define UMP_DEBUG_ASSERT_ALIGNMENT(ptr, align)
-#endif /* UMP_DEBUG_SKIP_ASSERT */
-
-/**
- * @def     UMP_DEBUG_ASSERT_RANGE(x,min,max)
- * @brief   If variable x is not between or equal to max and min, the assertion triggers.
- *          The checking is disabled if "UMP_DEBUG_SKIP_ASSERT" is defined.
- */
-#define UMP_DEBUG_ASSERT_RANGE(x, min, max) \
-	UMP_DEBUG_ASSERT( (x) >= (min) && (x) <= (max), \
-	                  (#x " out of range (%2.2f)", (double)x ) \
-	                )
-
-/**
- * @def     UMP_DEBUG_ASSERT_LEQ(x,max)
- * @brief   If variable x is less than or equal to max, the assertion triggers.
- *          The checking is disabled if "UMP_DEBUG_SKIP_ASSERT" is defined.
- */
-#define UMP_DEBUG_ASSERT_LEQ(x, max) \
-	UMP_DEBUG_ASSERT( (x) <= (max), \
-	                  (#x " out of range (%2.2f)", (double)x ) \
-	                )
-
-/**
- * @def     UMP_DEBUG_CODE( X )
- * @brief   Run the code X on debug builds.
- *          The code will not be used if UMP_DEBUG_SKIP_CODE is defined .
- *
- */
-#ifdef UMP_DEBUG_SKIP_CODE
-#define UMP_DEBUG_CODE( X )
-#else
-#define UMP_DEBUG_CODE( X ) X
-#endif /* UMP_DEBUG_SKIP_CODE */
-
-#endif /* _UMP_DEBUG_H_ */
-
diff --git a/drivers/gpu/arm/mali400/include/ump/ump_kernel_interface.h b/drivers/gpu/arm/mali400/include/ump/ump_kernel_interface.h
deleted file mode 100755
index ad2e0fcee269..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump_kernel_interface.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2008-2010, 2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_kernel_interface.h
- *
- * This file contains the kernel space part of the UMP API.
- */
-
-#ifndef __UMP_KERNEL_INTERFACE_H__
-#define __UMP_KERNEL_INTERFACE_H__
-
-
-/** @defgroup ump_kernel_space_api UMP Kernel Space API
- * @{ */
-
-
-#include "ump_kernel_platform.h"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/**
- * External representation of a UMP handle in kernel space.
- */
-typedef void *ump_dd_handle;
-
-/**
- * Typedef for a secure ID, a system wide identificator for UMP memory buffers.
- */
-typedef unsigned int ump_secure_id;
-
-
-/**
- * Value to indicate an invalid UMP memory handle.
- */
-#define UMP_DD_HANDLE_INVALID ((ump_dd_handle)0)
-
-
-/**
- * Value to indicate an invalid secure Id.
- */
-#define UMP_INVALID_SECURE_ID ((ump_secure_id)-1)
-
-
-/**
- * UMP error codes for kernel space.
- */
-typedef enum
-{
-	UMP_DD_SUCCESS, /**< indicates success */
-	UMP_DD_INVALID, /**< indicates failure */
-} ump_dd_status_code;
-
-
-/**
- * Struct used to describe a physical block used by UMP memory
- */
-typedef struct ump_dd_physical_block
-{
-	unsigned long addr; /**< The physical address of the block */
-	unsigned long size; /**< The length of the block, typically page aligned */
-} ump_dd_physical_block;
-
-
-/**
- * Retrieves the secure ID for the specified UMP memory.
- *
- * This identificator is unique across the entire system, and uniquely identifies
- * the specified UMP memory. This identificator can later be used through the
- * @ref ump_dd_handle_create_from_secure_id "ump_dd_handle_create_from_secure_id" or
- * @ref ump_handle_create_from_secure_id "ump_handle_create_from_secure_id"
- * functions in order to access this UMP memory, for instance from another process.
- *
- * @note There is a user space equivalent function called @ref ump_secure_id_get "ump_secure_id_get"
- *
- * @see ump_dd_handle_create_from_secure_id
- * @see ump_handle_create_from_secure_id
- * @see ump_secure_id_get
- *
- * @param mem Handle to UMP memory.
- *
- * @return Returns the secure ID for the specified UMP memory.
- */
-UMP_KERNEL_API_EXPORT ump_secure_id ump_dd_secure_id_get(ump_dd_handle mem);
-
-
-/**
- * Retrieves a handle to allocated UMP memory.
- *
- * The usage of UMP memory is reference counted, so this will increment the reference
- * count by one for the specified UMP memory.
- * Use @ref ump_dd_reference_release "ump_dd_reference_release" when there is no longer any
- * use for the retrieved handle.
- *
- * @note There is a user space equivalent function called @ref ump_handle_create_from_secure_id "ump_handle_create_from_secure_id"
- *
- * @see ump_dd_reference_release
- * @see ump_handle_create_from_secure_id
- *
- * @param secure_id The secure ID of the UMP memory to open, that can be retrieved using the @ref ump_secure_id_get "ump_secure_id_get " function.
- *
- * @return UMP_INVALID_MEMORY_HANDLE indicates failure, otherwise a valid handle is returned.
- */
-UMP_KERNEL_API_EXPORT ump_dd_handle ump_dd_handle_create_from_secure_id(ump_secure_id secure_id);
-
-
-/**
- * Retrieves the number of physical blocks used by the specified UMP memory.
- *
- * This function retrieves the number of @ref ump_dd_physical_block "ump_dd_physical_block" structs needed
- * to describe the physical memory layout of the given UMP memory. This can later be used when calling
- * the functions @ref ump_dd_phys_blocks_get "ump_dd_phys_blocks_get" and
- * @ref ump_dd_phys_block_get "ump_dd_phys_block_get".
- *
- * @see ump_dd_phys_blocks_get
- * @see ump_dd_phys_block_get
- *
- * @param mem Handle to UMP memory.
- *
- * @return The number of ump_dd_physical_block structs required to describe the physical memory layout of the specified UMP memory.
- */
-UMP_KERNEL_API_EXPORT unsigned long ump_dd_phys_block_count_get(ump_dd_handle mem);
-
-
-/**
- * Retrieves all physical memory block information for specified UMP memory.
- *
- * This function can be used by other device drivers in order to create MMU tables.
- *
- * @note This function will fail if the num_blocks parameter is either to large or to small.
- *
- * @see ump_dd_phys_block_get
- *
- * @param mem Handle to UMP memory.
- * @param blocks An array of @ref ump_dd_physical_block "ump_dd_physical_block" structs that will receive the physical description.
- * @param num_blocks The number of blocks to return in the blocks array. Use the function
- *                   @ref ump_dd_phys_block_count_get "ump_dd_phys_block_count_get" first to determine the number of blocks required.
- *
- * @return UMP_DD_SUCCESS indicates success, UMP_DD_INVALID indicates failure.
- */
-UMP_KERNEL_API_EXPORT ump_dd_status_code ump_dd_phys_blocks_get(ump_dd_handle mem, ump_dd_physical_block *blocks, unsigned long num_blocks);
-
-
-/**
- * Retrieves the physical memory block information for specified block for the specified UMP memory.
- *
- * This function can be used by other device drivers in order to create MMU tables.
- *
- * @note This function will return UMP_DD_INVALID if the specified index is out of range.
- *
- * @see ump_dd_phys_blocks_get
- *
- * @param mem Handle to UMP memory.
- * @param index Which physical info block to retrieve.
- * @param block Pointer to a @ref ump_dd_physical_block "ump_dd_physical_block" struct which will receive the requested information.
- *
- * @return UMP_DD_SUCCESS indicates success, UMP_DD_INVALID indicates failure.
- */
-UMP_KERNEL_API_EXPORT ump_dd_status_code ump_dd_phys_block_get(ump_dd_handle mem, unsigned long index, ump_dd_physical_block *block);
-
-
-/**
- * Retrieves the actual size of the specified UMP memory.
- *
- * The size is reported in bytes, and is typically page aligned.
- *
- * @note There is a user space equivalent function called @ref ump_size_get "ump_size_get"
- *
- * @see ump_size_get
- *
- * @param mem Handle to UMP memory.
- *
- * @return Returns the allocated size of the specified UMP memory, in bytes.
- */
-UMP_KERNEL_API_EXPORT unsigned long ump_dd_size_get(ump_dd_handle mem);
-
-
-/**
- * Adds an extra reference to the specified UMP memory.
- *
- * This function adds an extra reference to the specified UMP memory. This function should
- * be used every time a UMP memory handle is duplicated, that is, assigned to another ump_dd_handle
- * variable. The function @ref ump_dd_reference_release "ump_dd_reference_release" must then be used
- * to release each copy of the UMP memory handle.
- *
- * @note You are not required to call @ref ump_dd_reference_add "ump_dd_reference_add"
- * for UMP handles returned from
- * @ref ump_dd_handle_create_from_secure_id "ump_dd_handle_create_from_secure_id",
- * because these handles are already reference counted by this function.
- *
- * @note There is a user space equivalent function called @ref ump_reference_add "ump_reference_add"
- *
- * @see ump_reference_add
- *
- * @param mem Handle to UMP memory.
- */
-UMP_KERNEL_API_EXPORT void ump_dd_reference_add(ump_dd_handle mem);
-
-
-/**
- * Releases a reference from the specified UMP memory.
- *
- * This function should be called once for every reference to the UMP memory handle.
- * When the last reference is released, all resources associated with this UMP memory
- * handle are freed.
- *
- * @note There is a user space equivalent function called @ref ump_reference_release "ump_reference_release"
- *
- * @see ump_reference_release
- *
- * @param mem Handle to UMP memory.
- */
-UMP_KERNEL_API_EXPORT void ump_dd_reference_release(ump_dd_handle mem);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/** @} */ /* end group ump_kernel_space_api */
-
-
-#endif  /* __UMP_KERNEL_INTERFACE_H__ */
diff --git a/drivers/gpu/arm/mali400/include/ump/ump_kernel_interface_ref_drv.h b/drivers/gpu/arm/mali400/include/ump/ump_kernel_interface_ref_drv.h
deleted file mode 100755
index ca3f9acc6537..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump_kernel_interface_ref_drv.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2009-2010, 2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_kernel_interface.h
- */
-
-#ifndef __UMP_KERNEL_INTERFACE_REF_DRV_H__
-#define __UMP_KERNEL_INTERFACE_REF_DRV_H__
-
-#include "ump_kernel_interface.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Turn specified physical memory into UMP memory. */
-UMP_KERNEL_API_EXPORT ump_dd_handle ump_dd_handle_create_from_phys_blocks(ump_dd_physical_block *blocks, unsigned long num_blocks);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* __UMP_KERNEL_INTERFACE_REF_DRV_H__ */
diff --git a/drivers/gpu/arm/mali400/include/ump/ump_kernel_platform.h b/drivers/gpu/arm/mali400/include/ump/ump_kernel_platform.h
deleted file mode 100755
index ed9ed33e5ba3..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump_kernel_platform.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2008-2010 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_kernel_platform.h
- *
- * This file should define UMP_KERNEL_API_EXPORT,
- * which dictates how the UMP kernel API should be exported/imported.
- * Modify this file, if needed, to match your platform setup.
- */
-
-#ifndef __UMP_KERNEL_PLATFORM_H__
-#define __UMP_KERNEL_PLATFORM_H__
-
-/** @addtogroup ump_kernel_space_api
- * @{ */
-
-/**
- * A define which controls how UMP kernel space API functions are imported and exported.
- * This define should be set by the implementor of the UMP API.
- */
-
-#if defined(_WIN32)
-
-#if defined(UMP_BUILDING_UMP_LIBRARY)
-#define UMP_KERNEL_API_EXPORT __declspec(dllexport)
-#else
-#define UMP_KERNEL_API_EXPORT __declspec(dllimport)
-#endif
-
-#else
-
-#define UMP_KERNEL_API_EXPORT
-
-#endif
-
-
-/** @} */ /* end group ump_kernel_space_api */
-
-
-#endif /* __UMP_KERNEL_PLATFORM_H__ */
diff --git a/drivers/gpu/arm/mali400/include/ump/ump_osu.h b/drivers/gpu/arm/mali400/include/ump/ump_osu.h
deleted file mode 100755
index f656313e5afb..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump_osu.h
+++ /dev/null
@@ -1,423 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2008-2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_osu.h
- * Defines the OS abstraction layer for the base driver
- */
-
-#ifndef __UMP_OSU_H__
-#define __UMP_OSU_H__
-
-#include <stdarg.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-typedef unsigned int u32;
-#ifdef _MSC_VER
-typedef unsigned __int64        u64;
-typedef signed   __int64        s64;
-#else
-typedef unsigned long long      u64;
-typedef signed long long        s64;
-#endif
-
-#ifndef NULL
-#define NULL ((void*)0)
-#endif
-
-typedef unsigned long ump_bool;
-
-#ifndef UMP_TRUE
-#define UMP_TRUE ((ump_bool)1)
-#endif
-
-#ifndef UMP_FALSE
-#define UMP_FALSE ((ump_bool)0)
-#endif
-
-#define UMP_STATIC          static
-
-/**
- * @addtogroup ump_user_space_api Unified Device Driver (UDD) APIs used by UMP
- *
- * @{
- */
-
-/**
- * @defgroup ump_osuapi UDD OS Abstraction for User-side (OSU) APIs for UMP
- *
- * @{
- */
-
-/* The following is necessary to prevent the _ump_osk_errcode_t doxygen from
- * becoming unreadable: */
-/** @cond OSU_COPY_OF__UMP_OSU_ERRCODE_T */
-
-/**
- * @brief OSU/OSK Error codes.
- *
- * Each OS may use its own set of error codes, and may require that the
- * User/Kernel interface take certain error code. This means that the common
- * error codes need to be sufficiently rich to pass the correct error code
- * through from the OSK/OSU to U/K layer, across all OSs.
- *
- * The result is that some error codes will appear redundant on some OSs.
- * Under all OSs, the OSK/OSU layer must translate native OS error codes to
- * _ump_osk/u_errcode_t codes. Similarly, the U/K layer must translate from
- * _ump_osk/u_errcode_t codes to native OS error codes.
- *
- */
-typedef enum
-{
-	_UMP_OSK_ERR_OK = 0,              /**< Success. */
-	_UMP_OSK_ERR_FAULT = -1,          /**< General non-success */
-	_UMP_OSK_ERR_INVALID_FUNC = -2,   /**< Invalid function requested through User/Kernel interface (e.g. bad IOCTL number) */
-	_UMP_OSK_ERR_INVALID_ARGS = -3,   /**< Invalid arguments passed through User/Kernel interface */
-	_UMP_OSK_ERR_NOMEM = -4,          /**< Insufficient memory */
-	_UMP_OSK_ERR_TIMEOUT = -5,        /**< Timeout occured */
-	_UMP_OSK_ERR_RESTARTSYSCALL = -6, /**< Special: On certain OSs, must report when an interruptable mutex is interrupted. Ignore otherwise. */
-	_UMP_OSK_ERR_ITEM_NOT_FOUND = -7, /**< Table Lookup failed */
-	_UMP_OSK_ERR_BUSY = -8,           /**< Device/operation is busy. Try again later */
-	_UMP_OSK_ERR_UNSUPPORTED = -9,  /**< Optional part of the interface used, and is unsupported */
-} _ump_osk_errcode_t;
-
-/** @endcond */ /* end cond OSU_COPY_OF__UMP_OSU_ERRCODE_T */
-
-/**
- * @brief OSU Error codes.
- *
- * OSU error codes - enum values intentionally same as OSK
- */
-typedef enum
-{
-	_UMP_OSU_ERR_OK = 0,           /**< Success. */
-	_UMP_OSU_ERR_FAULT = -1,       /**< General non-success */
-	_UMP_OSU_ERR_TIMEOUT = -2,     /**< Timeout occured */
-} _ump_osu_errcode_t;
-
-/** @brief Translate OSU error code to base driver error code.
- *
- * The _UMP_OSU_TRANSLATE_ERROR macro translates an OSU error code to the
- * error codes in use by the base driver.
- */
-#define _UMP_OSU_TRANSLATE_ERROR(_ump_osu_errcode) ( ( _UMP_OSU_ERR_OK == (_ump_osu_errcode) ) ? UMP_ERR_NO_ERROR : UMP_ERR_FUNCTION_FAILED)
-
-/** @defgroup _ump_osu_lock OSU Mutual Exclusion Locks
-  * @{ */
-
-/** @brief OSU Mutual Exclusion Lock flags type.
- *
- * This is made to look like and function identically to the OSK locks (refer
- * to \ref _ump_osk_lock). However, please note the following \b important
- * differences:
- * - the OSU default lock is a Sleeping, non-interruptible mutex.
- * - the OSU adds the ANYUNLOCK type of lock which allows a thread which doesn't
- * own the lock to release the lock.
- * - the order parameter when creating a lock is currently unused
- *
- * @note Pay careful attention to the difference in default locks for OSU and
- * OSK locks; OSU locks are always non-interruptible, but OSK locks are by
- * default, interruptible. This has implications for systems that do not
- * distinguish between user and kernel mode.
- */
-typedef enum
-{
-	_UMP_OSU_LOCKFLAG_DEFAULT = 0, /**< Default lock type. */
-	/** @enum _ump_osu_lock_flags_t
-	 *
-	 * Flags from 0x0--0x8000 are RESERVED for Kernel-mode
-	 */
-	_UMP_OSU_LOCKFLAG_ANYUNLOCK = 0x10000, /**< Mutex that guarantees that any thread can unlock it when locked. Otherwise, this will not be possible. */
-	/** @enum _ump_osu_lock_flags_t
-	 *
-	 * Flags from 0x10000 are RESERVED for User-mode
-	 */
-	_UMP_OSU_LOCKFLAG_STATIC = 0x20000, /* Flag in OSU reserved range to identify lock as a statically initialized lock */
-
-} _ump_osu_lock_flags_t;
-
-typedef enum
-{
-	_UMP_OSU_LOCKMODE_UNDEF = -1,  /**< Undefined lock mode. For internal use only */
-	_UMP_OSU_LOCKMODE_RW    = 0x0, /**< Default. Lock is used to protect data that is read from and written to */
-	/** @enum _ump_osu_lock_mode_t
-	 *
-	 * Lock modes 0x1--0x3F are RESERVED for Kernel-mode */
-} _ump_osu_lock_mode_t;
-
-/** @brief Private type for Mutual Exclusion lock objects. */
-typedef struct _ump_osu_lock_t_struct _ump_osu_lock_t;
-
-/** @brief The number of static locks supported in _ump_osu_lock_static(). */
-#define UMP_OSU_STATIC_LOCK_COUNT (sizeof(_ump_osu_static_locks) / sizeof(_ump_osu_lock_t))
-
-/** @} */ /* end group _ump_osu_lock */
-
-/** @defgroup _ump_osu_memory OSU Memory Allocation
- * @{ */
-
-/** @brief Allocate zero-initialized memory.
- *
- * Returns a buffer capable of containing at least \a n elements of \a size
- * bytes each. The buffer is initialized to zero.
- *
- * The buffer is suitably aligned for storage and subsequent access of every
- * type that the compiler supports. Therefore, the pointer to the start of the
- * buffer may be cast into any pointer type, and be subsequently accessed from
- * such a pointer, without loss of information.
- *
- * When the buffer is no longer in use, it must be freed with _ump_osu_free().
- * Failure to do so will cause a memory leak.
- *
- * @note Most toolchains supply memory allocation functions that meet the
- * compiler's alignment requirements.
- *
- * @param n Number of elements to allocate
- * @param size Size of each element
- * @return On success, the zero-initialized buffer allocated. NULL on failure
- */
-void *_ump_osu_calloc(u32 n, u32 size);
-
-/** @brief Allocate memory.
- *
- * Returns a buffer capable of containing at least \a size bytes. The
- * contents of the buffer are undefined.
- *
- * The buffer is suitably aligned for storage and subsequent access of every
- * type that the compiler supports. Therefore, the pointer to the start of the
- * buffer may be cast into any pointer type, and be subsequently accessed from
- * such a pointer, without loss of information.
- *
- * When the buffer is no longer in use, it must be freed with _ump_osu_free().
- * Failure to do so will cause a memory leak.
- *
- * @note Most toolchains supply memory allocation functions that meet the
- * compiler's alignment requirements.
- *
- * Remember to free memory using _ump_osu_free().
- * @param size Number of bytes to allocate
- * @return On success, the buffer allocated. NULL on failure.
- */
-void *_ump_osu_malloc(u32 size);
-
-/** @brief Free memory.
- *
- * Reclaims the buffer pointed to by the parameter \a ptr for the system.
- * All memory returned from _ump_osu_malloc(), _ump_osu_calloc() and
- * _ump_osu_realloc() must be freed before the application exits. Otherwise,
- * a memory leak will occur.
- *
- * Memory must be freed once. It is an error to free the same non-NULL pointer
- * more than once.
- *
- * It is legal to free the NULL pointer.
- *
- * @param ptr Pointer to buffer to free
- */
-void _ump_osu_free(void *ptr);
-
-/** @brief Copies memory.
- *
- * Copies the \a len bytes from the buffer pointed by the parameter \a src
- * directly to the buffer pointed by \a dst.
- *
- * It is an error for \a src to overlap \a dst anywhere in \a len bytes.
- *
- * @param dst Pointer to the destination array where the content is to be
- * copied.
- * @param src Pointer to the source of data to be copied.
- * @param len Number of bytes to copy.
- * @return \a dst is always passed through unmodified.
- */
-void *_ump_osu_memcpy(void *dst, const void *src, u32   len);
-
-/** @brief Fills memory.
- *
- * Sets the first \a size bytes of the block of memory pointed to by \a ptr to
- * the specified value
- * @param ptr Pointer to the block of memory to fill.
- * @param chr Value to be set, passed as u32. Only the 8 Least Significant Bits (LSB)
- * are used.
- * @param size Number of bytes to be set to the value.
- * @return \a ptr is always passed through unmodified
- */
-void *_ump_osu_memset(void *ptr, u32 chr, u32 size);
-
-/** @} */ /* end group _ump_osu_memory */
-
-
-/** @addtogroup _ump_osu_lock
- * @{ */
-
-/** @brief Initialize a Mutual Exclusion Lock.
- *
- * Locks are created in the signalled (unlocked) state.
- *
- * The parameter \a initial must be zero.
- *
- * At present, the parameter \a order must be zero. It remains for future
- * expansion for mutex order checking.
- *
- * @param flags flags combined with bitwise OR ('|'), or zero. There are
- * restrictions on which flags can be combined, see \ref _ump_osu_lock_flags_t.
- * @param initial For future expansion into semaphores. SBZ.
- * @param order The locking order of the mutex. SBZ.
- * @return On success, a pointer to a \ref _ump_osu_lock_t object. NULL on failure.
- */
-_ump_osu_lock_t *_ump_osu_lock_init(_ump_osu_lock_flags_t flags, u32 initial, u32 order);
-
-/** @brief Obtain a statically initialized Mutual Exclusion Lock.
- *
- * Retrieves a reference to a statically initialized lock. Up to
- * _UMP_OSU_STATIC_LOCK_COUNT statically initialized locks are
- * available. Only _ump_osu_lock_wait(), _ump_osu_lock_trywait(),
- * _ump_osu_lock_signal() can be used with statically initialized locks.
- * _UMP_OSU_LOCKMODE_RW mode should be used when waiting and signalling
- * statically initialized locks.
- *
- * For the same \a nr a pointer to the same statically initialized lock is
- * returned. That is, given the following code:
- * @code
- *  extern u32 n;
- *
- *  _ump_osu_lock_t *locka = _ump_osu_lock_static(n);
- *  _ump_osu_lock_t *lockb = _ump_osu_lock_static(n);
- * @endcode
- * Then (locka == lockb), for all 0 <= n < UMP_OSU_STATIC_LOCK_COUNT.
- *
- * @param nr index of a statically initialized lock [0..UMP_OSU_STATIC_LOCK_COUNT-1]
- * @return On success, a pointer to a _ump_osu_lock_t object. NULL on failure.
- */
-_ump_osu_lock_t *_ump_osu_lock_static(u32 nr);
-
-/** @brief Initialize a Mutual Exclusion Lock safely across multiple threads.
- *
- * The _ump_osu_lock_auto_init() function guarantees that the given lock will
- * be initialized once and precisely once, even in a situation involving
- * multiple threads.
- *
- * This is necessary because the first call to certain Public API functions must
- * initialize the API. However, there can be a race involved to call the first
- * library function in multi-threaded applications. To resolve this race, a
- * mutex can be used. This mutex must be initialized, but initialized only once
- * by any thread that might compete for its initialization. This function
- * guarantees the initialization to happen correctly, even when there is an
- * initialization race between multiple threads.
- *
- * Otherwise, the operation is identical to the _ump_osu_lock_init() function.
- * For more details, refer to _ump_osu_lock_init().
- *
- * @param pplock pointer to storage for a _ump_osu_lock_t pointer. This
- * _ump_osu_lock_t pointer may point to a _ump_osu_lock_t that has been
- * initialized already
- * @param flags flags combined with bitwise OR ('|'), or zero. There are
- * restrictions on which flags can be combined. Refer to
- * \ref _ump_osu_lock_flags_t for more information.
- * The absence of any flags (the value 0) results in a sleeping-mutex,
- * which is non-interruptible.
- * @param initial For future expansion into semaphores. SBZ.
- * @param order The locking order of the mutex. SBZ.
- * @return On success, _UMP_OSU_ERR_OK is returned and a pointer to an
- * initialized \ref _ump_osu_lock_t object is written into \a *pplock.
- * _UMP_OSU_ERR_FAULT is returned on failure.
- */
-_ump_osu_errcode_t _ump_osu_lock_auto_init(_ump_osu_lock_t **pplock, _ump_osu_lock_flags_t flags, u32 initial, u32 order);
-
-/** @brief Wait for a lock to be signalled (obtained).
- *
- * After a thread has successfully waited on the lock, the lock is obtained by
- * the thread, and is marked as unsignalled. The thread releases the lock by
- * signalling it.
- *
- * To prevent deadlock, locks must always be obtained in the same order.
- *
- * @param lock the lock to wait upon (obtain).
- * @param mode the mode in which the lock should be obtained. Currently this
- * must be _UMP_OSU_LOCKMODE_RW.
- * @return On success, _UMP_OSU_ERR_OK, _UMP_OSU_ERR_FAULT on error.
- */
-_ump_osu_errcode_t _ump_osu_lock_wait(_ump_osu_lock_t *lock, _ump_osu_lock_mode_t mode);
-
-/** @brief Wait for a lock to be signalled (obtained) with timeout
- *
- * After a thread has successfully waited on the lock, the lock is obtained by
- * the thread, and is marked as unsignalled. The thread releases the lock by
- * signalling it.
- *
- * To prevent deadlock, locks must always be obtained in the same order.
- *
- * This version can return early if it cannot obtain the lock within the given timeout.
- *
- * @param lock the lock to wait upon (obtain).
- * @param mode the mode in which the lock should be obtained. Currently this
- * must be _UMP_OSU_LOCKMODE_RW.
- * @param timeout Relative time in microseconds for the timeout
- * @return _UMP_OSU_ERR_OK if the lock was obtained, _UMP_OSU_ERR_TIMEOUT if the timeout expired or  _UMP_OSU_ERR_FAULT on error.
- */
-_ump_osu_errcode_t _ump_osu_lock_timed_wait(_ump_osu_lock_t *lock, _ump_osu_lock_mode_t mode, u64 timeout);
-
-/** @brief Test for a lock to be signalled and obtains the lock when so.
- *
- * Obtains the lock only when it is in signalled state. The lock is then
- * marked as unsignalled. The lock is released again by signalling
- * it by _ump_osu_lock_signal().
- *
- * If the lock could not be obtained immediately (that is, another thread
- * currently holds the lock), then this function \b does \b not wait for the
- * lock to be in a signalled state. Instead, an error code is immediately
- * returned to indicate that the thread could not obtain the lock.
- *
- * To prevent deadlock, locks must always be obtained in the same order.
- *
- * @param lock the lock to wait upon (obtain).
- * @param mode the mode in which the lock should be obtained. Currently this
- * must be _UMP_OSU_LOCKMODE_RW.
- * @return When the lock was obtained, _UMP_OSU_ERR_OK. If the lock could not
- * be obtained, _UMP_OSU_ERR_FAULT.
- */
-_ump_osu_errcode_t _ump_osu_lock_trywait(_ump_osu_lock_t *lock, _ump_osu_lock_mode_t mode);
-
-/** @brief Signal (release) a lock.
- *
- * Locks may only be signalled by the thread that originally waited upon the
- * lock, unless the lock was created using the _UMP_OSU_LOCKFLAG_ANYUNLOCK flag.
- *
- * @param lock the lock to signal (release).
- * @param mode the mode in which the lock should be obtained. This must match
- * the mode in which the lock was waited upon.
- */
-void _ump_osu_lock_signal(_ump_osu_lock_t *lock, _ump_osu_lock_mode_t mode);
-
-/** @brief Terminate a lock.
- *
- * This terminates a lock and frees all associated resources.
- *
- * It is a programming error to terminate the lock when it is held (unsignalled)
- * by a thread.
- *
- * @param lock the lock to terminate.
- */
-void _ump_osu_lock_term(_ump_osu_lock_t *lock);
-/** @} */ /* end group _ump_osu_lock */
-
-/** @} */ /* end group osuapi */
-
-/** @} */ /* end group uddapi */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __UMP_OSU_H__ */
diff --git a/drivers/gpu/arm/mali400/include/ump/ump_platform.h b/drivers/gpu/arm/mali400/include/ump/ump_platform.h
deleted file mode 100755
index 6560fb7cf3c1..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump_platform.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2008-2011, 2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_platform.h
- *
- * This file should define UMP_API_EXPORT,
- * which dictates how the UMP user space API should be exported/imported.
- * Modify this file, if needed, to match your platform setup.
- */
-
-#ifndef __UMP_PLATFORM_H__
-#define __UMP_PLATFORM_H__
-
-/** @addtogroup ump_user_space_api
- * @{ */
-
-/**
- * A define which controls how UMP user space API functions are imported and exported.
- * This define should be set by the implementor of the UMP API.
- */
-#if defined(_WIN32)
-
-#define UMP_API_EXPORT
-
-#elif defined(__SYMBIAN32__)
-
-#define UMP_API_EXPORT IMPORT_C
-
-#else
-
-#if defined(__GNUC__)
-#if __GNUC__ >= 4
-#   define MALI_VISIBLE  __attribute__ ((visibility ("default")))       /**< Function should be visible from outside the dll */
-#else
-#   define MALI_VISIBLE
-#endif
-
-#elif defined(__ARMCC_VERSION)
-/* ARMCC specific */
-#   define MALI_VISIBLE  __declspec(dllexport)
-
-#else
-#   define MALI_VISIBLE
-
-#endif
-
-#define UMP_API_EXPORT MALI_VISIBLE
-
-#endif
-
-/** @} */ /* end group ump_user_space_api */
-
-
-#endif /* __UMP_PLATFORM_H__ */
diff --git a/drivers/gpu/arm/mali400/include/ump/ump_ref_drv.h b/drivers/gpu/arm/mali400/include/ump/ump_ref_drv.h
deleted file mode 100755
index c1c09650111d..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump_ref_drv.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2009-2010, 2012-2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_ref_drv.h
- *
- * Reference driver extensions to the UMP user space API for allocating UMP memory
- */
-
-#ifndef _UNIFIED_MEMORY_PROVIDER_REF_DRV_H_
-#define _UNIFIED_MEMORY_PROVIDER_REF_DRV_H_
-
-#include "ump.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef enum
-{
-	/* This enum must match with the IOCTL enum in ump_ioctl.h */
-	UMP_REF_DRV_CONSTRAINT_NONE = 0,
-	UMP_REF_DRV_CONSTRAINT_PHYSICALLY_LINEAR = 1,
-	UMP_REF_DRV_CONSTRAINT_USE_CACHE = 4,
-	UMP_REF_DRV_CONSTRAINT_PRE_RESERVE = 8,
-} ump_alloc_constraints;
-
-/** Allocate an UMP handle containing a memory buffer.
- * Input: Size: The minimum size for the allocation.
- * Usage: If this is UMP_REF_DRV_CONSTRAINT_USE_CACHE, the allocation is mapped as cached by the cpu.
- *        If it is UMP_REF_DRV_CONSTRAINT_NONE it is mapped as noncached.
- *        The flag UMP_REF_DRV_CONSTRAINT_PHYSICALLY_LINEAR is not supported.*/
-UMP_API_EXPORT ump_handle ump_ref_drv_allocate(unsigned long size, ump_alloc_constraints usage);
-
-UMP_API_EXPORT int ump_phy_addr_get(ump_handle memh);
-
-typedef enum
-{
-	UMP_MSYNC_CLEAN = 0 ,
-	UMP_MSYNC_CLEAN_AND_INVALIDATE = 1,
-	UMP_MSYNC_INVALIDATE = 2,
-	UMP_MSYNC_READOUT_CACHE_ENABLED = 128,
-} ump_cpu_msync_op;
-
-typedef enum
-{
-	UMP_READ = 1,
-	UMP_READ_WRITE = 3,
-} ump_lock_usage;
-
-/** Flushing cache for an ump_handle.
- * The function will always CLEAN_AND_INVALIDATE as long as the \a op is not UMP_MSYNC_READOUT_CACHE_ENABLED.
- * If so it will only report back if the given ump_handle is cacheable.
- * At the momement the implementation does not use \a address or \a size.
- * Return value is 1 if cache is enabled, and 0 if it is disabled for the given allocation.*/
-UMP_API_EXPORT int ump_cpu_msync_now(ump_handle mem, ump_cpu_msync_op op, void *address, int size);
-
-
-typedef enum
-{
-	UMP_USED_BY_CPU = 0,
-	UMP_USED_BY_MALI = 1,
-	UMP_USED_BY_UNKNOWN_DEVICE = 100,
-} ump_hw_usage;
-
-typedef enum
-{
-	UMP_CACHE_OP_START = 0,
-	UMP_CACHE_OP_FINISH  = 1,
-} ump_cache_op_control;
-
-/** Cache operation control. Tell when cache maintenance operations start and end.
-This will allow the kernel to merge cache operations togheter, thus making them faster */
-UMP_API_EXPORT int ump_cache_operations_control(ump_cache_op_control op);
-
-/** Memory synchronization - cache flushing if previous user was different hardware */
-UMP_API_EXPORT int ump_switch_hw_usage(ump_handle mem, ump_hw_usage new_user);
-
-/** Memory synchronization - cache flushing if previous user was different hardware */
-UMP_API_EXPORT int ump_switch_hw_usage_secure_id(ump_secure_id ump_id, ump_hw_usage new_user);
-
-/** Locking buffer. Blocking call if the buffer is already locked. */
-UMP_API_EXPORT int ump_lock(ump_handle mem, ump_lock_usage lock_usage);
-
-/** Locking buffer. Blocking call if the buffer is already locked. */
-UMP_API_EXPORT int ump_lock_secure_id(ump_secure_id ump_id, ump_lock_usage lock_usage);
-
-/** Unlocking buffer. Let other users lock the buffer for their usage */
-UMP_API_EXPORT int ump_unlock(ump_handle mem);
-
-/** Unlocking buffer. Let other users lock the buffer for their usage */
-UMP_API_EXPORT int ump_unlock_secure_id(ump_secure_id ump_id);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*_UNIFIED_MEMORY_PROVIDER_REF_DRV_H_ */
diff --git a/drivers/gpu/arm/mali400/include/ump/ump_uk_types.h b/drivers/gpu/arm/mali400/include/ump/ump_uk_types.h
deleted file mode 100755
index 8db8d55030af..000000000000
--- a/drivers/gpu/arm/mali400/include/ump/ump_uk_types.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2009-2010, 2012-2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_uk_types.h
- * Defines the types and constants used in the user-kernel interface
- */
-
-#ifndef __UMP_UK_TYPES_H__
-#define __UMP_UK_TYPES_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Helpers for API version handling */
-#define MAKE_VERSION_ID(x) (((x) << 16UL) | (x))
-#define IS_VERSION_ID(x) (((x) & 0xFFFF) == (((x) >> 16UL) & 0xFFFF))
-#define GET_VERSION(x) (((x) >> 16UL) & 0xFFFF)
-#define IS_API_MATCH(x, y) (IS_VERSION_ID((x)) && IS_VERSION_ID((y)) && (GET_VERSION((x)) == GET_VERSION((y))))
-
-/**
- * API version define.
- * Indicates the version of the kernel API
- * The version is a 16bit integer incremented on each API change.
- * The 16bit integer is stored twice in a 32bit integer
- * So for version 1 the value would be 0x00010001
- */
-#define UMP_IOCTL_API_VERSION MAKE_VERSION_ID(2)
-
-typedef enum
-{
-	_UMP_IOC_QUERY_API_VERSION = 1,
-	_UMP_IOC_ALLOCATE,
-	_UMP_IOC_RELEASE,
-	_UMP_IOC_SIZE_GET,
-	_UMP_IOC_MAP_MEM,    /* not used in Linux */
-	_UMP_IOC_UNMAP_MEM,  /* not used in Linux */
-	_UMP_IOC_MSYNC,
-	_UMP_IOC_CACHE_OPERATIONS_CONTROL,
-	_UMP_IOC_SWITCH_HW_USAGE,
-	_UMP_IOC_LOCK,
-	_UMP_IOC_UNLOCK,
-}_ump_uk_functions;
-
-typedef enum
-{
-	UMP_REF_DRV_UK_CONSTRAINT_NONE = 0,
-	UMP_REF_DRV_UK_CONSTRAINT_PHYSICALLY_LINEAR = 1,
-	UMP_REF_DRV_UK_CONSTRAINT_USE_CACHE = 4,
-	UMP_REF_DRV_UK_CONSTRAINT_PRE_RESERVE = 8,
-	UMP_REF_DRV_UK_CONSTRAINT_MEM_SWITCH = 16,
-} ump_uk_alloc_constraints;
-
-typedef enum
-{
-	_UMP_UK_MSYNC_CLEAN = 0,
-	_UMP_UK_MSYNC_CLEAN_AND_INVALIDATE = 1,
-	_UMP_UK_MSYNC_INVALIDATE = 2,
-	_UMP_UK_MSYNC_FLUSH_L1   = 3,
-	_UMP_UK_MSYNC_READOUT_CACHE_ENABLED = 128,
-} ump_uk_msync_op;
-
-typedef enum
-{
-	_UMP_UK_CACHE_OP_START = 0,
-	_UMP_UK_CACHE_OP_FINISH  = 1,
-} ump_uk_cache_op_control;
-
-typedef enum
-{
-	_UMP_UK_READ = 1,
-	_UMP_UK_READ_WRITE = 3,
-} ump_uk_lock_usage;
-
-typedef enum
-{
-	_UMP_UK_USED_BY_CPU = 0,
-	_UMP_UK_USED_BY_MALI = 1,
-	_UMP_UK_USED_BY_UNKNOWN_DEVICE = 100,
-} ump_uk_user;
-
-/**
- * Get API version ([in,out] u32 api_version, [out] u32 compatible)
- */
-typedef struct _ump_uk_api_version_s
-{
-	void *ctx;      /**< [in,out] user-kernel context (trashed on output) */
-	u32 version;    /**< Set to the user space version on entry, stores the device driver version on exit */
-	u32 compatible; /**< Non-null if the device is compatible with the client */
-} _ump_uk_api_version_s;
-
-/**
- * ALLOCATE ([out] u32 secure_id, [in,out] u32 size,  [in] contraints)
- */
-typedef struct _ump_uk_allocate_s
-{
-	void *ctx;                              /**< [in,out] user-kernel context (trashed on output) */
-	u32 secure_id;                          /**< Return value from DD to Userdriver */
-	u32 size;                               /**< Input and output. Requested size; input. Returned size; output */
-	ump_uk_alloc_constraints constraints;   /**< Only input to Devicedriver */
-} _ump_uk_allocate_s;
-
-/**
- * SIZE_GET ([in] u32 secure_id, [out]size )
- */
-typedef struct _ump_uk_size_get_s
-{
-	void *ctx;                              /**< [in,out] user-kernel context (trashed on output) */
-	u32 secure_id;                          /**< Input to DD */
-	u32 size;                               /**< Returned size; output */
-} _ump_uk_size_get_s;
-
-/**
- * Release ([in] u32 secure_id)
- */
-typedef struct _ump_uk_release_s
-{
-	void *ctx;                              /**< [in,out] user-kernel context (trashed on output) */
-	u32 secure_id;                          /**< Input to DD */
-} _ump_uk_release_s;
-
-typedef struct _ump_uk_map_mem_s
-{
-	void *ctx;                      /**< [in,out] user-kernel context (trashed on output) */
-	void *mapping;                  /**< [out] Returns user-space virtual address for the mapping */
-	void *phys_addr;                /**< [in] physical address */
-	unsigned long size;             /**< [in] size */
-	u32 secure_id;                  /**< [in] secure_id to assign to mapping */
-	void *_ukk_private;             /**< Only used inside linux port between kernel frontend and common part to store vma */
-	u32 cookie;
-	u32 is_cached;            /**< [in,out] caching of CPU mappings */
-} _ump_uk_map_mem_s;
-
-typedef struct _ump_uk_unmap_mem_s
-{
-	void *ctx;            /**< [in,out] user-kernel context (trashed on output) */
-	void *mapping;
-	u32 size;
-	void *_ukk_private;
-	u32 cookie;
-} _ump_uk_unmap_mem_s;
-
-typedef struct _ump_uk_msync_s
-{
-	void *ctx;            /**< [in,out] user-kernel context (trashed on output) */
-	void *mapping;        /**< [in] mapping addr */
-	void *address;        /**< [in] flush start addr */
-	u32 size;             /**< [in] size to flush */
-	ump_uk_msync_op op;   /**< [in] flush operation */
-	u32 cookie;           /**< [in] cookie stored with reference to the kernel mapping internals */
-	u32 secure_id;        /**< [in] secure_id that identifies the ump buffer */
-	u32 is_cached;        /**< [out] caching of CPU mappings */
-} _ump_uk_msync_s;
-
-typedef struct _ump_uk_cache_operations_control_s
-{
-	void *ctx;                   /**< [in,out] user-kernel context (trashed on output) */
-	ump_uk_cache_op_control op;  /**< [in] cache operations start/stop */
-} _ump_uk_cache_operations_control_s;
-
-
-typedef struct _ump_uk_switch_hw_usage_s
-{
-	void *ctx;            /**< [in,out] user-kernel context (trashed on output) */
-	u32 secure_id;        /**< [in] secure_id that identifies the ump buffer */
-	ump_uk_user new_user;         /**< [in] cookie stored with reference to the kernel mapping internals */
-
-} _ump_uk_switch_hw_usage_s;
-
-typedef struct _ump_uk_lock_s
-{
-	void *ctx;            /**< [in,out] user-kernel context (trashed on output) */
-	u32 secure_id;        /**< [in] secure_id that identifies the ump buffer */
-	ump_uk_lock_usage lock_usage;
-} _ump_uk_lock_s;
-
-typedef struct _ump_uk_unlock_s
-{
-	void *ctx;            /**< [in,out] user-kernel context (trashed on output) */
-	u32 secure_id;        /**< [in] secure_id that identifies the ump buffer */
-} _ump_uk_unlock_s;
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __UMP_UK_TYPES_H__ */
diff --git a/drivers/gpu/arm/mali400/mali/common/mali_dma.c b/drivers/gpu/arm/mali400/mali/common/mali_dma.c
deleted file mode 100755
index b3529a317fa5..000000000000
--- a/drivers/gpu/arm/mali400/mali/common/mali_dma.c
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2012-2014 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-#include "mali_kernel_common.h"
-#include "mali_osk.h"
-#include "mali_hw_core.h"
-#include "mali_dma.h"
-
-/**
- * Size of the Mali-450 DMA unit registers in bytes.
- */
-#define MALI450_DMA_REG_SIZE 0x08
-
-/**
- * Value that appears in MEMSIZE if an error occurs when reading the command list.
- */
-#define MALI450_DMA_BUS_ERR_VAL 0xffffffff
-
-/**
- * Mali DMA registers
- * Used in the register read/write routines.
- * See the hardware documentation for more information about each register.
- */
-typedef enum mali_dma_register {
-
-	MALI450_DMA_REG_SOURCE_ADDRESS = 0x0000,
-	MALI450_DMA_REG_SOURCE_SIZE = 0x0004,
-} mali_dma_register;
-
-struct mali_dma_core {
-	struct mali_hw_core  hw_core;      /**< Common for all HW cores */
-	_mali_osk_spinlock_t *lock;            /**< Lock protecting access to DMA core */
-	mali_dma_pool pool;                /**< Memory pool for command buffers */
-};
-
-static struct mali_dma_core *mali_global_dma_core = NULL;
-
-struct mali_dma_core *mali_dma_create(_mali_osk_resource_t *resource)
-{
-	struct mali_dma_core *dma;
-	_mali_osk_errcode_t err;
-
-	MALI_DEBUG_ASSERT(NULL == mali_global_dma_core);
-
-	dma = _mali_osk_malloc(sizeof(struct mali_dma_core));
-	if (dma == NULL) goto alloc_failed;
-
-	dma->lock = _mali_osk_spinlock_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_DMA_COMMAND);
-	if (NULL == dma->lock) goto lock_init_failed;
-
-	dma->pool = mali_dma_pool_create(MALI_DMA_CMD_BUF_SIZE, 4, 0);
-	if (NULL == dma->pool) goto dma_pool_failed;
-
-	err = mali_hw_core_create(&dma->hw_core, resource, MALI450_DMA_REG_SIZE);
-	if (_MALI_OSK_ERR_OK != err) goto hw_core_failed;
-
-	mali_global_dma_core = dma;
-	MALI_DEBUG_PRINT(2, ("Mali DMA: Created Mali APB DMA unit\n"));
-	return dma;
-
-	/* Error handling */
-
-hw_core_failed:
-	mali_dma_pool_destroy(dma->pool);
-dma_pool_failed:
-	_mali_osk_spinlock_term(dma->lock);
-lock_init_failed:
-	_mali_osk_free(dma);
-alloc_failed:
-	MALI_DEBUG_PRINT(2, ("Mali DMA: Failed to create APB DMA unit\n"));
-	return NULL;
-}
-
-void mali_dma_delete(struct mali_dma_core *dma)
-{
-	MALI_DEBUG_ASSERT_POINTER(dma);
-
-	MALI_DEBUG_PRINT(2, ("Mali DMA: Deleted Mali APB DMA unit\n"));
-
-	mali_hw_core_delete(&dma->hw_core);
-	_mali_osk_spinlock_term(dma->lock);
-	mali_dma_pool_destroy(dma->pool);
-	_mali_osk_free(dma);
-}
-
-static void mali_dma_bus_error(struct mali_dma_core *dma)
-{
-	u32 addr = mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS);
-
-	MALI_PRINT_ERROR(("Mali DMA: Bus error when reading command list from 0x%lx\n", addr));
-	MALI_IGNORE(addr);
-
-	/* Clear the bus error */
-	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE, 0);
-}
-
-static mali_bool mali_dma_is_busy(struct mali_dma_core *dma)
-{
-	u32 val;
-	mali_bool dma_busy_flag = MALI_FALSE;
-
-	MALI_DEBUG_ASSERT_POINTER(dma);
-
-	val = mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE);
-
-	if (MALI450_DMA_BUS_ERR_VAL == val) {
-		/* Bus error reading command list */
-		mali_dma_bus_error(dma);
-		return MALI_FALSE;
-	}
-	if (val > 0) {
-		dma_busy_flag = MALI_TRUE;
-	}
-
-	return dma_busy_flag;
-}
-
-static void mali_dma_start_transfer(struct mali_dma_core *dma, mali_dma_cmd_buf *buf)
-{
-	u32 memsize = buf->size * 4;
-	u32 addr = buf->phys_addr;
-
-	MALI_DEBUG_ASSERT_POINTER(dma);
-	MALI_DEBUG_ASSERT(memsize < (1 << 16));
-	MALI_DEBUG_ASSERT(0 == (memsize & 0x3)); /* 4 byte aligned */
-
-	MALI_DEBUG_ASSERT(!mali_dma_is_busy(dma));
-
-	/* Writes the physical source memory address of chunk containing command headers and data */
-	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS, addr);
-
-	/* Writes the length of transfer */
-	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE, memsize);
-}
-
-_mali_osk_errcode_t mali_dma_get_cmd_buf(mali_dma_cmd_buf *buf)
-{
-	MALI_DEBUG_ASSERT_POINTER(buf);
-
-	buf->virt_addr = (u32 *)mali_dma_pool_alloc(mali_global_dma_core->pool, &buf->phys_addr);
-	if (NULL == buf->virt_addr) {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	/* size contains the number of words in the buffer and is incremented
-	 * as commands are added to the buffer. */
-	buf->size = 0;
-
-	return _MALI_OSK_ERR_OK;
-}
-
-void mali_dma_put_cmd_buf(mali_dma_cmd_buf *buf)
-{
-	MALI_DEBUG_ASSERT_POINTER(buf);
-
-	if (NULL == buf->virt_addr) return;
-
-	mali_dma_pool_free(mali_global_dma_core->pool, buf->virt_addr, buf->phys_addr);
-
-	buf->virt_addr = NULL;
-}
-
-_mali_osk_errcode_t mali_dma_start(struct mali_dma_core *dma, mali_dma_cmd_buf *buf)
-{
-	_mali_osk_errcode_t err = _MALI_OSK_ERR_OK;
-
-	_mali_osk_spinlock_lock(dma->lock);
-
-	if (mali_dma_is_busy(dma)) {
-		err = _MALI_OSK_ERR_BUSY;
-		goto out;
-	}
-
-	mali_dma_start_transfer(dma, buf);
-
-out:
-	_mali_osk_spinlock_unlock(dma->lock);
-	return err;
-}
-
-void mali_dma_debug(struct mali_dma_core *dma)
-{
-	MALI_DEBUG_ASSERT_POINTER(dma);
-	MALI_DEBUG_PRINT(1, ("DMA unit registers:\n\t%08x, %08x\n",
-			     mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS),
-			     mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE)
-			    ));
-
-}
-
-struct mali_dma_core *mali_dma_get_global_dma_core(void)
-{
-	/* Returns the global dma core object */
-	return mali_global_dma_core;
-}
diff --git a/drivers/gpu/arm/mali400/mali/common/mali_dma.h b/drivers/gpu/arm/mali400/mali/common/mali_dma.h
deleted file mode 100755
index 16c57711a9d7..000000000000
--- a/drivers/gpu/arm/mali400/mali/common/mali_dma.h
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2012-2014 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-#ifndef __MALI_DMA_H__
-#define __MALI_DMA_H__
-
-#include "mali_osk.h"
-#include "mali_osk_mali.h"
-#include "mali_hw_core.h"
-
-#define MALI_DMA_CMD_BUF_SIZE 1024
-
-typedef struct mali_dma_cmd_buf {
-	u32 *virt_addr;           /**< CPU address of command buffer */
-	mali_dma_addr phys_addr;  /**< Physical address of command buffer */
-	u32 size;                 /**< Number of prepared words in command buffer */
-} mali_dma_cmd_buf;
-
-/** @brief Create a new DMA unit
- *
- * This is called from entry point of the driver in order to create and
- * intialize the DMA resource
- *
- * @param resource it will be a pointer to a DMA resource
- * @return DMA object on success, NULL on failure
- */
-struct mali_dma_core *mali_dma_create(_mali_osk_resource_t *resource);
-
-/** @brief Delete DMA unit
- *
- * This is called on entry point of driver if the driver initialization fails
- * after initialization of the DMA unit. It is also called on the exit of the
- * driver to delete the DMA resource
- *
- * @param dma Pointer to DMA unit object
- */
-void mali_dma_delete(struct mali_dma_core *dma);
-
-/** @brief Retrieves the MALI DMA core object (if there is)
- *
- * @return The Mali DMA object otherwise NULL
- */
-struct mali_dma_core *mali_dma_get_global_dma_core(void);
-
-/**
- * @brief Run a command buffer on the DMA unit
- *
- * @param dma Pointer to the DMA unit to use
- * @param buf Pointer to the command buffer to use
- * @return _MALI_OSK_ERR_OK if the buffer was started successfully,
- *         _MALI_OSK_ERR_BUSY if the DMA unit is busy.
- */
-_mali_osk_errcode_t mali_dma_start(struct mali_dma_core *dma, mali_dma_cmd_buf *buf);
-
-/**
- * @brief Create a DMA command
- *
- * @param core Mali core
- * @param reg offset to register of core
- * @param n number of registers to write
- */
-MALI_STATIC_INLINE u32 mali_dma_command_write(struct mali_hw_core *core, u32 reg, u32 n)
-{
-	u32 core_offset = core->phys_offset;
-
-	MALI_DEBUG_ASSERT(reg < 0x2000);
-	MALI_DEBUG_ASSERT(n < 0x800);
-	MALI_DEBUG_ASSERT(core_offset < 0x30000);
-	MALI_DEBUG_ASSERT(0 == ((core_offset + reg) & ~0x7FFFF));
-
-	return (n << 20) | (core_offset + reg);
-}
-
-/**
- * @brief Add a array write to DMA command buffer
- *
- * @param buf DMA command buffer to fill in
- * @param core Core to do DMA to
- * @param reg Register on core to start writing to
- * @param data Pointer to data to write
- * @param count Number of 4 byte words to write
- */
-MALI_STATIC_INLINE void mali_dma_write_array(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
-		u32 reg, u32 *data, u32 count)
-{
-	MALI_DEBUG_ASSERT((buf->size + 1 + count) < MALI_DMA_CMD_BUF_SIZE / 4);
-
-	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, count);
-
-	_mali_osk_memcpy(buf->virt_addr + buf->size, data, count * sizeof(*buf->virt_addr));
-
-	buf->size += count;
-}
-
-/**
- * @brief Add a conditional array write to DMA command buffer
- *
- * @param buf DMA command buffer to fill in
- * @param core Core to do DMA to
- * @param reg Register on core to start writing to
- * @param data Pointer to data to write
- * @param count Number of 4 byte words to write
- * @param ref Pointer to referance data that can be skipped if equal
- */
-MALI_STATIC_INLINE void mali_dma_write_array_conditional(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
-		u32 reg, u32 *data, u32 count, const u32 *ref)
-{
-	/* Do conditional array writes are not yet implemented, fallback to a
-	 * normal array write. */
-	mali_dma_write_array(buf, core, reg, data, count);
-}
-
-/**
- * @brief Add a conditional register write to the DMA command buffer
- *
- * If the data matches the reference the command will be skipped.
- *
- * @param buf DMA command buffer to fill in
- * @param core Core to do DMA to
- * @param reg Register on core to start writing to
- * @param data Pointer to data to write
- * @param ref Pointer to referance data that can be skipped if equal
- */
-MALI_STATIC_INLINE void mali_dma_write_conditional(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
-		u32 reg, u32 data, const u32 ref)
-{
-	/* Skip write if reference value is equal to data. */
-	if (data == ref) return;
-
-	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, 1);
-
-	buf->virt_addr[buf->size++] = data;
-
-	MALI_DEBUG_ASSERT(buf->size < MALI_DMA_CMD_BUF_SIZE / 4);
-}
-
-/**
- * @brief Add a register write to the DMA command buffer
- *
- * @param buf DMA command buffer to fill in
- * @param core Core to do DMA to
- * @param reg Register on core to start writing to
- * @param data Pointer to data to write
- */
-MALI_STATIC_INLINE void mali_dma_write(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
-				       u32 reg, u32 data)
-{
-	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, 1);
-
-	buf->virt_addr[buf->size++] = data;
-
-	MALI_DEBUG_ASSERT(buf->size < MALI_DMA_CMD_BUF_SIZE / 4);
-}
-
-/**
- * @brief Prepare DMA command buffer for use
- *
- * This function allocates the DMA buffer itself.
- *
- * @param buf The mali_dma_cmd_buf to prepare
- * @return _MALI_OSK_ERR_OK if the \a buf is ready to use
- */
-_mali_osk_errcode_t mali_dma_get_cmd_buf(mali_dma_cmd_buf *buf);
-
-/**
- * @brief Check if a DMA command buffer is ready for use
- *
- * @param buf The mali_dma_cmd_buf to check
- * @return MALI_TRUE if buffer is usable, MALI_FALSE otherwise
- */
-MALI_STATIC_INLINE mali_bool mali_dma_cmd_buf_is_valid(mali_dma_cmd_buf *buf)
-{
-	return NULL != buf->virt_addr;
-}
-
-/**
- * @brief Return a DMA command buffer
- *
- * @param buf Pointer to DMA command buffer to return
- */
-void mali_dma_put_cmd_buf(mali_dma_cmd_buf *buf);
-
-#endif /* __MALI_DMA_H__ */
diff --git a/drivers/gpu/arm/mali400/mali/common/mali_gp_scheduler.h b/drivers/gpu/arm/mali400/mali/common/mali_gp_scheduler.h
deleted file mode 100755
index 1cfbd7707b65..000000000000
--- a/drivers/gpu/arm/mali400/mali/common/mali_gp_scheduler.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2012-2014 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-#ifndef __MALI_GP_SCHEDULER_H__
-#define __MALI_GP_SCHEDULER_H__
-
-#include "mali_osk.h"
-#include "mali_gp_job.h"
-#include "mali_group.h"
-
-_mali_osk_errcode_t mali_gp_scheduler_initialize(void);
-void mali_gp_scheduler_terminate(void);
-
-void mali_gp_scheduler_job_done(struct mali_group *group, struct mali_gp_job *job, mali_bool success);
-void mali_gp_scheduler_oom(struct mali_group *group, struct mali_gp_job *job);
-u32 mali_gp_scheduler_dump_state(char *buf, u32 size);
-
-void mali_gp_scheduler_suspend(void);
-void mali_gp_scheduler_resume(void);
-
-/**
- * @brief Abort all running and queued GP jobs from session.
- *
-* This functions aborts all GP jobs from the specified session. Queued jobs are removed from the
-* queue and jobs currently running on a core will be aborted.
- *
- * @param session Session that is aborting.
- */
-void mali_gp_scheduler_abort_session(struct mali_session_data *session);
-
-/**
- * @brief Reset all groups
- *
- * This function resets all groups known by the GP scheuduler. This must be
- * called after the Mali HW has been powered on in order to reset the HW.
- */
-void mali_gp_scheduler_reset_all_groups(void);
-
-/**
- * @brief Zap TLB on all groups with \a session active
- *
- * The scheculer will zap the session on all groups it owns.
- */
-void mali_gp_scheduler_zap_all_active(struct mali_session_data *session);
-
-/**
- * @brief Re-enable a group that has been disabled with mali_gp_scheduler_disable_group
- *
- * If a Mali PMU is present, the group will be powered back on and added back
- * into the GP scheduler.
- *
- * @param group Pointer to the group to enable
- */
-void mali_gp_scheduler_enable_group(struct mali_group *group);
-
-/**
- * @brief Disable a group
- *
- * The group will be taken out of the GP scheduler and powered off, if a Mali
- * PMU is present.
- *
- * @param group Pointer to the group to disable
- */
-void mali_gp_scheduler_disable_group(struct mali_group *group);
-
-/**
- * @brief Used by the Timeline system to queue a GP job.
- *
- * @note @ref mali_scheduler_schedule_from_mask() should be called if this function returns non-zero.
- *
- * @param job The GP job that is being activated.
- *
- * @return A scheduling bitmask that can be used to decide if scheduling is necessary after this
- * call.
- */
-mali_scheduler_mask mali_gp_scheduler_activate_job(struct mali_gp_job *job);
-
-/**
- * @brief Schedule queued jobs on idle cores.
- */
-void mali_gp_scheduler_schedule(void);
-
-/**
- * @brief Submit a GP job to the GP scheduler.
- *
- * This will add the GP job to the Timeline system.
- *
- * @param session Session this job belongs to.
- * @param job GP job that will be submitted
- * @return Point on GP timeline for job.
- */
-mali_timeline_point mali_gp_scheduler_submit_job(struct mali_session_data *session, struct mali_gp_job *job);
-
-#endif /* __MALI_GP_SCHEDULER_H__ */
diff --git a/drivers/gpu/arm/mali400/mali/common/mali_pp_scheduler.h b/drivers/gpu/arm/mali400/mali/common/mali_pp_scheduler.h
deleted file mode 100755
index 2f77e22f92ec..000000000000
--- a/drivers/gpu/arm/mali400/mali/common/mali_pp_scheduler.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2012-2014 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-#ifndef __MALI_PP_SCHEDULER_H__
-#define __MALI_PP_SCHEDULER_H__
-
-#include "mali_osk.h"
-#include "mali_pp_job.h"
-#include "mali_group.h"
-#include "linux/mali/mali_utgard.h"
-
-/** Initalize the HW independent parts of the  PP scheduler
- */
-_mali_osk_errcode_t mali_pp_scheduler_initialize(void);
-void mali_pp_scheduler_terminate(void);
-
-/** Poplulate the PP scheduler with groups
- */
-void mali_pp_scheduler_populate(void);
-void mali_pp_scheduler_depopulate(void);
-
-/**
- * @brief Handle job completion.
- *
- * Will attempt to start a new job on the locked group.
- *
- * If all sub jobs have completed the job's tracker will be released, any other resources associated
- * with the job will be freed.  A notification will also be sent to user space.
- *
- * Releasing the tracker might activate other jobs, so if appropriate we also schedule them.
- *
- * @note Group must be locked when entering this function.  Will be unlocked before exiting.
- *
- * @param group The group that completed the job.
- * @param job The job that is done.
- * @param sub_job Sub job of job.
- * @param success MALI_TRUE if job completed successfully, MALI_FALSE if not.
- * @param in_upper_half MALI_TRUE if called from upper half, MALI_FALSE if not.
- */
-void mali_pp_scheduler_job_done(struct mali_group *group, struct mali_pp_job *job, u32 sub_job, mali_bool success, mali_bool in_upper_half);
-
-void mali_pp_scheduler_suspend(void);
-void mali_pp_scheduler_resume(void);
-
-/**
- * @brief Abort all running and queued PP jobs from session.
- *
- * This functions aborts all PP jobs from the specified session. Queued jobs are removed from the
- * queue and jobs currently running on a core will be aborted.
- *
- * @param session Session that is aborting.
- */
-void mali_pp_scheduler_abort_session(struct mali_session_data *session);
-
-/**
- * @brief Reset all groups
- *
- * This function resets all groups known by the PP scheuduler. This must be
- * called after the Mali HW has been powered on in order to reset the HW.
- *
- * This function is intended for power on reset of all cores.
- * No locking is done, which can only be safe if the scheduler is paused and
- * all cores idle. That is always the case on init and power on.
- */
-void mali_pp_scheduler_reset_all_groups(void);
-
-/**
- * @brief Zap TLB on all groups with \a session active
- *
- * The scheculer will zap the session on all groups it owns.
- */
-void mali_pp_scheduler_zap_all_active(struct mali_session_data *session);
-
-/**
- * @brief Get the virtual PP core
- *
- * The returned PP core may only be used to prepare DMA command buffers for the
- * PP core. Other actions must go through the PP scheduler, or the virtual
- * group.
- *
- * @return Pointer to the virtual PP core, NULL if this doesn't exist
- */
-struct mali_pp_core *mali_pp_scheduler_get_virtual_pp(void);
-
-u32 mali_pp_scheduler_dump_state(char *buf, u32 size);
-
-void mali_pp_scheduler_enable_group(struct mali_group *group);
-void mali_pp_scheduler_disable_group(struct mali_group *group);
-
-/**
- * @brief Used by the Timeline system to queue a PP job.
- *
- * @note @ref mali_scheduler_schedule_from_mask() should be called if this function returns non-zero.
- *
- * @param job The PP job that is being activated.
- *
- * @return A scheduling bitmask that can be used to decide if scheduling is necessary after this
- * call.
- */
-mali_scheduler_mask mali_pp_scheduler_activate_job(struct mali_pp_job *job);
-
-/**
- * @brief Schedule queued jobs on idle cores.
- */
-void mali_pp_scheduler_schedule(void);
-
-int mali_pp_scheduler_set_perf_level(u32 cores, mali_bool override);
-
-void mali_pp_scheduler_core_scaling_enable(void);
-void mali_pp_scheduler_core_scaling_disable(void);
-mali_bool mali_pp_scheduler_core_scaling_is_enabled(void);
-
-u32 mali_pp_scheduler_get_num_cores_total(void);
-u32 mali_pp_scheduler_get_num_cores_enabled(void);
-
-/**
- * @brief Returns the number of Pixel Processors in the system irrespective of the context
- *
- * @return number of physical Pixel Processor cores in the system
- */
-u32 mali_pp_scheduler_get_num_cores_total(void);
-
-#endif /* __MALI_PP_SCHEDULER_H__ */
diff --git a/drivers/gpu/arm/mali400/mali/linux/license/proprietary/mali_kernel_license.h b/drivers/gpu/arm/mali400/mali/linux/license/proprietary/mali_kernel_license.h
deleted file mode 100755
index b422bc3c21fa..000000000000
--- a/drivers/gpu/arm/mali400/mali/linux/license/proprietary/mali_kernel_license.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2010, 2013-2014 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file mali_kernel_license.h
- * Defines for the macro MODULE_LICENSE.
- */
-
-#ifndef __MALI_KERNEL_LICENSE_H__
-#define __MALI_KERNEL_LICENSE_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define MALI_KERNEL_LINUX_LICENSE     "Proprietary"
-#define MALI_LICENSE_IS_GPL 0
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __MALI_KERNEL_LICENSE_H__ */
diff --git a/drivers/gpu/arm/mali400/mali/platform/tcc8900/tcc8900.c b/drivers/gpu/arm/mali400/mali/platform/tcc8900/tcc8900.c
deleted file mode 100755
index d7d2d6fb9be7..000000000000
--- a/drivers/gpu/arm/mali400/mali/platform/tcc8900/tcc8900.c
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2009-2010, 2012 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file mali_platform.c
- * Platform specific Mali driver functions for the TCC8900 platform
- */
-#include <linux/platform_device.h>
-#include <linux/version.h>
-#include <linux/pm.h>
-#ifdef CONFIG_PM_RUNTIME
-#include <linux/pm_runtime.h>
-#endif
-#include <linux/mali/mali_utgard.h>
-#include "mali_kernel_common.h"
-
-static void mali_platform_device_release(struct device *device);
-
-#define MALI_GP_IRQ    25
-#define MALI_PP_IRQ    24
-#define MALI_MMU_IRQ   26
-
-static struct resource mali_gpu_resources[] =
-{
-	MALI_GPU_RESOURCES_MALI200(0xF0000000, MALI_GP_IRQ, MALI_PP_IRQ, MALI_MMU_IRQ)
-};
-
-static struct platform_device mali_gpu_device =
-{
-	.name = MALI_GPU_NAME_UTGARD,
-	.id = 0,
-	.dev.release = mali_platform_device_release,
-};
-
-static struct mali_gpu_device_data mali_gpu_data =
-{
-#if 0
-	/* Dedicated memory setup (not sure if this is actually reserved on the platforms any more) */
-	.dedicated_mem_start = 0x48A00000, /* Physical start address */
-	.dedicated_mem_size = 0x07800000, /* 120MB */
-#endif
-	.shared_mem_size = 96 * 1024 * 1024, /* 96MB */
-	.fb_start = 0x48200000,
-	.fb_size = 0x00800000,
-};
-
-int mali_platform_device_register(void)
-{
-	int err;
-
-	MALI_DEBUG_PRINT(4, ("mali_platform_device_register() called\n"));
-
-	/* Connect resources to the device */
-	err = platform_device_add_resources(&mali_gpu_device, mali_gpu_resources, sizeof(mali_gpu_resources) / sizeof(mali_gpu_resources[0]));
-	if (0 == err)
-	{
-		err = platform_device_add_data(&mali_gpu_device, &mali_gpu_data, sizeof(mali_gpu_data));
-		if (0 == err)
-		{
-			/* Register the platform device */
-			err = platform_device_register(&mali_gpu_device);
-			if (0 == err)
-			{
-#ifdef CONFIG_PM_RUNTIME
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
-				pm_runtime_set_autosuspend_delay(&(mali_gpu_device.dev), 1000);
-				pm_runtime_use_autosuspend(&(mali_gpu_device.dev));
-#endif
-				pm_runtime_enable(&(mali_gpu_device.dev));
-#endif
-
-				return 0;
-			}
-		}
-
-		platform_device_unregister(&mali_gpu_device);
-	}
-
-	return err;
-}
-
-void mali_platform_device_unregister(void)
-{
-	MALI_DEBUG_PRINT(4, ("mali_platform_device_unregister() called\n"));
-
-	platform_device_unregister(&mali_gpu_device);
-}
-
-static void mali_platform_device_release(struct device *device)
-{
-	MALI_DEBUG_PRINT(4, ("mali_platform_device_release() called\n"));
-}
diff --git a/drivers/gpu/arm/mali400/ump/arch-pb-virtex5-m400-4/config.h b/drivers/gpu/arm/mali400/ump/arch-pb-virtex5-m400-4/config.h
deleted file mode 100755
index e45e31d92bf0..000000000000
--- a/drivers/gpu/arm/mali400/ump/arch-pb-virtex5-m400-4/config.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2008-2011 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-#ifndef __ARCH_CONFIG_H__
-#define __ARCH_CONFIG_H__
-
-#define ARCH_UMP_BACKEND_DEFAULT          1
-#define ARCH_UMP_MEMORY_ADDRESS_DEFAULT   0//0xC8000000
-#define ARCH_UMP_MEMORY_SIZE_DEFAULT 512UL * 1024UL * 1024UL
-#endif /* __ARCH_CONFIG_H__ */
diff --git a/drivers/gpu/arm/mali400/ump/linux/license/proprietary/ump_kernel_license.h b/drivers/gpu/arm/mali400/ump/linux/license/proprietary/ump_kernel_license.h
deleted file mode 100755
index 93ac8082bf13..000000000000
--- a/drivers/gpu/arm/mali400/ump/linux/license/proprietary/ump_kernel_license.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * This confidential and proprietary software may be used only as
- * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2010-2011, 2013 ARM Limited
- * ALL RIGHTS RESERVED
- * The entire notice above must be reproduced on all authorised
- * copies and copies may only be made to the extent permitted
- * by a licensing agreement from ARM Limited.
- */
-
-/**
- * @file ump_kernel_license.h
- * Defines for the macro MODULE_LICENSE.
- */
-
-#ifndef __UMP_KERNEL_LICENSE_H__
-#define __UMP_KERNEL_LICENSE_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define UMP_KERNEL_LINUX_LICENSE     "Proprietary"
-#define UMP_LICENSE_IS_GPL 0
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __UMP_KERNEL_LICENSE_H__ */
-- 
2.35.3

