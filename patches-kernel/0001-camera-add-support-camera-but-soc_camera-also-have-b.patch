From 478513bf4091a76136e5d31263dc24986a83f112 Mon Sep 17 00:00:00 2001
From: ddl <ddl@rock-chips.com>
Date: Fri, 11 Nov 2011 14:52:17 +0800
Subject: [PATCH] camera: add support camera, but soc_camera also have bug
 which queue buf is sched when auto focus ioctl

---
 arch/arm/mach-rk29/board-rk29-ddr3sdk.c    |    2 +-
 drivers/media/video/Kconfig                |   12 +
 drivers/media/video/ov2659.c               |   20 +-
 drivers/media/video/ov5642.c               |   22 +-
 drivers/media/video/rk29_camera.c          | 1043 +++++++++++++++++++-
 drivers/media/video/rk29_camera_oneframe.c |  321 ++++--
 drivers/media/video/soc_camera.c           |  138 +--
 include/media/soc_camera.h                 |    2 +-
 8 files changed, 1346 insertions(+), 214 deletions(-)
 mode change 100644 => 100755 drivers/media/video/rk29_camera.c
 mode change 100644 => 100755 drivers/media/video/soc_camera.c

diff --git a/arch/arm/mach-rk29/board-rk29-ddr3sdk.c b/arch/arm/mach-rk29/board-rk29-ddr3sdk.c
index 8ca56212d521..b589b176341f 100755
--- a/arch/arm/mach-rk29/board-rk29-ddr3sdk.c
+++ b/arch/arm/mach-rk29/board-rk29-ddr3sdk.c
@@ -109,7 +109,7 @@
 #define PMEM_SKYPE_SIZE     0
 #define PMEM_CAM_SIZE       PMEM_CAM_NECESSARY
 #ifdef CONFIG_VIDEO_RK29_WORK_IPP
-#define MEM_CAMIPP_SIZE     SZ_4M
+#define MEM_CAMIPP_SIZE     PMEM_CAMIPP_NECESSARY
 #else
 #define MEM_CAMIPP_SIZE     0
 #endif
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index aab1f5807590..9b95d139ee1f 100755
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1143,6 +1143,18 @@ config VIDEO_RK29_WORK_NOT_IPP
 	bool "VIP don't work with IPP"
 
 endchoice
+choice
+	prompt "RK29XX camera digital zoom with IPP "
+	depends on VIDEO_RK29 && RK29_IPP && VIDEO_RK29_WORK_IPP
+	default VIDEO_RK29_DIGITALZOOM_IPP_ON
+	---help---
+		RK29 Camera digital zoom with IPP
+config VIDEO_RK29_DIGITALZOOM_IPP_ON
+	bool "Digital zoom with IPP on"
+
+config VIDEO_RK29_DIGITALZOOM_IPP_OFF
+	bool "Digital zoom with IPP off"
+endchoice
 
 config VIDEO_MX2_HOSTSUPPORT
 	bool
diff --git a/drivers/media/video/ov2659.c b/drivers/media/video/ov2659.c
index ce8c74791ccb..85f5c20e7b8f 100755
--- a/drivers/media/video/ov2659.c
+++ b/drivers/media/video/ov2659.c
@@ -1503,7 +1503,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1722,7 +1722,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -1771,7 +1771,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     const struct sensor_datafmt *fmt;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1947,7 +1947,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -1976,7 +1976,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2292,7 +2292,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2351,7 +2351,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2641,7 +2641,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2666,7 +2666,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2754,7 +2754,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/ov5642.c b/drivers/media/video/ov5642.c
index 134a1598e97b..9b0b2f98cd6a 100755
--- a/drivers/media/video/ov5642.c
+++ b/drivers/media/video/ov5642.c
@@ -4103,7 +4103,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -4310,7 +4310,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 }
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -4359,7 +4359,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     const struct sensor_datafmt *fmt;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -4595,7 +4595,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -4624,7 +4624,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -5035,7 +5035,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -5094,7 +5094,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -5419,7 +5419,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -5444,7 +5444,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -5468,7 +5468,7 @@ static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     #if CONFIG_SENSOR_Focus
 	struct soc_camera_device *icd = client->dev.platform_data;
@@ -5580,7 +5580,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;    
     struct sensor *sensor = to_sensor(client);
     int ret = 0,i;
diff --git a/drivers/media/video/rk29_camera.c b/drivers/media/video/rk29_camera.c
old mode 100644
new mode 100755
index 6c6f75f332fe..106c2ecece07
--- a/drivers/media/video/rk29_camera.c
+++ b/drivers/media/video/rk29_camera.c
@@ -1,5 +1,5 @@
 #include <mach/rk29_camera.h> 
-
+#include <mach/iomux.h>
 #ifndef PMEM_CAM_SIZE
 #ifdef CONFIG_VIDEO_RK29 
 /*---------------- Camera Sensor Fixed Macro Begin  ------------------------*/
@@ -39,16 +39,22 @@
 
 #if (PMEM_CAM_FULL_RESOLUTION == 0x500000)
 #define PMEM_CAM_NECESSARY   0x1200000       /* 1280*720*1.5*4(preview) + 7.5M(capture raw) + 4M(jpeg encode output) */
+#define PMEM_CAMIPP_NECESSARY    0x800000
 #elif (PMEM_CAM_FULL_RESOLUTION == 0x300000)
 #define PMEM_CAM_NECESSARY   0xe00000        /* 1280*720*1.5*4(preview) + 4.5M(capture raw) + 3M(jpeg encode output) */
+#define PMEM_CAMIPP_NECESSARY    0x500000
 #elif (PMEM_CAM_FULL_RESOLUTION == 0x200000) /* 1280*720*1.5*4(preview) + 3M(capture raw) + 3M(jpeg encode output) */
 #define PMEM_CAM_NECESSARY   0xc00000
+#define PMEM_CAMIPP_NECESSARY    0x400000
 #elif ((PMEM_CAM_FULL_RESOLUTION == 0x100000) || (PMEM_CAM_FULL_RESOLUTION == 0x130000))
 #define PMEM_CAM_NECESSARY   0x800000        /* 800*600*1.5*4(preview) + 2M(capture raw) + 2M(jpeg encode output) */
+#define PMEM_CAMIPP_NECESSARY    0x400000
 #elif (PMEM_CAM_FULL_RESOLUTION == 0x30000)
 #define PMEM_CAM_NECESSARY   0x400000        /* 640*480*1.5*4(preview) + 1M(capture raw) + 1M(jpeg encode output) */
+#define PMEM_CAMIPP_NECESSARY    0x400000
 #else
 #define PMEM_CAM_NECESSARY   0x1200000
+#define PMEM_CAMIPP_NECESSARY    0x800000
 #endif
 /*---------------- Camera Sensor Fixed Macro End  ------------------------*/
 #else   //#ifdef CONFIG_VIDEO_RK29 
@@ -111,7 +117,969 @@ static struct rk29camera_platform_data rk29_camera_platform_data = {
 	#endif
 };
 
-
+static int rk29_sensor_iomux(int pin)
+{    
+    switch (pin)
+    {
+        case RK29_PIN0_PA0:        
+        case RK29_PIN0_PA1:        
+        case RK29_PIN0_PA2:
+        case RK29_PIN0_PA3:
+        case RK29_PIN0_PA4:
+        {
+            break;	
+        }
+        case RK29_PIN0_PA5:
+        {
+             rk29_mux_api_set(GPIO0A5_FLASHDQS_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PA6:
+        {
+             rk29_mux_api_set(GPIO0A6_MIIMD_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PA7:
+        {
+             rk29_mux_api_set(GPIO0A7_MIIMDCLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB0:
+        {
+             rk29_mux_api_set(GPIO0B0_EBCSDCE0_SMCADDR0_HOSTDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB1:
+        {
+             rk29_mux_api_set(GPIO0B1_EBCSDCE1_SMCADDR1_HOSTDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB2:
+        {
+             rk29_mux_api_set(GPIO0B2_EBCSDCE2_SMCADDR2_HOSTDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB3:
+        {
+             rk29_mux_api_set(GPIO0B3_EBCBORDER0_SMCADDR3_HOSTDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB4:
+        {
+             rk29_mux_api_set(GPIO0B4_EBCBORDER1_SMCWEN_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB5:
+        {
+             rk29_mux_api_set(GPIO0B5_EBCVCOM_SMCBLSN0_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB6:
+        {
+             rk29_mux_api_set(GPIO0B6_EBCSDSHR_SMCBLSN1_HOSTINT_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB7:
+        {
+             rk29_mux_api_set(GPIO0B7_EBCGDOE_SMCOEN_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC0:
+        {
+             rk29_mux_api_set(GPIO0C0_EBCGDSP_SMCDATA8_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC1:
+        {
+             rk29_mux_api_set(GPIO0C1_EBCGDR1_SMCDATA9_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC2:
+        {
+             rk29_mux_api_set(GPIO0C2_EBCSDCE0_SMCDATA10_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC3:
+        {
+             rk29_mux_api_set(GPIO0C3_EBCSDCE1_SMCDATA11_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC4:
+        {
+             rk29_mux_api_set(GPIO0C4_EBCSDCE2_SMCDATA12_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC5:
+        {
+             rk29_mux_api_set(GPIO0C5_EBCSDCE3_SMCDATA13_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC6:
+        {
+             rk29_mux_api_set(GPIO0C6_EBCSDCE4_SMCDATA14_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC7:
+        {
+             rk29_mux_api_set(GPIO0C7_EBCSDCE5_SMCDATA15_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD0:
+        {
+             rk29_mux_api_set(GPIO0D0_EBCSDOE_SMCADVN_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD1:
+        {
+             rk29_mux_api_set(GPIO0D1_EBCGDCLK_SMCADDR4_HOSTDATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD2:
+        {
+             rk29_mux_api_set(GPIO0D2_FLASHCSN1_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD3:
+        {
+             rk29_mux_api_set(GPIO0D3_FLASHCSN2_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD4:
+        {
+             rk29_mux_api_set(GPIO0D4_FLASHCSN3_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD5:
+        {
+             rk29_mux_api_set(GPIO0D5_FLASHCSN4_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD6:
+        {
+             rk29_mux_api_set(GPIO0D6_FLASHCSN5_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD7:
+        {
+             rk29_mux_api_set(GPIO0D7_FLASHCSN6_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA0:
+        {
+             rk29_mux_api_set(GPIO1A0_FLASHCS7_MDDRTQ_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA1:
+        {
+             rk29_mux_api_set(GPIO1A1_SMCCSN0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA2:
+        {
+             rk29_mux_api_set(GPIO1A2_SMCCSN1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA3:
+        {
+             rk29_mux_api_set(GPIO1A3_EMMCDETECTN_SPI1CS1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA4:
+        {
+             rk29_mux_api_set(GPIO1A4_EMMCWRITEPRT_SPI0CS1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA5:
+        {
+             rk29_mux_api_set(GPIO1A5_EMMCPWREN_PWM3_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA6:
+        {
+             rk29_mux_api_set(GPIO1A6_I2C1SDA_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA7:
+        {
+             rk29_mux_api_set(GPIO1A7_I2C1SCL_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB0:
+        {
+             rk29_mux_api_set(GPIO1B0_VIPDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB1:
+        {
+             rk29_mux_api_set(GPIO1B1_VIPDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB2:
+        {
+             rk29_mux_api_set(GPIO1B2_VIPDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB3:
+        {
+             rk29_mux_api_set(GPIO1B3_VIPDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB4:
+        {
+             rk29_mux_api_set(GPIO1B4_VIPCLKOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB5:
+        {
+             rk29_mux_api_set(GPIO1B5_PWM0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB6:
+        {
+             rk29_mux_api_set(GPIO1B6_UART0SIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB7:
+        {
+             rk29_mux_api_set(GPIO1B7_UART0SOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC0:
+        {
+             rk29_mux_api_set(GPIO1C0_UART0CTSN_SDMMC1DETECTN_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC1:
+        {
+             rk29_mux_api_set(GPIO1C1_UART0RTSN_SDMMC1WRITEPRT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC2:
+        {
+             rk29_mux_api_set(GPIO1C2_SDMMC1CMD_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC3:
+        {
+             rk29_mux_api_set(GPIO1C3_SDMMC1DATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC4:
+        {
+             rk29_mux_api_set(GPIO1C4_SDMMC1DATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC5:
+        {
+             rk29_mux_api_set(GPIO1C5_SDMMC1DATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC6:
+        {
+             rk29_mux_api_set(GPIO1C6_SDMMC1DATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC7:
+        {
+             rk29_mux_api_set(GPIO1C7_SDMMC1CLKOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD0:
+        {
+             rk29_mux_api_set(GPIO1D0_SDMMC0CLKOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD1:
+        {
+             rk29_mux_api_set(GPIO1D1_SDMMC0CMD_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD2:
+        {
+             rk29_mux_api_set(GPIO1D2_SDMMC0DATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD3:
+        {
+             rk29_mux_api_set(GPIO1D3_SDMMC0DATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD4:
+        {
+             rk29_mux_api_set(GPIO1D4_SDMMC0DATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD5:
+        {
+             rk29_mux_api_set(GPIO1D5_SDMMC0DATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD6:
+        {
+             rk29_mux_api_set(GPIO1D6_SDMMC0DATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD7:
+        {
+             rk29_mux_api_set(GPIO1D7_SDMMC0DATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA0:
+        {
+             rk29_mux_api_set(GPIO2A0_SDMMC0DATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA1:
+        {
+             rk29_mux_api_set(GPIO2A1_SDMMC0DATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA2:
+        {
+             rk29_mux_api_set(GPIO2A2_SDMMC0DETECTN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA3:
+        {
+             rk29_mux_api_set(GPIO2A3_SDMMC0WRITEPRT_PWM2_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA4:
+        {
+             rk29_mux_api_set(GPIO2A4_UART1SIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA5:
+        {
+             rk29_mux_api_set(GPIO2A5_UART1SOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA6:
+        {
+             rk29_mux_api_set(GPIO2A6_UART2CTSN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA7:
+        {
+             rk29_mux_api_set(GPIO2A7_UART2RTSN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB0:
+        {
+             rk29_mux_api_set(GPIO2B0_UART2SIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB1:
+        {
+             rk29_mux_api_set(GPIO2B1_UART2SOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB2:
+        {
+             rk29_mux_api_set(GPIO2B2_UART3SIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB3:
+        {
+             rk29_mux_api_set(GPIO2B3_UART3SOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB4:
+        {
+             rk29_mux_api_set(GPIO2B4_UART3CTSN_I2C3SDA_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB5:
+        {
+             rk29_mux_api_set(GPIO2B5_UART3RTSN_I2C3SCL_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB6:
+        {
+             rk29_mux_api_set(GPIO2B6_I2C0SDA_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB7:
+        {
+             rk29_mux_api_set(GPIO2B7_I2C0SCL_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC0:
+        {
+             rk29_mux_api_set(GPIO2C0_SPI0CLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC1:
+        {
+             rk29_mux_api_set(GPIO2C1_SPI0CSN0_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC2:
+        {
+             rk29_mux_api_set(GPIO2C2_SPI0TXD_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC3:
+        {
+             rk29_mux_api_set(GPIO2C3_SPI0RXD_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC4:
+        {
+             rk29_mux_api_set(GPIO2C4_SPI1CLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC5:
+        {
+             rk29_mux_api_set(GPIO2C5_SPI1CSN0_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC6:
+        {
+             rk29_mux_api_set(GPIO2C6_SPI1TXD_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC7:
+        {
+             rk29_mux_api_set(GPIO2C7_SPI1RXD_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD0:
+        {
+             rk29_mux_api_set(GPIO2D0_I2S0CLK_MIIRXCLKIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD1:
+        {
+             rk29_mux_api_set(GPIO2D1_I2S0SCLK_MIICRS_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD2:
+        {
+             rk29_mux_api_set(GPIO2D2_I2S0LRCKRX_MIITXERR_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD3:
+        {
+             rk29_mux_api_set(GPIO2D3_I2S0SDI_MIICOL_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD4:
+        {
+             rk29_mux_api_set(GPIO2D4_I2S0SDO0_MIIRXD2_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD5:
+        {
+             rk29_mux_api_set(GPIO2D5_I2S0SDO1_MIIRXD3_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD6:
+        {
+             rk29_mux_api_set(GPIO2D6_I2S0SDO2_MIITXD2_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD7:
+        {
+             rk29_mux_api_set(GPIO2D7_I2S0SDO3_MIITXD3_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA0:
+        {
+             rk29_mux_api_set(GPIO3A0_I2S1CLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA1:
+        {
+             rk29_mux_api_set(GPIO3A1_I2S1SCLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA2:
+        {
+             rk29_mux_api_set(GPIO3A2_I2S1LRCKRX_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA3:
+        {
+             rk29_mux_api_set(GPIO3A3_I2S1SDI_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA4:
+        {
+             rk29_mux_api_set(GPIO3A4_I2S1SDO_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA5:
+        {
+             rk29_mux_api_set(GPIO3A5_I2S1LRCKTX_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA6:
+        {
+             rk29_mux_api_set(GPIO3A6_SMCADDR14_HOSTDATA14_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA7:
+        {
+             rk29_mux_api_set(GPIO3A7_SMCADDR15_HOSTDATA15_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB0:
+        {
+             rk29_mux_api_set(GPIO3B0_EMMCLKOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB1:
+        {
+             rk29_mux_api_set(GPIO3B1_EMMCMD_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB2:
+        {
+             rk29_mux_api_set(GPIO3B2_EMMCDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB3:
+        {
+             rk29_mux_api_set(GPIO3B3_EMMCDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB4:
+        {
+             rk29_mux_api_set(GPIO3B4_EMMCDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB5:
+        {
+             rk29_mux_api_set(GPIO3B5_EMMCDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB6:
+        {
+             rk29_mux_api_set(GPIO3B6_EMMCDATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB7:
+        {
+             rk29_mux_api_set(GPIO3B7_EMMCDATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC0:
+        {
+             rk29_mux_api_set(GPIO3C0_EMMCDATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC1:
+        {
+             rk29_mux_api_set(GPIO3C1_EMMCDATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC2:
+        {
+             rk29_mux_api_set(GPIO3C2_SMCADDR13_HOSTDATA13_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC3:
+        {
+             rk29_mux_api_set(GPIO3C3_SMCADDR10_HOSTDATA10_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC4:
+        {
+             rk29_mux_api_set(GPIO3C4_SMCADDR11_HOSTDATA11_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC5:
+        {
+             rk29_mux_api_set(GPIO3C5_SMCADDR12_HOSTDATA12_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC6:
+        {
+             rk29_mux_api_set(GPIO3C6_SMCADDR16_HOSTDATA16_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC7:
+        {
+             rk29_mux_api_set(GPIO3C7_SMCADDR17_HOSTDATA17_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD0:
+        {
+             rk29_mux_api_set(GPIO3D0_SMCADDR18_HOSTADDR0_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD1:
+        {
+             rk29_mux_api_set(GPIO3D1_SMCADDR19_HOSTADDR1_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD2:
+        {
+             rk29_mux_api_set(GPIO3D2_HOSTCSN_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD3:
+        {
+             rk29_mux_api_set(GPIO3D3_HOSTRDN_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD4:
+        {
+             rk29_mux_api_set(GPIO3D4_HOSTWRN_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD5:
+        {
+             rk29_mux_api_set(GPIO3D5_SMCADDR7_HOSTDATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD6:
+        {
+             rk29_mux_api_set(GPIO3D6_SMCADDR8_HOSTDATA8_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD7:
+        {
+             rk29_mux_api_set(GPIO3D7_SMCADDR9_HOSTDATA9_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PA0:
+        case RK29_PIN4_PA1:
+        case RK29_PIN4_PA2:
+        case RK29_PIN4_PA3:
+        case RK29_PIN4_PA4:
+        {            
+            break;	
+        }
+        case RK29_PIN4_PA5:
+        {
+             rk29_mux_api_set(GPIO4A5_OTG0DRVVBUS_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PA6:
+        {
+             rk29_mux_api_set(GPIO4A6_OTG1DRVVBUS_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PA7:
+        {
+             rk29_mux_api_set(GPIO4A7_SPDIFTX_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB0:
+        {
+             rk29_mux_api_set(GPIO4B0_FLASHDATA8_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB1:
+        {
+             rk29_mux_api_set(GPIO4B1_FLASHDATA9_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB2:
+        {
+             rk29_mux_api_set(GPIO4B2_FLASHDATA10_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB3:
+        {
+             rk29_mux_api_set(GPIO4B3_FLASHDATA11_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB4:
+        {
+             rk29_mux_api_set(GPIO4B4_FLASHDATA12_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB5:
+        {
+             rk29_mux_api_set(GPIO4B5_FLASHDATA13_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB6:
+        {
+             rk29_mux_api_set(GPIO4B6_FLASHDATA14_NAME ,0);
+            break;	
+        }
+        case RK29_PIN4_PB7:
+        {
+             rk29_mux_api_set(GPIO4B7_FLASHDATA15_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC0:
+        {
+             rk29_mux_api_set(GPIO4C0_RMIICLKOUT_RMIICLKIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC1:
+        {
+             rk29_mux_api_set(GPIO4C1_RMIITXEN_MIITXEN_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC2:
+        {
+             rk29_mux_api_set(GPIO4C2_RMIITXD1_MIITXD1_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC3:
+        {
+             rk29_mux_api_set(GPIO4C3_RMIITXD0_MIITXD0_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC4:
+        {
+             rk29_mux_api_set(GPIO4C4_RMIIRXERR_MIIRXERR_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC5:
+        {
+             rk29_mux_api_set(GPIO4C5_RMIICSRDVALID_MIIRXDVALID_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC6:
+        {
+             rk29_mux_api_set(GPIO4C6_RMIIRXD1_MIIRXD1_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC7:
+        {
+             rk29_mux_api_set(GPIO4C7_RMIIRXD0_MIIRXD0_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PD0:
+        case RK29_PIN4_PD1:
+        {
+             rk29_mux_api_set(GPIO4D10_CPUTRACEDATA10_NAME,0);             
+            break;	
+        }
+        case RK29_PIN4_PD2:
+        case RK29_PIN4_PD3:
+        {
+             rk29_mux_api_set(GPIO4D32_CPUTRACEDATA32_NAME,0);           
+            break;	
+        }
+        case RK29_PIN4_PD4:
+        {
+             rk29_mux_api_set(GPIO4D4_CPUTRACECLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PD5:
+        {
+             rk29_mux_api_set(GPIO4D5_CPUTRACECTL_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PD6:
+        {
+             rk29_mux_api_set(GPIO4D6_I2S0LRCKTX0_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PD7:
+        {
+             rk29_mux_api_set(GPIO4D7_I2S0LRCKTX1_NAME,0);
+            break;	
+        } 
+        case RK29_PIN5_PA0:
+        case RK29_PIN5_PA1:
+        case RK29_PIN5_PA2:
+        {      
+            break;	
+        }
+        case RK29_PIN5_PA3:
+        {
+             rk29_mux_api_set(GPIO5A3_MIITXCLKIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PA4:
+        {
+             rk29_mux_api_set(GPIO5A4_TSSYNC_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PA5:
+        {
+             rk29_mux_api_set(GPIO5A5_HSADCDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PA6:
+        {
+             rk29_mux_api_set(GPIO5A6_HSADCDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PA7:
+        {
+             rk29_mux_api_set(GPIO5A7_HSADCDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB0:
+        {
+             rk29_mux_api_set(GPIO5B0_HSADCDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB1:
+        {
+             rk29_mux_api_set(GPIO5B1_HSADCDATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB2:
+        {
+             rk29_mux_api_set(GPIO5B2_HSADCDATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB3:
+        {
+             rk29_mux_api_set(GPIO5B3_HSADCDATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB4:
+        {
+             rk29_mux_api_set(GPIO5B4_HSADCDATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB5:
+        {
+             rk29_mux_api_set(GPIO5B5_HSADCDATA8_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB6:
+        {
+             rk29_mux_api_set(GPIO5B6_HSADCDATA9_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB7:
+        {
+             rk29_mux_api_set(GPIO5B7_HSADCCLKOUTGPSCLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC0:
+        {
+             rk29_mux_api_set(GPIO5C0_EBCSDDO0_SMCDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC1:
+        {
+             rk29_mux_api_set(GPIO5C1_EBCSDDO1_SMCDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC2:
+        {
+             rk29_mux_api_set(GPIO5C2_EBCSDDO2_SMCDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC3:
+        {
+             rk29_mux_api_set(GPIO5C3_EBCSDDO3_SMCDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC4:
+        {
+             rk29_mux_api_set(GPIO5C4_EBCSDDO4_SMCDATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC5:
+        {
+             rk29_mux_api_set(GPIO5C5_EBCSDDO5_SMCDATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC6:
+        {
+             rk29_mux_api_set(GPIO5C6_EBCSDDO6_SMCDATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC7:
+        {
+             rk29_mux_api_set(GPIO5C7_EBCSDDO7_SMCDATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD0:
+        {
+             rk29_mux_api_set(GPIO5D0_EBCSDLE_SMCADDR5_HOSTDATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD1:
+        {
+             rk29_mux_api_set(GPIO5D1_EBCSDCLK_SMCADDR6_HOSTDATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD2:
+        {
+             rk29_mux_api_set(GPIO5D2_PWM1_UART1SIRIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD3:
+        {
+             rk29_mux_api_set(GPIO5D3_I2C2SDA_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD4:
+        {
+             rk29_mux_api_set(GPIO5D4_I2C2SCL_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD5:
+        {
+             rk29_mux_api_set(GPIO5D5_SDMMC0PWREN_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD6:
+        {
+             rk29_mux_api_set(GPIO5D6_SDMMC1PWREN_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD7:
+        case RK29_PIN6_PA0:
+        case RK29_PIN6_PA1:
+        case RK29_PIN6_PA2:
+        case RK29_PIN6_PA3:
+        case RK29_PIN6_PA4:
+        case RK29_PIN6_PA5:
+        case RK29_PIN6_PA6:
+        case RK29_PIN6_PA7:
+        case RK29_PIN6_PB0:
+        case RK29_PIN6_PB1:
+        case RK29_PIN6_PB2:
+        case RK29_PIN6_PB3:
+        case RK29_PIN6_PB4:
+        case RK29_PIN6_PB5:
+        case RK29_PIN6_PB6:
+        case RK29_PIN6_PB7:
+        case RK29_PIN6_PC0:
+        case RK29_PIN6_PC1:
+        case RK29_PIN6_PC2:
+        case RK29_PIN6_PC3:
+        {
+            break;
+        }
+        case RK29_PIN6_PC4:
+        case RK29_PIN6_PC5:
+        {
+             rk29_mux_api_set(GPIO6C54_CPUTRACEDATA54_NAME,0);
+            break;	
+        }
+        case RK29_PIN6_PC6:
+        case RK29_PIN6_PC7:
+        {
+             rk29_mux_api_set(GPIO6C76_CPUTRACEDATA76_NAME,0);
+            break;	
+        }
+        case RK29_PIN6_PD0:
+        case RK29_PIN6_PD1:
+        case RK29_PIN6_PD2:
+        case RK29_PIN6_PD3:
+        case RK29_PIN6_PD4:
+        case RK29_PIN6_PD5:
+        case RK29_PIN6_PD6:
+        case RK29_PIN6_PD7:
+        {
+            break;	
+        }    
+        default:
+        {
+            printk("Pin=%d isn't RK29 GPIO, Please init it's iomux yourself!",pin);
+            break;
+        }
+    }
+    return 0;
+}
 
 static int sensor_power_default_cb (struct rk29camera_gpio_res *res, int on)
 {
@@ -124,15 +1092,15 @@ static int sensor_power_default_cb (struct rk29camera_gpio_res *res, int on)
 		     if (camera_io_init & RK29_CAM_POWERACTIVE_MASK) {
             if (on) {
             	gpio_set_value(camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-    			dprintk("\n%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+    			dprintk("%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
     			msleep(10);
     		} else {
     			gpio_set_value(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-    			dprintk("\n%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+    			dprintk("%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
     		}
 		} else {
 			ret = RK29_CAM_EIO_REQUESTFAIL;
-			printk("\n%s..%s..PowerPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_power);
+			printk("%s..%s..PowerPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_power);
 	    }        
     } else {
 		ret = RK29_CAM_EIO_INVALID;
@@ -152,14 +1120,14 @@ static int sensor_reset_default_cb (struct rk29camera_gpio_res *res, int on)
 		if (camera_io_init & RK29_CAM_RESETACTIVE_MASK) {
 			if (on) {
 	        	gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-	        	dprintk("\n%s..%s..ResetPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+	        	dprintk("%s..%s..ResetPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
 			} else {
 				gpio_set_value(camera_reset,(((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-        		dprintk("\n%s..%s..ResetPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_reset, (((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+        		dprintk("%s..%s..ResetPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_reset, (((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
 	        }
 		} else {
 			ret = RK29_CAM_EIO_REQUESTFAIL;
-			printk("\n%s..%s..ResetPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_reset);
+			printk("%s..%s..ResetPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_reset);
 		}
     } else {
 		ret = RK29_CAM_EIO_INVALID;
@@ -179,14 +1147,14 @@ static int sensor_powerdown_default_cb (struct rk29camera_gpio_res *res, int on)
 		if (camera_io_init & RK29_CAM_POWERDNACTIVE_MASK) {
 			if (on) {
 	        	gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-	        	dprintk("\n%s..%s..PowerDownPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+	        	dprintk("%s..%s..PowerDownPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
 			} else {
 				gpio_set_value(camera_powerdown,(((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-        		dprintk("\n%s..%s..PowerDownPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_powerdown, (((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+        		dprintk("%s..%s..PowerDownPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_powerdown, (((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
 	        }
 		} else {
 			ret = RK29_CAM_EIO_REQUESTFAIL;
-			dprintk("\n%s..%s..PowerDownPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_powerdown);
+			dprintk("%s..%s..PowerDownPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_powerdown);
 		}
     } else {
 		ret = RK29_CAM_EIO_INVALID;
@@ -216,26 +1184,26 @@ static int sensor_flash_default_cb (struct rk29camera_gpio_res *res, int on)
                 case Flash_On:
                 {
                     gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-	        	    dprintk("\n%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    dprintk("%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
 	        	    break;
                 }
 
                 case Flash_Torch:
                 {
                     gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-	        	    dprintk("\n%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    dprintk("%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
 	        	    break;
                 }
 
                 default:
                 {
-                    printk("\n%s..%s..Flash command(%d) is invalidate \n",__FUNCTION__,res->dev_name,on);
+                    printk("%s..%s..Flash command(%d) is invalidate \n",__FUNCTION__,res->dev_name,on);
                     break;
                 }
             }
 		} else {
 			ret = RK29_CAM_EIO_REQUESTFAIL;
-			printk("\n%s..%s..FlashPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_flash);
+			printk("%s..%s..FlashPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_flash);
 		}
     } else {
 		ret = RK29_CAM_EIO_INVALID;
@@ -272,63 +1240,85 @@ static int rk29_sensor_io_init(void)
             ret = gpio_request(camera_power, "camera power");
             if (ret) {
                 if (i == 0) {
-                    printk("\n%s..%s..power pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
+                    printk("%s..%s..power pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
 				    goto sensor_io_int_loop_end;
                 } else {
                     if (camera_power != rk29_camera_platform_data.gpio_res[0].gpio_power) {
-                        printk("\n%s..%s..power pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
+                        printk("%s..%s..power pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
                         goto sensor_io_int_loop_end;
                     }
                 }
             }
 
+            if (rk29_sensor_iomux(camera_power) < 0) {
+                printk(KERN_ERR "%s..%s..power pin(%d) iomux init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
+                goto sensor_io_int_loop_end;
+            }
+            
 			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_POWERACTIVE_MASK;
             gpio_set_value(camera_reset, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
             gpio_direction_output(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
 
-			printk("\n%s....power pin(%d) init success(0x%x)  \n",__FUNCTION__,camera_power,(((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+			dprintk("%s....power pin(%d) init success(0x%x)  \n",__FUNCTION__,camera_power,(((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
 
         }
 
         if (camera_reset != INVALID_GPIO) {
             ret = gpio_request(camera_reset, "camera reset");
             if (ret) {
-                printk("\n%s..%s..reset pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_reset);
+                printk("%s..%s..reset pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_reset);
                 goto sensor_io_int_loop_end;
             }
+
+            if (rk29_sensor_iomux(camera_reset) < 0) {
+                printk(KERN_ERR "%s..%s..reset pin(%d) iomux init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_reset);
+                goto sensor_io_int_loop_end;
+            }
+            
 			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_RESETACTIVE_MASK;
             gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
             gpio_direction_output(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
 
-			dprintk("\n%s....reset pin(%d) init success(0x%x)\n",__FUNCTION__,camera_reset,((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+			dprintk("%s....reset pin(%d) init success(0x%x)\n",__FUNCTION__,camera_reset,((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
 
         }
 
 		if (camera_powerdown != INVALID_GPIO) {
             ret = gpio_request(camera_powerdown, "camera powerdown");
             if (ret) {
-                printk("\n%s..%s..powerdown pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_powerdown);
+                printk("%s..%s..powerdown pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_powerdown);
+                goto sensor_io_int_loop_end;
+            }
+
+            if (rk29_sensor_iomux(camera_powerdown) < 0) {
+                printk(KERN_ERR "%s..%s..powerdown pin(%d) iomux init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_powerdown);
                 goto sensor_io_int_loop_end;
             }
+            
 			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_POWERDNACTIVE_MASK;
             gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
             gpio_direction_output(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
 
-			printk("\n%s....powerdown pin(%d) init success(0x%x) \n",__FUNCTION__,camera_powerdown,((camera_ioflag&RK29_CAM_POWERDNACTIVE_BITPOS)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+			dprintk("%s....powerdown pin(%d) init success(0x%x) \n",__FUNCTION__,camera_powerdown,((camera_ioflag&RK29_CAM_POWERDNACTIVE_BITPOS)>>RK29_CAM_POWERDNACTIVE_BITPOS));
 
         }
 
 		if (camera_flash != INVALID_GPIO) {
             ret = gpio_request(camera_flash, "camera flash");
             if (ret) {
-                printk("\n%s..%s..flash pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_flash);
+                printk("%s..%s..flash pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_flash);
 				goto sensor_io_int_loop_end;
             }
+
+            if (rk29_sensor_iomux(camera_flash) < 0) {
+                printk(KERN_ERR "%s..%s..flash pin(%d) iomux init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_flash);                
+            }
+            
 			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_FLASHACTIVE_MASK;
             gpio_set_value(camera_flash, ((~camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));    /* falsh off */
             gpio_direction_output(camera_flash, ((~camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
 
-			dprintk("\n%s....flash pin(%d) init success(0x%x) \n",__FUNCTION__,camera_flash,((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+			dprintk("%s....flash pin(%d) init success(0x%x) \n",__FUNCTION__,camera_flash,((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
 
         }
 		continue;
@@ -350,7 +1340,7 @@ static int rk29_sensor_io_deinit(int sensor)
 	camera_powerdown = rk29_camera_platform_data.gpio_res[sensor].gpio_powerdown;
     camera_flash = rk29_camera_platform_data.gpio_res[sensor].gpio_flash;
 
-    printk("\n%s..%s enter..",__FUNCTION__,rk29_camera_platform_data.gpio_res[sensor].dev_name);
+    printk("%s..%s enter..\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[sensor].dev_name);
 
 	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_POWERACTIVE_MASK) {
 	    if (camera_power != INVALID_GPIO) {
@@ -499,6 +1489,7 @@ static struct platform_device rk29_soc_camera_pdrv_0 = {
 	},
 };
 #endif
+#if (CONFIG_SENSOR_IIC_ADDR_1 != 0x00)
 static struct i2c_board_info rk29_i2c_cam_info_1[] = {
 	{
 		I2C_BOARD_INFO(SENSOR_NAME_1, CONFIG_SENSOR_IIC_ADDR_1>>1)
@@ -526,7 +1517,7 @@ static struct platform_device rk29_soc_camera_pdrv_1 = {
 		.platform_data = &rk29_iclink_1,
 	},
 };
-
+#endif
 
 static u64 rockchip_device_camera_dmamask = 0xffffffffUL;
 static struct resource rk29_camera_resource[] = {
diff --git a/drivers/media/video/rk29_camera_oneframe.c b/drivers/media/video/rk29_camera_oneframe.c
index ff63a0c3e277..8da0b077f989 100755
--- a/drivers/media/video/rk29_camera_oneframe.c
+++ b/drivers/media/video/rk29_camera_oneframe.c
@@ -48,7 +48,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 	printk(KERN_WARNING"rk29xx_camera: " fmt , ## arg); } while (0)
 
 #define RK29CAMERA_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
-#define RK29CAMERA_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
+#define RK29CAMERA_DG(format, ...) dprintk(0, format, ## __VA_ARGS__)
 
 // VIP Reg Offset
 #define RK29_VIP_AHBR_CTRL                0x00
@@ -126,11 +126,23 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define read_grf_reg(addr) __raw_readl(addr+RK29_GRF_BASE)
 #define mask_grf_reg(addr, msk, val)    write_vip_reg(addr, (val)|((~(msk))&read_vip_reg(addr)))
 
+#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF
 #define CAM_WORKQUEUE_IS_EN()   ((pcdev->host_width != pcdev->icd->user_width) || (pcdev->host_height != pcdev->icd->user_height)\
                                   || (pcdev->icd_cb.sensor_cb))
 #define CAM_IPPWORK_IS_EN()     ((pcdev->host_width != pcdev->icd->user_width) || (pcdev->host_height != pcdev->icd->user_height))                                  
-
+#else
+#define CAM_WORKQUEUE_IS_EN()   (true)
+#define CAM_IPPWORK_IS_EN()     ((pcdev->zoominfo.a.c.width != pcdev->icd->user_width) || (pcdev->zoominfo.a.c.height != pcdev->icd->user_height))
+#endif
 //Configure Macro
+/*
+*            Driver Version Note
+*v0.0.1 : this driver first support rk2918;
+*v0.0.2 : fix this driver support v4l2 format is V4L2_PIX_FMT_NV12 and V4L2_PIX_FMT_NV16,is not V4L2_PIX_FMT_YUV420 
+*         and V4L2_PIX_FMT_YUV422P;
+*v0.0.3 : this driver support VIDIOC_ENUM_FRAMEINTERVALS;
+*v0.0.4 : this driver support digital zoom;
+*/
 #define RK29_CAM_VERSION_CODE KERNEL_VERSION(0, 1, 3)
 
 /* limit to rk29 hardware capabilities */
@@ -199,6 +211,12 @@ struct rk29_camera_frmivalinfo
     struct soc_camera_device *icd;
     struct rk29_camera_frmivalenum *fival_list;
 };
+struct rk29_camera_zoominfo
+{
+    struct semaphore sem;
+    struct v4l2_crop a;
+    int zoom_rate;
+};
 struct rk29_camera_dev
 {
     struct soc_camera_host	soc_host;
@@ -239,7 +257,8 @@ struct rk29_camera_dev
     struct resource		*res;
 
     struct list_head	capture;
-
+    struct rk29_camera_zoominfo zoominfo;
+    
     spinlock_t		lock;
 
     struct videobuf_buffer	*active;
@@ -253,6 +272,22 @@ struct rk29_camera_dev
     rk29_camera_sensor_cb_s icd_cb;
     struct rk29_camera_frmivalinfo icd_frmival[2];
 };
+
+static const struct v4l2_queryctrl rk29_camera_controls[] =
+{
+	#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
+    {
+        .id		= V4L2_CID_ZOOM_ABSOLUTE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "DigitalZoom Control",
+        .minimum	= 100,
+        .maximum	= 300,
+        .step		= 5,
+        .default_value = 100,
+    },
+    #endif
+};
+
 static DEFINE_MUTEX(camera_lock);
 static const char *rk29_cam_driver_description = "RK29_Camera";
 static struct rk29_camera_dev *rk29_camdev_info_ptr;
@@ -283,7 +318,11 @@ static int rk29_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 
 
 	if (CAM_WORKQUEUE_IS_EN()) {
-        if (CAM_IPPWORK_IS_EN()) {
+        #ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF
+        if (CAM_IPPWORK_IS_EN()) 
+        #endif
+        {
+            BUG_ON(pcdev->vipmem_size<pcdev->vipmem_bsize);
     		if (*count > pcdev->vipmem_size/pcdev->vipmem_bsize) {    /* Buffers must be limited, when this resolution is genered by IPP */
     			*count = pcdev->vipmem_size/pcdev->vipmem_bsize;
     		}
@@ -304,7 +343,7 @@ static int rk29_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 		}
 	}
 
-    RK29CAMERA_DG("%s..%d.. videobuf size:%d, vipmem_buf size:%d \n",__FUNCTION__,__LINE__, *size,pcdev->vipmem_bsize);
+    RK29CAMERA_DG("%s..%d.. videobuf size:%d, vipmem_buf size:%d, count:%d \n",__FUNCTION__,__LINE__, *size,pcdev->vipmem_size, *count);
 
     return 0;
 }
@@ -321,7 +360,11 @@ static void rk29_videobuf_free(struct videobuf_queue *vq, struct rk29_buffer *bu
 
     if (in_interrupt())
         BUG();
-
+    /*
+	 * This waits until this buffer is out of danger, i.e., until it is no
+	 * longer in STATE_QUEUED or STATE_ACTIVE
+	 */
+	//videobuf_waiton(vq, &buf->vb, 0, 0);
     videobuf_dma_contig_free(vq, &buf->vb);
     dev_dbg(&icd->dev, "%s freed\n", __func__);
     buf->vb.state = VIDEOBUF_NEEDS_INIT;
@@ -391,7 +434,7 @@ static inline void rk29_videobuf_capture(struct videobuf_buffer *vb)
 	struct rk29_camera_dev *pcdev = rk29_camdev_info_ptr;
 
     if (vb) {
-		if (CAM_IPPWORK_IS_EN()) {
+		if (CAM_WORKQUEUE_IS_EN()) {
 			y_addr = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
 			uv_addr = y_addr + pcdev->host_width*pcdev->host_height;
 
@@ -469,46 +512,84 @@ static void rk29_camera_capture_process(struct work_struct *work)
 	struct rk29_camera_dev *pcdev = camera_work->pcdev;
 	struct rk29_ipp_req ipp_req;
 	unsigned long int flags;
-
-    if (CAM_IPPWORK_IS_EN()) {
-    	ipp_req.src0.YrgbMst = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
-    	ipp_req.src0.CbrMst= ipp_req.src0.YrgbMst + pcdev->host_width*pcdev->host_height;
-    	ipp_req.src0.w = pcdev->host_width;
-    	ipp_req.src0.h = pcdev->host_height;
-    	rk29_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.src0.fmt);
-
-    	ipp_req.dst0.YrgbMst = vb->boff;
-    	ipp_req.dst0.CbrMst= vb->boff+vb->width * vb->height;
-    	ipp_req.dst0.w = pcdev->icd->user_width;
-    	ipp_req.dst0.h = pcdev->icd->user_height;
-    	rk29_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.dst0.fmt);
-
-    	ipp_req.src_vir_w = ipp_req.src0.w;
-    	ipp_req.dst_vir_w = ipp_req.dst0.w;
-    	ipp_req.timeout = 100;
-    	ipp_req.flag = IPP_ROT_0;
-
-    	//if (ipp_do_blit(&ipp_req)) {
-    	if (ipp_blit_sync(&ipp_req)) {
-    		spin_lock_irqsave(&pcdev->lock, flags);
-    		vb->state = VIDEOBUF_ERROR;
-    		spin_unlock_irqrestore(&pcdev->lock, flags);
-    		RK29CAMERA_TR("Capture image(vb->i:0x%x) which IPP operated is error!\n", vb->i);
-    		RK29CAMERA_TR("ipp_req.src0.YrgbMst:0x%x ipp_req.src0.CbrMst:0x%x \n", ipp_req.src0.YrgbMst,ipp_req.src0.CbrMst);
-    		RK29CAMERA_TR("ipp_req.src0.w:0x%x ipp_req.src0.h:0x%x \n",ipp_req.src0.w,ipp_req.src0.h);
-    		RK29CAMERA_TR("ipp_req.src0.fmt:0x%x\n",ipp_req.src0.fmt);
-    		RK29CAMERA_TR("ipp_req.dst0.YrgbMst:0x%x ipp_req.dst0.CbrMst:0x%x \n",ipp_req.dst0.YrgbMst,ipp_req.dst0.CbrMst);
-    		RK29CAMERA_TR("ipp_req.dst0.w:0x%x ipp_req.dst0.h:0x%x \n",ipp_req.dst0.w ,ipp_req.dst0.h);
-    		RK29CAMERA_TR("ipp_req.dst0.fmt:0x%x\n",ipp_req.dst0.fmt);
-    		RK29CAMERA_TR("ipp_req.src_vir_w:0x%x ipp_req.dst_vir_w :0x%x\n",ipp_req.src_vir_w ,ipp_req.dst_vir_w);
-    	    RK29CAMERA_TR("ipp_req.timeout:0x%x ipp_req.flag :0x%x\n",ipp_req.timeout,ipp_req.flag);
-    	}
-    } 
+    int src_y_offset,src_uv_offset,dst_y_offset,dst_uv_offset,src_y_size,dst_y_size;
+    int scale_times,w,h,vipdata_base;
+	
+    /*
+    *ddl@rock-chips.com: 
+    * IPP Dest image resolution is 2047x1088, so scale operation break up some times
+    */
+    if ((pcdev->icd->user_width > 0x7f0) || (pcdev->icd->user_height > 0x430)) {
+        scale_times = MAX((pcdev->icd->user_width/0x7f0),(pcdev->icd->user_height/0x430));        
+        scale_times++;
+    } else {
+        scale_times = 1;
+    }
+    
+    memset(&ipp_req, 0, sizeof(struct rk29_ipp_req));
+    
+    down(&pcdev->zoominfo.sem);
+    
+    ipp_req.timeout = 100;
+    ipp_req.flag = IPP_ROT_0;    
+    ipp_req.src0.w = pcdev->zoominfo.a.c.width/scale_times;
+    ipp_req.src0.h = pcdev->zoominfo.a.c.height/scale_times;
+    ipp_req.src_vir_w = pcdev->host_width;
+    rk29_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.src0.fmt);
+    ipp_req.dst0.w = pcdev->icd->user_width/scale_times;
+    ipp_req.dst0.h = pcdev->icd->user_height/scale_times;
+    ipp_req.dst_vir_w = pcdev->icd->user_width;        
+    rk29_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.dst0.fmt);
+
+    vipdata_base = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
+    src_y_size = pcdev->host_width*pcdev->host_height;
+    dst_y_size = pcdev->icd->user_width*pcdev->icd->user_height;
+    
+    for (h=0; h<scale_times; h++) {
+        for (w=0; w<scale_times; w++) {
+            
+            src_y_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->host_width 
+                        + pcdev->zoominfo.a.c.left + w*pcdev->zoominfo.a.c.width/scale_times;
+		    src_uv_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->host_width/2
+                        + pcdev->zoominfo.a.c.left + w*pcdev->zoominfo.a.c.width/scale_times;
+
+            dst_y_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times + pcdev->icd->user_width*w/scale_times;
+            dst_uv_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times/2 + pcdev->icd->user_width*w/scale_times;
+
+    		ipp_req.src0.YrgbMst = vipdata_base + src_y_offset;
+    		ipp_req.src0.CbrMst = vipdata_base + src_y_size + src_uv_offset;
+    		ipp_req.dst0.YrgbMst = vb->boff + dst_y_offset;
+    		ipp_req.dst0.CbrMst = vb->boff + dst_y_size + dst_uv_offset;
+
+    		if (ipp_blit_sync(&ipp_req)) {
+    			spin_lock_irqsave(&pcdev->lock, flags);
+    			vb->state = VIDEOBUF_ERROR;
+    			spin_unlock_irqrestore(&pcdev->lock, flags);
+
+                RK29CAMERA_TR("Capture image(vb->i:0x%x) which IPP operated is error:\n",vb->i);
+                RK29CAMERA_TR("widx:%d hidx:%d ",w,h);
+                RK29CAMERA_TR("%dx%d@(%d,%d)->%dx%d\n",pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height,pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,pcdev->icd->user_width,pcdev->icd->user_height);
+            	RK29CAMERA_TR("ipp_req.src0.YrgbMst:0x%x ipp_req.src0.CbrMst:0x%x \n", ipp_req.src0.YrgbMst,ipp_req.src0.CbrMst);
+            	RK29CAMERA_TR("ipp_req.src0.w:0x%x ipp_req.src0.h:0x%x \n",ipp_req.src0.w,ipp_req.src0.h);
+            	RK29CAMERA_TR("ipp_req.src0.fmt:0x%x\n",ipp_req.src0.fmt);
+            	RK29CAMERA_TR("ipp_req.dst0.YrgbMst:0x%x ipp_req.dst0.CbrMst:0x%x \n",ipp_req.dst0.YrgbMst,ipp_req.dst0.CbrMst);
+            	RK29CAMERA_TR("ipp_req.dst0.w:0x%x ipp_req.dst0.h:0x%x \n",ipp_req.dst0.w ,ipp_req.dst0.h);
+            	RK29CAMERA_TR("ipp_req.dst0.fmt:0x%x\n",ipp_req.dst0.fmt);
+            	RK29CAMERA_TR("ipp_req.src_vir_w:0x%x ipp_req.dst_vir_w :0x%x\n",ipp_req.src_vir_w ,ipp_req.dst_vir_w);
+            	RK29CAMERA_TR("ipp_req.timeout:0x%x ipp_req.flag :0x%x\n",ipp_req.timeout,ipp_req.flag);
+                
+    			goto do_ipp_err;
+    		}
+        }
+    }
 
     if (pcdev->icd_cb.sensor_cb)
         (pcdev->icd_cb.sensor_cb)(vb);
-
-	wake_up(&(camera_work->vb->done));
+	
+do_ipp_err:
+    up(&pcdev->zoominfo.sem);
+    wake_up(&(camera_work->vb->done)); 
+	return;
 }
 static irqreturn_t rk29_camera_irq(int irq, void *data)
 {
@@ -579,7 +660,6 @@ static void rk29_videobuf_release(struct videobuf_queue *vq,
     struct soc_camera_device *icd = vq->priv_data;
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
     struct rk29_camera_dev *pcdev = ici->priv;
-
 #ifdef DEBUG
     dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,
             vb, vb->baddr, vb->bsize);
@@ -595,11 +675,11 @@ static void rk29_videobuf_release(struct videobuf_queue *vq,
         case VIDEOBUF_PREPARED:
             dev_dbg(&icd->dev, "%s (prepared)\n", __func__);
             break;
-        default:
+        default:  
             dev_dbg(&icd->dev, "%s (unknown)\n", __func__);
             break;
     }
-#endif
+#endif	
 	if (vb == pcdev->active) {
 		RK29CAMERA_DG("%s Wait for this video buf(0x%x) write finished!\n ",__FUNCTION__,(unsigned int)vb);
 		interruptible_sleep_on_timeout(&vb->done, 100);
@@ -630,7 +710,7 @@ static void rk29_camera_init_videobuf(struct videobuf_queue *q,
                                    V4L2_BUF_TYPE_VIDEO_CAPTURE,
                                    V4L2_FIELD_NONE,
                                    sizeof(struct rk29_buffer),
-                                   icd);
+                                   icd,&icd->video_lock);
 }
 static int rk29_camera_activate(struct rk29_camera_dev *pcdev, struct soc_camera_device *icd)
 {
@@ -767,6 +847,8 @@ static int rk29_camera_add_device(struct soc_camera_device *icd)
     pcdev->active = NULL;
     pcdev->icd = NULL;
 	pcdev->reginfo_suspend.Inval = Reg_Invalidate;
+    pcdev->zoominfo.zoom_rate = 100;
+        
 	/* ddl@rock-chips.com: capture list must be reset, because this list may be not empty,
      * if app havn't dequeue all videobuf before close camera device;
 	*/
@@ -960,7 +1042,7 @@ static const struct soc_mbus_pixelfmt rk29_camera_formats[] = {
 		.fourcc			= V4L2_PIX_FMT_NV12,
 		.name			= "YUV420 NV12",
 		.bits_per_sample	= 8,
-		.packing		= SOC_MBUS_PACKING_2X8_PADHI,
+		.packing		= SOC_MBUS_PACKING_1_5X8,
 		.order			= SOC_MBUS_ORDER_LE,
 	},{
 		.fourcc			= V4L2_PIX_FMT_NV16,
@@ -972,7 +1054,7 @@ static const struct soc_mbus_pixelfmt rk29_camera_formats[] = {
 		.fourcc			= V4L2_PIX_FMT_YUV420,
 		.name			= "NV12(v0.0.1)",
 		.bits_per_sample	= 8,
-		.packing		= SOC_MBUS_PACKING_2X8_PADHI,
+		.packing		= SOC_MBUS_PACKING_1_5X8,
 		.order			= SOC_MBUS_ORDER_LE,
 	},{
 		.fourcc			= V4L2_PIX_FMT_YUV422P,
@@ -1046,7 +1128,7 @@ static void rk29_camera_setup_format(struct soc_camera_device *icd, __u32 host_p
 	return;
 }
 
-static int rk29_camera_get_formats(struct soc_camera_device *icd, int idx,
+static int rk29_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,
 				  struct soc_camera_format_xlate *xlate)
 {
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
@@ -1208,7 +1290,7 @@ static int rk29_camera_set_fmt(struct soc_camera_device *icd,
     		ret = -EINVAL;
     		goto RK29_CAMERA_SET_FMT_END;
     	}    	
-    	if (unlikely((usr_w <16) || (usr_w > 2047) || (usr_h < 16) || (usr_h > 2047))) {
+    	if (unlikely((usr_w <16)||(usr_h < 16))) {
     		RK29CAMERA_TR("Senor and IPP both invalid destination resolution(%dx%d)\n",usr_w,usr_h);
     		ret = -EINVAL;
             goto RK29_CAMERA_SET_FMT_END;
@@ -1225,8 +1307,35 @@ static int rk29_camera_set_fmt(struct soc_camera_device *icd,
         rect.width = mf.width;
         rect.height = mf.height;
 
-        RK29CAMERA_DG("%s..%s..v4l2_mbus_code:%d  icd:%dx%d  host:%dx%d \n",__FUNCTION__,xlate->host_fmt->name, mf.code,
-			           rect.width,rect.height, pix->width,pix->height);
+        down(&pcdev->zoominfo.sem);        
+        pcdev->zoominfo.a.c.width = rect.width*100/pcdev->zoominfo.zoom_rate;
+		pcdev->zoominfo.a.c.width &= ~0x03;
+		pcdev->zoominfo.a.c.height = rect.height*100/pcdev->zoominfo.zoom_rate;
+		pcdev->zoominfo.a.c.height &= ~0x03;
+		pcdev->zoominfo.a.c.left = ((rect.width - pcdev->zoominfo.a.c.width)>>1)&(~0x01);
+		pcdev->zoominfo.a.c.top = ((rect.height - pcdev->zoominfo.a.c.height)>>1)&(~0x01);
+        up(&pcdev->zoominfo.sem);
+
+        /* ddl@rock-chips.com: IPP work limit check */
+        if ((pcdev->zoominfo.a.c.width != usr_w) || (pcdev->zoominfo.a.c.height != usr_h)) {
+            if (usr_w > 0x7f0) {
+                if (((usr_w>>1)&0x3f) && (((usr_w>>1)&0x3f) <= 8)) {
+                    RK29CAMERA_TR("IPP Destination resolution(%dx%d, ((%d div 1) mod 64)=%d is <= 8)",usr_w,usr_h, usr_w, (int)((usr_w>>1)&0x3f));
+                    ret = -EINVAL;
+                    goto RK29_CAMERA_SET_FMT_END;
+                }
+            } else {
+                if ((usr_w&0x3f) && ((usr_w&0x3f) <= 8)) {
+                    RK29CAMERA_TR("IPP Destination resolution(%dx%d, %d mod 64=%d is <= 8)",usr_w,usr_h, usr_w, (int)(usr_w&0x3f));
+                    ret = -EINVAL;
+                    goto RK29_CAMERA_SET_FMT_END;
+                }
+            }
+        }
+        
+        RK29CAMERA_DG("%s..%s icd width:%d  host width:%d (zoom: %dx%d@(%d,%d)->%dx%d)\n",__FUNCTION__,xlate->host_fmt->name,
+			           rect.width, pix->width, pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height, pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,
+			           pix->width, pix->height);
         rk29_camera_setup_format(icd, pix->pixelformat, mf.code, &rect); 
         
 		if (CAM_IPPWORK_IS_EN()) {
@@ -1381,7 +1490,7 @@ static int rk29_camera_try_fmt(struct soc_camera_device *icd,
     return ret;
 }
 
-static int rk29_camera_reqbufs(struct soc_camera_file *icf,
+static int rk29_camera_reqbufs(struct soc_camera_device *icd,
                                struct v4l2_requestbuffers *p)
 {
     int i;
@@ -1391,7 +1500,7 @@ static int rk29_camera_reqbufs(struct soc_camera_file *icf,
      * a dma IRQ can occur for an in-work or unlinked buffer. Until now
      * it hadn't triggered */
     for (i = 0; i < p->count; i++) {
-        struct rk29_buffer *buf = container_of(icf->vb_vidq.bufs[i],
+        struct rk29_buffer *buf = container_of(icd->vb_vidq.bufs[i],
                                                            struct rk29_buffer, vb);
         buf->inwork = 0;
         INIT_LIST_HEAD(&buf->vb.queue);
@@ -1402,10 +1511,10 @@ static int rk29_camera_reqbufs(struct soc_camera_file *icf,
 
 static unsigned int rk29_camera_poll(struct file *file, poll_table *pt)
 {
-    struct soc_camera_file *icf = file->private_data;
+    struct soc_camera_device *icd = file->private_data;
     struct rk29_buffer *buf;
 
-    buf = list_entry(icf->vb_vidq.stream.next, struct rk29_buffer,
+    buf = list_entry(icd->vb_vidq.stream.next, struct rk29_buffer,
                      vb.stream);
 
     poll_wait(file, &buf->vb.done, pt);
@@ -1666,6 +1775,92 @@ int rk29_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_f
 
     return ret;
 }
+
+#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
+static int rk29_camera_set_digit_zoom(struct soc_camera_device *icd,
+								const struct v4l2_queryctrl *qctrl, int zoom_rate)
+{
+	struct v4l2_crop a;
+	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct rk29_camera_dev *pcdev = ici->priv;
+	
+/* ddl@rock-chips.com : The largest resolution is 2047x1088, so larger resolution must be operated some times
+   (Assume operate times is 4),but resolution which ipp can operate ,it is width and height must be even. */
+	a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	a.c.width = pcdev->host_width*100/zoom_rate;
+	a.c.width &= ~0x03;    
+	a.c.height = pcdev->host_height*100/zoom_rate;
+	a.c.height &= ~0x03;
+	
+	a.c.left = ((pcdev->host_width - a.c.width)>>1)&(~0x01);
+	a.c.top = ((pcdev->host_height - a.c.height)>>1)&(~0x01);
+
+    down(&pcdev->zoominfo.sem);
+	pcdev->zoominfo.a.c.height = a.c.height;
+	pcdev->zoominfo.a.c.width = a.c.width;
+	pcdev->zoominfo.a.c.top = a.c.top;
+	pcdev->zoominfo.a.c.left = a.c.left;
+    up(&pcdev->zoominfo.sem);
+    
+	RK29CAMERA_DG("%s..zoom_rate:%d (%dx%d at (%d,%d)-> %dx%d)\n",__FUNCTION__, zoom_rate,a.c.width, a.c.height, a.c.left, a.c.top, pcdev->host_width, pcdev->host_height );
+
+	return 0;
+}
+#endif
+static inline struct v4l2_queryctrl const *rk29_camera_soc_camera_find_qctrl(
+	struct soc_camera_host_ops *ops, int id)
+{
+	int i;
+
+	for (i = 0; i < ops->num_controls; i++)
+		if (ops->controls[i].id == id)
+			return &ops->controls[i];
+
+	return NULL;
+}
+
+
+static int rk29_camera_set_ctrl(struct soc_camera_device *icd,
+								struct v4l2_control *sctrl)
+{
+
+	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	const struct v4l2_queryctrl *qctrl;
+    struct rk29_camera_dev *pcdev = ici->priv;
+    int ret = 0;
+
+	qctrl = rk29_camera_soc_camera_find_qctrl(ici->ops, sctrl->id);
+	if (!qctrl) {
+		ret = -ENOIOCTLCMD;
+        goto rk29_camera_set_ctrl_end;
+	}
+
+	switch (sctrl->id)
+	{
+	#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
+		case V4L2_CID_ZOOM_ABSOLUTE:
+		{
+			if ((sctrl->value < qctrl->minimum) || (sctrl->value > qctrl->maximum)){
+        		ret = -EINVAL;
+                goto rk29_camera_set_ctrl_end;
+        	}
+            ret = rk29_camera_set_digit_zoom(icd, qctrl, sctrl->value);
+			if (ret == 0) {
+				pcdev->zoominfo.zoom_rate = sctrl->value;
+            } else { 
+                goto rk29_camera_set_ctrl_end;
+            }
+			break;
+		}
+    #endif
+		default:
+			ret = -ENOIOCTLCMD;
+			break;
+	}
+rk29_camera_set_ctrl_end:
+	return ret;
+}
+
 static struct soc_camera_host_ops rk29_soc_camera_host_ops =
 {
     .owner		= THIS_MODULE,
@@ -1675,7 +1870,7 @@ static struct soc_camera_host_ops rk29_soc_camera_host_ops =
     .resume		= rk29_camera_resume,
     .enum_frameinervals = rk29_camera_enum_frameintervals,
     .set_crop	= rk29_camera_set_crop,
-    .get_formats	= rk29_camera_get_formats,
+    .get_formats	= rk29_camera_get_formats, 
     .put_formats	= rk29_camera_put_formats,
     .set_fmt	= rk29_camera_set_fmt,
     .try_fmt	= rk29_camera_try_fmt,
@@ -1684,7 +1879,10 @@ static struct soc_camera_host_ops rk29_soc_camera_host_ops =
     .poll		= rk29_camera_poll,
     .querycap	= rk29_camera_querycap,
     .set_bus_param	= rk29_camera_set_bus_param,
-    .s_stream = rk29_camera_s_stream   /* ddl@rock-chips.com : Add stream control for host */
+    .s_stream = rk29_camera_s_stream,   /* ddl@rock-chips.com : Add stream control for host */
+    .set_ctrl = rk29_camera_set_ctrl,
+    .controls = rk29_camera_controls,
+    .num_controls = ARRAY_SIZE(rk29_camera_controls)
     
 };
 static int rk29_camera_probe(struct platform_device *pdev)
@@ -1726,6 +1924,8 @@ static int rk29_camera_probe(struct platform_device *pdev)
 
 	pcdev->pd_display = clk_get(&pdev->dev,"pd_display");
 
+	pcdev->zoominfo.zoom_rate = 100;
+
     if (!pcdev->aclk_ddr_lcdc || !pcdev->aclk_disp_matrix ||  !pcdev->hclk_cpu_display ||
 		!pcdev->vip_slave || !pcdev->vip_out || !pcdev->vip_input || !pcdev->vip_bus || !pcdev->pd_display ||
 		IS_ERR(pcdev->aclk_ddr_lcdc) || IS_ERR(pcdev->aclk_disp_matrix) ||  IS_ERR(pcdev->hclk_cpu_display) || IS_ERR(pcdev->pd_display) ||
@@ -1764,6 +1964,7 @@ static int rk29_camera_probe(struct platform_device *pdev)
 	#endif
     INIT_LIST_HEAD(&pcdev->capture);
     spin_lock_init(&pcdev->lock);
+    sema_init(&pcdev->zoominfo.sem,1);
 
     /*
      * Request the regions.
diff --git a/drivers/media/video/soc_camera.c b/drivers/media/video/soc_camera.c
old mode 100644
new mode 100755
index 372bd75bc4b3..86ab89524d06
--- a/drivers/media/video/soc_camera.c
+++ b/drivers/media/video/soc_camera.c
@@ -484,29 +484,17 @@ static int soc_camera_open(struct file *file)
 					icd->current_fmt->host_fmt->fourcc,
 			},
 		};
-<<<<<<< HEAD
 
-		ret = soc_camera_power_set(icd, icl, 1);
-		if (ret < 0)
-			goto epower;
-
-		/* The camera could have been already on, try to reset */
-		if (icl->reset)
-			icl->reset(icd->pdev);
-=======
         /* ddl@rock-chips.com : accelerate device open  */
         if ((file->f_flags & O_ACCMODE) == O_RDWR) {
-    		if (icl->power) {
-    			ret = icl->power(icd->pdev, 1);
-    			if (ret < 0)
-    				goto epower;
-    		}
+            ret = soc_camera_power_set(icd, icl, 1);
+    		if (ret < 0)
+    			goto epower;
 
     		/* The camera could have been already on, try to reset */
     		if (icl->reset)
     			icl->reset(icd->pdev);
-       }
->>>>>>> parent of 15f7fab... temp revert rk change
+        }
 
 		ret = ici->ops->add(icd);
 		if (ret < 0) {
@@ -518,29 +506,26 @@ static int soc_camera_open(struct file *file)
 		ret = pm_runtime_resume(&icd->vdev->dev);
 		if (ret < 0 && ret != -ENOSYS)
 			goto eresume;
-
+        /* ddl@rock-chips.com : accelerate device open  */
         if ((file->f_flags & O_ACCMODE) == O_RDWR) {
-		/*
-		 * Try to configure with default parameters. Notice: this is the
-		 * very first open, so, we cannot race against other calls,
-		 * apart from someone else calling open() simultaneously, but
-		 * .video_lock is protecting us against it.
-		 */
-		ret = soc_camera_set_fmt(icd, &f);
-		if (ret < 0)
-			goto esfmt;
-<<<<<<< HEAD
+    		/*
+    		 * Try to configure with default parameters. Notice: this is the
+    		 * very first open, so, we cannot race against other calls,
+    		 * apart from someone else calling open() simultaneously, but
+    		 * .video_lock is protecting us against it.
+    		 */
+    		ret = soc_camera_set_fmt(icd, &f);
+    		if (ret < 0)
+    			goto esfmt;
+        }
 
-		if (ici->ops->init_videobuf) {
+        if (ici->ops->init_videobuf) {
 			ici->ops->init_videobuf(&icd->vb_vidq, icd);
 		} else {
 			ret = ici->ops->init_videobuf2(&icd->vb2_vidq, icd);
 			if (ret < 0)
 				goto einitvb;
 		}
-=======
-        }
->>>>>>> parent of 15f7fab... temp revert rk change
 	}
 
 	file->private_data = icd;
@@ -582,14 +567,9 @@ static int soc_camera_close(struct file *file)
 		if (ici->ops->init_videobuf2)
 			vb2_queue_release(&icd->vb2_vidq);
 
-<<<<<<< HEAD
-		soc_camera_power_set(icd, icl, 0);
-=======
-        if ((file->f_flags & O_ACCMODE) == O_RDWR) {
-		if (icl->power)
-			icl->power(icd->pdev, 0);
+        if ((file->f_flags & O_ACCMODE) == O_RDWR) {   /* ddl@rock-chips.com : accelerate device open  */
+            soc_camera_power_set(icd, icl, 0);	
         }
->>>>>>> parent of 15f7fab... temp revert rk change
 	}
 
 	if (icd->streamer == file)
@@ -680,14 +660,8 @@ static struct v4l2_file_operations soc_camera_fops = {
 static int soc_camera_s_fmt_vid_cap(struct file *file, void *priv,
 				    struct v4l2_format *f)
 {
-<<<<<<< HEAD
 	struct soc_camera_device *icd = file->private_data;
 	int ret;
-=======
-	struct soc_camera_file *icf = file->private_data;
-	struct soc_camera_device *icd = icf->icd;
-	int ret,i;
->>>>>>> parent of 15f7fab... temp revert rk change
 
 	WARN_ON(priv != file->private_data);
 
@@ -699,31 +673,10 @@ static int soc_camera_s_fmt_vid_cap(struct file *file, void *priv,
 	if (icd->streamer && icd->streamer != file)
 		return -EBUSY;
 
-<<<<<<< HEAD
 	if (is_streaming(to_soc_camera_host(icd->dev.parent), icd)) {
-=======
-	#if 1
-	if (icf->vb_vidq.bufs[0]) {
->>>>>>> parent of 15f7fab... temp revert rk change
 		dev_err(&icd->dev, "S_FMT denied: queue initialised\n");
 		return -EBUSY;
 	}
-	#else
-
-	/* ddl@rock-chips.com :
-	     Judge queue  initialised by Judge icf->vb_vidq.bufs[0] whether is NULL , it is error.    */
-
-	i = 0;
-	while (icf->vb_vidq.bufs[i] && (i<VIDEO_MAX_FRAME)) {
-		if (icf->vb_vidq.bufs[i]->state != VIDEOBUF_NEEDS_INIT) {
-			dev_err(&icd->dev, "S_FMT denied: queue initialised, icf->vb_vidq.bufs[%d]->state:0x%x\n",i,icf->vb_vidq.bufs[i]->state);
-			ret = -EBUSY;
-			goto unlock;
-		}
-		i++;
-	}
-
-	#endif
 
 	ret = soc_camera_set_fmt(icd, f);
 
@@ -732,12 +685,11 @@ static int soc_camera_s_fmt_vid_cap(struct file *file, void *priv,
 
 	return ret;
 }
+/* ddl@rock-chips.com : Add ioctrl - VIDIOC_ENUM_FRAMEINTERVALS for soc-camera */
 static int soc_camera_enum_frameintervals (struct file *file, void  *priv,
 					   struct v4l2_frmivalenum *fival)
 {
-    struct soc_camera_file *icf = file->private_data;
-	struct soc_camera_device *icd = icf->icd;
-	const struct soc_camera_data_format *format;
+    struct soc_camera_device *icd = file->private_data;
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     int ret;
@@ -745,11 +697,12 @@ static int soc_camera_enum_frameintervals (struct file *file, void  *priv,
 	WARN_ON(priv != file->private_data);
 
     ret = v4l2_subdev_call(sd, video, enum_frameintervals, fival);
-    if (ret == -ENOIOCTLCMD) 
+    if (ret == -ENOIOCTLCMD) {
         if (ici->ops->enum_frameinervals)
            ret = ici->ops->enum_frameinervals(icd, fival); 
         else 
            ret = -ENOIOCTLCMD;
+    }
 
     return ret;
 }
@@ -813,8 +766,6 @@ static int soc_camera_streamon(struct file *file, void *priv,
 	struct soc_camera_device *icd = file->private_data;
 	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
 	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-	struct soc_camera_host *ici =
-                    to_soc_camera_host(icd->dev.parent);
 	int ret;
 
 	WARN_ON(priv != file->private_data);
@@ -822,25 +773,20 @@ static int soc_camera_streamon(struct file *file, void *priv,
 	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
 
-<<<<<<< HEAD
 	if (icd->streamer != file)
-		return -EBUSY;
-
-=======
-	mutex_lock(&icd->video_lock);
+		return -EBUSY;    
 
-	v4l2_subdev_call(sd, video, s_stream, 1);
-    if (ici->ops->s_stream)
-	    ici->ops->s_stream(icd, 1);				/* ddl@rock-chips.com : Add stream control for host */
->>>>>>> parent of 15f7fab... temp revert rk change
 	/* This calls buf_queue from host driver's videobuf_queue_ops */
 	if (ici->ops->init_videobuf)
 		ret = videobuf_streamon(&icd->vb_vidq);
 	else
 		ret = vb2_streamon(&icd->vb2_vidq, i);
 
-	if (!ret)
+	if (!ret) {
 		v4l2_subdev_call(sd, video, s_stream, 1);
+        if (ici->ops->s_stream)
+	        ici->ops->s_stream(icd, 1);				/* ddl@rock-chips.com : Add stream control for host */
+	}
 
 	return ret;
 }
@@ -850,25 +796,15 @@ static int soc_camera_streamoff(struct file *file, void *priv,
 {
 	struct soc_camera_device *icd = file->private_data;
 	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-<<<<<<< HEAD
 	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-=======
-    struct soc_camera_host *ici =
-                    to_soc_camera_host(icd->dev.parent);
->>>>>>> parent of 15f7fab... temp revert rk change
 
 	WARN_ON(priv != file->private_data);
 
 	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
-<<<<<<< HEAD
 
 	if (icd->streamer != file)
 		return -EBUSY;
-=======
-    
-	mutex_lock(&icd->video_lock);
->>>>>>> parent of 15f7fab... temp revert rk change
 
 	/*
 	 * This calls buf_release from host driver's videobuf_queue_ops for all
@@ -883,12 +819,8 @@ static int soc_camera_streamoff(struct file *file, void *priv,
     if (ici->ops->s_stream)
 		ici->ops->s_stream(icd, 0);				/* ddl@rock-chips.com : Add stream control for host */
 
-<<<<<<< HEAD
-=======
-    videobuf_mmap_free(&icf->vb_vidq);          /* ddl@rock-chips.com : free video buf */
-	mutex_unlock(&icd->video_lock);
-
->>>>>>> parent of 15f7fab... temp revert rk change
+    videobuf_mmap_free(&icd->vb_vidq);          /* ddl@rock-chips.com : free video buf */
+	
 	return 0;
 }
 
@@ -927,8 +859,7 @@ static int soc_camera_queryctrl(struct file *file, void *priv,
 static int soc_camera_querymenu(struct file *file, void *priv,
                                 struct v4l2_querymenu *qm)
 {
-    struct soc_camera_file *icf = file->private_data;
-    struct soc_camera_device *icd = icf->icd;
+    struct soc_camera_device *icd = file->private_data;
     struct v4l2_queryctrl qctrl;
     int i,j;
 
@@ -1000,8 +931,7 @@ static int soc_camera_s_ctrl(struct file *file, void *priv,
 static int soc_camera_try_ext_ctrl(struct file *file, void *priv,
                              struct v4l2_ext_controls *ctrl)
 {
-    struct soc_camera_file *icf = file->private_data;
-    struct soc_camera_device *icd = icf->icd;
+    struct soc_camera_device *icd = file->private_data;
     const struct v4l2_queryctrl *qctrl;
     int i;
 
@@ -1025,8 +955,7 @@ static int soc_camera_try_ext_ctrl(struct file *file, void *priv,
 static int soc_camera_g_ext_ctrl(struct file *file, void *priv,
                              struct v4l2_ext_controls *ctrl)
 {
-    struct soc_camera_file *icf = file->private_data;
-    struct soc_camera_device *icd = icf->icd;
+    struct soc_camera_device *icd = file->private_data;
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
 
     WARN_ON(priv != file->private_data);
@@ -1040,8 +969,7 @@ static int soc_camera_g_ext_ctrl(struct file *file, void *priv,
 static int soc_camera_s_ext_ctrl(struct file *file, void *priv,
                              struct v4l2_ext_controls *ctrl)
 {
-    struct soc_camera_file *icf = file->private_data;
-    struct soc_camera_device *icd = icf->icd;
+    struct soc_camera_device *icd = file->private_data;
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
 
     WARN_ON(priv != file->private_data);
diff --git a/include/media/soc_camera.h b/include/media/soc_camera.h
index 73a84dc398d8..97a44f5b0c6b 100644
--- a/include/media/soc_camera.h
+++ b/include/media/soc_camera.h
@@ -68,7 +68,7 @@ struct soc_camera_host_ops {
 	void (*remove)(struct soc_camera_device *);
 	int (*suspend)(struct soc_camera_device *, pm_message_t);
 	int (*resume)(struct soc_camera_device *);
-    int (*enum_frameinervals)(struct soc_camera_device *, struct v4l2_frmivalenum *);
+    int (*enum_frameinervals)(struct soc_camera_device *, struct v4l2_frmivalenum *);/* ddl@rock-chips.com :Add ioctrl - VIDIOC_ENUM_FRAMEINTERVALS for soc-camera */
 	/*
 	 * .get_formats() is called for each client device format, but
 	 * .put_formats() is only called once. Further, if any of the calls to
-- 
2.35.3

