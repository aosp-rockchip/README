From 5d91bd6092905101c679f64e675a37db176d511d Mon Sep 17 00:00:00 2001
From: yxj <yxj@rock-chips.com>
Date: Wed, 19 Feb 2014 17:40:36 +0800
Subject: [PATCH] rk32 edp: base version

---
 drivers/video/rockchip/transmitter/Kconfig    |    8 +-
 drivers/video/rockchip/transmitter/Makefile   |   21 +-
 drivers/video/rockchip/transmitter/rk32_dp.c  | 1227 +++++++++++++++++
 drivers/video/rockchip/transmitter/rk32_dp.h  |  649 +++++++++
 .../video/rockchip/transmitter/rk32_dp_reg.c  | 1156 ++++++++++++++++
 5 files changed, 3049 insertions(+), 12 deletions(-)
 create mode 100644 drivers/video/rockchip/transmitter/rk32_dp.c
 create mode 100644 drivers/video/rockchip/transmitter/rk32_dp.h
 create mode 100644 drivers/video/rockchip/transmitter/rk32_dp_reg.c

diff --git a/drivers/video/rockchip/transmitter/Kconfig b/drivers/video/rockchip/transmitter/Kconfig
index 5147a7df8771..6aaa1e51d95b 100644
--- a/drivers/video/rockchip/transmitter/Kconfig
+++ b/drivers/video/rockchip/transmitter/Kconfig
@@ -26,11 +26,15 @@ config RK616_LVDS
 		
 
 config DP_ANX6345
-	bool "RGB to Display Port transmitter anx6345,anx9804,anx9805 support"
+	bool "RGB to DisplayPort transmitter anx6345,anx9804,anx9805 support"
 	depends on RK_TRSM
 
 config DP501
-	bool"RGB to Display Port transmitter dp501 support"
+	bool"RGB to DisplayPort transmitter dp501 support"
+	depends on RK_TRSM
+
+config RK32_DP
+	bool "RK32 RGB to DisplayPort transmitter support "
 	depends on RK_TRSM
 
 config MIPI_DSI
diff --git a/drivers/video/rockchip/transmitter/Makefile b/drivers/video/rockchip/transmitter/Makefile
index ab9dbc47a5b2..c098ef3ecf3d 100644
--- a/drivers/video/rockchip/transmitter/Makefile
+++ b/drivers/video/rockchip/transmitter/Makefile
@@ -1,14 +1,15 @@
 #
 # Makefile for display transmitter like lvds edp mipi
 #
-obj-$(CONFIG_RK2928_LVDS)          += rk2928_lvds.o
-obj-$(CONFIG_RK3026_LVDS)          += rk3026_lvds.o
-obj-$(CONFIG_RK610_LVDS)	  += rk610_lcd.o
-obj-$(CONFIG_RK616_LVDS)          += rk616_lvds.o
-obj-$(CONFIG_DP_ANX6345)          += dp_anx6345.o
-obj-$(CONFIG_DP501)          += dp501.o
-obj-$(CONFIG_MIPI_DSI)     			+= mipi_dsi.o 
-obj-$(CONFIG_RK616_MIPI_DSI)     	+= rk616_mipi_dsi.o
-obj-$(CONFIG_TC358768_RGB2MIPI)     += tc358768.o
-obj-$(CONFIG_SSD2828_RGB2MIPI)      += ssd2828.o
+obj-$(CONFIG_RK2928_LVDS)       += rk2928_lvds.o
+obj-$(CONFIG_RK3026_LVDS)       += rk3026_lvds.o
+obj-$(CONFIG_RK610_LVDS)	+= rk610_lcd.o
+obj-$(CONFIG_RK616_LVDS)        += rk616_lvds.o
+obj-$(CONFIG_DP_ANX6345)        += dp_anx6345.o
+obj-$(CONFIG_DP501)          	+= dp501.o
+obj-$(CONFIG_RK32_DP)		+= rk32_dp.o rk32_dp_reg.o
+obj-$(CONFIG_MIPI_DSI)     	+= mipi_dsi.o 
+obj-$(CONFIG_RK616_MIPI_DSI)	+= rk616_mipi_dsi.o
+obj-$(CONFIG_TC358768_RGB2MIPI) += tc358768.o
+obj-$(CONFIG_SSD2828_RGB2MIPI)  += ssd2828.o
 
diff --git a/drivers/video/rockchip/transmitter/rk32_dp.c b/drivers/video/rockchip/transmitter/rk32_dp.c
new file mode 100644
index 000000000000..edf2e0167496
--- /dev/null
+++ b/drivers/video/rockchip/transmitter/rk32_dp.c
@@ -0,0 +1,1227 @@
+/*
+ * DisplayPort driver for rk32xx
+ *
+ * Copyright (C) ROCKCHIP, Inc.
+ *Author:yxj<yxj@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/rk_fb.h>
+#include "rk32_dp.h"
+#include "../../../arch/arm/mach-rockchip/iomap.h"
+#include "../../../arch/arm/mach-rockchip/grf.h"
+
+#if defined(CONFIG_OF)
+#include <linux/of.h>
+#endif
+
+/*#define BIST_MODE*/
+
+static int rk32_edp_init_edp(struct rk32_edp *edp)
+{
+	rk32_edp_reset(edp);
+	rk32_edp_init_analog_param(edp);
+	rk32_edp_init_interrupt(edp);
+
+	rk32_edp_enable_sw_function(edp);
+
+	rk32_edp_init_analog_func(edp);
+
+	rk32_edp_init_hpd(edp);
+	rk32_edp_init_aux(edp);
+
+	return 0;
+}
+
+static int rk32_edp_detect_hpd(struct rk32_edp *edp)
+{
+	int timeout_loop = 0;
+
+	rk32_edp_init_hpd(edp);
+
+	udelay(200);
+
+	while (rk32_edp_get_plug_in_status(edp) != 0) {
+		timeout_loop++;
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(edp->dev, "failed to get hpd plug status\n");
+			return -ETIMEDOUT;
+		}
+		udelay(10);
+	}
+
+	return 0;
+}
+
+static unsigned char rk32_edp_calc_edid_check_sum(unsigned char *edid_data)
+{
+	int i;
+	unsigned char sum = 0;
+
+	for (i = 0; i < EDID_BLOCK_LENGTH; i++)
+		sum = sum + edid_data[i];
+
+	return sum;
+}
+
+static int rk32_edp_read_edid(struct rk32_edp *edp)
+{
+	unsigned char edid[EDID_BLOCK_LENGTH * 2];
+	unsigned int extend_block = 0;
+	unsigned char sum;
+	unsigned char test_vector;
+	int retval;
+
+	/*
+	 * EDID device address is 0x50.
+	 * However, if necessary, you must have set upper address
+	 * into E-EDID in I2C device, 0x30.
+	 */
+
+	/* Read Extension Flag, Number of 128-byte EDID extension blocks */
+	retval = rk32_edp_read_byte_from_i2c(edp, I2C_EDID_DEVICE_ADDR,
+				EDID_EXTENSION_FLAG,
+				&extend_block);
+	if (retval < 0) {
+		dev_err(edp->dev, "EDID extension flag failed!\n");
+		return -EIO;
+	}
+
+	if (extend_block > 0) {
+		dev_dbg(edp->dev, "EDID data includes a single extension!\n");
+
+		/* Read EDID data */
+		retval = rk32_edp_read_bytes_from_i2c(edp, I2C_EDID_DEVICE_ADDR,
+						EDID_HEADER_PATTERN,
+						EDID_BLOCK_LENGTH,
+						&edid[EDID_HEADER_PATTERN]);
+		if (retval != 0) {
+			dev_err(edp->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		sum = rk32_edp_calc_edid_check_sum(edid);
+		if (sum != 0) {
+			dev_warn(edp->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		/* Read additional EDID data */
+		retval = rk32_edp_read_bytes_from_i2c(edp,
+				I2C_EDID_DEVICE_ADDR,
+				EDID_BLOCK_LENGTH,
+				EDID_BLOCK_LENGTH,
+				&edid[EDID_BLOCK_LENGTH]);
+		if (retval != 0) {
+			dev_err(edp->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		sum = rk32_edp_calc_edid_check_sum(&edid[EDID_BLOCK_LENGTH]);
+		if (sum != 0) {
+			dev_warn(edp->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		retval = rk32_edp_read_byte_from_dpcd(edp,
+				DPCD_ADDR_TEST_REQUEST,
+				&test_vector);
+		if (retval < 0) {
+			dev_err(edp->dev, "DPCD EDID Read failed!\n");
+			return retval;
+		}
+
+		if (test_vector & DPCD_TEST_EDID_READ) {
+			retval = rk32_edp_write_byte_to_dpcd(edp,
+					DPCD_ADDR_TEST_EDID_CHECKSUM,
+					edid[EDID_BLOCK_LENGTH + EDID_CHECKSUM]);
+			if (retval < 0) {
+				dev_err(edp->dev, "DPCD EDID Write failed!\n");
+				return retval;
+			}
+			retval = rk32_edp_write_byte_to_dpcd(edp,
+					DPCD_ADDR_TEST_RESPONSE,
+					DPCD_TEST_EDID_CHECKSUM_WRITE);
+			if (retval < 0) {
+				dev_err(edp->dev, "DPCD EDID checksum failed!\n");
+				return retval;
+			}
+		}
+	} else {
+		dev_info(edp->dev, "EDID data does not include any extensions.\n");
+
+		/* Read EDID data */
+		retval = rk32_edp_read_bytes_from_i2c(edp,
+				I2C_EDID_DEVICE_ADDR,
+				EDID_HEADER_PATTERN,
+				EDID_BLOCK_LENGTH,
+				&edid[EDID_HEADER_PATTERN]);
+		if (retval != 0) {
+			dev_err(edp->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		sum = rk32_edp_calc_edid_check_sum(edid);
+		if (sum != 0) {
+			dev_warn(edp->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		retval = rk32_edp_read_byte_from_dpcd(edp,
+				DPCD_ADDR_TEST_REQUEST,
+				&test_vector);
+		if (retval < 0) {
+			dev_err(edp->dev, "DPCD EDID Read failed!\n");
+			return retval;
+		}
+
+		if (test_vector & DPCD_TEST_EDID_READ) {
+			retval = rk32_edp_write_byte_to_dpcd(edp,
+					DPCD_ADDR_TEST_EDID_CHECKSUM,
+					edid[EDID_CHECKSUM]);
+			if (retval < 0) {
+				dev_err(edp->dev, "DPCD EDID Write failed!\n");
+				return retval;
+			}
+			retval = rk32_edp_write_byte_to_dpcd(edp,
+					DPCD_ADDR_TEST_RESPONSE,
+					DPCD_TEST_EDID_CHECKSUM_WRITE);
+			if (retval < 0) {
+				dev_err(edp->dev, "DPCD EDID checksum failed!\n");
+				return retval;
+			}
+		}
+	}
+
+	dev_err(edp->dev, "EDID Read success!\n");
+	return 0;
+}
+
+static int rk32_edp_handle_edid(struct rk32_edp *edp)
+{
+	u8 buf[12];
+	int i;
+	int retval;
+
+	/* Read DPCD DPCD_ADDR_DPCD_REV~RECEIVE_PORT1_CAP_1 */
+	retval = rk32_edp_read_bytes_from_dpcd(edp, DPCD_ADDR_DPCD_REV,
+					12, buf);
+	if (retval < 0)
+		return retval;
+
+	/* Read EDID */
+	for (i = 0; i < 3; i++) {
+		retval = rk32_edp_read_edid(edp);
+		if (retval == 0)
+			break;
+	}
+
+	return retval;
+}
+
+static int rk32_edp_enable_rx_to_enhanced_mode(struct rk32_edp *edp,
+						bool enable)
+{
+	u8 data;
+	int retval;
+
+	retval = rk32_edp_read_byte_from_dpcd(edp,
+			DPCD_ADDR_LANE_COUNT_SET, &data);
+	if (retval < 0)
+		return retval;
+
+	if (enable) {
+		retval = rk32_edp_write_byte_to_dpcd(edp,
+				DPCD_ADDR_LANE_COUNT_SET,
+				DPCD_ENHANCED_FRAME_EN |
+				DPCD_LANE_COUNT_SET(data));
+	} else {
+		/*retval = rk32_edp_write_byte_to_dpcd(edp,
+				DPCD_ADDR_CONFIGURATION_SET, 0);*/
+
+		retval = rk32_edp_write_byte_to_dpcd(edp,
+				DPCD_ADDR_LANE_COUNT_SET,
+				DPCD_LANE_COUNT_SET(data));
+	}
+
+	return retval;
+}
+
+void rk32_edp_rx_control(struct rk32_edp *edp, bool enable)
+{
+	/*rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED1,0);
+	rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED2,0x90);
+
+	if (enable) {
+		rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED3,0x84);
+		rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED3,0x00);
+	} else {
+		rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED3,0x80);
+	}*/
+}
+
+static int rk32_edp_is_enhanced_mode_available(struct rk32_edp *edp)
+{
+	u8 data;
+	int retval;
+
+	retval = rk32_edp_read_byte_from_dpcd(edp,
+			DPCD_ADDR_MAX_LANE_COUNT, &data);
+	if (retval < 0)
+		return retval;
+
+	return DPCD_ENHANCED_FRAME_CAP(data);
+}
+
+static void rk32_edp_disable_rx_zmux(struct rk32_edp *edp)
+{
+	/*rk32_edp_write_byte_to_dpcd(edp,
+			DPCD_ADDR_USER_DEFINED1, 0);
+	rk32_edp_write_byte_to_dpcd(edp,
+			DPCD_ADDR_USER_DEFINED2, 0x83);
+	rk32_edp_write_byte_to_dpcd(edp,
+			DPCD_ADDR_USER_DEFINED3, 0x27);*/
+}
+
+static int rk32_edp_set_enhanced_mode(struct rk32_edp *edp)
+{
+	u8 data;
+	int retval;
+
+	retval = rk32_edp_is_enhanced_mode_available(edp);
+	if (retval < 0)
+		return retval;
+
+	data = (u8)retval;
+	retval = rk32_edp_enable_rx_to_enhanced_mode(edp, data);
+	if (retval < 0)
+		return retval;
+
+	rk32_edp_enable_enhanced_mode(edp, data);
+
+	return 0;
+}
+
+static int rk32_edp_training_pattern_dis(struct rk32_edp *edp)
+{
+	int retval;
+
+	rk32_edp_set_training_pattern(edp, DP_NONE);
+
+	retval = rk32_edp_write_byte_to_dpcd(edp,
+			DPCD_ADDR_TRAINING_PATTERN_SET,
+			DPCD_TRAINING_PATTERN_DISABLED);
+	if (retval < 0)
+		return retval;
+
+	return 0;
+}
+
+static void rk32_edp_set_lane_lane_pre_emphasis(struct rk32_edp *edp,
+					int pre_emphasis, int lane)
+{
+	switch (lane) {
+	case 0:
+		rk32_edp_set_lane0_pre_emphasis(edp, pre_emphasis);
+		break;
+	case 1:
+		rk32_edp_set_lane1_pre_emphasis(edp, pre_emphasis);
+		break;
+
+	case 2:
+		rk32_edp_set_lane2_pre_emphasis(edp, pre_emphasis);
+		break;
+
+	case 3:
+		rk32_edp_set_lane3_pre_emphasis(edp, pre_emphasis);
+		break;
+	}
+}
+
+static int rk32_edp_link_start(struct rk32_edp *edp)
+{
+	u8 buf[4];
+	int lane;
+	int lane_count;
+	int retval;
+
+	lane_count = edp->link_train.lane_count;
+
+	edp->link_train.lt_state = LT_CLK_RECOVERY;
+	edp->link_train.eq_loop = 0;
+
+	for (lane = 0; lane < lane_count; lane++)
+		edp->link_train.cr_loop[lane] = 0;
+
+	/* Set sink to D0 (Sink Not Ready) mode. */
+	retval = rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_SINK_POWER_STATE,
+				DPCD_SET_POWER_STATE_D0);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to set sink device to D0!\n");
+		return retval;
+	}
+
+	/* Set link rate and count as you want to establish*/
+	rk32_edp_set_link_bandwidth(edp, edp->link_train.link_rate);
+	rk32_edp_set_lane_count(edp, edp->link_train.lane_count);
+
+	/* Setup RX configuration */
+	buf[0] = edp->link_train.link_rate;
+	buf[1] = edp->link_train.lane_count;
+	retval = rk32_edp_write_bytes_to_dpcd(edp, DPCD_ADDR_LINK_BW_SET,
+					2, buf);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to set bandwidth and lane count!\n");
+		return retval;
+	}
+
+	/* Set TX pre-emphasis to level1 */
+	for (lane = 0; lane < lane_count; lane++)
+		rk32_edp_set_lane_lane_pre_emphasis(edp,
+			PRE_EMPHASIS_LEVEL_1, lane);
+
+	/* Set training pattern 1 */
+	rk32_edp_set_training_pattern(edp, TRAINING_PTN1);
+
+	/* Set RX training pattern */
+	retval = rk32_edp_write_byte_to_dpcd(edp,
+			DPCD_ADDR_TRAINING_PATTERN_SET,
+			DPCD_SCRAMBLING_DISABLED |
+			DPCD_TRAINING_PATTERN_1);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to set training pattern 1!\n");
+		return retval;
+	}
+
+	for (lane = 0; lane < lane_count; lane++)
+		buf[lane] = DPCD_PRE_EMPHASIS_PATTERN2_LEVEL0 |
+			    DPCD_VOLTAGE_SWING_PATTERN1_LEVEL0;
+	retval = rk32_edp_write_bytes_to_dpcd(edp,
+			DPCD_ADDR_TRAINING_LANE0_SET,
+			lane_count, buf);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to set training lane!\n");
+		return retval;
+	}
+
+	return 0;
+}
+
+static unsigned char rk32_edp_get_lane_status(u8 link_status[2], int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = link_status[lane>>1];
+
+	return (link_value >> shift) & 0xf;
+}
+
+static int rk32_edp_clock_recovery_ok(u8 link_status[2], int lane_count)
+{
+	int lane;
+	u8 lane_status;
+
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = rk32_edp_get_lane_status(link_status, lane);
+		if ((lane_status & DPCD_LANE_CR_DONE) == 0)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int rk32_edp_channel_eq_ok(u8 link_align[3], int lane_count)
+{
+	int lane;
+	u8 lane_align;
+	u8 lane_status;
+
+	lane_align = link_align[2];
+	if ((lane_align & DPCD_INTERLANE_ALIGN_DONE) == 0)
+		return -EINVAL;
+
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = rk32_edp_get_lane_status(link_align, lane);
+		lane_status &= DPCD_CHANNEL_EQ_BITS;
+		if (lane_status != DPCD_CHANNEL_EQ_BITS)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned char rk32_edp_get_adjust_request_voltage(u8 adjust_request[2],
+							int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = adjust_request[lane>>1];
+
+	return (link_value >> shift) & 0x3;
+}
+
+static unsigned char rk32_edp_get_adjust_request_pre_emphasis(
+					u8 adjust_request[2],
+					int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = adjust_request[lane>>1];
+
+	return ((link_value >> shift) & 0xc) >> 2;
+}
+
+static void rk32_edp_set_lane_link_training(struct rk32_edp *edp,
+					u8 training_lane_set, int lane)
+{
+	switch (lane) {
+	case 0:
+		rk32_edp_set_lane0_link_training(edp, training_lane_set);
+		break;
+	case 1:
+		rk32_edp_set_lane1_link_training(edp, training_lane_set);
+		break;
+
+	case 2:
+		rk32_edp_set_lane2_link_training(edp, training_lane_set);
+		break;
+
+	case 3:
+		rk32_edp_set_lane3_link_training(edp, training_lane_set);
+		break;
+	}
+}
+
+static unsigned int rk32_edp_get_lane_link_training(
+				struct rk32_edp *edp,
+				int lane)
+{
+	u32 reg;
+
+	switch (lane) {
+	case 0:
+		reg = rk32_edp_get_lane0_link_training(edp);
+		break;
+	case 1:
+		reg = rk32_edp_get_lane1_link_training(edp);
+		break;
+	case 2:
+		reg = rk32_edp_get_lane2_link_training(edp);
+		break;
+	case 3:
+		reg = rk32_edp_get_lane3_link_training(edp);
+		break;
+	}
+
+	return reg;
+}
+
+static void rk32_edp_reduce_link_rate(struct rk32_edp *edp)
+{
+	rk32_edp_training_pattern_dis(edp);
+
+	edp->link_train.lt_state = FAILED;
+}
+
+static int rk32_edp_process_clock_recovery(struct rk32_edp *edp)
+{
+	u8 link_status[2];
+	int lane;
+	int lane_count;
+
+	u8 adjust_request[2];
+	u8 voltage_swing;
+	u8 pre_emphasis;
+	u8 training_lane;
+	int retval;
+
+	udelay(100);
+
+	lane_count = edp->link_train.lane_count;
+
+	retval = rk32_edp_read_bytes_from_dpcd(edp,
+			DPCD_ADDR_LANE0_1_STATUS,
+			2, link_status);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to read lane status!\n");
+		return retval;
+	}
+
+	if (rk32_edp_clock_recovery_ok(link_status, lane_count) == 0) {
+		/* set training pattern 2 for EQ */
+		rk32_edp_set_training_pattern(edp, TRAINING_PTN2);
+
+		for (lane = 0; lane < lane_count; lane++) {
+			retval = rk32_edp_read_bytes_from_dpcd(edp,
+					DPCD_ADDR_ADJUST_REQUEST_LANE0_1,
+					2, adjust_request);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to read adjust request!\n");
+				return retval;
+			}
+
+			voltage_swing = rk32_edp_get_adjust_request_voltage(
+							adjust_request, lane);
+			pre_emphasis = rk32_edp_get_adjust_request_pre_emphasis(
+							adjust_request, lane);
+			training_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |
+					DPCD_PRE_EMPHASIS_SET(pre_emphasis);
+
+			if (voltage_swing == VOLTAGE_LEVEL_3)
+				training_lane |= DPCD_MAX_SWING_REACHED;
+			if (pre_emphasis == PRE_EMPHASIS_LEVEL_3)
+				training_lane |= DPCD_MAX_PRE_EMPHASIS_REACHED;
+
+			edp->link_train.training_lane[lane] = training_lane;
+
+			rk32_edp_set_lane_link_training(edp,
+				edp->link_train.training_lane[lane],
+				lane);
+		}
+
+		retval = rk32_edp_write_byte_to_dpcd(edp,
+				DPCD_ADDR_TRAINING_PATTERN_SET,
+				DPCD_SCRAMBLING_DISABLED |
+				DPCD_TRAINING_PATTERN_2);
+		if (retval < 0) {
+			dev_err(edp->dev, "failed to set training pattern 2!\n");
+			return retval;
+		}
+
+		retval = rk32_edp_write_bytes_to_dpcd(edp,
+				DPCD_ADDR_TRAINING_LANE0_SET,
+				lane_count,
+				edp->link_train.training_lane);
+		if (retval < 0) {
+			dev_err(edp->dev, "failed to set training lane!\n");
+			return retval;
+		}
+
+		dev_info(edp->dev, "Link Training Clock Recovery success\n");
+		edp->link_train.lt_state = LT_EQ_TRAINING;
+	} else {
+		for (lane = 0; lane < lane_count; lane++) {
+			training_lane = rk32_edp_get_lane_link_training(
+							edp, lane);
+			retval = rk32_edp_read_bytes_from_dpcd(edp,
+					DPCD_ADDR_ADJUST_REQUEST_LANE0_1,
+					2, adjust_request);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to read adjust request!\n");
+				return retval;
+			}
+
+			voltage_swing = rk32_edp_get_adjust_request_voltage(
+							adjust_request, lane);
+			pre_emphasis = rk32_edp_get_adjust_request_pre_emphasis(
+							adjust_request, lane);
+
+			if (voltage_swing == VOLTAGE_LEVEL_3 ||
+			    pre_emphasis == PRE_EMPHASIS_LEVEL_3) {
+				dev_err(edp->dev, "voltage or pre emphasis reached max level\n");
+				goto reduce_link_rate;
+			}
+
+			if ((DPCD_VOLTAGE_SWING_GET(training_lane) ==
+					voltage_swing) &&
+			   (DPCD_PRE_EMPHASIS_GET(training_lane) ==
+					pre_emphasis)) {
+				edp->link_train.cr_loop[lane]++;
+				if (edp->link_train.cr_loop[lane] == MAX_CR_LOOP) {
+					dev_err(edp->dev, "CR Max loop\n");
+					goto reduce_link_rate;
+				}
+			}
+
+			training_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |
+					DPCD_PRE_EMPHASIS_SET(pre_emphasis);
+
+			if (voltage_swing == VOLTAGE_LEVEL_3)
+				training_lane |= DPCD_MAX_SWING_REACHED;
+			if (pre_emphasis == PRE_EMPHASIS_LEVEL_3)
+				training_lane |= DPCD_MAX_PRE_EMPHASIS_REACHED;
+
+			edp->link_train.training_lane[lane] = training_lane;
+
+			rk32_edp_set_lane_link_training(edp,
+				edp->link_train.training_lane[lane], lane);
+		}
+
+		retval = rk32_edp_write_bytes_to_dpcd(edp,
+				DPCD_ADDR_TRAINING_LANE0_SET,
+				lane_count,
+				edp->link_train.training_lane);
+		if (retval < 0) {
+			dev_err(edp->dev, "failed to set training lane!\n");
+			return retval;
+		}
+	}
+
+	return 0;
+
+reduce_link_rate:
+	rk32_edp_reduce_link_rate(edp);
+	return -EIO;
+}
+
+static int rk32_edp_process_equalizer_training(struct rk32_edp *edp)
+{
+	u8 link_status[2];
+	u8 link_align[3];
+	int lane;
+	int lane_count;
+	u32 reg;
+
+	u8 adjust_request[2];
+	u8 voltage_swing;
+	u8 pre_emphasis;
+	u8 training_lane;
+	int retval;
+
+	udelay(400);
+
+	lane_count = edp->link_train.lane_count;
+
+	retval = rk32_edp_read_bytes_from_dpcd(edp,
+			DPCD_ADDR_LANE0_1_STATUS,
+			2, link_status);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to read lane status!\n");
+		return retval;
+	}
+
+	if (rk32_edp_clock_recovery_ok(link_status, lane_count) == 0) {
+		link_align[0] = link_status[0];
+		link_align[1] = link_status[1];
+
+		retval = rk32_edp_read_byte_from_dpcd(edp,
+				DPCD_ADDR_LANE_ALIGN_STATUS_UPDATED,
+				&link_align[2]);
+		if (retval < 0) {
+			dev_err(edp->dev, "failed to read lane aligne status!\n");
+			return retval;
+		}
+
+		for (lane = 0; lane < lane_count; lane++) {
+			retval = rk32_edp_read_bytes_from_dpcd(edp,
+					DPCD_ADDR_ADJUST_REQUEST_LANE0_1,
+					2, adjust_request);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to read adjust request!\n");
+				return retval;
+			}
+
+			voltage_swing = rk32_edp_get_adjust_request_voltage(
+							adjust_request, lane);
+			pre_emphasis = rk32_edp_get_adjust_request_pre_emphasis(
+							adjust_request, lane);
+			training_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |
+					DPCD_PRE_EMPHASIS_SET(pre_emphasis);
+
+			if (voltage_swing == VOLTAGE_LEVEL_3)
+				training_lane |= DPCD_MAX_SWING_REACHED;
+			if (pre_emphasis == PRE_EMPHASIS_LEVEL_3)
+				training_lane |= DPCD_MAX_PRE_EMPHASIS_REACHED;
+
+			edp->link_train.training_lane[lane] = training_lane;
+		}
+
+		if (rk32_edp_channel_eq_ok(link_align, lane_count) == 0) {
+			/* traing pattern Set to Normal */
+			retval = rk32_edp_training_pattern_dis(edp);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to disable training pattern!\n");
+				return retval;
+			}
+
+			dev_info(edp->dev, "Link Training success!\n");
+
+			rk32_edp_get_link_bandwidth(edp, &reg);
+			edp->link_train.link_rate = reg;
+			dev_dbg(edp->dev, "final bandwidth = %.2x\n",
+				edp->link_train.link_rate);
+
+			rk32_edp_get_lane_count(edp, &reg);
+			edp->link_train.lane_count = reg;
+			dev_dbg(edp->dev, "final lane count = %.2x\n",
+				edp->link_train.lane_count);
+
+			edp->link_train.lt_state = FINISHED;
+		} else {
+			/* not all locked */
+			edp->link_train.eq_loop++;
+
+			if (edp->link_train.eq_loop > MAX_EQ_LOOP) {
+				dev_err(edp->dev, "EQ Max loop\n");
+				goto reduce_link_rate;
+			}
+
+			for (lane = 0; lane < lane_count; lane++)
+				rk32_edp_set_lane_link_training(edp,
+					edp->link_train.training_lane[lane],
+					lane);
+
+			retval = rk32_edp_write_bytes_to_dpcd(edp,
+					DPCD_ADDR_TRAINING_LANE0_SET,
+					lane_count,
+					edp->link_train.training_lane);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to set training lane!\n");
+				return retval;
+			}
+		}
+	} else {
+		goto reduce_link_rate;
+	}
+
+	return 0;
+
+reduce_link_rate:
+	rk32_edp_reduce_link_rate(edp);
+	return -EIO;
+}
+
+static int rk32_edp_get_max_rx_bandwidth(struct rk32_edp *edp,
+					u8 *bandwidth)
+{
+	u8 data;
+	int retval;
+
+	/*
+	 * For DP rev.1.1, Maximum link rate of Main Link lanes
+	 * 0x06 = 1.62 Gbps, 0x0a = 2.7 Gbps
+	 */
+	retval = rk32_edp_read_byte_from_dpcd(edp,
+			DPCD_ADDR_MAX_LINK_RATE, &data);
+	if (retval < 0)
+		return retval;
+
+	*bandwidth = data;
+	return 0;
+}
+
+static int rk32_edp_get_max_rx_lane_count(struct rk32_edp *edp,
+					u8 *lane_count)
+{
+	u8 data;
+	int retval;
+
+	/*
+	 * For DP rev.1.1, Maximum number of Main Link lanes
+	 * 0x01 = 1 lane, 0x02 = 2 lanes, 0x04 = 4 lanes
+	 */
+	retval = rk32_edp_read_byte_from_dpcd(edp,
+			DPCD_ADDR_MAX_LANE_COUNT, &data);
+	if (retval < 0)
+		return retval;
+
+	*lane_count = DPCD_MAX_LANE_COUNT(data);
+	return 0;
+}
+
+static int rk32_edp_init_training(struct rk32_edp *edp,
+			enum link_lane_count_type max_lane,
+			u32 max_rate)
+{
+	int retval;
+
+	/*
+	 * MACRO_RST must be applied after the PLL_LOCK to avoid
+	 * the DP inter pair skew issue for at least 10 us
+	 */
+	rk32_edp_reset_macro(edp);
+
+	
+	retval = rk32_edp_get_max_rx_bandwidth(edp, &edp->link_train.link_rate);
+	if (retval < 0)
+		return retval;
+
+	retval = rk32_edp_get_max_rx_lane_count(edp, &edp->link_train.lane_count);
+	if (retval < 0)
+		return retval;
+
+	if ((edp->link_train.link_rate != LINK_RATE_1_62GBPS) &&
+	   (edp->link_train.link_rate != LINK_RATE_2_70GBPS)) {
+		dev_err(edp->dev, "Rx Max Link Rate is abnormal :%x !\n",
+			edp->link_train.link_rate);
+		edp->link_train.link_rate = LINK_RATE_1_62GBPS;
+	}
+
+	if (edp->link_train.lane_count == 0) {
+		dev_err(edp->dev, "Rx Max Lane count is abnormal :%x !\n",
+			edp->link_train.lane_count);
+		edp->link_train.lane_count = (u8)LANE_CNT1;
+	}
+
+	
+	if (edp->link_train.lane_count > max_lane)
+		edp->link_train.lane_count = max_lane;
+	if (edp->link_train.link_rate > max_rate)
+		edp->link_train.link_rate = max_rate;
+
+	
+	rk32_edp_analog_power_ctr(edp, 1);
+
+	return 0;
+}
+
+static int rk32_edp_sw_link_training(struct rk32_edp *edp)
+{
+	int retval = 0;
+	int training_finished = 0;
+
+	edp->link_train.lt_state = LT_START;
+
+	/* Process here */
+	while (!training_finished) {
+		switch (edp->link_train.lt_state) {
+		case LT_START:
+			retval = rk32_edp_link_start(edp);
+			if (retval)
+				dev_err(edp->dev, "LT Start failed\n");
+			break;
+		case LT_CLK_RECOVERY:
+			retval = rk32_edp_process_clock_recovery(edp);
+			if (retval)
+				dev_err(edp->dev, "LT CR failed\n");
+			break;
+		case LT_EQ_TRAINING:
+			retval = rk32_edp_process_equalizer_training(edp);
+			if (retval)
+				dev_err(edp->dev, "LT EQ failed\n");
+			break;
+		case FINISHED:
+			training_finished = 1;
+			break;
+		case FAILED:
+			return -EREMOTEIO;
+		}
+	}
+
+	return retval;
+}
+
+static int rk32_edp_set_link_train(struct rk32_edp *edp,
+				u32 count,
+				u32 bwtype)
+{
+	int retval;
+
+	retval = rk32_edp_init_training(edp, count, bwtype);
+	if (retval < 0)
+		dev_err(edp->dev, "DP LT init failed!\n");
+
+	retval = rk32_edp_sw_link_training(edp);
+	if (retval < 0)
+		dev_err(edp->dev, "DP LT failed!\n");
+
+	return retval;
+}
+
+static int rk32_edp_config_video(struct rk32_edp *edp,
+			struct video_info *video_info)
+{
+	int retval = 0;
+	int timeout_loop = 0;
+	int done_count = 0;
+
+	rk32_edp_config_video_slave_mode(edp, video_info);
+
+	rk32_edp_set_video_color_format(edp, video_info->color_depth,
+			video_info->color_space,
+			video_info->dynamic_range,
+			video_info->ycbcr_coeff);
+
+	if (rk32_edp_get_pll_lock_status(edp) == DP_PLL_UNLOCKED) {
+		dev_err(edp->dev, "PLL is not locked yet.\n");
+		return -EINVAL;
+	}
+
+	for (;;) {
+		timeout_loop++;
+		if (rk32_edp_is_slave_video_stream_clock_on(edp) == 0)
+			break;
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(edp->dev, "Timeout of video streamclk ok\n");
+			return -ETIMEDOUT;
+		}
+
+		usleep_range(1, 1);
+	}
+
+	/* Set to use the register calculated M/N video */
+	rk32_edp_set_video_cr_mn(edp, CALCULATED_M, 0, 0);
+
+	/* For video bist, Video timing must be generated by register */
+	rk32_edp_set_video_timing_mode(edp, VIDEO_TIMING_FROM_CAPTURE);
+
+	/* Disable video mute */
+	rk32_edp_enable_video_mute(edp, 0);
+
+	/* Configure video slave mode */
+	rk32_edp_enable_video_master(edp, 0);
+
+	/* Enable video */
+	rk32_edp_start_video(edp);
+
+	timeout_loop = 0;
+
+	for (;;) {
+		timeout_loop++;
+		if (rk32_edp_is_video_stream_on(edp) == 0) {
+			done_count++;
+			if (done_count > 10)
+				break;
+		} else if (done_count) {
+			done_count = 0;
+		}
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(edp->dev, "Timeout of video streamclk ok\n");
+			return -ETIMEDOUT;
+		}
+
+		usleep_range(1000, 1000);
+	}
+
+	if (retval != 0)
+		dev_err(edp->dev, "Video stream is not detected!\n");
+
+	return retval;
+}
+
+static int rk32_edp_enable_scramble(struct rk32_edp *edp, bool enable)
+{
+	u8 data;
+	int retval;
+
+	if (enable) {
+		rk32_edp_enable_scrambling(edp);
+
+		retval = rk32_edp_read_byte_from_dpcd(edp,
+				DPCD_ADDR_TRAINING_PATTERN_SET,
+				&data);
+		if (retval < 0)
+			return retval;
+
+		retval = rk32_edp_write_byte_to_dpcd(edp,
+				DPCD_ADDR_TRAINING_PATTERN_SET,
+				(u8)(data & ~DPCD_SCRAMBLING_DISABLED));
+		if (retval < 0)
+			return retval;
+	} else {
+		rk32_edp_disable_scrambling(edp);
+
+		retval = rk32_edp_read_byte_from_dpcd(edp,
+				DPCD_ADDR_TRAINING_PATTERN_SET,
+				&data);
+		if (retval < 0)
+			return retval;
+
+		retval = rk32_edp_write_byte_to_dpcd(edp,
+				DPCD_ADDR_TRAINING_PATTERN_SET,
+				(u8)(data | DPCD_SCRAMBLING_DISABLED));
+		if (retval < 0)
+			return retval;
+	}
+
+	return 0;
+}
+
+static irqreturn_t rk32_edp_irq_handler(int irq, void *arg)
+{
+	struct rk32_edp *edp = arg;
+
+	dev_err(edp->dev, "rk32_edp_irq_handler\n");
+	return IRQ_HANDLED;
+}
+
+static int rk32_edp_enable(struct rk32_edp *edp)
+{
+	int ret = 0;
+	int retry = 0;
+
+	if (edp->enabled)
+		goto out;
+
+	edp->enabled = 1;
+	clk_prepare_enable(edp->clk_edp);
+	clk_prepare_enable(edp->clk_24m);
+edp_phy_init:
+
+	
+	rk32_edp_init_edp(edp);
+
+	
+	ret = rk32_edp_handle_edid(edp);
+	if (ret) {
+		dev_err(edp->dev, "unable to handle edid\n");
+		goto out;
+	}
+
+	rk32_edp_disable_rx_zmux(edp);
+
+	
+	ret = rk32_edp_enable_scramble(edp, 0);
+	if (ret) {
+		dev_err(edp->dev, "unable to set scramble\n");
+		goto out;
+	}
+
+	ret = rk32_edp_enable_rx_to_enhanced_mode(edp, 0);
+	if (ret) {
+		dev_err(edp->dev, "unable to set enhanced mode\n");
+		goto out;
+	}
+	rk32_edp_enable_enhanced_mode(edp, 0);
+
+	
+	rk32_edp_rx_control(edp,0);
+
+       /* Link Training */
+	ret = rk32_edp_set_link_train(edp, LANE_CNT4, LINK_RATE_2_70GBPS);
+	if (ret) {
+		dev_err(edp->dev, "unable to do link train\n");
+		goto out;
+	}
+
+	/* Rx data enable */
+	rk32_edp_rx_control(edp,1);
+
+	rk32_edp_set_lane_count(edp, edp->video_info.lane_count);
+	rk32_edp_set_link_bandwidth(edp, edp->video_info.link_rate);
+
+	rk32_edp_init_video(edp);
+	ret = rk32_edp_config_video(edp, &edp->video_info);
+	if (ret) {
+		dev_err(edp->dev, "unable to config video\n");
+		goto out;
+	}
+
+	return 0;
+
+out:
+
+	if (retry < 3) {
+		retry++;
+		goto edp_phy_init;
+	}
+	
+	dev_err(edp->dev, "DP LT exceeds max retry count");
+
+	return ret;
+}
+	
+static void rk32_edp_disable(struct rk32_edp *edp)
+{
+	if (!edp->enabled)
+		return ;
+
+	edp->enabled = 0;
+
+	rk32_edp_reset(edp);
+	rk32_edp_analog_power_ctr(edp, 0);
+
+	clk_disable(edp->clk_24m);
+	clk_disable(edp->clk_edp);
+}
+
+
+
+static void rk32_edp_init(struct rk32_edp *edp)
+{
+
+	rk32_edp_enable(edp);
+}
+static int rk32_edp_probe(struct platform_device *pdev)
+{
+	struct rk32_edp *edp;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	u32 version;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing device tree node.\n");
+		return -EINVAL;
+	}
+
+	edp = devm_kzalloc(&pdev->dev, sizeof(struct rk32_edp), GFP_KERNEL);
+	if (!edp) {
+		dev_err(&pdev->dev, "no memory for state\n");
+		return -ENOMEM;
+	}
+	edp->dev = &pdev->dev;
+	edp->video_info.h_sync_polarity	= 0;
+	edp->video_info.v_sync_polarity	= 0;
+	edp->video_info.interlaced	= 0;
+	edp->video_info.color_space	= CS_RGB;
+	edp->video_info.dynamic_range	= VESA;
+	edp->video_info.ycbcr_coeff	= COLOR_YCBCR601;
+	edp->video_info.color_depth	= COLOR_8;
+
+	edp->video_info.link_rate	= LINK_RATE_2_70GBPS;
+	edp->video_info.lane_count	= LANE_CNT4;
+	
+	platform_set_drvdata(pdev, edp);
+	dev_set_name(edp->dev, "rk32-edp");
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	edp->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(edp->regs)) {
+		dev_err(&pdev->dev, "ioremap reg failed\n");
+		return PTR_ERR(edp->regs);
+	}
+	version = readl_relaxed(edp->regs + DP_VERSION);
+	dev_info(&pdev->dev, "edp version:0x%08x\n", version);
+	rk32_edp_init(edp);
+	dev_info(&pdev->dev, "rk32 edp driver probe success\n");
+
+	return 0;
+}
+
+static void rk32_edp_shutdown(struct platform_device *pdev)
+{
+
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk32_edp_dt_ids[] = {
+	{.compatible = "rockchip, rk32-edp",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, rk32_edp_dt_ids);
+#endif
+
+static struct platform_driver rk32_edp_driver = {
+	.probe = rk32_edp_probe,
+	.driver = {
+		   .name = "rk32-edp",
+		   .owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+		   .of_match_table = of_match_ptr(rk32_edp_dt_ids),
+#endif
+	},
+	.shutdown = rk32_edp_shutdown,
+};
+
+static int __init rk32_edp_module_init(void)
+{
+	return platform_driver_register(&rk32_edp_driver);
+}
+
+static void __exit rk32_edp_module_exit(void)
+{
+
+}
+
+fs_initcall(rk32_edp_module_init);
+module_exit(rk32_edp_module_exit);
diff --git a/drivers/video/rockchip/transmitter/rk32_dp.h b/drivers/video/rockchip/transmitter/rk32_dp.h
new file mode 100644
index 000000000000..3f426e91acf0
--- /dev/null
+++ b/drivers/video/rockchip/transmitter/rk32_dp.h
@@ -0,0 +1,649 @@
+#ifndef __RK32_DP_H
+#define __RK32_DP_H
+
+#define DP_VERSION				0x10
+
+#define TX_SW_RST				0x14
+
+#define FUNC_EN_1				0x18
+#define VID_CAP_FUNC_EN_N			(0x1 << 6)
+#define VID_FIFO_FUNC_EN_N			(0x1 << 5)
+#define AUD_FIFO_FUNC_EN_N			(0x1 << 4)
+#define AUD_FUNC_EN_N				(0x1 << 3)
+#define HDCP_FUNC_EN_N				(0x1 << 2)
+#define SW_FUNC_EN_N				(0x1 << 0)
+
+#define FUNC_EN_2				0x1C
+#define SSC_FUNC_EN_N				(0x1 << 7)
+#define AUX_FUNC_EN_N				(0x1 << 2)
+#define SERDES_FIFO_FUNC_EN_N			(0x1 << 1)
+#define LS_CLK_DOMAIN_FUNC_EN_N			(0x1 << 0)
+
+#define VIDEO_CTL_1				0x20
+#define VIDEO_EN				(0x1 << 7)
+#define VIDEO_MUTE				(0x1 << 6)
+
+#define VIDEO_CTL_2				0x24
+#define IN_D_RANGE_MASK				(0x1 << 7)
+#define IN_D_RANGE_SHIFT			(7)
+#define IN_D_RANGE_CEA				(0x1 << 7)
+#define IN_D_RANGE_VESA				(0x0 << 7)
+#define IN_BPC_MASK				(0x7 << 4)
+#define IN_BPC_SHIFT				(4)
+#define IN_BPC_12_BITS				(0x3 << 4)
+#define IN_BPC_10_BITS				(0x2 << 4)
+#define IN_BPC_8_BITS				(0x1 << 4)
+#define IN_BPC_6_BITS				(0x0 << 4)
+#define IN_COLOR_F_MASK				(0x3 << 0)
+#define IN_COLOR_F_SHIFT			(0)
+#define IN_COLOR_F_YCBCR444			(0x2 << 0)
+#define IN_COLOR_F_YCBCR422			(0x1 << 0)
+#define IN_COLOR_F_RGB				(0x0 << 0)
+
+#define VIDEO_CTL_3				0x28
+#define IN_YC_COEFFI_MASK			(0x1 << 7)
+#define IN_YC_COEFFI_SHIFT			(7)
+#define IN_YC_COEFFI_ITU709			(0x1 << 7)
+#define IN_YC_COEFFI_ITU601			(0x0 << 7)
+#define VID_CHK_UPDATE_TYPE_MASK		(0x1 << 4)
+#define VID_CHK_UPDATE_TYPE_SHIFT		(4)
+#define VID_CHK_UPDATE_TYPE_1			(0x1 << 4)
+#define VID_CHK_UPDATE_TYPE_0			(0x0 << 4)
+
+#define VIDEO_CTL_4				0x2c
+#define BIST_EN					(0x1 << 3)
+#define BIST_WH_64				(0x1 << 2)
+#define BIST_WH_32				(0x0 << 2)
+#define BIST_TYPE_COLR_BAR			(0x0 << 0)
+#define BIST_TYPE_GRAY_BAR			(0x1 << 0)
+#define BIST_TYPE_MOBILE_BAR			(0x2 << 0)
+
+#define VIDEO_CTL_8				0x3C
+#define VID_HRES_TH(x)				(((x) & 0xf) << 4)
+#define VID_VRES_TH(x)				(((x) & 0xf) << 0)
+
+#define VIDEO_CTL_10				0x44
+#define F_SEL					(0x1 << 4)
+#define INTERACE_SCAN_CFG			(0x1 << 2)
+#define VSYNC_POLARITY_CFG			(0x1 << 1)
+#define HSYNC_POLARITY_CFG			(0x1 << 0)
+
+#define PLL_REG_1				0xfc
+#define REF_CLK_24M				(0x01 << 1)
+#define REF_CLK_27M				(0x0 << 1)
+
+#define DP_PWRDN				0x12c
+#define PD_INC_BG				(0x1 << 7)
+#define PD_EXP_BG				(0x1 << 6)
+#define PD_AUX					(0x1 << 5)
+#define PD_PLL					(0x1 << 4)
+#define PD_CH3					(0x1 << 3)
+#define PD_CH2					(0x1 << 2)
+#define PD_CH1					(0x1 << 1)
+#define PD_CH0					(0x1 << 0)
+
+#define LANE_MAP				0x35C
+#define LANE3_MAP_LOGIC_LANE_0			(0x0 << 6)
+#define LANE3_MAP_LOGIC_LANE_1			(0x1 << 6)
+#define LANE3_MAP_LOGIC_LANE_2			(0x2 << 6)
+#define LANE3_MAP_LOGIC_LANE_3			(0x3 << 6)
+#define LANE2_MAP_LOGIC_LANE_0			(0x0 << 4)
+#define LANE2_MAP_LOGIC_LANE_1			(0x1 << 4)
+#define LANE2_MAP_LOGIC_LANE_2			(0x2 << 4)
+#define LANE2_MAP_LOGIC_LANE_3			(0x3 << 4)
+#define LANE1_MAP_LOGIC_LANE_0			(0x0 << 2)
+#define LANE1_MAP_LOGIC_LANE_1			(0x1 << 2)
+#define LANE1_MAP_LOGIC_LANE_2			(0x2 << 2)
+#define LANE1_MAP_LOGIC_LANE_3			(0x3 << 2)
+#define LANE0_MAP_LOGIC_LANE_0			(0x0 << 0)
+#define LANE0_MAP_LOGIC_LANE_1			(0x1 << 0)
+#define LANE0_MAP_LOGIC_LANE_2			(0x2 << 0)
+#define LANE0_MAP_LOGIC_LANE_3			(0x3 << 0)
+
+#define ANALOG_CTL_2				0x374
+#define SEL_24M					(0x1 << 3)
+
+/*#define ANALOG_CTL_3				0x378
+#define PLL_FILTER_CTL_1			0x37C
+#define TX_AMP_TUNING_CTL			0x380*/
+
+#define AUX_HW_RETRY_CTL			0x390
+
+#define INT_STA					0x3c0
+
+#define COMMON_INT_STA_1			0x3C4
+#define VSYNC_DET				(0x1 << 7)
+#define PLL_LOCK_CHG				(0x1 << 6)
+#define SPDIF_ERR				(0x1 << 5)
+#define SPDIF_UNSTBL				(0x1 << 4)
+#define VID_FORMAT_CHG				(0x1 << 3)
+#define AUD_CLK_CHG				(0x1 << 2)
+#define VID_CLK_CHG				(0x1 << 1)
+#define SW_INT					(0x1 << 0)
+
+#define COMMON_INT_STA_2			0x3C8
+#define ENC_EN_CHG				(0x1 << 6)
+#define HW_BKSV_RDY				(0x1 << 3)
+#define HW_SHA_DONE				(0x1 << 2)
+#define HW_AUTH_STATE_CHG			(0x1 << 1)
+#define HW_AUTH_DONE				(0x1 << 0)
+
+#define COMMON_INT_STA_3			0x3CC
+#define AFIFO_UNDER				(0x1 << 7)
+#define AFIFO_OVER				(0x1 << 6)
+#define R0_CHK_FLAG				(0x1 << 5)
+
+#define COMMON_INT_STA_4			0x3D0
+#define PSR_ACTIVE				(0x1 << 7)
+#define PSR_INACTIVE				(0x1 << 6)
+#define SPDIF_BI_PHASE_ERR			(0x1 << 5)
+#define HOTPLUG_CHG				(0x1 << 2)
+#define HPD_LOST				(0x1 << 1)
+#define PLUG					(0x1 << 0)
+
+#define DP_INT_STA				0x3DC
+#define INT_HPD					(0x1 << 6)
+#define HW_LT_DONE				(0x1 << 5)
+#define SINK_LOST				(0x1 << 3)
+#define LINK_LOST				(0x1 << 2)
+#define RPLY_RECEIV				(0x1 << 1)
+#define AUX_ERR					(0x1 << 0)
+
+#define COMMON_INT_MASK_1			0x3E0
+#define COMMON_INT_MASK_2			0x3E4
+#define COMMON_INT_MASK_3			0x3E8
+#define COMMON_INT_MASK_4			0x3EC
+#define DP_INT_STA_MASK				0x3F8
+
+#define INT_CTL					0x3FC
+#define SOFT_INT_CTRL				(0x1 << 2)
+#define INT_POL					(0x1 << 0)
+
+#define SYS_CTL_1				0x600
+#define DET_STA					(0x1 << 2)
+#define FORCE_DET				(0x1 << 1)
+#define DET_CTRL				(0x1 << 0)
+
+#define SYS_CTL_2				0x604
+#define CHA_CRI(x)				(((x) & 0xf) << 4)
+#define CHA_STA					(0x1 << 2)
+#define FORCE_CHA				(0x1 << 1)
+#define CHA_CTRL				(0x1 << 0)
+
+#define SYS_CTL_3				0x608
+#define HPD_STATUS				(0x1 << 6)
+#define F_HPD					(0x1 << 5)
+#define HPD_CTRL				(0x1 << 4)
+#define HDCP_RDY				(0x1 << 3)
+#define STRM_VALID				(0x1 << 2)
+#define F_VALID					(0x1 << 1)
+#define VALID_CTRL				(0x1 << 0)
+
+#define SYS_CTL_4				0x60C
+#define FIX_M_AUD				(0x1 << 4)
+#define ENHANCED				(0x1 << 3)
+#define FIX_M_VID				(0x1 << 2)
+#define M_VID_UPDATE_CTRL			(0x3 << 0)
+
+
+#define PKT_SEND_CTL				0x640
+#define HDCP_CTL				0x648
+
+#define LINK_BW_SET				0x680
+#define LANE_CNT_SET				0x684
+
+#define TRAINING_PTN_SET			0x688
+#define SCRAMBLING_DISABLE			(0x1 << 5)
+#define SCRAMBLING_ENABLE			(0x0 << 5)
+#define LINK_QUAL_PATTERN_SET_MASK		(0x7 << 2)
+#define LINK_QUAL_PATTERN_SET_HBR2		(0x5 << 2)
+#define LINK_QUAL_PATTERN_SET_80BIT		(0x4 << 2)
+#define LINK_QUAL_PATTERN_SET_PRBS7		(0x3 << 2)
+#define LINK_QUAL_PATTERN_SET_D10_2		(0x1 << 2)
+#define LINK_QUAL_PATTERN_SET_DISABLE		(0x0 << 2)
+#define SW_TRAINING_PATTERN_SET_MASK		(0x3 << 0)
+#define SW_TRAINING_PATTERN_SET_PTN2		(0x2 << 0)
+#define SW_TRAINING_PATTERN_SET_PTN1		(0x1 << 0)
+#define SW_TRAINING_PATTERN_SET_DISABLE		(0x0 << 0)
+
+#define LN0_LINK_TRAINING_CTL			0x68C
+#define LN1_LINK_TRAINING_CTL			0x690
+#define LN2_LINK_TRAINING_CTL			0x694
+#define LN3_LINK_TRAINING_CTL			0x698
+
+#define HW_LT_CTL				0x6a0
+#define HW_LT_EN				(0x1 << 0)
+
+#define DEBUG_CTL				0x6C0
+#define PLL_LOCK				(0x1 << 4)
+#define F_PLL_LOCK				(0x1 << 3)
+#define PLL_LOCK_CTRL				(0x1 << 2)
+#define POLL_EN					(0x1 << 1)
+#define PN_INV					(0x1 << 0)
+
+#define HPD_DEGLITCH_L				0x6C4
+#define HPD_DEGLITCH_H				0x6C8
+#define LINK_DEBUG_CTL				0x6E0
+
+#define M_VID_0					0x700
+#define M_VID_1					0x704
+#define M_VID_2					0x708
+#define N_VID_0					0x70C
+#define N_VID_1					0x710
+#define N_VID_2					0x714
+
+#define VIDEO_FIFO_THRD				0x730
+#define AUDIO_MARGIN				0x73C
+
+#define M_VID_GEN_FILTER_TH			0x764
+#define M_AUD_GEN_FILTER_TH			0x778
+
+#define AUX_CH_STA				0x780
+#define AUX_BUSY				(0x1 << 4)
+#define AUX_STATUS_MASK				(0xf << 0)
+
+#define AUX_CH_DEFER_CTL			0x788
+#define DEFER_CTRL_EN				(0x1 << 7)
+#define DEFER_COUNT(x)				(((x) & 0x7f) << 0)
+
+#define AUX_RX_COMM				0x78C
+#define AUX_RX_COMM_I2C_DEFER			(0x2 << 2)
+#define AUX_RX_COMM_AUX_DEFER			(0x2 << 0)
+
+#define BUFFER_DATA_CTL				0x790
+#define BUF_CLR					(0x1 << 7)
+#define BUF_HAVE_DATA				(0x1 << 4)
+#define BUF_DATA_COUNT(x)			(((x) & 0xf) << 0)
+
+#define AUX_CH_CTL_1				0x794
+#define AUX_LENGTH(x)				(((x - 1) & 0xf) << 4)
+#define AUX_TX_COMM_MASK			(0xf << 0)
+#define AUX_TX_COMM_DP_TRANSACTION		(0x1 << 3)
+#define AUX_TX_COMM_I2C_TRANSACTION		(0x0 << 3)
+#define AUX_TX_COMM_MOT				(0x1 << 2)
+#define AUX_TX_COMM_WRITE			(0x0 << 0)
+#define AUX_TX_COMM_READ			(0x1 << 0)
+
+#define DP_AUX_ADDR_7_0				0x798
+#define DP_AUX_ADDR_15_8			0x79C
+#define DP_AUX_ADDR_19_16			0x7A0
+
+#define AUX_CH_CTL_2				0x7A4
+#define PD_AUX_IDLE				(0x1 << 3)
+#define ADDR_ONLY				(0x1 << 1)
+#define AUX_EN					(0x1 << 0)
+
+#define BUF_DATA_0				0x7C0
+
+#define SOC_GENERAL_CTL				0x800
+
+/* TX_SW_RESET */
+#define RST_DP_TX				(0x1 << 0)
+
+/* ANALOG_CTL_1 */
+#define TX_TERMINAL_CTRL_50_OHM			(0x1 << 4)
+
+
+
+/* ANALOG_CTL_3 */
+#define DRIVE_DVDD_BIT_1_0625V			(0x4 << 5)
+#define VCO_BIT_600_MICRO			(0x5 << 0)
+
+/* PLL_FILTER_CTL_1 */
+#define PD_RING_OSC				(0x1 << 6)
+#define AUX_TERMINAL_CTRL_37_5_OHM		(0x0 << 4)
+#define AUX_TERMINAL_CTRL_45_OHM		(0x1 << 4)
+#define AUX_TERMINAL_CTRL_50_OHM		(0x2 << 4)
+#define AUX_TERMINAL_CTRL_65_OHM		(0x3 << 4)
+#define TX_CUR1_2X				(0x1 << 2)
+#define TX_CUR_16_MA				(0x3 << 0)
+
+/* TX_AMP_TUNING_CTL */
+#define CH3_AMP_SHIFT				(24)
+#define CH3_AMP_400_MV				(0x0 << 24)
+#define CH2_AMP_SHIFT				(16)
+#define CH2_AMP_400_MV				(0x0 << 16)
+#define CH1_AMP_SHIFT				(8)
+#define CH1_AMP_400_MV				(0x0 << 8)
+#define CH0_AMP_SHIFT				(0)
+#define CH0_AMP_400_MV				(0x0 << 0)
+
+/* AUX_HW_RETRY_CTL */
+#define AUX_BIT_PERIOD_EXPECTED_DELAY(x)	(((x) & 0x7) << 8)
+#define AUX_HW_RETRY_INTERVAL_MASK		(0x3 << 3)
+#define AUX_HW_RETRY_INTERVAL_600_MICROSECONDS	(0x0 << 3)
+#define AUX_HW_RETRY_INTERVAL_800_MICROSECONDS	(0x1 << 3)
+#define AUX_HW_RETRY_INTERVAL_1000_MICROSECONDS	(0x2 << 3)
+#define AUX_HW_RETRY_INTERVAL_1800_MICROSECONDS	(0x3 << 3)
+#define AUX_HW_RETRY_COUNT_SEL(x)		(((x) & 0x7) << 0)
+
+
+
+/* LN0_LINK_TRAINING_CTL */
+#define PRE_EMPHASIS_SET_MASK			(0x3 << 3)
+#define PRE_EMPHASIS_SET_SHIFT			(3)
+
+
+/* PLL_CTL */
+#define DP_PLL_PD				(0x1 << 7)
+#define DP_PLL_RESET				(0x1 << 6)
+#define DP_PLL_LOOP_BIT_DEFAULT			(0x1 << 4)
+#define DP_PLL_REF_BIT_1_1250V			(0x5 << 0)
+#define DP_PLL_REF_BIT_1_2500V			(0x7 << 0)
+
+/* PHY_TEST */
+#define MACRO_RST				(0x1 << 5)
+#define CH1_TEST				(0x1 << 1)
+#define CH0_TEST				(0x1 << 0)
+
+
+
+/* AUX_ADDR_7_0 */
+#define AUX_ADDR_7_0(x)				(((x) >> 0) & 0xff)
+
+/* AUX_ADDR_15_8 */
+#define AUX_ADDR_15_8(x)			(((x) >> 8) & 0xff)
+
+/* AUX_ADDR_19_16 */
+#define AUX_ADDR_19_16(x)			(((x) >> 16) & 0x0f)
+
+
+/* I2C EDID Chip ID, Slave Address */
+#define I2C_EDID_DEVICE_ADDR			0x50
+#define I2C_E_EDID_DEVICE_ADDR			0x30
+
+#define EDID_BLOCK_LENGTH			0x80
+#define EDID_HEADER_PATTERN			0x00
+#define EDID_EXTENSION_FLAG			0x7e
+#define EDID_CHECKSUM				0x7f
+
+
+/* Definition for DPCD Register */
+#define DPCD_ADDR_DPCD_REV			0x0000
+#define DPCD_ADDR_MAX_LINK_RATE			0x0001
+#define DPCD_ADDR_MAX_LANE_COUNT		0x0002
+#define DPCD_ADDR_LINK_BW_SET			0x0100
+#define DPCD_ADDR_LANE_COUNT_SET		0x0101
+#define DPCD_ADDR_TRAINING_PATTERN_SET		0x0102
+#define DPCD_ADDR_TRAINING_LANE0_SET		0x0103
+#define DPCD_ADDR_LANE0_1_STATUS		0x0202
+#define DPCD_ADDR_LANE_ALIGN_STATUS_UPDATED	0x0204
+#define DPCD_ADDR_ADJUST_REQUEST_LANE0_1	0x0206
+#define DPCD_ADDR_ADJUST_REQUEST_LANE2_3	0x0207
+#define DPCD_ADDR_TEST_REQUEST			0x0218
+#define DPCD_ADDR_TEST_RESPONSE			0x0260
+#define DPCD_ADDR_TEST_EDID_CHECKSUM		0x0261
+#define DPCD_ADDR_SINK_POWER_STATE		0x0600
+
+/* DPCD_ADDR_MAX_LANE_COUNT */
+#define DPCD_ENHANCED_FRAME_CAP(x)		(((x) >> 7) & 0x1)
+#define DPCD_MAX_LANE_COUNT(x)			((x) & 0x1f)
+
+/* DPCD_ADDR_LANE_COUNT_SET */
+#define DPCD_ENHANCED_FRAME_EN			(0x1 << 7)
+#define DPCD_LANE_COUNT_SET(x)			((x) & 0x1f)
+
+/* DPCD_ADDR_TRAINING_PATTERN_SET */
+#define DPCD_SCRAMBLING_DISABLED		(0x1 << 5)
+#define DPCD_SCRAMBLING_ENABLED			(0x0 << 5)
+#define DPCD_TRAINING_PATTERN_2			(0x2 << 0)
+#define DPCD_TRAINING_PATTERN_1			(0x1 << 0)
+#define DPCD_TRAINING_PATTERN_DISABLED		(0x0 << 0)
+
+/* DPCD_ADDR_TRAINING_LANE0_SET */
+#define DPCD_MAX_PRE_EMPHASIS_REACHED		(0x1 << 5)
+#define DPCD_PRE_EMPHASIS_SET(x)		(((x) & 0x3) << 3)
+#define DPCD_PRE_EMPHASIS_GET(x)		(((x) >> 3) & 0x3)
+#define DPCD_PRE_EMPHASIS_PATTERN2_LEVEL0	(0x0 << 3)
+#define DPCD_MAX_SWING_REACHED			(0x1 << 2)
+#define DPCD_VOLTAGE_SWING_SET(x)		(((x) & 0x3) << 0)
+#define DPCD_VOLTAGE_SWING_GET(x)		(((x) >> 0) & 0x3)
+#define DPCD_VOLTAGE_SWING_PATTERN1_LEVEL0	(0x0 << 0)
+
+/* DPCD_ADDR_LANE0_1_STATUS */
+#define DPCD_LANE_SYMBOL_LOCKED			(0x1 << 2)
+#define DPCD_LANE_CHANNEL_EQ_DONE		(0x1 << 1)
+#define DPCD_LANE_CR_DONE			(0x1 << 0)
+#define DPCD_CHANNEL_EQ_BITS			(DPCD_LANE_CR_DONE|	\
+						 DPCD_LANE_CHANNEL_EQ_DONE|\
+						 DPCD_LANE_SYMBOL_LOCKED)
+
+/* DPCD_ADDR_LANE_ALIGN__STATUS_UPDATED */
+#define DPCD_LINK_STATUS_UPDATED		(0x1 << 7)
+#define DPCD_DOWNSTREAM_PORT_STATUS_CHANGED	(0x1 << 6)
+#define DPCD_INTERLANE_ALIGN_DONE		(0x1 << 0)
+
+/* DPCD_ADDR_TEST_REQUEST */
+#define DPCD_TEST_EDID_READ			(0x1 << 2)
+
+/* DPCD_ADDR_TEST_RESPONSE */
+#define DPCD_TEST_EDID_CHECKSUM_WRITE		(0x1 << 2)
+
+/* DPCD_ADDR_SINK_POWER_STATE */
+#define DPCD_SET_POWER_STATE_D0			(0x1 << 0)
+#define DPCD_SET_POWER_STATE_D4			(0x2 << 0)
+
+#define DP_TIMEOUT_LOOP_CNT 100
+#define MAX_CR_LOOP 5
+#define MAX_EQ_LOOP 5
+
+#define REF_CLK_FROM_INTER			(1 << 4)
+enum color_coefficient {
+	COLOR_YCBCR601,
+	COLOR_YCBCR709
+};
+
+enum dynamic_range {
+	VESA,
+	CEA
+};
+
+enum pll_status {
+	DP_PLL_UNLOCKED,
+	DP_PLL_LOCKED
+};
+
+enum clock_recovery_m_value_type {
+	CALCULATED_M,
+	REGISTER_M
+};
+
+enum video_timing_recognition_type {
+	VIDEO_TIMING_FROM_CAPTURE,
+	VIDEO_TIMING_FROM_REGISTER
+};
+
+enum pattern_set {
+	PRBS7,
+	D10_2,
+	TRAINING_PTN1,
+	TRAINING_PTN2,
+	DP_NONE
+};
+
+enum color_space {
+	CS_RGB,
+	CS_YCBCR422,
+	CS_YCBCR444
+};
+
+enum color_depth {
+	COLOR_6,
+	COLOR_8,
+	COLOR_10,
+	COLOR_12
+};
+
+enum link_rate_type {
+	LINK_RATE_1_62GBPS = 0x06,
+	LINK_RATE_2_70GBPS = 0x0a
+};
+
+enum link_lane_count_type {
+	LANE_CNT1 = 1,
+	LANE_CNT2 = 2,
+	LANE_CNT4 = 4
+};
+
+enum link_training_state {
+	LT_START,
+	LT_CLK_RECOVERY,
+	LT_EQ_TRAINING,
+	FINISHED,
+	FAILED
+};
+
+enum voltage_swing_level {
+	VOLTAGE_LEVEL_0,
+	VOLTAGE_LEVEL_1,
+	VOLTAGE_LEVEL_2,
+	VOLTAGE_LEVEL_3,
+};
+
+enum pre_emphasis_level {
+	PRE_EMPHASIS_LEVEL_0,
+	PRE_EMPHASIS_LEVEL_1,
+	PRE_EMPHASIS_LEVEL_2,
+	PRE_EMPHASIS_LEVEL_3,
+};
+
+enum analog_power_block {
+	AUX_BLOCK,
+	CH0_BLOCK,
+	CH1_BLOCK,
+	CH2_BLOCK,
+	CH3_BLOCK,
+	ANALOG_TOTAL,
+	POWER_ALL
+};
+
+struct video_info {
+	char *name;
+
+	bool h_sync_polarity;
+	bool v_sync_polarity;
+	bool interlaced;
+
+	enum color_space color_space;
+	enum dynamic_range dynamic_range;
+	enum color_coefficient ycbcr_coeff;
+	enum color_depth color_depth;
+
+	enum link_rate_type link_rate;
+	enum link_lane_count_type lane_count;
+};
+
+struct link_train {
+	int eq_loop;
+	int cr_loop[4];
+
+	u8 link_rate;
+	u8 lane_count;
+	u8 training_lane[4];
+
+	enum link_training_state lt_state;
+};
+
+
+
+struct rk32_edp {
+	struct device 		*dev;
+	void __iomem  		*regs;
+	struct clk    		*clk_edp;
+	struct clk    		*clk_24m;
+	struct link_train	link_train;
+	struct video_info	video_info;
+	int 			enabled;
+};
+
+
+void rk32_edp_enable_video_mute(struct rk32_edp *edp, bool enable);
+void rk32_edp_stop_video(struct rk32_edp *edp);
+void rk32_edp_lane_swap(struct rk32_edp *edp, bool enable);
+void rk32_edp_init_analog_param(struct rk32_edp *edp);
+void rk32_edp_init_interrupt(struct rk32_edp *edp);
+void rk32_edp_reset(struct rk32_edp *edp);
+void rk32_edp_config_interrupt(struct rk32_edp *edp);
+u32 rk32_edp_get_pll_lock_status(struct rk32_edp *edp);
+void rk32_edp_analog_power_ctr(struct rk32_edp *edp, bool enable);
+void rk32_edp_init_analog_func(struct rk32_edp *edp);
+void rk32_edp_init_hpd(struct rk32_edp *edp);
+void rk32_edp_reset_aux(struct rk32_edp *edp);
+void rk32_edp_init_aux(struct rk32_edp *edp);
+int rk32_edp_get_plug_in_status(struct rk32_edp *edp);
+void rk32_edp_enable_sw_function(struct rk32_edp *edp);
+int rk32_edp_start_aux_transaction(struct rk32_edp *edp);
+int rk32_edp_write_byte_to_dpcd(struct rk32_edp *edp,
+				unsigned int reg_addr,
+				unsigned char data);
+int rk32_edp_read_byte_from_dpcd(struct rk32_edp *edp,
+				unsigned int reg_addr,
+				unsigned char *data);
+int rk32_edp_write_bytes_to_dpcd(struct rk32_edp *edp,
+				unsigned int reg_addr,
+				unsigned int count,
+				unsigned char data[]);
+int rk32_edp_read_bytes_from_dpcd(struct rk32_edp *edp,
+				unsigned int reg_addr,
+				unsigned int count,
+				unsigned char data[]);
+int rk32_edp_select_i2c_device(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int reg_addr);
+int rk32_edp_read_byte_from_i2c(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int reg_addr,
+				unsigned int *data);
+int rk32_edp_read_bytes_from_i2c(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int reg_addr,
+				unsigned int count,
+				unsigned char edid[]);
+void rk32_edp_set_link_bandwidth(struct rk32_edp *edp, u32 bwtype);
+void rk32_edp_get_link_bandwidth(struct rk32_edp *edp, u32 *bwtype);
+void rk32_edp_set_lane_count(struct rk32_edp *edp, u32 count);
+void rk32_edp_get_lane_count(struct rk32_edp *edp, u32 *count);
+void rk32_edp_enable_enhanced_mode(struct rk32_edp *edp, bool enable);
+void rk32_edp_set_training_pattern(struct rk32_edp *edp,
+				 enum pattern_set pattern);
+void rk32_edp_set_lane0_pre_emphasis(struct rk32_edp *edp, u32 level);
+void rk32_edp_set_lane1_pre_emphasis(struct rk32_edp *edp, u32 level);
+void rk32_edp_set_lane2_pre_emphasis(struct rk32_edp *edp, u32 level);
+void rk32_edp_set_lane3_pre_emphasis(struct rk32_edp *edp, u32 level);
+void rk32_edp_set_lane0_link_training(struct rk32_edp *edp,
+				u32 training_lane);
+void rk32_edp_set_lane1_link_training(struct rk32_edp *edp,
+				u32 training_lane);
+void rk32_edp_set_lane2_link_training(struct rk32_edp *edp,
+				u32 training_lane);
+void rk32_edp_set_lane3_link_training(struct rk32_edp *edp,
+				u32 training_lane);
+u32 rk32_edp_get_lane0_link_training(struct rk32_edp *edp);
+u32 rk32_edp_get_lane1_link_training(struct rk32_edp *edp);
+u32 rk32_edp_get_lane2_link_training(struct rk32_edp *edp);
+u32 rk32_edp_get_lane3_link_training(struct rk32_edp *edp);
+void rk32_edp_reset_macro(struct rk32_edp *edp);
+int rk32_edp_init_video(struct rk32_edp *edp);
+
+void rk32_edp_set_video_color_format(struct rk32_edp *edp,
+				u32 color_depth,
+				u32 color_space,
+				u32 dynamic_range,
+				u32 coeff);
+int rk32_edp_is_slave_video_stream_clock_on(struct rk32_edp *edp);
+void rk32_edp_set_video_cr_mn(struct rk32_edp *edp,
+			enum clock_recovery_m_value_type type,
+			u32 m_value,
+			u32 n_value);
+void rk32_edp_set_video_timing_mode(struct rk32_edp *edp, u32 type);
+void rk32_edp_enable_video_master(struct rk32_edp *edp, bool enable);
+void rk32_edp_start_video(struct rk32_edp *edp);
+int rk32_edp_is_video_stream_on(struct rk32_edp *edp);
+void rk32_edp_config_video_slave_mode(struct rk32_edp *edp,
+			struct video_info *video_info);
+void rk32_edp_enable_scrambling(struct rk32_edp *edp);
+void rk32_edp_disable_scrambling(struct rk32_edp *edp);
+void rk32_edp_rx_control(struct rk32_edp *edp, bool enable);
+
+
+#endif
diff --git a/drivers/video/rockchip/transmitter/rk32_dp_reg.c b/drivers/video/rockchip/transmitter/rk32_dp_reg.c
new file mode 100644
index 000000000000..30e620946d68
--- /dev/null
+++ b/drivers/video/rockchip/transmitter/rk32_dp_reg.c
@@ -0,0 +1,1156 @@
+/*
+ * Samsung DP (Display port) register interface driver.
+ *
+ * Copyright (C) 2012 Samsung Electronics Co., Ltd.
+ * Author: Jingoo Han <jg1.han@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include "../../../arch/arm/mach-rockchip/cpu.h"
+#include "../../../arch/arm/mach-rockchip/iomap.h"
+#include "../../../arch/arm/mach-rockchip/grf.h"
+
+#include "rk32_dp.h"
+
+
+void rk32_edp_enable_video_mute(struct rk32_edp *edp, bool enable)
+{
+	u32 val;
+
+	if (enable) {
+		val = readl(edp->regs + VIDEO_CTL_1);
+		val |= VIDEO_MUTE;
+		writel(val, edp->regs + VIDEO_CTL_1);
+	} else {
+		val = readl(edp->regs + VIDEO_CTL_1);
+		val &= ~VIDEO_MUTE;
+		writel(val, edp->regs + VIDEO_CTL_1);
+	}
+}
+
+void rk32_edp_stop_video(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + VIDEO_CTL_1);
+	val &= ~VIDEO_EN;
+	writel(val, edp->regs + VIDEO_CTL_1);
+}
+
+void rk32_edp_lane_swap(struct rk32_edp *edp, bool enable)
+{
+	u32 val;
+
+	
+	if (enable)
+		val = LANE3_MAP_LOGIC_LANE_0 | LANE2_MAP_LOGIC_LANE_1 |
+			LANE1_MAP_LOGIC_LANE_2 | LANE0_MAP_LOGIC_LANE_3;
+	else
+		val = LANE3_MAP_LOGIC_LANE_3 | LANE2_MAP_LOGIC_LANE_2 |
+			LANE1_MAP_LOGIC_LANE_1 | LANE0_MAP_LOGIC_LANE_0;
+	
+	writel(val, edp->regs + LANE_MAP);
+}
+
+void rk32_edp_init_analog_param(struct rk32_edp *edp)
+{
+	u32 val;
+	/*struct rk32_edp_platdata *pdata = edp->dev->platform_data;
+	struct analog_param *analog_param = pdata->analog_param;
+
+	val = TX_TERMINAL_CTRL_50_OHM;
+	writel(val, edp->regs + ANALOG_CTL_1);*/
+
+#ifndef CONFIG_RK_FPGA
+	val = (REF_CLK_FROM_INTER << 16) | REF_CLK_FROM_INTER;
+	writel_relaxed(val,RK_GRF_VIRT + GRF_SOC_CON12);
+#endif
+
+	val = SEL_24M;
+	writel(val, edp->regs + ANALOG_CTL_2);
+	
+	val = REF_CLK_24M;
+	writel(val, edp->regs + PLL_REG_1);
+	/*val = DRIVE_DVDD_BIT_1_0625V | VCO_BIT_600_MICRO;
+	writel(val, edp->regs + ANALOG_CTL_3);
+
+	if (!analog_param) {
+		val = PD_RING_OSC | AUX_TERMINAL_CTRL_50_OHM |
+			TX_CUR1_2X | TX_CUR_16_MA;
+		writel(val, edp->regs + PLL_FILTER_CTL_1);
+
+		val = CH3_AMP_400_MV | CH2_AMP_400_MV |
+			CH1_AMP_400_MV | CH0_AMP_400_MV;
+		writel(val, edp->regs + TX_AMP_TUNING_CTL);
+	} else {
+		int tx_amp;
+
+		val = PD_RING_OSC | TX_CUR1_2X | TX_CUR_16_MA;
+		switch (analog_param->aux_tx_terminal_resistor) {
+		case AUX_TX_37_5_OHM:
+			val |= AUX_TERMINAL_CTRL_37_5_OHM;
+			break;
+		case AUX_TX_45_OHM:
+			val |= AUX_TERMINAL_CTRL_45_OHM;
+			break;
+		case AUX_TX_50_OHM:
+			val |= AUX_TERMINAL_CTRL_50_OHM;
+			break;
+		case AUX_TX_65_OHM:
+			val |= AUX_TERMINAL_CTRL_65_OHM;
+			break;
+		}
+		writel(val, edp->regs + PLL_FILTER_CTL_1);
+
+		tx_amp = analog_param->tx_amplitude;
+		if (tx_amp < 200000 || tx_amp > 500000) {
+			dev_warn(edp->dev,
+				 "TX amp out of range, defaulting to 400mV\n");
+			tx_amp = 400000;
+		}
+
+		tx_amp = ((tx_amp - 400000) / 12500) & 0x1f;
+
+		val = (tx_amp << CH3_AMP_SHIFT) | (tx_amp << CH2_AMP_SHIFT) |
+			(tx_amp << CH1_AMP_SHIFT) | (tx_amp << CH0_AMP_SHIFT);
+		writel(val, edp->regs + TX_AMP_TUNING_CTL);
+	}*/
+}
+
+void rk32_edp_init_interrupt(struct rk32_edp *edp)
+{
+	/* Set interrupt pin assertion polarity as high */
+	writel(INT_POL, edp->regs + INT_CTL);
+
+	/* Clear pending valisers */
+	writel(0xff, edp->regs + COMMON_INT_STA_1);
+	writel(0x4f, edp->regs + COMMON_INT_STA_2);
+	writel(0xff, edp->regs + COMMON_INT_STA_3);
+	writel(0x27, edp->regs + COMMON_INT_STA_4);
+	
+	writel(0x7f, edp->regs + DP_INT_STA);
+
+	/* 0:mask,1: unmask */
+	writel(0x00, edp->regs + COMMON_INT_MASK_1);
+	writel(0x00, edp->regs + COMMON_INT_MASK_2);
+	writel(0x00, edp->regs + COMMON_INT_MASK_3);
+	writel(0x00, edp->regs + COMMON_INT_MASK_4);
+	writel(0x00, edp->regs + DP_INT_STA_MASK);
+}
+
+void rk32_edp_reset(struct rk32_edp *edp)
+{
+	u32 val;
+
+	//writel(RST_DP_TX, edp->regs + TX_SW_RST);
+
+	rk32_edp_stop_video(edp);
+	rk32_edp_enable_video_mute(edp, 0);
+
+	val = VID_CAP_FUNC_EN_N | AUD_FIFO_FUNC_EN_N |
+		AUD_FUNC_EN_N | HDCP_FUNC_EN_N | SW_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_1);
+
+	val = SSC_FUNC_EN_N | AUX_FUNC_EN_N |
+		SERDES_FIFO_FUNC_EN_N |
+		LS_CLK_DOMAIN_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_2);
+
+	udelay(20);
+
+	rk32_edp_lane_swap(edp, 0);
+
+	writel(0x0, edp->regs + SYS_CTL_1);
+	writel(0x40, edp->regs + SYS_CTL_2);
+	writel(0x0, edp->regs + SYS_CTL_3);
+	writel(0x0, edp->regs + SYS_CTL_4);
+
+	writel(0x0, edp->regs + PKT_SEND_CTL);
+	writel(0x0, edp->regs + HDCP_CTL);
+
+	writel(0x5e, edp->regs + HPD_DEGLITCH_L);
+	writel(0x1a, edp->regs + HPD_DEGLITCH_H);
+
+	writel(0x10, edp->regs + LINK_DEBUG_CTL);
+
+	writel(0x0, edp->regs + VIDEO_FIFO_THRD);
+	writel(0x20, edp->regs + AUDIO_MARGIN);
+
+	writel(0x4, edp->regs + M_VID_GEN_FILTER_TH);
+	writel(0x2, edp->regs + M_AUD_GEN_FILTER_TH);
+
+	writel(0x0, edp->regs + SOC_GENERAL_CTL);
+
+}
+
+void rk32_edp_config_interrupt(struct rk32_edp *edp)
+{
+	u32 val;
+
+	/* 0: mask, 1: unmask */
+	val = 0;
+	writel(val, edp->regs + COMMON_INT_MASK_1);
+
+	writel(val, edp->regs + COMMON_INT_MASK_2);
+
+	writel(val, edp->regs + COMMON_INT_MASK_3);
+
+	writel(val, edp->regs + COMMON_INT_MASK_4);
+
+	writel(val, edp->regs + DP_INT_STA_MASK);
+}
+
+u32 rk32_edp_get_pll_lock_status(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + DEBUG_CTL);
+	if (val & PLL_LOCK)
+		return DP_PLL_LOCKED;
+	else
+		return DP_PLL_UNLOCKED;
+}
+
+
+void rk32_edp_analog_power_ctr(struct rk32_edp *edp, bool enable)
+{
+	u32 val;
+
+	if (enable) {
+		val = PD_EXP_BG | PD_AUX | PD_PLL |
+			PD_CH3 | PD_CH2 | PD_CH1 | PD_CH0;
+		writel(val, edp->regs + DP_PWRDN);
+		udelay(10);
+		writel(0x0,edp->regs + DP_PWRDN);
+	} else {
+		val = PD_EXP_BG | PD_AUX | PD_PLL |
+			PD_CH3 | PD_CH2 | PD_CH1 | PD_CH0;
+		writel(val, edp->regs + DP_PWRDN);
+	}
+}
+
+
+void rk32_edp_init_analog_func(struct rk32_edp *edp)
+{
+	u32 val;
+
+	rk32_edp_analog_power_ctr(edp, 1);
+
+	val = PLL_LOCK_CHG;
+	writel(val, edp->regs + COMMON_INT_STA_1);
+
+	val = readl(edp->regs + DEBUG_CTL);
+	val &= ~(F_PLL_LOCK | PLL_LOCK_CTRL);
+	writel(val, edp->regs + DEBUG_CTL);
+
+	/* Power up PLL */
+	if (rk32_edp_get_pll_lock_status(edp) == DP_PLL_UNLOCKED)
+		dev_warn(edp->dev, "edp pll unlocked.....\n");
+
+	/* Enable Serdes FIFO function and Link symbol clock domain module */
+	val = readl(edp->regs + FUNC_EN_2);
+	val &= ~(SERDES_FIFO_FUNC_EN_N | LS_CLK_DOMAIN_FUNC_EN_N
+		| AUX_FUNC_EN_N);
+	writel(val, edp->regs + FUNC_EN_2);
+}
+
+void rk32_edp_init_hpd(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = HOTPLUG_CHG | HPD_LOST | PLUG;
+	writel(val, edp->regs + COMMON_INT_STA_4);
+
+	val = INT_HPD;
+	writel(val, edp->regs + DP_INT_STA);
+
+	val = readl(edp->regs + SYS_CTL_3);
+	val &= ~(F_HPD | HPD_CTRL);
+	writel(val, edp->regs + SYS_CTL_3);
+}
+
+void rk32_edp_reset_aux(struct rk32_edp *edp)
+{
+	u32 val;
+
+	/* Disable AUX channel module */
+	val = readl(edp->regs + FUNC_EN_2);
+	val |= AUX_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_2);
+}
+
+void rk32_edp_init_aux(struct rk32_edp *edp)
+{
+	u32 val;
+
+	/* Clear inerrupts related to AUX channel */
+	val = RPLY_RECEIV | AUX_ERR;
+	writel(val, edp->regs + DP_INT_STA);
+
+	rk32_edp_reset_aux(edp);
+
+	/* Disable AUX transaction H/W retry */
+	/*val = AUX_BIT_PERIOD_EXPECTED_DELAY(3) | AUX_HW_RETRY_COUNT_SEL(0)|
+		AUX_HW_RETRY_INTERVAL_600_MICROSECONDS;
+	writel(val, edp->regs + AUX_HW_RETRY_CTL) ;*/
+
+	/* Receive AUX Channel DEFER commands equal to DEFFER_COUNT*64 */
+	val = DEFER_CTRL_EN | DEFER_COUNT(1);
+	writel(val, edp->regs + AUX_CH_DEFER_CTL);
+
+	/* Enable AUX channel module */
+	val = readl(edp->regs + FUNC_EN_2);
+	val &= ~AUX_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_2);
+}
+
+int rk32_edp_get_plug_in_status(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + SYS_CTL_3);
+	if (val & HPD_STATUS)
+		return 0;
+
+	return -EINVAL;
+}
+
+void rk32_edp_enable_sw_function(struct rk32_edp *edp)
+{
+	u32 val;
+	val = readl(edp->regs + FUNC_EN_1);
+	val &= ~SW_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_1);
+}
+
+int rk32_edp_start_aux_transaction(struct rk32_edp *edp)
+{
+	int val;
+	int retval = 0;
+	int timeout_loop = 0;
+	int aux_timeout = 0;
+
+	/* Enable AUX CH operation */
+	val = readl(edp->regs + AUX_CH_CTL_2);
+	val |= AUX_EN;
+	writel(val, edp->regs + AUX_CH_CTL_2);
+
+	/* Is AUX CH operation enabled? */
+	val = readl(edp->regs + AUX_CH_CTL_2);
+	while (val & AUX_EN) {
+		aux_timeout++;
+		if ((DP_TIMEOUT_LOOP_CNT * 10) < aux_timeout) {
+			dev_err(edp->dev, "AUX CH enable timeout!\n");
+			return -ETIMEDOUT;
+		}
+		val = readl(edp->regs + AUX_CH_CTL_2);
+		udelay(100);
+	}
+
+	/* Is AUX CH command redply received? */
+	val = readl(edp->regs + DP_INT_STA);
+	while (!(val & RPLY_RECEIV)) {
+		timeout_loop++;
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(edp->dev, "AUX CH command redply failed!\n");
+			return -ETIMEDOUT;
+		}
+		val = readl(edp->regs + DP_INT_STA);
+		udelay(10);
+	}
+
+	/* Clear interrupt source for AUX CH command redply */
+	writel(RPLY_RECEIV, edp->regs + DP_INT_STA);
+
+	/* Clear interrupt source for AUX CH access error */
+	val = readl(edp->regs + DP_INT_STA);
+	if (val & AUX_ERR) {
+		writel(AUX_ERR, edp->regs + DP_INT_STA);
+		return -EREMOTEIO;
+	}
+
+	/* Check AUX CH error access status */
+	val = readl(edp->regs + AUX_CH_STA);
+	if ((val & AUX_STATUS_MASK) != 0) {
+		dev_err(edp->dev, "AUX CH error happens: %d\n\n",
+			val & AUX_STATUS_MASK);
+		return -EREMOTEIO;
+	}
+
+	return retval;
+}
+
+int rk32_edp_write_byte_to_dpcd(struct rk32_edp *edp,
+				unsigned int val_addr,
+				unsigned char data)
+{
+	u32 val;
+	int i;
+	int retval;
+
+	for (i = 0; i < 3; i++) {
+		/* Clear AUX CH data buffer */
+		val = BUF_CLR;
+		writel(val, edp->regs + BUFFER_DATA_CTL);
+
+		/* Select DPCD device address */
+		val = AUX_ADDR_7_0(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_7_0);
+		val = AUX_ADDR_15_8(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_15_8);
+		val = AUX_ADDR_19_16(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_19_16);
+
+		/* Write data buffer */
+		val = (unsigned int)data;
+		writel(val, edp->regs + BUF_DATA_0);
+
+		/*
+		 * Set DisplayPort transaction and write 1 byte
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		val = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;
+		writel(val, edp->regs + AUX_CH_CTL_1);
+
+		/* Start AUX transaction */
+		retval = rk32_edp_start_aux_transaction(edp);
+		if (retval == 0)
+			break;
+		else
+			dev_dbg(edp->dev, "Aux Transaction fail!\n");
+	}
+
+	return retval;
+}
+
+int rk32_edp_read_byte_from_dpcd(struct rk32_edp *edp,
+				unsigned int val_addr,
+				unsigned char *data)
+{
+	u32 val;
+	int i;
+	int retval;
+
+	for (i = 0; i < 10; i++) {
+		/* Clear AUX CH data buffer */
+		val = BUF_CLR;
+		writel(val, edp->regs + BUFFER_DATA_CTL);
+
+		/* Select DPCD device address */
+		val = AUX_ADDR_7_0(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_7_0);
+		val = AUX_ADDR_15_8(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_15_8);
+		val = AUX_ADDR_19_16(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_19_16);
+
+		/*
+		 * Set DisplayPort transaction and read 1 byte
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		val = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;
+		writel(val, edp->regs + AUX_CH_CTL_1);
+
+		/* Start AUX transaction */
+		retval = rk32_edp_start_aux_transaction(edp);
+		if (retval == 0)
+			break;
+		else
+			dev_dbg(edp->dev, "Aux Transaction fail!\n");
+	}
+
+	/* Read data buffer */
+	val = readl(edp->regs + BUF_DATA_0);
+	*data = (unsigned char)(val & 0xff);
+
+	return retval;
+}
+
+int rk32_edp_write_bytes_to_dpcd(struct rk32_edp *edp,
+				unsigned int val_addr,
+				unsigned int count,
+				unsigned char data[])
+{
+	u32 val;
+	unsigned int start_offset;
+	unsigned int cur_data_count;
+	unsigned int cur_data_idx;
+	int i;
+	int retval = 0;
+
+	/* Clear AUX CH data buffer */
+	val = BUF_CLR;
+	writel(val, edp->regs + BUFFER_DATA_CTL);
+
+	start_offset = 0;
+	while (start_offset < count) {
+		/* Buffer size of AUX CH is 16 * 4bytes */
+		if ((count - start_offset) > 16)
+			cur_data_count = 16;
+		else
+			cur_data_count = count - start_offset;
+
+		for (i = 0; i < 10; i++) {
+			/* Select DPCD device address */
+			val = AUX_ADDR_7_0(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_7_0);
+			val = AUX_ADDR_15_8(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_15_8);
+			val = AUX_ADDR_19_16(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_19_16);
+
+			for (cur_data_idx = 0; cur_data_idx < cur_data_count;
+			     cur_data_idx++) {
+				val = data[start_offset + cur_data_idx];
+				writel(val, edp->regs + BUF_DATA_0
+							  + 4 * cur_data_idx);
+			}
+
+			/*
+			 * Set DisplayPort transaction and write
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			val = AUX_LENGTH(cur_data_count) |
+				AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;
+			writel(val, edp->regs + AUX_CH_CTL_1);
+
+			/* Start AUX transaction */
+			retval = rk32_edp_start_aux_transaction(edp);
+			if (retval == 0)
+				break;
+			else
+				dev_dbg(edp->dev, "Aux Transaction fail!\n");
+		}
+
+		start_offset += cur_data_count;
+	}
+
+	return retval;
+}
+
+int rk32_edp_read_bytes_from_dpcd(struct rk32_edp *edp,
+				unsigned int val_addr,
+				unsigned int count,
+				unsigned char data[])
+{
+	u32 val;
+	unsigned int start_offset;
+	unsigned int cur_data_count;
+	unsigned int cur_data_idx;
+	int i;
+	int retval = 0;
+
+	/* Clear AUX CH data buffer */
+	val = BUF_CLR;
+	writel(val, edp->regs + BUFFER_DATA_CTL);
+
+	start_offset = 0;
+	while (start_offset < count) {
+		/* Buffer size of AUX CH is 16 * 4bytes */
+		if ((count - start_offset) > 16)
+			cur_data_count = 16;
+		else
+			cur_data_count = count - start_offset;
+
+		/* AUX CH Request Transaction process */
+		for (i = 0; i < 10; i++) {
+			/* Select DPCD device address */
+			val = AUX_ADDR_7_0(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_7_0);
+			val = AUX_ADDR_15_8(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_15_8);
+			val = AUX_ADDR_19_16(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_19_16);
+
+			/*
+			 * Set DisplayPort transaction and read
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			val = AUX_LENGTH(cur_data_count) |
+				AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;
+			writel(val, edp->regs + AUX_CH_CTL_1);
+
+			/* Start AUX transaction */
+			retval = rk32_edp_start_aux_transaction(edp);
+			if (retval == 0)
+				break;
+			else
+				dev_dbg(edp->dev, "Aux Transaction fail!\n");
+		}
+
+		for (cur_data_idx = 0; cur_data_idx < cur_data_count;
+		    cur_data_idx++) {
+			val = readl(edp->regs + BUF_DATA_0
+						 + 4 * cur_data_idx);
+			data[start_offset + cur_data_idx] =
+				(unsigned char)val;
+		}
+
+		start_offset += cur_data_count;
+	}
+
+	return retval;
+}
+
+int rk32_edp_select_i2c_device(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int val_addr)
+{
+	u32 val;
+	int retval;
+
+	/* Set EDID device address */
+	val = device_addr;
+	writel(val, edp->regs + DP_AUX_ADDR_7_0);
+	writel(0x0, edp->regs + DP_AUX_ADDR_15_8);
+	writel(0x0, edp->regs + DP_AUX_ADDR_19_16);
+
+	/* Set offset from base address of EDID device */
+	writel(val_addr, edp->regs + BUF_DATA_0);
+
+	/*
+	 * Set I2C transaction and write address
+	 * If bit 3 is 1, DisplayPort transaction.
+	 * If Bit 3 is 0, I2C transaction.
+	 */
+	val = AUX_TX_COMM_I2C_TRANSACTION | AUX_TX_COMM_MOT |
+		AUX_TX_COMM_WRITE;
+	writel(val, edp->regs + AUX_CH_CTL_1);
+
+	/* Start AUX transaction */
+	retval = rk32_edp_start_aux_transaction(edp);
+	if (retval != 0)
+		dev_dbg(edp->dev, "Aux Transaction fail!\n");
+
+	return retval;
+}
+
+int rk32_edp_read_byte_from_i2c(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int val_addr,
+				unsigned int *data)
+{
+	u32 val;
+	int i;
+	int retval;
+
+	for (i = 0; i < 10; i++) {
+		/* Clear AUX CH data buffer */
+		val = BUF_CLR;
+		writel(val, edp->regs + BUFFER_DATA_CTL);
+
+		/* Select EDID device */
+		retval = rk32_edp_select_i2c_device(edp, device_addr, val_addr);
+		if (retval != 0) {
+			dev_err(edp->dev, "Select EDID device fail!\n");
+			continue;
+		}
+
+		/*
+		 * Set I2C transaction and read data
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		val = AUX_TX_COMM_I2C_TRANSACTION | AUX_TX_COMM_READ;
+		writel(val, edp->regs + AUX_CH_CTL_1);
+
+		/* Start AUX transaction */
+		retval = rk32_edp_start_aux_transaction(edp);
+		if (retval == 0)
+			break;
+		else
+			dev_dbg(edp->dev, "Aux Transaction fail!\n");
+	}
+
+	/* Read data */
+	if (retval == 0)
+		*data = readl(edp->regs + BUF_DATA_0);
+
+	return retval;
+}
+
+int rk32_edp_read_bytes_from_i2c(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int val_addr,
+				unsigned int count,
+				unsigned char edid[])
+{
+	u32 val;
+	unsigned int i, j;
+	unsigned int cur_data_idx;
+	unsigned int defer = 0;
+	int retval = 0;
+
+	for (i = 0; i < count; i += 16) {
+		for (j = 0; j < 100; j++) {
+			/* Clear AUX CH data buffer */
+			val = BUF_CLR;
+			writel(val, edp->regs + BUFFER_DATA_CTL);
+
+			/* Set normal AUX CH command */
+			val = readl(edp->regs + AUX_CH_CTL_2);
+			val &= ~ADDR_ONLY;
+			writel(val, edp->regs + AUX_CH_CTL_2);
+
+			/*
+			 * If Rx sends defer, Tx sends only reads
+			 * request without sending addres
+			 */
+			if (!defer)
+				retval = rk32_edp_select_i2c_device(edp,
+						device_addr, val_addr + i);
+			else
+				defer = 0;
+
+			/*
+			 * Set I2C transaction and write data
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			val = AUX_LENGTH(16) | AUX_TX_COMM_I2C_TRANSACTION |
+				AUX_TX_COMM_READ;
+			writel(val, edp->regs + AUX_CH_CTL_1);
+
+			/* Start AUX transaction */
+			retval = rk32_edp_start_aux_transaction(edp);
+			if (retval == 0)
+				break;
+			else
+				dev_dbg(edp->dev, "Aux Transaction fail!\n");
+
+			/* Check if Rx sends defer */
+			val = readl(edp->regs + AUX_RX_COMM);
+			if (val == AUX_RX_COMM_AUX_DEFER ||
+				val == AUX_RX_COMM_I2C_DEFER) {
+				dev_err(edp->dev, "Defer: %d\n\n", val);
+				defer = 1;
+			}
+		}
+
+		for (cur_data_idx = 0; cur_data_idx < 16; cur_data_idx++) {
+			val = readl(edp->regs + BUF_DATA_0 + 4 * cur_data_idx);
+			edid[i + cur_data_idx] = (unsigned char)val;
+		}
+	}
+
+	return retval;
+}
+
+void rk32_edp_set_link_bandwidth(struct rk32_edp *edp, u32 bwtype)
+{
+	u32 val;
+
+	val = bwtype;
+	if ((bwtype == LINK_RATE_2_70GBPS) || (bwtype == LINK_RATE_1_62GBPS))
+		writel(val, edp->regs + LINK_BW_SET);
+}
+
+void rk32_edp_get_link_bandwidth(struct rk32_edp *edp, u32 *bwtype)
+{
+	u32 val;
+
+	val = readl(edp->regs + LINK_BW_SET);
+	*bwtype = val;
+}
+
+void rk32_edp_set_lane_count(struct rk32_edp *edp, u32 count)
+{
+	u32 val;
+
+	val = count;
+	writel(val, edp->regs + LANE_CNT_SET);
+}
+
+void rk32_edp_get_lane_count(struct rk32_edp *edp, u32 *count)
+{
+	u32 val;
+
+	val = readl(edp->regs + LANE_CNT_SET);
+	*count = val;
+}
+
+void rk32_edp_enable_enhanced_mode(struct rk32_edp *edp, bool enable)
+{
+	u32 val;
+
+	if (enable) {
+		val = readl(edp->regs + SYS_CTL_4);
+		val |= ENHANCED;
+		writel(val, edp->regs + SYS_CTL_4);
+	} else {
+		val = readl(edp->regs + SYS_CTL_4);
+		val &= ~ENHANCED;
+		writel(val, edp->regs + SYS_CTL_4);
+	}
+}
+
+void rk32_edp_set_training_pattern(struct rk32_edp *edp,
+				 enum pattern_set pattern)
+{
+	u32 val;
+
+	switch (pattern) {
+	case PRBS7:
+		val = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_PRBS7;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	case D10_2:
+		val = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_D10_2;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	case TRAINING_PTN1:
+		val = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN1;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	case TRAINING_PTN2:
+		val = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN2;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	case DP_NONE:
+		val = SCRAMBLING_ENABLE |
+			LINK_QUAL_PATTERN_SET_DISABLE |
+			SW_TRAINING_PATTERN_SET_DISABLE;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	default:
+		break;
+	}
+}
+
+void rk32_edp_set_lane0_pre_emphasis(struct rk32_edp *edp, u32 level)
+{
+	u32 val;
+
+	val = level << PRE_EMPHASIS_SET_SHIFT;
+	writel(val, edp->regs + LN0_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane1_pre_emphasis(struct rk32_edp *edp, u32 level)
+{
+	u32 val;
+
+	val = level << PRE_EMPHASIS_SET_SHIFT;
+	writel(val, edp->regs + LN1_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane2_pre_emphasis(struct rk32_edp *edp, u32 level)
+{
+	u32 val;
+
+	val = level << PRE_EMPHASIS_SET_SHIFT;
+	writel(val, edp->regs + LN2_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane3_pre_emphasis(struct rk32_edp *edp, u32 level)
+{
+	u32 val;
+
+	val = level << PRE_EMPHASIS_SET_SHIFT;
+	writel(val, edp->regs + LN3_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane0_link_training(struct rk32_edp *edp,
+					u32 training_lane)
+{
+	u32 val;
+
+	val = training_lane;
+	writel(val, edp->regs + LN0_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane1_link_training(struct rk32_edp *edp,
+					u32 training_lane)
+{
+	u32 val;
+
+	val = training_lane;
+	writel(val, edp->regs + LN1_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane2_link_training(struct rk32_edp *edp,
+					u32 training_lane)
+{
+	u32 val;
+
+	val = training_lane;
+	writel(val, edp->regs + LN2_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane3_link_training(struct rk32_edp *edp,
+					u32 training_lane)
+{
+	u32 val;
+
+	val = training_lane;
+	writel(val, edp->regs + LN3_LINK_TRAINING_CTL);
+}
+
+u32 rk32_edp_get_lane0_link_training(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + LN0_LINK_TRAINING_CTL);
+	return val;
+}
+
+u32 rk32_edp_get_lane1_link_training(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + LN1_LINK_TRAINING_CTL);
+	return val;
+}
+
+u32 rk32_edp_get_lane2_link_training(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + LN2_LINK_TRAINING_CTL);
+	return val;
+}
+
+u32 rk32_edp_get_lane3_link_training(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + LN3_LINK_TRAINING_CTL);
+	return val;
+}
+
+void rk32_edp_reset_macro(struct rk32_edp *edp)
+{
+	/*u32 val;
+
+	val = readl(edp->regs + PHY_TEST);
+	val |= MACRO_RST;
+	writel(val, edp->regs + PHY_TEST);
+
+	
+	udelay(10);
+
+	val &= ~MACRO_RST;
+	writel(val, edp->regs + PHY_TEST);*/
+}
+
+int rk32_edp_init_video(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = VSYNC_DET | VID_FORMAT_CHG | VID_CLK_CHG;
+	writel(val, edp->regs + COMMON_INT_STA_1);
+
+	val = 0x0;
+	writel(val, edp->regs + SYS_CTL_1);
+
+	val = CHA_CRI(4) | CHA_CTRL;
+	writel(val, edp->regs + SYS_CTL_2);
+
+	val = 0x0;
+	writel(val, edp->regs + SYS_CTL_3);
+
+	val = VID_HRES_TH(2) | VID_VRES_TH(0);
+	writel(val, edp->regs + VIDEO_CTL_8);
+
+	return 0;
+}
+
+void rk32_edp_set_video_color_format(struct rk32_edp *edp,
+			u32 color_dedpth,
+			u32 color_space,
+			u32 dynamic_range,
+			u32 coeff)
+{
+	u32 val;
+
+	/* Configure the input color dedpth, color space, dynamic range */
+	val = (dynamic_range << IN_D_RANGE_SHIFT) |
+		(color_dedpth << IN_BPC_SHIFT) |
+		(color_space << IN_COLOR_F_SHIFT);
+	writel(val, edp->regs + VIDEO_CTL_2);
+
+	/* Set Input Color YCbCr Coefficients to ITU601 or ITU709 */
+	val = readl(edp->regs + VIDEO_CTL_3);
+	val &= ~IN_YC_COEFFI_MASK;
+	if (coeff)
+		val |= IN_YC_COEFFI_ITU709;
+	else
+		val |= IN_YC_COEFFI_ITU601;
+	writel(val, edp->regs + VIDEO_CTL_3);
+}
+
+int rk32_edp_is_slave_video_stream_clock_on(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + SYS_CTL_1);
+	writel(val, edp->regs + SYS_CTL_1);
+
+	val = readl(edp->regs + SYS_CTL_1);
+
+	if (!(val & DET_STA)) {
+		dev_dbg(edp->dev, "Input stream clock not detected.\n");
+		return -EINVAL;
+	}
+
+	val = readl(edp->regs + SYS_CTL_2);
+	writel(val, edp->regs + SYS_CTL_2);
+
+	val = readl(edp->regs + SYS_CTL_2);
+	dev_dbg(edp->dev, "wait SYS_CTL_2.\n");
+
+	if (val & CHA_STA) {
+		dev_dbg(edp->dev, "Input stream clk is changing\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void rk32_edp_set_video_cr_mn(struct rk32_edp *edp,
+		enum clock_recovery_m_value_type type,
+		u32 m_value,
+		u32 n_value)
+{
+	u32 val;
+
+	if (type == REGISTER_M) {
+		val = readl(edp->regs + SYS_CTL_4);
+		val |= FIX_M_VID;
+		writel(val, edp->regs + SYS_CTL_4);
+		val = m_value & 0xff;
+		writel(val, edp->regs + M_VID_0);
+		val = (m_value >> 8) & 0xff;
+		writel(val, edp->regs + M_VID_1);
+		val = (m_value >> 16) & 0xff;
+		writel(val, edp->regs + M_VID_2);
+
+		val = n_value & 0xff;
+		writel(val, edp->regs + N_VID_0);
+		val = (n_value >> 8) & 0xff;
+		writel(val, edp->regs + N_VID_1);
+		val = (n_value >> 16) & 0xff;
+		writel(val, edp->regs + N_VID_2);
+	} else  {
+		val = readl(edp->regs + SYS_CTL_4);
+		val &= ~FIX_M_VID;
+		writel(val, edp->regs + SYS_CTL_4);
+
+		writel(0x00, edp->regs + N_VID_0);
+		writel(0x80, edp->regs + N_VID_1);
+		writel(0x00, edp->regs + N_VID_2);
+	}
+}
+
+void rk32_edp_set_video_timing_mode(struct rk32_edp *edp, u32 type)
+{
+	u32 val;
+
+	if (type == VIDEO_TIMING_FROM_CAPTURE) {
+		val = readl(edp->regs + VIDEO_CTL_10);
+		val &= ~F_SEL;
+		writel(val, edp->regs + VIDEO_CTL_10);
+	} else {
+		val = readl(edp->regs + VIDEO_CTL_10);
+		val |= F_SEL;
+		writel(val, edp->regs + VIDEO_CTL_10);
+	}
+}
+
+void rk32_edp_enable_video_master(struct rk32_edp *edp, bool enable)
+{
+	/*u32 val;
+
+	if (enable) {
+		val = readl(edp->regs + SOC_GENERAL_CTL);
+		val &= ~VIDEO_MODE_MASK;
+		val |= VIDEO_MASTER_MODE_EN | VIDEO_MODE_MASTER_MODE;
+		writel(val, edp->regs + SOC_GENERAL_CTL);
+	} else {
+		val = readl(edp->regs + SOC_GENERAL_CTL);
+		val &= ~VIDEO_MODE_MASK;
+		val |= VIDEO_MODE_SLAVE_MODE;
+		writel(val, edp->regs + SOC_GENERAL_CTL);
+	}*/
+}
+
+void rk32_edp_start_video(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + VIDEO_CTL_1);
+	val |= VIDEO_EN;
+	writel(val, edp->regs + VIDEO_CTL_1);
+}
+
+int rk32_edp_is_video_stream_on(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + SYS_CTL_3);
+	writel(val, edp->regs + SYS_CTL_3);
+
+	val = readl(edp->regs + SYS_CTL_3);
+	if (!(val & STRM_VALID)) {
+		dev_dbg(edp->dev, "Input video stream is not detected.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void rk32_edp_config_video_slave_mode(struct rk32_edp *edp,
+			struct video_info *video_info)
+{
+	u32 val;
+
+	val = readl(edp->regs + FUNC_EN_1);
+	val &= ~(VID_FIFO_FUNC_EN_N);
+	writel(val, edp->regs + FUNC_EN_1);
+
+	val = readl(edp->regs + VIDEO_CTL_10);
+	val &= ~INTERACE_SCAN_CFG;
+	val |= (video_info->interlaced << 2);
+	writel(val, edp->regs + VIDEO_CTL_10);
+
+	val = readl(edp->regs + VIDEO_CTL_10);
+	val &= ~VSYNC_POLARITY_CFG;
+	val |= (video_info->v_sync_polarity << 1);
+	writel(val, edp->regs + VIDEO_CTL_10);
+
+	val = readl(edp->regs + VIDEO_CTL_10);
+	val &= ~HSYNC_POLARITY_CFG;
+	val |= (video_info->h_sync_polarity << 0);
+	writel(val, edp->regs + VIDEO_CTL_10);
+
+	/*val = AUDIO_MODE_SPDIF_MODE | VIDEO_MODE_SLAVE_MODE;
+	writel(val, edp->regs + SOC_GENERAL_CTL);*/
+}
+
+void rk32_edp_enable_scrambling(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + TRAINING_PTN_SET);
+	val &= ~SCRAMBLING_DISABLE;
+	writel(val, edp->regs + TRAINING_PTN_SET);
+}
+
+void rk32_edp_disable_scrambling(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + TRAINING_PTN_SET);
+	val |= SCRAMBLING_DISABLE;
+	writel(val, edp->regs + TRAINING_PTN_SET);
+}
-- 
2.35.3

